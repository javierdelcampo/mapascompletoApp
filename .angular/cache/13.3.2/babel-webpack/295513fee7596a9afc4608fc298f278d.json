{"ast":null,"code":"/* Mapbox GL JS is Copyright Â© 2020 Mapbox and subject to the Mapbox Terms of Service ((https://www.mapbox.com/legal/tos/). */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.mapboxgl = factory());\n})(this, function () {\n  'use strict';\n  /* eslint-disable */\n\n  var shared, worker, mapboxgl; // define gets called three times: one for each chunk. we rely on the order\n  // they're imported to know which is which\n\n  function define(_, chunk) {\n    if (!shared) {\n      shared = chunk;\n    } else if (!worker) {\n      worker = chunk;\n    } else {\n      var workerBundleString = \"self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (\" + shared + \")(sharedChunk); (\" + worker + \")(sharedChunk); self.onerror = null;\";\n      var sharedChunk = {};\n      shared(sharedChunk);\n      mapboxgl = chunk(sharedChunk);\n\n      if (typeof window !== 'undefined' && window && window.URL && window.URL.createObjectURL) {\n        mapboxgl.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], {\n          type: 'text/javascript'\n        }));\n      }\n    }\n  }\n\n  define([\"exports\"], function (t) {\n    \"use strict\";\n\n    var e = \"2.8.0\",\n        r = n;\n\n    function n(t, e, r, n) {\n      this.cx = 3 * t, this.bx = 3 * (r - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e, this.by = 3 * (n - e) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = n, this.p2x = r, this.p2y = n;\n    }\n\n    n.prototype.sampleCurveX = function (t) {\n      return ((this.ax * t + this.bx) * t + this.cx) * t;\n    }, n.prototype.sampleCurveY = function (t) {\n      return ((this.ay * t + this.by) * t + this.cy) * t;\n    }, n.prototype.sampleCurveDerivativeX = function (t) {\n      return (3 * this.ax * t + 2 * this.bx) * t + this.cx;\n    }, n.prototype.solveCurveX = function (t, e) {\n      var r, n, i, s, a;\n\n      for (void 0 === e && (e = 1e-6), i = t, a = 0; a < 8; a++) {\n        if (s = this.sampleCurveX(i) - t, Math.abs(s) < e) return i;\n        var o = this.sampleCurveDerivativeX(i);\n        if (Math.abs(o) < 1e-6) break;\n        i -= s / o;\n      }\n\n      if ((i = t) < (r = 0)) return r;\n      if (i > (n = 1)) return n;\n\n      for (; r < n;) {\n        if (s = this.sampleCurveX(i), Math.abs(s - t) < e) return i;\n        t > s ? r = i : n = i, i = .5 * (n - r) + r;\n      }\n\n      return i;\n    }, n.prototype.solve = function (t, e) {\n      return this.sampleCurveY(this.solveCurveX(t, e));\n    };\n    var i = s;\n\n    function s(t, e) {\n      this.x = t, this.y = e;\n    }\n\n    s.prototype = {\n      clone: function () {\n        return new s(this.x, this.y);\n      },\n      add: function (t) {\n        return this.clone()._add(t);\n      },\n      sub: function (t) {\n        return this.clone()._sub(t);\n      },\n      multByPoint: function (t) {\n        return this.clone()._multByPoint(t);\n      },\n      divByPoint: function (t) {\n        return this.clone()._divByPoint(t);\n      },\n      mult: function (t) {\n        return this.clone()._mult(t);\n      },\n      div: function (t) {\n        return this.clone()._div(t);\n      },\n      rotate: function (t) {\n        return this.clone()._rotate(t);\n      },\n      rotateAround: function (t, e) {\n        return this.clone()._rotateAround(t, e);\n      },\n      matMult: function (t) {\n        return this.clone()._matMult(t);\n      },\n      unit: function () {\n        return this.clone()._unit();\n      },\n      perp: function () {\n        return this.clone()._perp();\n      },\n      round: function () {\n        return this.clone()._round();\n      },\n      mag: function () {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n      },\n      equals: function (t) {\n        return this.x === t.x && this.y === t.y;\n      },\n      dist: function (t) {\n        return Math.sqrt(this.distSqr(t));\n      },\n      distSqr: function (t) {\n        var e = t.x - this.x,\n            r = t.y - this.y;\n        return e * e + r * r;\n      },\n      angle: function () {\n        return Math.atan2(this.y, this.x);\n      },\n      angleTo: function (t) {\n        return Math.atan2(this.y - t.y, this.x - t.x);\n      },\n      angleWith: function (t) {\n        return this.angleWithSep(t.x, t.y);\n      },\n      angleWithSep: function (t, e) {\n        return Math.atan2(this.x * e - this.y * t, this.x * t + this.y * e);\n      },\n      _matMult: function (t) {\n        var e = t[2] * this.x + t[3] * this.y;\n        return this.x = t[0] * this.x + t[1] * this.y, this.y = e, this;\n      },\n      _add: function (t) {\n        return this.x += t.x, this.y += t.y, this;\n      },\n      _sub: function (t) {\n        return this.x -= t.x, this.y -= t.y, this;\n      },\n      _mult: function (t) {\n        return this.x *= t, this.y *= t, this;\n      },\n      _div: function (t) {\n        return this.x /= t, this.y /= t, this;\n      },\n      _multByPoint: function (t) {\n        return this.x *= t.x, this.y *= t.y, this;\n      },\n      _divByPoint: function (t) {\n        return this.x /= t.x, this.y /= t.y, this;\n      },\n      _unit: function () {\n        return this._div(this.mag()), this;\n      },\n      _perp: function () {\n        var t = this.y;\n        return this.y = this.x, this.x = -t, this;\n      },\n      _rotate: function (t) {\n        var e = Math.cos(t),\n            r = Math.sin(t),\n            n = r * this.x + e * this.y;\n        return this.x = e * this.x - r * this.y, this.y = n, this;\n      },\n      _rotateAround: function (t, e) {\n        var r = Math.cos(t),\n            n = Math.sin(t),\n            i = e.y + n * (this.x - e.x) + r * (this.y - e.y);\n        return this.x = e.x + r * (this.x - e.x) - n * (this.y - e.y), this.y = i, this;\n      },\n      _round: function () {\n        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;\n      }\n    }, s.convert = function (t) {\n      return t instanceof s ? t : Array.isArray(t) ? new s(t[0], t[1]) : t;\n    };\n    var a = \"undefined\" != typeof self ? self : {};\n    const o = Math.PI / 180,\n          l = 180 / Math.PI;\n\n    function u(t) {\n      return t * o;\n    }\n\n    function c(t) {\n      return t * l;\n    }\n\n    const h = [[0, 0], [1, 0], [1, 1], [0, 1]];\n\n    function p(t) {\n      if (t <= 0) return 0;\n      if (t >= 1) return 1;\n      const e = t * t,\n            r = e * t;\n      return 4 * (t < .5 ? r : 3 * (t - e) + r - .75);\n    }\n\n    function f(t, e, n, i) {\n      const s = new r(t, e, n, i);\n      return function (t) {\n        return s.solve(t);\n      };\n    }\n\n    const d = f(.25, .1, .25, 1);\n\n    function y(t, e, r) {\n      return Math.min(r, Math.max(e, t));\n    }\n\n    function m(t, e, r) {\n      return (r = y((r - t) / (e - t), 0, 1)) * r * (3 - 2 * r);\n    }\n\n    function g(t, e, r) {\n      const n = r - e,\n            i = ((t - e) % n + n) % n + e;\n      return i === e ? r : i;\n    }\n\n    function x(t, e, r) {\n      if (!t.length) return r(null, []);\n      let n = t.length;\n      const i = new Array(t.length);\n      let s = null;\n      t.forEach((t, a) => {\n        e(t, (t, e) => {\n          t && (s = t), i[a] = e, 0 == --n && r(s, i);\n        });\n      });\n    }\n\n    function v(t) {\n      const e = [];\n\n      for (const r in t) e.push(t[r]);\n\n      return e;\n    }\n\n    function b(t, ...e) {\n      for (const r of e) for (const e in r) t[e] = r[e];\n\n      return t;\n    }\n\n    let _ = 1;\n\n    function w() {\n      return _++;\n    }\n\n    function A() {\n      return function t(e) {\n        return e ? (e ^ Math.random() * (16 >> e / 4)).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, t);\n      }();\n    }\n\n    function k(t) {\n      return t <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));\n    }\n\n    function S(t) {\n      return !!t && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t);\n    }\n\n    function I(t, e) {\n      t.forEach(t => {\n        e[t] && (e[t] = e[t].bind(e));\n      });\n    }\n\n    function M(t, e) {\n      return -1 !== t.indexOf(e, t.length - e.length);\n    }\n\n    function T(t, e, r) {\n      const n = {};\n\n      for (const i in t) n[i] = e.call(r || this, t[i], i, t);\n\n      return n;\n    }\n\n    function z(t, e, r) {\n      const n = {};\n\n      for (const i in t) e.call(r || this, t[i], i, t) && (n[i] = t[i]);\n\n      return n;\n    }\n\n    function B(t) {\n      return Array.isArray(t) ? t.map(B) : \"object\" == typeof t && t ? T(t, B) : t;\n    }\n\n    const E = {};\n\n    function C(t) {\n      E[t] || (\"undefined\" != typeof console && console.warn(t), E[t] = !0);\n    }\n\n    function D(t, e, r) {\n      return (r.y - t.y) * (e.x - t.x) > (e.y - t.y) * (r.x - t.x);\n    }\n\n    function P(t) {\n      let e = 0;\n\n      for (let r, n, i = 0, s = t.length, a = s - 1; i < s; a = i++) r = t[i], n = t[a], e += (n.x - r.x) * (r.y + n.y);\n\n      return e;\n    }\n\n    function V() {\n      return \"undefined\" != typeof WorkerGlobalScope && \"undefined\" != typeof self && self instanceof WorkerGlobalScope;\n    }\n\n    function F(t) {\n      const e = {};\n\n      if (t.replace(/(?:^|(?:\\s*\\,\\s*))([^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)(?:\\=(?:([^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)|(?:\\\"((?:[^\"\\\\]|\\\\.)*)\\\")))?/g, (t, r, n, i) => {\n        const s = n || i;\n        return e[r] = !s || s.toLowerCase(), \"\";\n      }), e[\"max-age\"]) {\n        const t = parseInt(e[\"max-age\"], 10);\n        isNaN(t) ? delete e[\"max-age\"] : e[\"max-age\"] = t;\n      }\n\n      return e;\n    }\n\n    let L,\n        R,\n        U,\n        $,\n        j = null;\n\n    function O(t) {\n      if (null == j) {\n        const e = t.navigator ? t.navigator.userAgent : null;\n        j = !!t.safari || !(!e || !(/\\b(iPad|iPhone|iPod)\\b/.test(e) || e.match(\"Safari\") && !e.match(\"Chrome\")));\n      }\n\n      return j;\n    }\n\n    function q(t) {\n      try {\n        const e = a[t];\n        return e.setItem(\"_mapbox_test_\", 1), e.removeItem(\"_mapbox_test_\"), !0;\n      } catch (t) {\n        return !1;\n      }\n    }\n\n    const N = {\n      now: () => void 0 !== U ? U : a.performance.now(),\n\n      setNow(t) {\n        U = t;\n      },\n\n      restoreNow() {\n        U = void 0;\n      },\n\n      frame(t) {\n        const e = a.requestAnimationFrame(t);\n        return {\n          cancel: () => a.cancelAnimationFrame(e)\n        };\n      },\n\n      getImageData(t, e = 0) {\n        const {\n          width: r,\n          height: n\n        } = t;\n        $ || ($ = a.document.createElement(\"canvas\"));\n        const i = $.getContext(\"2d\");\n        if (!i) throw new Error(\"failed to create canvas 2d context\");\n        return (r > $.width || n > $.height) && ($.width = r, $.height = n), i.clearRect(-e, -e, r + 2 * e, n + 2 * e), i.drawImage(t, 0, 0, r, n), i.getImageData(-e, -e, r + 2 * e, n + 2 * e);\n      },\n\n      resolveURL: t => (L || (L = a.document.createElement(\"a\")), L.href = t, L.href),\n\n      get devicePixelRatio() {\n        return a.devicePixelRatio;\n      },\n\n      get prefersReducedMotion() {\n        return !!a.matchMedia && (null == R && (R = a.matchMedia(\"(prefers-reduced-motion: reduce)\")), R.matches);\n      }\n\n    };\n    let G;\n    const Z = {\n      API_URL: \"https://api.mapbox.com\",\n\n      get API_URL_REGEX() {\n        if (null == G) {\n          const t = /^((https?:)?\\/\\/)?([^\\/]+\\.)?mapbox\\.c(n|om)(\\/|\\?|$)/i;\n\n          try {\n            G = null != process.env.API_URL_REGEX ? new RegExp(process.env.API_URL_REGEX) : t;\n          } catch (e) {\n            G = t;\n          }\n        }\n\n        return G;\n      },\n\n      get EVENTS_URL() {\n        return this.API_URL ? 0 === this.API_URL.indexOf(\"https://api.mapbox.cn\") ? \"https://events.mapbox.cn/events/v2\" : 0 === this.API_URL.indexOf(\"https://api.mapbox.com\") ? \"https://events.mapbox.com/events/v2\" : null : null;\n      },\n\n      SESSION_PATH: \"/map-sessions/v1\",\n      FEEDBACK_URL: \"https://apps.mapbox.com/feedback\",\n      TILE_URL_VERSION: \"v4\",\n      RASTER_URL_PREFIX: \"raster/v1\",\n      REQUIRE_ACCESS_TOKEN: !0,\n      ACCESS_TOKEN: null,\n      MAX_PARALLEL_IMAGE_REQUESTS: 16\n    },\n          X = {\n      supported: !1,\n      testSupport: function (t) {\n        !H && Y && (W ? J(t) : K = t);\n      }\n    };\n    let K,\n        Y,\n        H = !1,\n        W = !1;\n\n    function J(t) {\n      const e = t.createTexture();\n      t.bindTexture(t.TEXTURE_2D, e);\n\n      try {\n        if (t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, Y), t.isContextLost()) return;\n        X.supported = !0;\n      } catch (t) {}\n\n      t.deleteTexture(e), H = !0;\n    }\n\n    a.document && (Y = a.document.createElement(\"img\"), Y.onload = function () {\n      K && J(K), K = null, W = !0;\n    }, Y.onerror = function () {\n      H = !0, K = null;\n    }, Y.src = \"data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=\");\n    const Q = \"01\",\n          tt = \"NO_ACCESS_TOKEN\";\n\n    function et(t) {\n      return 0 === t.indexOf(\"mapbox:\");\n    }\n\n    function rt(t) {\n      return Z.API_URL_REGEX.test(t);\n    }\n\n    const nt = /^(\\w+):\\/\\/([^/?]*)(\\/[^?]+)?\\??(.+)?/;\n\n    function it(t) {\n      const e = t.match(nt);\n      if (!e) throw new Error(\"Unable to parse URL object\");\n      return {\n        protocol: e[1],\n        authority: e[2],\n        path: e[3] || \"/\",\n        params: e[4] ? e[4].split(\"&\") : []\n      };\n    }\n\n    function st(t) {\n      const e = t.params.length ? `?${t.params.join(\"&\")}` : \"\";\n      return `${t.protocol}://${t.authority}${t.path}${e}`;\n    }\n\n    function at(t) {\n      if (!t) return null;\n      const e = t.split(\".\");\n      if (!e || 3 !== e.length) return null;\n\n      try {\n        return JSON.parse(decodeURIComponent(a.atob(e[1]).split(\"\").map(t => \"%\" + (\"00\" + t.charCodeAt(0).toString(16)).slice(-2)).join(\"\")));\n      } catch (t) {\n        return null;\n      }\n    }\n\n    class ot {\n      constructor(t) {\n        this.type = t, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;\n      }\n\n      getStorageKey(t) {\n        const e = at(Z.ACCESS_TOKEN);\n        let r = \"\";\n        return r = e && e.u ? a.btoa(encodeURIComponent(e.u).replace(/%([0-9A-F]{2})/g, (t, e) => String.fromCharCode(Number(\"0x\" + e)))) : Z.ACCESS_TOKEN || \"\", t ? `mapbox.eventData.${t}:${r}` : `mapbox.eventData:${r}`;\n      }\n\n      fetchEventData() {\n        const t = q(\"localStorage\"),\n              e = this.getStorageKey(),\n              r = this.getStorageKey(\"uuid\");\n        if (t) try {\n          const t = a.localStorage.getItem(e);\n          t && (this.eventData = JSON.parse(t));\n          const n = a.localStorage.getItem(r);\n          n && (this.anonId = n);\n        } catch (t) {\n          C(\"Unable to read from LocalStorage\");\n        }\n      }\n\n      saveEventData() {\n        const t = q(\"localStorage\"),\n              e = this.getStorageKey(),\n              r = this.getStorageKey(\"uuid\");\n        if (t) try {\n          a.localStorage.setItem(r, this.anonId), Object.keys(this.eventData).length >= 1 && a.localStorage.setItem(e, JSON.stringify(this.eventData));\n        } catch (t) {\n          C(\"Unable to write to LocalStorage\");\n        }\n      }\n\n      processRequests(t) {}\n\n      postEvent(t, r, n, i) {\n        if (!Z.EVENTS_URL) return;\n        const s = it(Z.EVENTS_URL);\n        s.params.push(`access_token=${i || Z.ACCESS_TOKEN || \"\"}`);\n        const a = {\n          event: this.type,\n          created: new Date(t).toISOString(),\n          sdkIdentifier: \"mapbox-gl-js\",\n          sdkVersion: e,\n          skuId: Q,\n          userId: this.anonId\n        },\n              o = r ? b(a, r) : a,\n              l = {\n          url: st(s),\n          headers: {\n            \"Content-Type\": \"text/plain\"\n          },\n          body: JSON.stringify([o])\n        };\n        this.pendingRequest = Tt(l, t => {\n          this.pendingRequest = null, n(t), this.saveEventData(), this.processRequests(i);\n        });\n      }\n\n      queueRequest(t, e) {\n        this.queue.push(t), this.processRequests(e);\n      }\n\n    }\n\n    const lt = new class extends ot {\n      constructor(t) {\n        super(\"appUserTurnstile\"), this._customAccessToken = t;\n      }\n\n      postTurnstileEvent(t, e) {\n        Z.EVENTS_URL && Z.ACCESS_TOKEN && Array.isArray(t) && t.some(t => et(t) || rt(t)) && this.queueRequest(Date.now(), e);\n      }\n\n      processRequests(t) {\n        if (this.pendingRequest || 0 === this.queue.length) return;\n        this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();\n        const e = at(Z.ACCESS_TOKEN),\n              r = e ? e.u : Z.ACCESS_TOKEN;\n        let n = r !== this.eventData.tokenU;\n        S(this.anonId) || (this.anonId = A(), n = !0);\n        const i = this.queue.shift();\n\n        if (this.eventData.lastSuccess) {\n          const t = new Date(this.eventData.lastSuccess),\n                e = new Date(i),\n                r = (i - this.eventData.lastSuccess) / 864e5;\n          n = n || r >= 1 || r < -1 || t.getDate() !== e.getDate();\n        } else n = !0;\n\n        n ? this.postEvent(i, {\n          \"enabled.telemetry\": !1\n        }, t => {\n          t || (this.eventData.lastSuccess = i, this.eventData.tokenU = r);\n        }, t) : this.processRequests();\n      }\n\n    }(),\n          ut = lt.postTurnstileEvent.bind(lt),\n          ct = new class extends ot {\n      constructor() {\n        super(\"map.load\"), this.success = {}, this.skuToken = \"\";\n      }\n\n      postMapLoadEvent(t, e, r, n) {\n        this.skuToken = e, this.errorCb = n, Z.EVENTS_URL && (r || Z.ACCESS_TOKEN ? this.queueRequest({\n          id: t,\n          timestamp: Date.now()\n        }, r) : this.errorCb(new Error(tt)));\n      }\n\n      processRequests(t) {\n        if (this.pendingRequest || 0 === this.queue.length) return;\n        const {\n          id: e,\n          timestamp: r\n        } = this.queue.shift();\n        e && this.success[e] || (this.anonId || this.fetchEventData(), S(this.anonId) || (this.anonId = A()), this.postEvent(r, {\n          skuToken: this.skuToken\n        }, t => {\n          t ? this.errorCb(t) : e && (this.success[e] = !0);\n        }, t));\n      }\n\n    }(),\n          ht = ct.postMapLoadEvent.bind(ct),\n          pt = new class extends ot {\n      constructor() {\n        super(\"map.auth\"), this.success = {}, this.skuToken = \"\";\n      }\n\n      getSession(t, e, r, n) {\n        if (!Z.API_URL || !Z.SESSION_PATH) return;\n        const i = it(Z.API_URL + Z.SESSION_PATH);\n        i.params.push(`sku=${e || \"\"}`), i.params.push(`access_token=${n || Z.ACCESS_TOKEN || \"\"}`);\n        const s = {\n          url: st(i),\n          headers: {\n            \"Content-Type\": \"text/plain\"\n          }\n        };\n        this.pendingRequest = zt(s, t => {\n          this.pendingRequest = null, r(t), this.saveEventData(), this.processRequests(n);\n        });\n      }\n\n      getSessionAPI(t, e, r, n) {\n        this.skuToken = e, this.errorCb = n, Z.SESSION_PATH && Z.API_URL && (r || Z.ACCESS_TOKEN ? this.queueRequest({\n          id: t,\n          timestamp: Date.now()\n        }, r) : this.errorCb(new Error(tt)));\n      }\n\n      processRequests(t) {\n        if (this.pendingRequest || 0 === this.queue.length) return;\n        const {\n          id: e,\n          timestamp: r\n        } = this.queue.shift();\n        e && this.success[e] || this.getSession(r, this.skuToken, t => {\n          t ? this.errorCb(t) : e && (this.success[e] = !0);\n        }, t);\n      }\n\n    }(),\n          ft = pt.getSessionAPI.bind(pt),\n          dt = new Set(),\n          yt = \"mapbox-tiles\";\n    let mt,\n        gt,\n        xt = 500,\n        vt = 50;\n\n    function bt() {\n      a.caches && !mt && (mt = a.caches.open(yt));\n    }\n\n    function _t(t) {\n      const e = t.indexOf(\"?\");\n      return e < 0 ? t : t.slice(0, e);\n    }\n\n    let wt = 1 / 0;\n    const At = {\n      Unknown: \"Unknown\",\n      Style: \"Style\",\n      Source: \"Source\",\n      Tile: \"Tile\",\n      Glyphs: \"Glyphs\",\n      SpriteImage: \"SpriteImage\",\n      SpriteJSON: \"SpriteJSON\",\n      Image: \"Image\"\n    };\n    \"function\" == typeof Object.freeze && Object.freeze(At);\n\n    class kt extends Error {\n      constructor(t, e, r) {\n        401 === e && rt(r) && (t += \": you may have provided an invalid Mapbox access token. See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes\"), super(t), this.status = e, this.url = r;\n      }\n\n      toString() {\n        return `${this.name}: ${this.message} (${this.status}): ${this.url}`;\n      }\n\n    }\n\n    const St = V() ? () => self.worker && self.worker.referrer : () => (\"blob:\" === a.location.protocol ? a.parent : a).location.href;\n\n    const It = function (t, e) {\n      if (!(/^file:/.test(r = t.url) || /^file:/.test(St()) && !/^\\w+:/.test(r))) {\n        if (a.fetch && a.Request && a.AbortController && a.Request.prototype.hasOwnProperty(\"signal\")) return function (t, e) {\n          const r = new a.AbortController(),\n                n = new a.Request(t.url, {\n            method: t.method || \"GET\",\n            body: t.body,\n            credentials: t.credentials,\n            headers: t.headers,\n            referrer: St(),\n            signal: r.signal\n          });\n          let i = !1,\n              s = !1;\n          const o = (l = n.url).indexOf(\"sku=\") > 0 && rt(l);\n          var l;\n          \"json\" === t.type && n.headers.set(\"Accept\", \"application/json\");\n\n          const u = (r, i, l) => {\n            if (s) return;\n            if (r && \"SecurityError\" !== r.message && C(r), i && l) return c(i);\n            const u = Date.now();\n            a.fetch(n).then(r => {\n              if (r.ok) {\n                const t = o ? r.clone() : null;\n                return c(r, t, u);\n              }\n\n              return e(new kt(r.statusText, r.status, t.url));\n            }).catch(t => {\n              20 !== t.code && e(new Error(t.message));\n            });\n          },\n                c = (r, o, l) => {\n            (\"arrayBuffer\" === t.type ? r.arrayBuffer() : \"json\" === t.type ? r.json() : r.text()).then(t => {\n              s || (o && l && function (t, e, r) {\n                if (bt(), !mt) return;\n                const n = {\n                  status: e.status,\n                  statusText: e.statusText,\n                  headers: new a.Headers()\n                };\n                e.headers.forEach((t, e) => n.headers.set(e, t));\n                const i = F(e.headers.get(\"Cache-Control\") || \"\");\n                if (i[\"no-store\"]) return;\n                i[\"max-age\"] && n.headers.set(\"Expires\", new Date(r + 1e3 * i[\"max-age\"]).toUTCString());\n                const s = n.headers.get(\"Expires\");\n                s && (new Date(s).getTime() - r < 42e4 || function (t, e) {\n                  if (void 0 === gt) try {\n                    new Response(new ReadableStream()), gt = !0;\n                  } catch (t) {\n                    gt = !1;\n                  }\n                  gt ? e(t.body) : t.blob().then(e);\n                }(e, e => {\n                  const r = new a.Response(e, n);\n                  bt(), mt && mt.then(e => e.put(_t(t.url), r)).catch(t => C(t.message));\n                }));\n              }(n, o, l), i = !0, e(null, t, r.headers.get(\"Cache-Control\"), r.headers.get(\"Expires\")));\n            }).catch(t => {\n              s || e(new Error(t.message));\n            });\n          };\n\n          return o ? function (t, e) {\n            if (bt(), !mt) return e(null);\n\n            const r = _t(t.url);\n\n            mt.then(t => {\n              t.match(r).then(n => {\n                const i = function (t) {\n                  if (!t) return !1;\n                  const e = new Date(t.headers.get(\"Expires\") || 0),\n                        r = F(t.headers.get(\"Cache-Control\") || \"\");\n                  return e > Date.now() && !r[\"no-cache\"];\n                }(n);\n\n                t.delete(r), i && t.put(r, n.clone()), e(null, n, i);\n              }).catch(e);\n            }).catch(e);\n          }(n, u) : u(null, null), {\n            cancel: () => {\n              s = !0, i || r.abort();\n            }\n          };\n        }(t, e);\n        if (V() && self.worker && self.worker.actor) return self.worker.actor.send(\"getResource\", t, e, void 0, !0);\n      }\n\n      var r;\n      return function (t, e) {\n        const r = new a.XMLHttpRequest();\n        r.open(t.method || \"GET\", t.url, !0), \"arrayBuffer\" === t.type && (r.responseType = \"arraybuffer\");\n\n        for (const e in t.headers) r.setRequestHeader(e, t.headers[e]);\n\n        return \"json\" === t.type && (r.responseType = \"text\", r.setRequestHeader(\"Accept\", \"application/json\")), r.withCredentials = \"include\" === t.credentials, r.onerror = () => {\n          e(new Error(r.statusText));\n        }, r.onload = () => {\n          if ((r.status >= 200 && r.status < 300 || 0 === r.status) && null !== r.response) {\n            let n = r.response;\n            if (\"json\" === t.type) try {\n              n = JSON.parse(r.response);\n            } catch (t) {\n              return e(t);\n            }\n            e(null, n, r.getResponseHeader(\"Cache-Control\"), r.getResponseHeader(\"Expires\"));\n          } else e(new kt(r.statusText, r.status, t.url));\n        }, r.send(t.body), {\n          cancel: () => r.abort()\n        };\n      }(t, e);\n    },\n          Mt = function (t, e) {\n      return It(b(t, {\n        type: \"arrayBuffer\"\n      }), e);\n    },\n          Tt = function (t, e) {\n      return It(b(t, {\n        method: \"POST\"\n      }), e);\n    },\n          zt = function (t, e) {\n      return It(b(t, {\n        method: \"GET\"\n      }), e);\n    };\n\n    function Bt(t) {\n      const e = a.document.createElement(\"a\");\n      return e.href = t, e.protocol === a.document.location.protocol && e.host === a.document.location.host;\n    }\n\n    const Et = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=\";\n    let Ct, Dt;\n    Ct = [], Dt = 0;\n\n    const Pt = function (t, e) {\n      if (X.supported && (t.headers || (t.headers = {}), t.headers.accept = \"image/webp,*/*\"), Dt >= Z.MAX_PARALLEL_IMAGE_REQUESTS) {\n        const r = {\n          requestParameters: t,\n          callback: e,\n          cancelled: !1,\n\n          cancel() {\n            this.cancelled = !0;\n          }\n\n        };\n        return Ct.push(r), r;\n      }\n\n      Dt++;\n      let r = !1;\n\n      const n = () => {\n        if (!r) for (r = !0, Dt--; Ct.length && Dt < Z.MAX_PARALLEL_IMAGE_REQUESTS;) {\n          const t = Ct.shift(),\n                {\n            requestParameters: e,\n            callback: r,\n            cancelled: n\n          } = t;\n          n || (t.cancel = Pt(e, r).cancel);\n        }\n      },\n            i = Mt(t, (t, r, i, s) => {\n        n(), t ? e(t) : r && (a.createImageBitmap ? function (t, e) {\n          const r = new a.Blob([new Uint8Array(t)], {\n            type: \"image/png\"\n          });\n          a.createImageBitmap(r).then(t => {\n            e(null, t);\n          }).catch(t => {\n            e(new Error(`Could not load image because of ${t.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));\n          });\n        }(r, (t, r) => e(t, r, i, s)) : function (t, e) {\n          const r = new a.Image(),\n                n = a.URL;\n          r.onload = () => {\n            e(null, r), n.revokeObjectURL(r.src), r.onload = null, a.requestAnimationFrame(() => {\n              r.src = Et;\n            });\n          }, r.onerror = () => e(new Error(\"Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.\"));\n          const i = new a.Blob([new Uint8Array(t)], {\n            type: \"image/png\"\n          });\n          r.src = t.byteLength ? n.createObjectURL(i) : Et;\n        }(r, (t, r) => e(t, r, i, s)));\n      });\n\n      return {\n        cancel: () => {\n          i.cancel(), n();\n        }\n      };\n    };\n\n    function Vt(t, e, r) {\n      r[t] && -1 !== r[t].indexOf(e) || (r[t] = r[t] || [], r[t].push(e));\n    }\n\n    function Ft(t, e, r) {\n      if (r && r[t]) {\n        const n = r[t].indexOf(e);\n        -1 !== n && r[t].splice(n, 1);\n      }\n    }\n\n    class Lt {\n      constructor(t, e = {}) {\n        b(this, e), this.type = t;\n      }\n\n    }\n\n    class Rt extends Lt {\n      constructor(t, e = {}) {\n        super(\"error\", b({\n          error: t\n        }, e));\n      }\n\n    }\n\n    class Ut {\n      on(t, e) {\n        return this._listeners = this._listeners || {}, Vt(t, e, this._listeners), this;\n      }\n\n      off(t, e) {\n        return Ft(t, e, this._listeners), Ft(t, e, this._oneTimeListeners), this;\n      }\n\n      once(t, e) {\n        return e ? (this._oneTimeListeners = this._oneTimeListeners || {}, Vt(t, e, this._oneTimeListeners), this) : new Promise(e => this.once(t, e));\n      }\n\n      fire(t, e) {\n        \"string\" == typeof t && (t = new Lt(t, e || {}));\n        const r = t.type;\n\n        if (this.listens(r)) {\n          t.target = this;\n          const e = this._listeners && this._listeners[r] ? this._listeners[r].slice() : [];\n\n          for (const r of e) r.call(this, t);\n\n          const n = this._oneTimeListeners && this._oneTimeListeners[r] ? this._oneTimeListeners[r].slice() : [];\n\n          for (const e of n) Ft(r, e, this._oneTimeListeners), e.call(this, t);\n\n          const i = this._eventedParent;\n          i && (b(t, \"function\" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i.fire(t));\n        } else t instanceof Rt && console.error(t.error);\n\n        return this;\n      }\n\n      listens(t) {\n        return !!(this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t));\n      }\n\n      setEventedParent(t, e) {\n        return this._eventedParent = t, this._eventedParentData = e, this;\n      }\n\n    }\n\n    var $t = JSON.parse('{\"$version\":8,\"$root\":{\"version\":{\"required\":true,\"type\":\"enum\",\"values\":[8]},\"name\":{\"type\":\"string\"},\"metadata\":{\"type\":\"*\"},\"center\":{\"type\":\"array\",\"value\":\"number\"},\"zoom\":{\"type\":\"number\"},\"bearing\":{\"type\":\"number\",\"default\":0,\"period\":360,\"units\":\"degrees\"},\"pitch\":{\"type\":\"number\",\"default\":0,\"units\":\"degrees\"},\"light\":{\"type\":\"light\"},\"terrain\":{\"type\":\"terrain\"},\"fog\":{\"type\":\"fog\"},\"sources\":{\"required\":true,\"type\":\"sources\"},\"sprite\":{\"type\":\"string\"},\"glyphs\":{\"type\":\"string\"},\"transition\":{\"type\":\"transition\"},\"projection\":{\"type\":\"projection\"},\"layers\":{\"required\":true,\"type\":\"array\",\"value\":\"layer\"}},\"sources\":{\"*\":{\"type\":\"source\"}},\"source\":[\"source_vector\",\"source_raster\",\"source_raster_dem\",\"source_geojson\",\"source_video\",\"source_image\"],\"source_vector\":{\"type\":{\"required\":true,\"type\":\"enum\",\"values\":{\"vector\":{}}},\"url\":{\"type\":\"string\"},\"tiles\":{\"type\":\"array\",\"value\":\"string\"},\"bounds\":{\"type\":\"array\",\"value\":\"number\",\"length\":4,\"default\":[-180,-85.051129,180,85.051129]},\"scheme\":{\"type\":\"enum\",\"values\":{\"xyz\":{},\"tms\":{}},\"default\":\"xyz\"},\"minzoom\":{\"type\":\"number\",\"default\":0},\"maxzoom\":{\"type\":\"number\",\"default\":22},\"attribution\":{\"type\":\"string\"},\"promoteId\":{\"type\":\"promoteId\"},\"volatile\":{\"type\":\"boolean\",\"default\":false},\"*\":{\"type\":\"*\"}},\"source_raster\":{\"type\":{\"required\":true,\"type\":\"enum\",\"values\":{\"raster\":{}}},\"url\":{\"type\":\"string\"},\"tiles\":{\"type\":\"array\",\"value\":\"string\"},\"bounds\":{\"type\":\"array\",\"value\":\"number\",\"length\":4,\"default\":[-180,-85.051129,180,85.051129]},\"minzoom\":{\"type\":\"number\",\"default\":0},\"maxzoom\":{\"type\":\"number\",\"default\":22},\"tileSize\":{\"type\":\"number\",\"default\":512,\"units\":\"pixels\"},\"scheme\":{\"type\":\"enum\",\"values\":{\"xyz\":{},\"tms\":{}},\"default\":\"xyz\"},\"attribution\":{\"type\":\"string\"},\"volatile\":{\"type\":\"boolean\",\"default\":false},\"*\":{\"type\":\"*\"}},\"source_raster_dem\":{\"type\":{\"required\":true,\"type\":\"enum\",\"values\":{\"raster-dem\":{}}},\"url\":{\"type\":\"string\"},\"tiles\":{\"type\":\"array\",\"value\":\"string\"},\"bounds\":{\"type\":\"array\",\"value\":\"number\",\"length\":4,\"default\":[-180,-85.051129,180,85.051129]},\"minzoom\":{\"type\":\"number\",\"default\":0},\"maxzoom\":{\"type\":\"number\",\"default\":22},\"tileSize\":{\"type\":\"number\",\"default\":512,\"units\":\"pixels\"},\"attribution\":{\"type\":\"string\"},\"encoding\":{\"type\":\"enum\",\"values\":{\"terrarium\":{},\"mapbox\":{}},\"default\":\"mapbox\"},\"volatile\":{\"type\":\"boolean\",\"default\":false},\"*\":{\"type\":\"*\"}},\"source_geojson\":{\"type\":{\"required\":true,\"type\":\"enum\",\"values\":{\"geojson\":{}}},\"data\":{\"type\":\"*\"},\"maxzoom\":{\"type\":\"number\",\"default\":18},\"attribution\":{\"type\":\"string\"},\"buffer\":{\"type\":\"number\",\"default\":128,\"maximum\":512,\"minimum\":0},\"filter\":{\"type\":\"*\"},\"tolerance\":{\"type\":\"number\",\"default\":0.375},\"cluster\":{\"type\":\"boolean\",\"default\":false},\"clusterRadius\":{\"type\":\"number\",\"default\":50,\"minimum\":0},\"clusterMaxZoom\":{\"type\":\"number\"},\"clusterMinPoints\":{\"type\":\"number\"},\"clusterProperties\":{\"type\":\"*\"},\"lineMetrics\":{\"type\":\"boolean\",\"default\":false},\"generateId\":{\"type\":\"boolean\",\"default\":false},\"promoteId\":{\"type\":\"promoteId\"}},\"source_video\":{\"type\":{\"required\":true,\"type\":\"enum\",\"values\":{\"video\":{}}},\"urls\":{\"required\":true,\"type\":\"array\",\"value\":\"string\"},\"coordinates\":{\"required\":true,\"type\":\"array\",\"length\":4,\"value\":{\"type\":\"array\",\"length\":2,\"value\":\"number\"}}},\"source_image\":{\"type\":{\"required\":true,\"type\":\"enum\",\"values\":{\"image\":{}}},\"url\":{\"required\":true,\"type\":\"string\"},\"coordinates\":{\"required\":true,\"type\":\"array\",\"length\":4,\"value\":{\"type\":\"array\",\"length\":2,\"value\":\"number\"}}},\"layer\":{\"id\":{\"type\":\"string\",\"required\":true},\"type\":{\"type\":\"enum\",\"values\":{\"fill\":{},\"line\":{},\"symbol\":{},\"circle\":{},\"heatmap\":{},\"fill-extrusion\":{},\"raster\":{},\"hillshade\":{},\"background\":{},\"sky\":{}},\"required\":true},\"metadata\":{\"type\":\"*\"},\"source\":{\"type\":\"string\"},\"source-layer\":{\"type\":\"string\"},\"minzoom\":{\"type\":\"number\",\"minimum\":0,\"maximum\":24},\"maxzoom\":{\"type\":\"number\",\"minimum\":0,\"maximum\":24},\"filter\":{\"type\":\"filter\"},\"layout\":{\"type\":\"layout\"},\"paint\":{\"type\":\"paint\"}},\"layout\":[\"layout_fill\",\"layout_line\",\"layout_circle\",\"layout_heatmap\",\"layout_fill-extrusion\",\"layout_symbol\",\"layout_raster\",\"layout_hillshade\",\"layout_background\",\"layout_sky\"],\"layout_background\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":{},\"none\":{}},\"default\":\"visible\",\"property-type\":\"constant\"}},\"layout_sky\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":{},\"none\":{}},\"default\":\"visible\",\"property-type\":\"constant\"}},\"layout_fill\":{\"fill-sort-key\":{\"type\":\"number\",\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":{},\"none\":{}},\"default\":\"visible\",\"property-type\":\"constant\"}},\"layout_circle\":{\"circle-sort-key\":{\"type\":\"number\",\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":{},\"none\":{}},\"default\":\"visible\",\"property-type\":\"constant\"}},\"layout_heatmap\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":{},\"none\":{}},\"default\":\"visible\",\"property-type\":\"constant\"}},\"layout_fill-extrusion\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":{},\"none\":{}},\"default\":\"visible\",\"property-type\":\"constant\"}},\"layout_line\":{\"line-cap\":{\"type\":\"enum\",\"values\":{\"butt\":{},\"round\":{},\"square\":{}},\"default\":\"butt\",\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"line-join\":{\"type\":\"enum\",\"values\":{\"bevel\":{},\"round\":{},\"miter\":{}},\"default\":\"miter\",\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"line-miter-limit\":{\"type\":\"number\",\"default\":2,\"requires\":[{\"line-join\":\"miter\"}],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"line-round-limit\":{\"type\":\"number\",\"default\":1.05,\"requires\":[{\"line-join\":\"round\"}],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"line-sort-key\":{\"type\":\"number\",\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":{},\"none\":{}},\"default\":\"visible\",\"property-type\":\"constant\"}},\"layout_symbol\":{\"symbol-placement\":{\"type\":\"enum\",\"values\":{\"point\":{},\"line\":{},\"line-center\":{}},\"default\":\"point\",\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"symbol-spacing\":{\"type\":\"number\",\"default\":250,\"minimum\":1,\"units\":\"pixels\",\"requires\":[{\"symbol-placement\":\"line\"}],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"symbol-avoid-edges\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"symbol-sort-key\":{\"type\":\"number\",\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"symbol-z-order\":{\"type\":\"enum\",\"values\":{\"auto\":{},\"viewport-y\":{},\"source\":{}},\"default\":\"auto\",\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"icon-allow-overlap\":{\"type\":\"boolean\",\"default\":false,\"requires\":[\"icon-image\"],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"icon-ignore-placement\":{\"type\":\"boolean\",\"default\":false,\"requires\":[\"icon-image\"],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"icon-optional\":{\"type\":\"boolean\",\"default\":false,\"requires\":[\"icon-image\",\"text-field\"],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"icon-rotation-alignment\":{\"type\":\"enum\",\"values\":{\"map\":{},\"viewport\":{},\"auto\":{}},\"default\":\"auto\",\"requires\":[\"icon-image\"],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"icon-size\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"units\":\"factor of the original icon size\",\"requires\":[\"icon-image\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"icon-text-fit\":{\"type\":\"enum\",\"values\":{\"none\":{},\"width\":{},\"height\":{},\"both\":{}},\"default\":\"none\",\"requires\":[\"icon-image\",\"text-field\"],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"icon-text-fit-padding\":{\"type\":\"array\",\"value\":\"number\",\"length\":4,\"default\":[0,0,0,0],\"units\":\"pixels\",\"requires\":[\"icon-image\",\"text-field\",{\"icon-text-fit\":[\"both\",\"width\",\"height\"]}],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"icon-image\":{\"type\":\"resolvedImage\",\"tokens\":true,\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"icon-rotate\":{\"type\":\"number\",\"default\":0,\"period\":360,\"units\":\"degrees\",\"requires\":[\"icon-image\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"icon-padding\":{\"type\":\"number\",\"default\":2,\"minimum\":0,\"units\":\"pixels\",\"requires\":[\"icon-image\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"icon-keep-upright\":{\"type\":\"boolean\",\"default\":false,\"requires\":[\"icon-image\",{\"icon-rotation-alignment\":\"map\"},{\"symbol-placement\":[\"line\",\"line-center\"]}],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"icon-offset\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"requires\":[\"icon-image\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"icon-anchor\":{\"type\":\"enum\",\"values\":{\"center\":{},\"left\":{},\"right\":{},\"top\":{},\"bottom\":{},\"top-left\":{},\"top-right\":{},\"bottom-left\":{},\"bottom-right\":{}},\"default\":\"center\",\"requires\":[\"icon-image\"],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"icon-pitch-alignment\":{\"type\":\"enum\",\"values\":{\"map\":{},\"viewport\":{},\"auto\":{}},\"default\":\"auto\",\"requires\":[\"icon-image\"],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-pitch-alignment\":{\"type\":\"enum\",\"values\":{\"map\":{},\"viewport\":{},\"auto\":{}},\"default\":\"auto\",\"requires\":[\"text-field\"],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-rotation-alignment\":{\"type\":\"enum\",\"values\":{\"map\":{},\"viewport\":{},\"auto\":{}},\"default\":\"auto\",\"requires\":[\"text-field\"],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-field\":{\"type\":\"formatted\",\"default\":\"\",\"tokens\":true,\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-font\":{\"type\":\"array\",\"value\":\"string\",\"default\":[\"Open Sans Regular\",\"Arial Unicode MS Regular\"],\"requires\":[\"text-field\"],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-size\":{\"type\":\"number\",\"default\":16,\"minimum\":0,\"units\":\"pixels\",\"requires\":[\"text-field\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-max-width\":{\"type\":\"number\",\"default\":10,\"minimum\":0,\"units\":\"ems\",\"requires\":[\"text-field\",{\"symbol-placement\":[\"point\"]}],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-line-height\":{\"type\":\"number\",\"default\":1.2,\"units\":\"ems\",\"requires\":[\"text-field\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-letter-spacing\":{\"type\":\"number\",\"default\":0,\"units\":\"ems\",\"requires\":[\"text-field\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-justify\":{\"type\":\"enum\",\"values\":{\"auto\":{},\"left\":{},\"center\":{},\"right\":{}},\"default\":\"center\",\"requires\":[\"text-field\"],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-radial-offset\":{\"type\":\"number\",\"units\":\"ems\",\"default\":0,\"requires\":[\"text-field\"],\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]}},\"text-variable-anchor\":{\"type\":\"array\",\"value\":\"enum\",\"values\":{\"center\":{},\"left\":{},\"right\":{},\"top\":{},\"bottom\":{},\"top-left\":{},\"top-right\":{},\"bottom-left\":{},\"bottom-right\":{}},\"requires\":[\"text-field\",{\"symbol-placement\":[\"point\"]}],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-anchor\":{\"type\":\"enum\",\"values\":{\"center\":{},\"left\":{},\"right\":{},\"top\":{},\"bottom\":{},\"top-left\":{},\"top-right\":{},\"bottom-left\":{},\"bottom-right\":{}},\"default\":\"center\",\"requires\":[\"text-field\",{\"!\":\"text-variable-anchor\"}],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-max-angle\":{\"type\":\"number\",\"default\":45,\"units\":\"degrees\",\"requires\":[\"text-field\",{\"symbol-placement\":[\"line\",\"line-center\"]}],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-writing-mode\":{\"type\":\"array\",\"value\":\"enum\",\"values\":{\"horizontal\":{},\"vertical\":{}},\"requires\":[\"text-field\"],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-rotate\":{\"type\":\"number\",\"default\":0,\"period\":360,\"units\":\"degrees\",\"requires\":[\"text-field\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-padding\":{\"type\":\"number\",\"default\":2,\"minimum\":0,\"units\":\"pixels\",\"requires\":[\"text-field\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-keep-upright\":{\"type\":\"boolean\",\"default\":true,\"requires\":[\"text-field\",{\"text-rotation-alignment\":\"map\"},{\"symbol-placement\":[\"line\",\"line-center\"]}],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-transform\":{\"type\":\"enum\",\"values\":{\"none\":{},\"uppercase\":{},\"lowercase\":{}},\"default\":\"none\",\"requires\":[\"text-field\"],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-offset\":{\"type\":\"array\",\"value\":\"number\",\"units\":\"ems\",\"length\":2,\"default\":[0,0],\"requires\":[\"text-field\",{\"!\":\"text-radial-offset\"}],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-allow-overlap\":{\"type\":\"boolean\",\"default\":false,\"requires\":[\"text-field\"],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-ignore-placement\":{\"type\":\"boolean\",\"default\":false,\"requires\":[\"text-field\"],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-optional\":{\"type\":\"boolean\",\"default\":false,\"requires\":[\"text-field\",\"icon-image\"],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":{},\"none\":{}},\"default\":\"visible\",\"property-type\":\"constant\"}},\"layout_raster\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":{},\"none\":{}},\"default\":\"visible\",\"property-type\":\"constant\"}},\"layout_hillshade\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":{},\"none\":{}},\"default\":\"visible\",\"property-type\":\"constant\"}},\"filter\":{\"type\":\"array\",\"value\":\"*\"},\"filter_symbol\":{\"type\":\"boolean\",\"default\":false,\"transition\":false,\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\",\"pitch\",\"distance-from-center\"]}},\"filter_fill\":{\"type\":\"boolean\",\"default\":false,\"transition\":false,\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\"]}},\"filter_line\":{\"type\":\"boolean\",\"default\":false,\"transition\":false,\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\"]}},\"filter_circle\":{\"type\":\"boolean\",\"default\":false,\"transition\":false,\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\"]}},\"filter_fill-extrusion\":{\"type\":\"boolean\",\"default\":false,\"transition\":false,\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\"]}},\"filter_heatmap\":{\"type\":\"boolean\",\"default\":false,\"transition\":false,\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\"]}},\"filter_operator\":{\"type\":\"enum\",\"values\":{\"==\":{},\"!=\":{},\">\":{},\">=\":{},\"<\":{},\"<=\":{},\"in\":{},\"!in\":{},\"all\":{},\"any\":{},\"none\":{},\"has\":{},\"!has\":{},\"within\":{}}},\"geometry_type\":{\"type\":\"enum\",\"values\":{\"Point\":{},\"LineString\":{},\"Polygon\":{}}},\"function\":{\"expression\":{\"type\":\"expression\"},\"stops\":{\"type\":\"array\",\"value\":\"function_stop\"},\"base\":{\"type\":\"number\",\"default\":1,\"minimum\":0},\"property\":{\"type\":\"string\",\"default\":\"$zoom\"},\"type\":{\"type\":\"enum\",\"values\":{\"identity\":{},\"exponential\":{},\"interval\":{},\"categorical\":{}},\"default\":\"exponential\"},\"colorSpace\":{\"type\":\"enum\",\"values\":{\"rgb\":{},\"lab\":{},\"hcl\":{}},\"default\":\"rgb\"},\"default\":{\"type\":\"*\",\"required\":false}},\"function_stop\":{\"type\":\"array\",\"minimum\":0,\"maximum\":24,\"value\":[\"number\",\"color\"],\"length\":2},\"expression\":{\"type\":\"array\",\"value\":\"*\",\"minimum\":1},\"fog\":{\"range\":{\"type\":\"array\",\"default\":[0.5,10],\"minimum\":-20,\"maximum\":20,\"length\":2,\"value\":\"number\",\"property-type\":\"data-constant\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"color\":{\"type\":\"color\",\"property-type\":\"data-constant\",\"default\":\"#ffffff\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"horizon-blend\":{\"type\":\"number\",\"property-type\":\"data-constant\",\"default\":0.1,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true}},\"light\":{\"anchor\":{\"type\":\"enum\",\"default\":\"viewport\",\"values\":{\"map\":{},\"viewport\":{}},\"property-type\":\"data-constant\",\"transition\":false,\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]}},\"position\":{\"type\":\"array\",\"default\":[1.15,210,30],\"length\":3,\"value\":\"number\",\"property-type\":\"data-constant\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"color\":{\"type\":\"color\",\"property-type\":\"data-constant\",\"default\":\"#ffffff\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"intensity\":{\"type\":\"number\",\"property-type\":\"data-constant\",\"default\":0.5,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true}},\"projection\":{\"name\":{\"type\":\"enum\",\"values\":{\"albers\":{},\"equalEarth\":{},\"equirectangular\":{},\"lambertConformalConic\":{},\"mercator\":{},\"naturalEarth\":{},\"winkelTripel\":{}},\"default\":\"mercator\",\"required\":true},\"center\":{\"type\":\"array\",\"length\":2,\"value\":\"number\",\"property-type\":\"data-constant\",\"transition\":false,\"requires\":[{\"name\":[\"albers\",\"lambertConformalConic\"]}]},\"parallels\":{\"type\":\"array\",\"length\":2,\"value\":\"number\",\"property-type\":\"data-constant\",\"transition\":false,\"requires\":[{\"name\":[\"albers\",\"lambertConformalConic\"]}]}},\"terrain\":{\"source\":{\"type\":\"string\",\"required\":true},\"exaggeration\":{\"type\":\"number\",\"property-type\":\"data-constant\",\"default\":1,\"minimum\":0,\"maximum\":1000,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true}},\"paint\":[\"paint_fill\",\"paint_line\",\"paint_circle\",\"paint_heatmap\",\"paint_fill-extrusion\",\"paint_symbol\",\"paint_raster\",\"paint_hillshade\",\"paint_background\",\"paint_sky\"],\"paint_fill\":{\"fill-antialias\":{\"type\":\"boolean\",\"default\":true,\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"fill-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"fill-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"requires\":[{\"!\":\"fill-pattern\"}],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"fill-outline-color\":{\"type\":\"color\",\"transition\":true,\"requires\":[{\"!\":\"fill-pattern\"},{\"fill-antialias\":true}],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"fill-translate\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"transition\":true,\"units\":\"pixels\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"fill-translate-anchor\":{\"type\":\"enum\",\"values\":{\"map\":{},\"viewport\":{}},\"default\":\"map\",\"requires\":[\"fill-translate\"],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"fill-pattern\":{\"type\":\"resolvedImage\",\"transition\":true,\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"cross-faded-data-driven\"}},\"paint_fill-extrusion\":{\"fill-extrusion-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"fill-extrusion-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"requires\":[{\"!\":\"fill-extrusion-pattern\"}],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"fill-extrusion-translate\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"transition\":true,\"units\":\"pixels\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"fill-extrusion-translate-anchor\":{\"type\":\"enum\",\"values\":{\"map\":{},\"viewport\":{}},\"default\":\"map\",\"requires\":[\"fill-extrusion-translate\"],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"fill-extrusion-pattern\":{\"type\":\"resolvedImage\",\"transition\":true,\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"cross-faded-data-driven\"},\"fill-extrusion-height\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"units\":\"meters\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"fill-extrusion-base\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"units\":\"meters\",\"transition\":true,\"requires\":[\"fill-extrusion-height\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"fill-extrusion-vertical-gradient\":{\"type\":\"boolean\",\"default\":true,\"transition\":false,\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"}},\"paint_line\":{\"line-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"line-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"requires\":[{\"!\":\"line-pattern\"}],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"line-translate\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"transition\":true,\"units\":\"pixels\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"line-translate-anchor\":{\"type\":\"enum\",\"values\":{\"map\":{},\"viewport\":{}},\"default\":\"map\",\"requires\":[\"line-translate\"],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"line-width\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"transition\":true,\"units\":\"pixels\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"line-gap-width\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"units\":\"pixels\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"line-offset\":{\"type\":\"number\",\"default\":0,\"transition\":true,\"units\":\"pixels\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"line-blur\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"units\":\"pixels\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"line-dasharray\":{\"type\":\"array\",\"value\":\"number\",\"minimum\":0,\"transition\":true,\"units\":\"line widths\",\"requires\":[{\"!\":\"line-pattern\"}],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"cross-faded-data-driven\"},\"line-pattern\":{\"type\":\"resolvedImage\",\"transition\":true,\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"cross-faded-data-driven\"},\"line-gradient\":{\"type\":\"color\",\"transition\":false,\"requires\":[{\"!\":\"line-pattern\"},{\"source\":\"geojson\",\"has\":{\"lineMetrics\":true}}],\"expression\":{\"interpolated\":true,\"parameters\":[\"line-progress\"]},\"property-type\":\"color-ramp\"}},\"paint_circle\":{\"circle-radius\":{\"type\":\"number\",\"default\":5,\"minimum\":0,\"transition\":true,\"units\":\"pixels\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"circle-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"circle-blur\":{\"type\":\"number\",\"default\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"circle-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"circle-translate\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"transition\":true,\"units\":\"pixels\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"circle-translate-anchor\":{\"type\":\"enum\",\"values\":{\"map\":{},\"viewport\":{}},\"default\":\"map\",\"requires\":[\"circle-translate\"],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"circle-pitch-scale\":{\"type\":\"enum\",\"values\":{\"map\":{},\"viewport\":{}},\"default\":\"map\",\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"circle-pitch-alignment\":{\"type\":\"enum\",\"values\":{\"map\":{},\"viewport\":{}},\"default\":\"viewport\",\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"circle-stroke-width\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"units\":\"pixels\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"circle-stroke-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"circle-stroke-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"}},\"paint_heatmap\":{\"heatmap-radius\":{\"type\":\"number\",\"default\":30,\"minimum\":1,\"transition\":true,\"units\":\"pixels\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"heatmap-weight\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"transition\":false,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"heatmap-intensity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"heatmap-color\":{\"type\":\"color\",\"default\":[\"interpolate\",[\"linear\"],[\"heatmap-density\"],0,\"rgba(0, 0, 255, 0)\",0.1,\"royalblue\",0.3,\"cyan\",0.5,\"lime\",0.7,\"yellow\",1,\"red\"],\"transition\":false,\"expression\":{\"interpolated\":true,\"parameters\":[\"heatmap-density\"]},\"property-type\":\"color-ramp\"},\"heatmap-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"}},\"paint_symbol\":{\"icon-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"requires\":[\"icon-image\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"icon-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"requires\":[\"icon-image\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"icon-halo-color\":{\"type\":\"color\",\"default\":\"rgba(0, 0, 0, 0)\",\"transition\":true,\"requires\":[\"icon-image\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"icon-halo-width\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"units\":\"pixels\",\"requires\":[\"icon-image\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"icon-halo-blur\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"units\":\"pixels\",\"requires\":[\"icon-image\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"icon-translate\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"transition\":true,\"units\":\"pixels\",\"requires\":[\"icon-image\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"icon-translate-anchor\":{\"type\":\"enum\",\"values\":{\"map\":{},\"viewport\":{}},\"default\":\"map\",\"requires\":[\"icon-image\",\"icon-translate\"],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"requires\":[\"text-field\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"text-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"overridable\":true,\"requires\":[\"text-field\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"text-halo-color\":{\"type\":\"color\",\"default\":\"rgba(0, 0, 0, 0)\",\"transition\":true,\"requires\":[\"text-field\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"text-halo-width\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"units\":\"pixels\",\"requires\":[\"text-field\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"text-halo-blur\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"units\":\"pixels\",\"requires\":[\"text-field\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"text-translate\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"transition\":true,\"units\":\"pixels\",\"requires\":[\"text-field\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-translate-anchor\":{\"type\":\"enum\",\"values\":{\"map\":{},\"viewport\":{}},\"default\":\"map\",\"requires\":[\"text-field\",\"text-translate\"],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"}},\"paint_raster\":{\"raster-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"raster-hue-rotate\":{\"type\":\"number\",\"default\":0,\"period\":360,\"transition\":true,\"units\":\"degrees\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"raster-brightness-min\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"raster-brightness-max\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"raster-saturation\":{\"type\":\"number\",\"default\":0,\"minimum\":-1,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"raster-contrast\":{\"type\":\"number\",\"default\":0,\"minimum\":-1,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"raster-resampling\":{\"type\":\"enum\",\"values\":{\"linear\":{},\"nearest\":{}},\"default\":\"linear\",\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"raster-fade-duration\":{\"type\":\"number\",\"default\":300,\"minimum\":0,\"transition\":false,\"units\":\"milliseconds\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"}},\"paint_hillshade\":{\"hillshade-illumination-direction\":{\"type\":\"number\",\"default\":335,\"minimum\":0,\"maximum\":359,\"transition\":false,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"hillshade-illumination-anchor\":{\"type\":\"enum\",\"values\":{\"map\":{},\"viewport\":{}},\"default\":\"viewport\",\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"hillshade-exaggeration\":{\"type\":\"number\",\"default\":0.5,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"hillshade-shadow-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"hillshade-highlight-color\":{\"type\":\"color\",\"default\":\"#FFFFFF\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"hillshade-accent-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"}},\"paint_background\":{\"background-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"requires\":[{\"!\":\"background-pattern\"}],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"background-pattern\":{\"type\":\"resolvedImage\",\"transition\":true,\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"cross-faded\"},\"background-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"}},\"paint_sky\":{\"sky-type\":{\"type\":\"enum\",\"values\":{\"gradient\":{},\"atmosphere\":{}},\"default\":\"atmosphere\",\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"sky-atmosphere-sun\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"units\":\"degrees\",\"minimum\":[0,0],\"maximum\":[360,180],\"transition\":false,\"requires\":[{\"sky-type\":\"atmosphere\"}],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"sky-atmosphere-sun-intensity\":{\"type\":\"number\",\"requires\":[{\"sky-type\":\"atmosphere\"}],\"default\":10,\"minimum\":0,\"maximum\":100,\"transition\":false,\"property-type\":\"data-constant\"},\"sky-gradient-center\":{\"type\":\"array\",\"requires\":[{\"sky-type\":\"gradient\"}],\"value\":\"number\",\"default\":[0,0],\"length\":2,\"units\":\"degrees\",\"minimum\":[0,0],\"maximum\":[360,180],\"transition\":false,\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"sky-gradient-radius\":{\"type\":\"number\",\"requires\":[{\"sky-type\":\"gradient\"}],\"default\":90,\"minimum\":0,\"maximum\":180,\"transition\":false,\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"sky-gradient\":{\"type\":\"color\",\"default\":[\"interpolate\",[\"linear\"],[\"sky-radial-progress\"],0.8,\"#87ceeb\",1,\"white\"],\"transition\":false,\"requires\":[{\"sky-type\":\"gradient\"}],\"expression\":{\"interpolated\":true,\"parameters\":[\"sky-radial-progress\"]},\"property-type\":\"color-ramp\"},\"sky-atmosphere-halo-color\":{\"type\":\"color\",\"default\":\"white\",\"transition\":false,\"requires\":[{\"sky-type\":\"atmosphere\"}],\"property-type\":\"data-constant\"},\"sky-atmosphere-color\":{\"type\":\"color\",\"default\":\"white\",\"transition\":false,\"requires\":[{\"sky-type\":\"atmosphere\"}],\"property-type\":\"data-constant\"},\"sky-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"}},\"transition\":{\"duration\":{\"type\":\"number\",\"default\":300,\"minimum\":0,\"units\":\"milliseconds\"},\"delay\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"units\":\"milliseconds\"}},\"property-type\":{\"data-driven\":{\"type\":\"property-type\"},\"cross-faded\":{\"type\":\"property-type\"},\"cross-faded-data-driven\":{\"type\":\"property-type\"},\"color-ramp\":{\"type\":\"property-type\"},\"data-constant\":{\"type\":\"property-type\"},\"constant\":{\"type\":\"property-type\"}},\"promoteId\":{\"*\":{\"type\":\"string\"}}}');\n\n    function jt(t, ...e) {\n      for (const r of e) for (const e in r) t[e] = r[e];\n\n      return t;\n    }\n\n    function Ot(t) {\n      return t instanceof Number || t instanceof String || t instanceof Boolean ? t.valueOf() : t;\n    }\n\n    function qt(t) {\n      if (Array.isArray(t)) return t.map(qt);\n\n      if (t instanceof Object && !(t instanceof Number || t instanceof String || t instanceof Boolean)) {\n        const e = {};\n\n        for (const r in t) e[r] = qt(t[r]);\n\n        return e;\n      }\n\n      return Ot(t);\n    }\n\n    class Nt extends Error {\n      constructor(t, e) {\n        super(e), this.message = e, this.key = t;\n      }\n\n    }\n\n    class Gt {\n      constructor(t, e = []) {\n        this.parent = t, this.bindings = {};\n\n        for (const [t, r] of e) this.bindings[t] = r;\n      }\n\n      concat(t) {\n        return new Gt(this, t);\n      }\n\n      get(t) {\n        if (this.bindings[t]) return this.bindings[t];\n        if (this.parent) return this.parent.get(t);\n        throw new Error(`${t} not found in scope.`);\n      }\n\n      has(t) {\n        return !!this.bindings[t] || !!this.parent && this.parent.has(t);\n      }\n\n    }\n\n    const Zt = {\n      kind: \"null\"\n    },\n          Xt = {\n      kind: \"number\"\n    },\n          Kt = {\n      kind: \"string\"\n    },\n          Yt = {\n      kind: \"boolean\"\n    },\n          Ht = {\n      kind: \"color\"\n    },\n          Wt = {\n      kind: \"object\"\n    },\n          Jt = {\n      kind: \"value\"\n    },\n          Qt = {\n      kind: \"collator\"\n    },\n          te = {\n      kind: \"formatted\"\n    },\n          ee = {\n      kind: \"resolvedImage\"\n    };\n\n    function re(t, e) {\n      return {\n        kind: \"array\",\n        itemType: t,\n        N: e\n      };\n    }\n\n    function ne(t) {\n      if (\"array\" === t.kind) {\n        const e = ne(t.itemType);\n        return \"number\" == typeof t.N ? `array<${e}, ${t.N}>` : \"value\" === t.itemType.kind ? \"array\" : `array<${e}>`;\n      }\n\n      return t.kind;\n    }\n\n    const ie = [Zt, Xt, Kt, Yt, Ht, te, Wt, re(Jt), ee];\n\n    function se(t, e) {\n      if (\"error\" === e.kind) return null;\n\n      if (\"array\" === t.kind) {\n        if (\"array\" === e.kind && (0 === e.N && \"value\" === e.itemType.kind || !se(t.itemType, e.itemType)) && (\"number\" != typeof t.N || t.N === e.N)) return null;\n      } else {\n        if (t.kind === e.kind) return null;\n        if (\"value\" === t.kind) for (const t of ie) if (!se(t, e)) return null;\n      }\n\n      return `Expected ${ne(t)} but found ${ne(e)} instead.`;\n    }\n\n    function ae(t, e) {\n      return e.some(e => e.kind === t.kind);\n    }\n\n    function oe(t, e) {\n      return e.some(e => \"null\" === e ? null === t : \"array\" === e ? Array.isArray(t) : \"object\" === e ? t && !Array.isArray(t) && \"object\" == typeof t : e === typeof t);\n    }\n\n    function le(t) {\n      var e = {\n        exports: {}\n      };\n      return t(e, e.exports), e.exports;\n    }\n\n    var ue = le(function (t, e) {\n      var r = {\n        transparent: [0, 0, 0, 0],\n        aliceblue: [240, 248, 255, 1],\n        antiquewhite: [250, 235, 215, 1],\n        aqua: [0, 255, 255, 1],\n        aquamarine: [127, 255, 212, 1],\n        azure: [240, 255, 255, 1],\n        beige: [245, 245, 220, 1],\n        bisque: [255, 228, 196, 1],\n        black: [0, 0, 0, 1],\n        blanchedalmond: [255, 235, 205, 1],\n        blue: [0, 0, 255, 1],\n        blueviolet: [138, 43, 226, 1],\n        brown: [165, 42, 42, 1],\n        burlywood: [222, 184, 135, 1],\n        cadetblue: [95, 158, 160, 1],\n        chartreuse: [127, 255, 0, 1],\n        chocolate: [210, 105, 30, 1],\n        coral: [255, 127, 80, 1],\n        cornflowerblue: [100, 149, 237, 1],\n        cornsilk: [255, 248, 220, 1],\n        crimson: [220, 20, 60, 1],\n        cyan: [0, 255, 255, 1],\n        darkblue: [0, 0, 139, 1],\n        darkcyan: [0, 139, 139, 1],\n        darkgoldenrod: [184, 134, 11, 1],\n        darkgray: [169, 169, 169, 1],\n        darkgreen: [0, 100, 0, 1],\n        darkgrey: [169, 169, 169, 1],\n        darkkhaki: [189, 183, 107, 1],\n        darkmagenta: [139, 0, 139, 1],\n        darkolivegreen: [85, 107, 47, 1],\n        darkorange: [255, 140, 0, 1],\n        darkorchid: [153, 50, 204, 1],\n        darkred: [139, 0, 0, 1],\n        darksalmon: [233, 150, 122, 1],\n        darkseagreen: [143, 188, 143, 1],\n        darkslateblue: [72, 61, 139, 1],\n        darkslategray: [47, 79, 79, 1],\n        darkslategrey: [47, 79, 79, 1],\n        darkturquoise: [0, 206, 209, 1],\n        darkviolet: [148, 0, 211, 1],\n        deeppink: [255, 20, 147, 1],\n        deepskyblue: [0, 191, 255, 1],\n        dimgray: [105, 105, 105, 1],\n        dimgrey: [105, 105, 105, 1],\n        dodgerblue: [30, 144, 255, 1],\n        firebrick: [178, 34, 34, 1],\n        floralwhite: [255, 250, 240, 1],\n        forestgreen: [34, 139, 34, 1],\n        fuchsia: [255, 0, 255, 1],\n        gainsboro: [220, 220, 220, 1],\n        ghostwhite: [248, 248, 255, 1],\n        gold: [255, 215, 0, 1],\n        goldenrod: [218, 165, 32, 1],\n        gray: [128, 128, 128, 1],\n        green: [0, 128, 0, 1],\n        greenyellow: [173, 255, 47, 1],\n        grey: [128, 128, 128, 1],\n        honeydew: [240, 255, 240, 1],\n        hotpink: [255, 105, 180, 1],\n        indianred: [205, 92, 92, 1],\n        indigo: [75, 0, 130, 1],\n        ivory: [255, 255, 240, 1],\n        khaki: [240, 230, 140, 1],\n        lavender: [230, 230, 250, 1],\n        lavenderblush: [255, 240, 245, 1],\n        lawngreen: [124, 252, 0, 1],\n        lemonchiffon: [255, 250, 205, 1],\n        lightblue: [173, 216, 230, 1],\n        lightcoral: [240, 128, 128, 1],\n        lightcyan: [224, 255, 255, 1],\n        lightgoldenrodyellow: [250, 250, 210, 1],\n        lightgray: [211, 211, 211, 1],\n        lightgreen: [144, 238, 144, 1],\n        lightgrey: [211, 211, 211, 1],\n        lightpink: [255, 182, 193, 1],\n        lightsalmon: [255, 160, 122, 1],\n        lightseagreen: [32, 178, 170, 1],\n        lightskyblue: [135, 206, 250, 1],\n        lightslategray: [119, 136, 153, 1],\n        lightslategrey: [119, 136, 153, 1],\n        lightsteelblue: [176, 196, 222, 1],\n        lightyellow: [255, 255, 224, 1],\n        lime: [0, 255, 0, 1],\n        limegreen: [50, 205, 50, 1],\n        linen: [250, 240, 230, 1],\n        magenta: [255, 0, 255, 1],\n        maroon: [128, 0, 0, 1],\n        mediumaquamarine: [102, 205, 170, 1],\n        mediumblue: [0, 0, 205, 1],\n        mediumorchid: [186, 85, 211, 1],\n        mediumpurple: [147, 112, 219, 1],\n        mediumseagreen: [60, 179, 113, 1],\n        mediumslateblue: [123, 104, 238, 1],\n        mediumspringgreen: [0, 250, 154, 1],\n        mediumturquoise: [72, 209, 204, 1],\n        mediumvioletred: [199, 21, 133, 1],\n        midnightblue: [25, 25, 112, 1],\n        mintcream: [245, 255, 250, 1],\n        mistyrose: [255, 228, 225, 1],\n        moccasin: [255, 228, 181, 1],\n        navajowhite: [255, 222, 173, 1],\n        navy: [0, 0, 128, 1],\n        oldlace: [253, 245, 230, 1],\n        olive: [128, 128, 0, 1],\n        olivedrab: [107, 142, 35, 1],\n        orange: [255, 165, 0, 1],\n        orangered: [255, 69, 0, 1],\n        orchid: [218, 112, 214, 1],\n        palegoldenrod: [238, 232, 170, 1],\n        palegreen: [152, 251, 152, 1],\n        paleturquoise: [175, 238, 238, 1],\n        palevioletred: [219, 112, 147, 1],\n        papayawhip: [255, 239, 213, 1],\n        peachpuff: [255, 218, 185, 1],\n        peru: [205, 133, 63, 1],\n        pink: [255, 192, 203, 1],\n        plum: [221, 160, 221, 1],\n        powderblue: [176, 224, 230, 1],\n        purple: [128, 0, 128, 1],\n        rebeccapurple: [102, 51, 153, 1],\n        red: [255, 0, 0, 1],\n        rosybrown: [188, 143, 143, 1],\n        royalblue: [65, 105, 225, 1],\n        saddlebrown: [139, 69, 19, 1],\n        salmon: [250, 128, 114, 1],\n        sandybrown: [244, 164, 96, 1],\n        seagreen: [46, 139, 87, 1],\n        seashell: [255, 245, 238, 1],\n        sienna: [160, 82, 45, 1],\n        silver: [192, 192, 192, 1],\n        skyblue: [135, 206, 235, 1],\n        slateblue: [106, 90, 205, 1],\n        slategray: [112, 128, 144, 1],\n        slategrey: [112, 128, 144, 1],\n        snow: [255, 250, 250, 1],\n        springgreen: [0, 255, 127, 1],\n        steelblue: [70, 130, 180, 1],\n        tan: [210, 180, 140, 1],\n        teal: [0, 128, 128, 1],\n        thistle: [216, 191, 216, 1],\n        tomato: [255, 99, 71, 1],\n        turquoise: [64, 224, 208, 1],\n        violet: [238, 130, 238, 1],\n        wheat: [245, 222, 179, 1],\n        white: [255, 255, 255, 1],\n        whitesmoke: [245, 245, 245, 1],\n        yellow: [255, 255, 0, 1],\n        yellowgreen: [154, 205, 50, 1]\n      };\n\n      function n(t) {\n        return (t = Math.round(t)) < 0 ? 0 : t > 255 ? 255 : t;\n      }\n\n      function i(t) {\n        return n(\"%\" === t[t.length - 1] ? parseFloat(t) / 100 * 255 : parseInt(t));\n      }\n\n      function s(t) {\n        return (e = \"%\" === t[t.length - 1] ? parseFloat(t) / 100 : parseFloat(t)) < 0 ? 0 : e > 1 ? 1 : e;\n        var e;\n      }\n\n      function a(t, e, r) {\n        return r < 0 ? r += 1 : r > 1 && (r -= 1), 6 * r < 1 ? t + (e - t) * r * 6 : 2 * r < 1 ? e : 3 * r < 2 ? t + (e - t) * (2 / 3 - r) * 6 : t;\n      }\n\n      try {\n        e.parseCSSColor = function (t) {\n          var e,\n              o = t.replace(/ /g, \"\").toLowerCase();\n          if (o in r) return r[o].slice();\n          if (\"#\" === o[0]) return 4 === o.length ? (e = parseInt(o.substr(1), 16)) >= 0 && e <= 4095 ? [(3840 & e) >> 4 | (3840 & e) >> 8, 240 & e | (240 & e) >> 4, 15 & e | (15 & e) << 4, 1] : null : 7 === o.length && (e = parseInt(o.substr(1), 16)) >= 0 && e <= 16777215 ? [(16711680 & e) >> 16, (65280 & e) >> 8, 255 & e, 1] : null;\n          var l = o.indexOf(\"(\"),\n              u = o.indexOf(\")\");\n\n          if (-1 !== l && u + 1 === o.length) {\n            var c = o.substr(0, l),\n                h = o.substr(l + 1, u - (l + 1)).split(\",\"),\n                p = 1;\n\n            switch (c) {\n              case \"rgba\":\n                if (4 !== h.length) return null;\n                p = s(h.pop());\n\n              case \"rgb\":\n                return 3 !== h.length ? null : [i(h[0]), i(h[1]), i(h[2]), p];\n\n              case \"hsla\":\n                if (4 !== h.length) return null;\n                p = s(h.pop());\n\n              case \"hsl\":\n                if (3 !== h.length) return null;\n                var f = (parseFloat(h[0]) % 360 + 360) % 360 / 360,\n                    d = s(h[1]),\n                    y = s(h[2]),\n                    m = y <= .5 ? y * (d + 1) : y + d - y * d,\n                    g = 2 * y - m;\n                return [n(255 * a(g, m, f + 1 / 3)), n(255 * a(g, m, f)), n(255 * a(g, m, f - 1 / 3)), p];\n\n              default:\n                return null;\n            }\n          }\n\n          return null;\n        };\n      } catch (t) {}\n    });\n\n    class ce {\n      constructor(t, e, r, n = 1) {\n        this.r = t, this.g = e, this.b = r, this.a = n;\n      }\n\n      static parse(t) {\n        if (!t) return;\n        if (t instanceof ce) return t;\n        if (\"string\" != typeof t) return;\n        const e = ue.parseCSSColor(t);\n        return e ? new ce(e[0] / 255 * e[3], e[1] / 255 * e[3], e[2] / 255 * e[3], e[3]) : void 0;\n      }\n\n      toString() {\n        const [t, e, r, n] = this.toArray();\n        return `rgba(${Math.round(t)},${Math.round(e)},${Math.round(r)},${n})`;\n      }\n\n      toArray() {\n        const {\n          r: t,\n          g: e,\n          b: r,\n          a: n\n        } = this;\n        return 0 === n ? [0, 0, 0, 0] : [255 * t / n, 255 * e / n, 255 * r / n, n];\n      }\n\n    }\n\n    ce.black = new ce(0, 0, 0, 1), ce.white = new ce(1, 1, 1, 1), ce.transparent = new ce(0, 0, 0, 0), ce.red = new ce(1, 0, 0, 1), ce.blue = new ce(0, 0, 1, 1);\n\n    class he {\n      constructor(t, e, r) {\n        this.sensitivity = t ? e ? \"variant\" : \"case\" : e ? \"accent\" : \"base\", this.locale = r, this.collator = new Intl.Collator(this.locale ? this.locale : [], {\n          sensitivity: this.sensitivity,\n          usage: \"search\"\n        });\n      }\n\n      compare(t, e) {\n        return this.collator.compare(t, e);\n      }\n\n      resolvedLocale() {\n        return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;\n      }\n\n    }\n\n    class pe {\n      constructor(t, e, r, n, i) {\n        this.text = t.normalize ? t.normalize() : t, this.image = e, this.scale = r, this.fontStack = n, this.textColor = i;\n      }\n\n    }\n\n    class fe {\n      constructor(t) {\n        this.sections = t;\n      }\n\n      static fromString(t) {\n        return new fe([new pe(t, null, null, null, null)]);\n      }\n\n      isEmpty() {\n        return 0 === this.sections.length || !this.sections.some(t => 0 !== t.text.length || t.image && 0 !== t.image.name.length);\n      }\n\n      static factory(t) {\n        return t instanceof fe ? t : fe.fromString(t);\n      }\n\n      toString() {\n        return 0 === this.sections.length ? \"\" : this.sections.map(t => t.text).join(\"\");\n      }\n\n      serialize() {\n        const t = [\"format\"];\n\n        for (const e of this.sections) {\n          if (e.image) {\n            t.push([\"image\", e.image.name]);\n            continue;\n          }\n\n          t.push(e.text);\n          const r = {};\n          e.fontStack && (r[\"text-font\"] = [\"literal\", e.fontStack.split(\",\")]), e.scale && (r[\"font-scale\"] = e.scale), e.textColor && (r[\"text-color\"] = [\"rgba\"].concat(e.textColor.toArray())), t.push(r);\n        }\n\n        return t;\n      }\n\n    }\n\n    class de {\n      constructor(t) {\n        this.name = t.name, this.available = t.available;\n      }\n\n      toString() {\n        return this.name;\n      }\n\n      static fromString(t) {\n        return t ? new de({\n          name: t,\n          available: !1\n        }) : null;\n      }\n\n      serialize() {\n        return [\"image\", this.name];\n      }\n\n    }\n\n    function ye(t, e, r, n) {\n      return \"number\" == typeof t && t >= 0 && t <= 255 && \"number\" == typeof e && e >= 0 && e <= 255 && \"number\" == typeof r && r >= 0 && r <= 255 ? void 0 === n || \"number\" == typeof n && n >= 0 && n <= 1 ? null : `Invalid rgba value [${[t, e, r, n].join(\", \")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(\"number\" == typeof n ? [t, e, r, n] : [t, e, r]).join(\", \")}]: 'r', 'g', and 'b' must be between 0 and 255.`;\n    }\n\n    function me(t) {\n      if (null === t) return !0;\n      if (\"string\" == typeof t) return !0;\n      if (\"boolean\" == typeof t) return !0;\n      if (\"number\" == typeof t) return !0;\n      if (t instanceof ce) return !0;\n      if (t instanceof he) return !0;\n      if (t instanceof fe) return !0;\n      if (t instanceof de) return !0;\n\n      if (Array.isArray(t)) {\n        for (const e of t) if (!me(e)) return !1;\n\n        return !0;\n      }\n\n      if (\"object\" == typeof t) {\n        for (const e in t) if (!me(t[e])) return !1;\n\n        return !0;\n      }\n\n      return !1;\n    }\n\n    function ge(t) {\n      if (null === t) return Zt;\n      if (\"string\" == typeof t) return Kt;\n      if (\"boolean\" == typeof t) return Yt;\n      if (\"number\" == typeof t) return Xt;\n      if (t instanceof ce) return Ht;\n      if (t instanceof he) return Qt;\n      if (t instanceof fe) return te;\n      if (t instanceof de) return ee;\n\n      if (Array.isArray(t)) {\n        const e = t.length;\n        let r;\n\n        for (const e of t) {\n          const t = ge(e);\n\n          if (r) {\n            if (r === t) continue;\n            r = Jt;\n            break;\n          }\n\n          r = t;\n        }\n\n        return re(r || Jt, e);\n      }\n\n      return Wt;\n    }\n\n    function xe(t) {\n      const e = typeof t;\n      return null === t ? \"\" : \"string\" === e || \"number\" === e || \"boolean\" === e ? String(t) : t instanceof ce || t instanceof fe || t instanceof de ? t.toString() : JSON.stringify(t);\n    }\n\n    class ve {\n      constructor(t, e) {\n        this.type = t, this.value = e;\n      }\n\n      static parse(t, e) {\n        if (2 !== t.length) return e.error(`'literal' expression requires exactly one argument, but found ${t.length - 1} instead.`);\n        if (!me(t[1])) return e.error(\"invalid value\");\n        const r = t[1];\n        let n = ge(r);\n        const i = e.expectedType;\n        return \"array\" !== n.kind || 0 !== n.N || !i || \"array\" !== i.kind || \"number\" == typeof i.N && 0 !== i.N || (n = i), new ve(n, r);\n      }\n\n      evaluate() {\n        return this.value;\n      }\n\n      eachChild() {}\n\n      outputDefined() {\n        return !0;\n      }\n\n      serialize() {\n        return \"array\" === this.type.kind || \"object\" === this.type.kind ? [\"literal\", this.value] : this.value instanceof ce ? [\"rgba\"].concat(this.value.toArray()) : this.value instanceof fe ? this.value.serialize() : this.value;\n      }\n\n    }\n\n    class be {\n      constructor(t) {\n        this.name = \"ExpressionEvaluationError\", this.message = t;\n      }\n\n      toJSON() {\n        return this.message;\n      }\n\n    }\n\n    const _e = {\n      string: Kt,\n      number: Xt,\n      boolean: Yt,\n      object: Wt\n    };\n\n    class we {\n      constructor(t, e) {\n        this.type = t, this.args = e;\n      }\n\n      static parse(t, e) {\n        if (t.length < 2) return e.error(\"Expected at least one argument.\");\n        let r,\n            n = 1;\n        const i = t[0];\n\n        if (\"array\" === i) {\n          let i, s;\n\n          if (t.length > 2) {\n            const r = t[1];\n            if (\"string\" != typeof r || !(r in _e) || \"object\" === r) return e.error('The item type argument of \"array\" must be one of string, number, boolean', 1);\n            i = _e[r], n++;\n          } else i = Jt;\n\n          if (t.length > 3) {\n            if (null !== t[2] && (\"number\" != typeof t[2] || t[2] < 0 || t[2] !== Math.floor(t[2]))) return e.error('The length argument to \"array\" must be a positive integer literal', 2);\n            s = t[2], n++;\n          }\n\n          r = re(i, s);\n        } else r = _e[i];\n\n        const s = [];\n\n        for (; n < t.length; n++) {\n          const r = e.parse(t[n], n, Jt);\n          if (!r) return null;\n          s.push(r);\n        }\n\n        return new we(r, s);\n      }\n\n      evaluate(t) {\n        for (let e = 0; e < this.args.length; e++) {\n          const r = this.args[e].evaluate(t);\n          if (!se(this.type, ge(r))) return r;\n          if (e === this.args.length - 1) throw new be(`Expected value to be of type ${ne(this.type)}, but found ${ne(ge(r))} instead.`);\n        }\n\n        return null;\n      }\n\n      eachChild(t) {\n        this.args.forEach(t);\n      }\n\n      outputDefined() {\n        return this.args.every(t => t.outputDefined());\n      }\n\n      serialize() {\n        const t = this.type,\n              e = [t.kind];\n\n        if (\"array\" === t.kind) {\n          const r = t.itemType;\n\n          if (\"string\" === r.kind || \"number\" === r.kind || \"boolean\" === r.kind) {\n            e.push(r.kind);\n            const n = t.N;\n            (\"number\" == typeof n || this.args.length > 1) && e.push(n);\n          }\n        }\n\n        return e.concat(this.args.map(t => t.serialize()));\n      }\n\n    }\n\n    class Ae {\n      constructor(t) {\n        this.type = te, this.sections = t;\n      }\n\n      static parse(t, e) {\n        if (t.length < 2) return e.error(\"Expected at least one argument.\");\n        const r = t[1];\n        if (!Array.isArray(r) && \"object\" == typeof r) return e.error(\"First argument must be an image or text section.\");\n        const n = [];\n        let i = !1;\n\n        for (let r = 1; r <= t.length - 1; ++r) {\n          const s = t[r];\n\n          if (i && \"object\" == typeof s && !Array.isArray(s)) {\n            i = !1;\n            let t = null;\n            if (s[\"font-scale\"] && (t = e.parse(s[\"font-scale\"], 1, Xt), !t)) return null;\n            let r = null;\n            if (s[\"text-font\"] && (r = e.parse(s[\"text-font\"], 1, re(Kt)), !r)) return null;\n            let a = null;\n            if (s[\"text-color\"] && (a = e.parse(s[\"text-color\"], 1, Ht), !a)) return null;\n            const o = n[n.length - 1];\n            o.scale = t, o.font = r, o.textColor = a;\n          } else {\n            const s = e.parse(t[r], 1, Jt);\n            if (!s) return null;\n            const a = s.type.kind;\n            if (\"string\" !== a && \"value\" !== a && \"null\" !== a && \"resolvedImage\" !== a) return e.error(\"Formatted text type must be 'string', 'value', 'image' or 'null'.\");\n            i = !0, n.push({\n              content: s,\n              scale: null,\n              font: null,\n              textColor: null\n            });\n          }\n        }\n\n        return new Ae(n);\n      }\n\n      evaluate(t) {\n        return new fe(this.sections.map(e => {\n          const r = e.content.evaluate(t);\n          return ge(r) === ee ? new pe(\"\", r, null, null, null) : new pe(xe(r), null, e.scale ? e.scale.evaluate(t) : null, e.font ? e.font.evaluate(t).join(\",\") : null, e.textColor ? e.textColor.evaluate(t) : null);\n        }));\n      }\n\n      eachChild(t) {\n        for (const e of this.sections) t(e.content), e.scale && t(e.scale), e.font && t(e.font), e.textColor && t(e.textColor);\n      }\n\n      outputDefined() {\n        return !1;\n      }\n\n      serialize() {\n        const t = [\"format\"];\n\n        for (const e of this.sections) {\n          t.push(e.content.serialize());\n          const r = {};\n          e.scale && (r[\"font-scale\"] = e.scale.serialize()), e.font && (r[\"text-font\"] = e.font.serialize()), e.textColor && (r[\"text-color\"] = e.textColor.serialize()), t.push(r);\n        }\n\n        return t;\n      }\n\n    }\n\n    class ke {\n      constructor(t) {\n        this.type = ee, this.input = t;\n      }\n\n      static parse(t, e) {\n        if (2 !== t.length) return e.error(\"Expected two arguments.\");\n        const r = e.parse(t[1], 1, Kt);\n        return r ? new ke(r) : e.error(\"No image name provided.\");\n      }\n\n      evaluate(t) {\n        const e = this.input.evaluate(t),\n              r = de.fromString(e);\n        return r && t.availableImages && (r.available = t.availableImages.indexOf(e) > -1), r;\n      }\n\n      eachChild(t) {\n        t(this.input);\n      }\n\n      outputDefined() {\n        return !1;\n      }\n\n      serialize() {\n        return [\"image\", this.input.serialize()];\n      }\n\n    }\n\n    const Se = {\n      \"to-boolean\": Yt,\n      \"to-color\": Ht,\n      \"to-number\": Xt,\n      \"to-string\": Kt\n    };\n\n    class Ie {\n      constructor(t, e) {\n        this.type = t, this.args = e;\n      }\n\n      static parse(t, e) {\n        if (t.length < 2) return e.error(\"Expected at least one argument.\");\n        const r = t[0];\n        if ((\"to-boolean\" === r || \"to-string\" === r) && 2 !== t.length) return e.error(\"Expected one argument.\");\n        const n = Se[r],\n              i = [];\n\n        for (let r = 1; r < t.length; r++) {\n          const n = e.parse(t[r], r, Jt);\n          if (!n) return null;\n          i.push(n);\n        }\n\n        return new Ie(n, i);\n      }\n\n      evaluate(t) {\n        if (\"boolean\" === this.type.kind) return Boolean(this.args[0].evaluate(t));\n\n        if (\"color\" === this.type.kind) {\n          let e, r;\n\n          for (const n of this.args) {\n            if (e = n.evaluate(t), r = null, e instanceof ce) return e;\n\n            if (\"string\" == typeof e) {\n              const r = t.parseColor(e);\n              if (r) return r;\n            } else if (Array.isArray(e) && (r = e.length < 3 || e.length > 4 ? `Invalid rbga value ${JSON.stringify(e)}: expected an array containing either three or four numeric values.` : ye(e[0], e[1], e[2], e[3]), !r)) return new ce(e[0] / 255, e[1] / 255, e[2] / 255, e[3]);\n          }\n\n          throw new be(r || `Could not parse color from value '${\"string\" == typeof e ? e : String(JSON.stringify(e))}'`);\n        }\n\n        if (\"number\" === this.type.kind) {\n          let e = null;\n\n          for (const r of this.args) {\n            if (e = r.evaluate(t), null === e) return 0;\n            const n = Number(e);\n            if (!isNaN(n)) return n;\n          }\n\n          throw new be(`Could not convert ${JSON.stringify(e)} to number.`);\n        }\n\n        return \"formatted\" === this.type.kind ? fe.fromString(xe(this.args[0].evaluate(t))) : \"resolvedImage\" === this.type.kind ? de.fromString(xe(this.args[0].evaluate(t))) : xe(this.args[0].evaluate(t));\n      }\n\n      eachChild(t) {\n        this.args.forEach(t);\n      }\n\n      outputDefined() {\n        return this.args.every(t => t.outputDefined());\n      }\n\n      serialize() {\n        if (\"formatted\" === this.type.kind) return new Ae([{\n          content: this.args[0],\n          scale: null,\n          font: null,\n          textColor: null\n        }]).serialize();\n        if (\"resolvedImage\" === this.type.kind) return new ke(this.args[0]).serialize();\n        const t = [`to-${this.type.kind}`];\n        return this.eachChild(e => {\n          t.push(e.serialize());\n        }), t;\n      }\n\n    }\n\n    const Me = [\"Unknown\", \"Point\", \"LineString\", \"Polygon\"];\n\n    class Te {\n      constructor() {\n        this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null;\n      }\n\n      id() {\n        return this.feature && \"id\" in this.feature && this.feature.id ? this.feature.id : null;\n      }\n\n      geometryType() {\n        return this.feature ? \"number\" == typeof this.feature.type ? Me[this.feature.type] : this.feature.type : null;\n      }\n\n      geometry() {\n        return this.feature && \"geometry\" in this.feature ? this.feature.geometry : null;\n      }\n\n      canonicalID() {\n        return this.canonical;\n      }\n\n      properties() {\n        return this.feature && this.feature.properties || {};\n      }\n\n      distanceFromCenter() {\n        if (this.featureTileCoord && this.featureDistanceData) {\n          const t = this.featureDistanceData.center,\n                e = this.featureDistanceData.scale,\n                {\n            x: r,\n            y: n\n          } = this.featureTileCoord;\n          return this.featureDistanceData.bearing[0] * (r * e - t[0]) + this.featureDistanceData.bearing[1] * (n * e - t[1]);\n        }\n\n        return 0;\n      }\n\n      parseColor(t) {\n        let e = this._parseColorCache[t];\n        return e || (e = this._parseColorCache[t] = ce.parse(t)), e;\n      }\n\n    }\n\n    class ze {\n      constructor(t, e, r, n) {\n        this.name = t, this.type = e, this._evaluate = r, this.args = n;\n      }\n\n      evaluate(t) {\n        return this._evaluate(t, this.args);\n      }\n\n      eachChild(t) {\n        this.args.forEach(t);\n      }\n\n      outputDefined() {\n        return !1;\n      }\n\n      serialize() {\n        return [this.name].concat(this.args.map(t => t.serialize()));\n      }\n\n      static parse(t, e) {\n        const r = t[0],\n              n = ze.definitions[r];\n        if (!n) return e.error(`Unknown expression \"${r}\". If you wanted a literal array, use [\"literal\", [...]].`, 0);\n        const i = Array.isArray(n) ? n[0] : n.type,\n              s = Array.isArray(n) ? [[n[1], n[2]]] : n.overloads,\n              a = s.filter(([e]) => !Array.isArray(e) || e.length === t.length - 1);\n        let o = null;\n\n        for (const [n, s] of a) {\n          o = new Je(e.registry, e.path, null, e.scope);\n          const a = [];\n          let l = !1;\n\n          for (let e = 1; e < t.length; e++) {\n            const r = t[e],\n                  i = Array.isArray(n) ? n[e - 1] : n.type,\n                  s = o.parse(r, 1 + a.length, i);\n\n            if (!s) {\n              l = !0;\n              break;\n            }\n\n            a.push(s);\n          }\n\n          if (!l) if (Array.isArray(n) && n.length !== a.length) o.error(`Expected ${n.length} arguments, but found ${a.length} instead.`);else {\n            for (let t = 0; t < a.length; t++) {\n              const e = Array.isArray(n) ? n[t] : n.type,\n                    r = a[t];\n              o.concat(t + 1).checkSubtype(e, r.type);\n            }\n\n            if (0 === o.errors.length) return new ze(r, i, s, a);\n          }\n        }\n\n        if (1 === a.length) e.errors.push(...o.errors);else {\n          const r = (a.length ? a : s).map(([t]) => {\n            return e = t, Array.isArray(e) ? `(${e.map(ne).join(\", \")})` : `(${ne(e.type)}...)`;\n            var e;\n          }).join(\" | \"),\n                n = [];\n\n          for (let r = 1; r < t.length; r++) {\n            const i = e.parse(t[r], 1 + n.length);\n            if (!i) return null;\n            n.push(ne(i.type));\n          }\n\n          e.error(`Expected arguments of type ${r}, but found (${n.join(\", \")}) instead.`);\n        }\n        return null;\n      }\n\n      static register(t, e) {\n        ze.definitions = e;\n\n        for (const r in e) t[r] = ze;\n      }\n\n    }\n\n    class Be {\n      constructor(t, e, r) {\n        this.type = Qt, this.locale = r, this.caseSensitive = t, this.diacriticSensitive = e;\n      }\n\n      static parse(t, e) {\n        if (2 !== t.length) return e.error(\"Expected one argument.\");\n        const r = t[1];\n        if (\"object\" != typeof r || Array.isArray(r)) return e.error(\"Collator options argument must be an object.\");\n        const n = e.parse(void 0 !== r[\"case-sensitive\"] && r[\"case-sensitive\"], 1, Yt);\n        if (!n) return null;\n        const i = e.parse(void 0 !== r[\"diacritic-sensitive\"] && r[\"diacritic-sensitive\"], 1, Yt);\n        if (!i) return null;\n        let s = null;\n        return r.locale && (s = e.parse(r.locale, 1, Kt), !s) ? null : new Be(n, i, s);\n      }\n\n      evaluate(t) {\n        return new he(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null);\n      }\n\n      eachChild(t) {\n        t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale);\n      }\n\n      outputDefined() {\n        return !1;\n      }\n\n      serialize() {\n        const t = {};\n        return t[\"case-sensitive\"] = this.caseSensitive.serialize(), t[\"diacritic-sensitive\"] = this.diacriticSensitive.serialize(), this.locale && (t.locale = this.locale.serialize()), [\"collator\", t];\n      }\n\n    }\n\n    const Ee = 8192;\n\n    function Ce(t, e) {\n      t[0] = Math.min(t[0], e[0]), t[1] = Math.min(t[1], e[1]), t[2] = Math.max(t[2], e[0]), t[3] = Math.max(t[3], e[1]);\n    }\n\n    function De(t, e) {\n      return !(t[0] <= e[0] || t[2] >= e[2] || t[1] <= e[1] || t[3] >= e[3]);\n    }\n\n    function Pe(t, e) {\n      const r = (180 + t[0]) / 360,\n            n = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t[1] * Math.PI / 360))) / 360,\n            i = Math.pow(2, e.z);\n      return [Math.round(r * i * Ee), Math.round(n * i * Ee)];\n    }\n\n    function Ve(t, e, r) {\n      const n = t[0] - e[0],\n            i = t[1] - e[1],\n            s = t[0] - r[0],\n            a = t[1] - r[1];\n      return n * a - s * i == 0 && n * s <= 0 && i * a <= 0;\n    }\n\n    function Fe(t, e) {\n      let r = !1;\n\n      for (let a = 0, o = e.length; a < o; a++) {\n        const o = e[a];\n\n        for (let e = 0, a = o.length; e < a - 1; e++) {\n          if (Ve(t, o[e], o[e + 1])) return !1;\n          (i = o[e])[1] > (n = t)[1] != (s = o[e + 1])[1] > n[1] && n[0] < (s[0] - i[0]) * (n[1] - i[1]) / (s[1] - i[1]) + i[0] && (r = !r);\n        }\n      }\n\n      var n, i, s;\n      return r;\n    }\n\n    function Le(t, e) {\n      for (let r = 0; r < e.length; r++) if (Fe(t, e[r])) return !0;\n\n      return !1;\n    }\n\n    function Re(t, e, r, n) {\n      const i = n[0] - r[0],\n            s = n[1] - r[1],\n            a = (t[0] - r[0]) * s - i * (t[1] - r[1]),\n            o = (e[0] - r[0]) * s - i * (e[1] - r[1]);\n      return a > 0 && o < 0 || a < 0 && o > 0;\n    }\n\n    function Ue(t, e, r) {\n      for (const u of r) for (let r = 0; r < u.length - 1; ++r) if (0 != (o = [(a = u[r + 1])[0] - (s = u[r])[0], a[1] - s[1]])[0] * (l = [(i = e)[0] - (n = t)[0], i[1] - n[1]])[1] - o[1] * l[0] && Re(n, i, s, a) && Re(s, a, n, i)) return !0;\n\n      var n, i, s, a, o, l;\n      return !1;\n    }\n\n    function $e(t, e) {\n      for (let r = 0; r < t.length; ++r) if (!Fe(t[r], e)) return !1;\n\n      for (let r = 0; r < t.length - 1; ++r) if (Ue(t[r], t[r + 1], e)) return !1;\n\n      return !0;\n    }\n\n    function je(t, e) {\n      for (let r = 0; r < e.length; r++) if ($e(t, e[r])) return !0;\n\n      return !1;\n    }\n\n    function Oe(t, e, r) {\n      const n = [];\n\n      for (let i = 0; i < t.length; i++) {\n        const s = [];\n\n        for (let n = 0; n < t[i].length; n++) {\n          const a = Pe(t[i][n], r);\n          Ce(e, a), s.push(a);\n        }\n\n        n.push(s);\n      }\n\n      return n;\n    }\n\n    function qe(t, e, r) {\n      const n = [];\n\n      for (let i = 0; i < t.length; i++) {\n        const s = Oe(t[i], e, r);\n        n.push(s);\n      }\n\n      return n;\n    }\n\n    function Ne(t, e, r, n) {\n      if (t[0] < r[0] || t[0] > r[2]) {\n        const e = .5 * n;\n        let i = t[0] - r[0] > e ? -n : r[0] - t[0] > e ? n : 0;\n        0 === i && (i = t[0] - r[2] > e ? -n : r[2] - t[0] > e ? n : 0), t[0] += i;\n      }\n\n      Ce(e, t);\n    }\n\n    function Ge(t, e, r, n) {\n      const i = Math.pow(2, n.z) * Ee,\n            s = [n.x * Ee, n.y * Ee],\n            a = [];\n      if (!t) return a;\n\n      for (const n of t) for (const t of n) {\n        const n = [t.x + s[0], t.y + s[1]];\n        Ne(n, e, r, i), a.push(n);\n      }\n\n      return a;\n    }\n\n    function Ze(t, e, r, n) {\n      const i = Math.pow(2, n.z) * Ee,\n            s = [n.x * Ee, n.y * Ee],\n            a = [];\n      if (!t) return a;\n\n      for (const r of t) {\n        const t = [];\n\n        for (const n of r) {\n          const r = [n.x + s[0], n.y + s[1]];\n          Ce(e, r), t.push(r);\n        }\n\n        a.push(t);\n      }\n\n      if (e[2] - e[0] <= i / 2) {\n        (o = e)[0] = o[1] = 1 / 0, o[2] = o[3] = -1 / 0;\n\n        for (const t of a) for (const n of t) Ne(n, e, r, i);\n      }\n\n      var o;\n      return a;\n    }\n\n    class Xe {\n      constructor(t, e) {\n        this.type = Yt, this.geojson = t, this.geometries = e;\n      }\n\n      static parse(t, e) {\n        if (2 !== t.length) return e.error(`'within' expression requires exactly one argument, but found ${t.length - 1} instead.`);\n\n        if (me(t[1])) {\n          const e = t[1];\n          if (\"FeatureCollection\" === e.type) for (let t = 0; t < e.features.length; ++t) {\n            const r = e.features[t].geometry.type;\n            if (\"Polygon\" === r || \"MultiPolygon\" === r) return new Xe(e, e.features[t].geometry);\n          } else if (\"Feature\" === e.type) {\n            const t = e.geometry.type;\n            if (\"Polygon\" === t || \"MultiPolygon\" === t) return new Xe(e, e.geometry);\n          } else if (\"Polygon\" === e.type || \"MultiPolygon\" === e.type) return new Xe(e, e);\n        }\n\n        return e.error(\"'within' expression requires valid geojson object that contains polygon geometry type.\");\n      }\n\n      evaluate(t) {\n        if (null != t.geometry() && null != t.canonicalID()) {\n          if (\"Point\" === t.geometryType()) return function (t, e) {\n            const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n                  n = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n                  i = t.canonicalID();\n            if (!i) return !1;\n\n            if (\"Polygon\" === e.type) {\n              const s = Oe(e.coordinates, n, i),\n                    a = Ge(t.geometry(), r, n, i);\n              if (!De(r, n)) return !1;\n\n              for (const t of a) if (!Fe(t, s)) return !1;\n            }\n\n            if (\"MultiPolygon\" === e.type) {\n              const s = qe(e.coordinates, n, i),\n                    a = Ge(t.geometry(), r, n, i);\n              if (!De(r, n)) return !1;\n\n              for (const t of a) if (!Le(t, s)) return !1;\n            }\n\n            return !0;\n          }(t, this.geometries);\n          if (\"LineString\" === t.geometryType()) return function (t, e) {\n            const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n                  n = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n                  i = t.canonicalID();\n            if (!i) return !1;\n\n            if (\"Polygon\" === e.type) {\n              const s = Oe(e.coordinates, n, i),\n                    a = Ze(t.geometry(), r, n, i);\n              if (!De(r, n)) return !1;\n\n              for (const t of a) if (!$e(t, s)) return !1;\n            }\n\n            if (\"MultiPolygon\" === e.type) {\n              const s = qe(e.coordinates, n, i),\n                    a = Ze(t.geometry(), r, n, i);\n              if (!De(r, n)) return !1;\n\n              for (const t of a) if (!je(t, s)) return !1;\n            }\n\n            return !0;\n          }(t, this.geometries);\n        }\n\n        return !1;\n      }\n\n      eachChild() {}\n\n      outputDefined() {\n        return !0;\n      }\n\n      serialize() {\n        return [\"within\", this.geojson];\n      }\n\n    }\n\n    function Ke(t) {\n      if (t instanceof ze) {\n        if (\"get\" === t.name && 1 === t.args.length) return !1;\n        if (\"feature-state\" === t.name) return !1;\n        if (\"has\" === t.name && 1 === t.args.length) return !1;\n        if (\"properties\" === t.name || \"geometry-type\" === t.name || \"id\" === t.name) return !1;\n        if (/^filter-/.test(t.name)) return !1;\n      }\n\n      if (t instanceof Xe) return !1;\n      let e = !0;\n      return t.eachChild(t => {\n        e && !Ke(t) && (e = !1);\n      }), e;\n    }\n\n    function Ye(t) {\n      if (t instanceof ze && \"feature-state\" === t.name) return !1;\n      let e = !0;\n      return t.eachChild(t => {\n        e && !Ye(t) && (e = !1);\n      }), e;\n    }\n\n    function He(t, e) {\n      if (t instanceof ze && e.indexOf(t.name) >= 0) return !1;\n      let r = !0;\n      return t.eachChild(t => {\n        r && !He(t, e) && (r = !1);\n      }), r;\n    }\n\n    class We {\n      constructor(t, e) {\n        this.type = e.type, this.name = t, this.boundExpression = e;\n      }\n\n      static parse(t, e) {\n        if (2 !== t.length || \"string\" != typeof t[1]) return e.error(\"'var' expression requires exactly one string literal argument.\");\n        const r = t[1];\n        return e.scope.has(r) ? new We(r, e.scope.get(r)) : e.error(`Unknown variable \"${r}\". Make sure \"${r}\" has been bound in an enclosing \"let\" expression before using it.`, 1);\n      }\n\n      evaluate(t) {\n        return this.boundExpression.evaluate(t);\n      }\n\n      eachChild() {}\n\n      outputDefined() {\n        return !1;\n      }\n\n      serialize() {\n        return [\"var\", this.name];\n      }\n\n    }\n\n    class Je {\n      constructor(t, e = [], r, n = new Gt(), i = []) {\n        this.registry = t, this.path = e, this.key = e.map(t => `[${t}]`).join(\"\"), this.scope = n, this.errors = i, this.expectedType = r;\n      }\n\n      parse(t, e, r, n, i = {}) {\n        return e ? this.concat(e, r, n)._parse(t, i) : this._parse(t, i);\n      }\n\n      _parse(t, e) {\n        function r(t, e, r) {\n          return \"assert\" === r ? new we(e, [t]) : \"coerce\" === r ? new Ie(e, [t]) : t;\n        }\n\n        if (null !== t && \"string\" != typeof t && \"boolean\" != typeof t && \"number\" != typeof t || (t = [\"literal\", t]), Array.isArray(t)) {\n          if (0 === t.length) return this.error('Expected an array with at least one element. If you wanted a literal array, use [\"literal\", []].');\n          const n = t[0];\n          if (\"string\" != typeof n) return this.error(`Expression name must be a string, but found ${typeof n} instead. If you wanted a literal array, use [\"literal\", [...]].`, 0), null;\n          const i = this.registry[n];\n\n          if (i) {\n            let n = i.parse(t, this);\n            if (!n) return null;\n\n            if (this.expectedType) {\n              const t = this.expectedType,\n                    i = n.type;\n              if (\"string\" !== t.kind && \"number\" !== t.kind && \"boolean\" !== t.kind && \"object\" !== t.kind && \"array\" !== t.kind || \"value\" !== i.kind) {\n                if (\"color\" !== t.kind && \"formatted\" !== t.kind && \"resolvedImage\" !== t.kind || \"value\" !== i.kind && \"string\" !== i.kind) {\n                  if (this.checkSubtype(t, i)) return null;\n                } else n = r(n, t, e.typeAnnotation || \"coerce\");\n              } else n = r(n, t, e.typeAnnotation || \"assert\");\n            }\n\n            if (!(n instanceof ve) && \"resolvedImage\" !== n.type.kind && Qe(n)) {\n              const t = new Te();\n\n              try {\n                n = new ve(n.type, n.evaluate(t));\n              } catch (t) {\n                return this.error(t.message), null;\n              }\n            }\n\n            return n;\n          }\n\n          return this.error(`Unknown expression \"${n}\". If you wanted a literal array, use [\"literal\", [...]].`, 0);\n        }\n\n        return this.error(void 0 === t ? \"'undefined' value invalid. Use null instead.\" : \"object\" == typeof t ? 'Bare objects invalid. Use [\"literal\", {...}] instead.' : `Expected an array, but found ${typeof t} instead.`);\n      }\n\n      concat(t, e, r) {\n        const n = \"number\" == typeof t ? this.path.concat(t) : this.path,\n              i = r ? this.scope.concat(r) : this.scope;\n        return new Je(this.registry, n, e || null, i, this.errors);\n      }\n\n      error(t, ...e) {\n        const r = `${this.key}${e.map(t => `[${t}]`).join(\"\")}`;\n        this.errors.push(new Nt(r, t));\n      }\n\n      checkSubtype(t, e) {\n        const r = se(t, e);\n        return r && this.error(r), r;\n      }\n\n    }\n\n    function Qe(t) {\n      if (t instanceof We) return Qe(t.boundExpression);\n      if (t instanceof ze && \"error\" === t.name) return !1;\n      if (t instanceof Be) return !1;\n      if (t instanceof Xe) return !1;\n      const e = t instanceof Ie || t instanceof we;\n      let r = !0;\n      return t.eachChild(t => {\n        r = e ? r && Qe(t) : r && t instanceof ve;\n      }), !!r && Ke(t) && He(t, [\"zoom\", \"heatmap-density\", \"line-progress\", \"sky-radial-progress\", \"accumulated\", \"is-supported-script\", \"pitch\", \"distance-from-center\"]);\n    }\n\n    function tr(t, e) {\n      const r = t.length - 1;\n      let n,\n          i,\n          s = 0,\n          a = r,\n          o = 0;\n\n      for (; s <= a;) if (o = Math.floor((s + a) / 2), n = t[o], i = t[o + 1], n <= e) {\n        if (o === r || e < i) return o;\n        s = o + 1;\n      } else {\n        if (!(n > e)) throw new be(\"Input is not a number.\");\n        a = o - 1;\n      }\n\n      return 0;\n    }\n\n    class er {\n      constructor(t, e, r) {\n        this.type = t, this.input = e, this.labels = [], this.outputs = [];\n\n        for (const [t, e] of r) this.labels.push(t), this.outputs.push(e);\n      }\n\n      static parse(t, e) {\n        if (t.length - 1 < 4) return e.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);\n        if ((t.length - 1) % 2 != 0) return e.error(\"Expected an even number of arguments.\");\n        const r = e.parse(t[1], 1, Xt);\n        if (!r) return null;\n        const n = [];\n        let i = null;\n        e.expectedType && \"value\" !== e.expectedType.kind && (i = e.expectedType);\n\n        for (let r = 1; r < t.length; r += 2) {\n          const s = 1 === r ? -1 / 0 : t[r],\n                a = t[r + 1],\n                o = r,\n                l = r + 1;\n          if (\"number\" != typeof s) return e.error('Input/output pairs for \"step\" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o);\n          if (n.length && n[n.length - 1][0] >= s) return e.error('Input/output pairs for \"step\" expressions must be arranged with input values in strictly ascending order.', o);\n          const u = e.parse(a, l, i);\n          if (!u) return null;\n          i = i || u.type, n.push([s, u]);\n        }\n\n        return new er(i, r, n);\n      }\n\n      evaluate(t) {\n        const e = this.labels,\n              r = this.outputs;\n        if (1 === e.length) return r[0].evaluate(t);\n        const n = this.input.evaluate(t);\n        if (n <= e[0]) return r[0].evaluate(t);\n        const i = e.length;\n        return n >= e[i - 1] ? r[i - 1].evaluate(t) : r[tr(e, n)].evaluate(t);\n      }\n\n      eachChild(t) {\n        t(this.input);\n\n        for (const e of this.outputs) t(e);\n      }\n\n      outputDefined() {\n        return this.outputs.every(t => t.outputDefined());\n      }\n\n      serialize() {\n        const t = [\"step\", this.input.serialize()];\n\n        for (let e = 0; e < this.labels.length; e++) e > 0 && t.push(this.labels[e]), t.push(this.outputs[e].serialize());\n\n        return t;\n      }\n\n    }\n\n    function rr(t, e, r) {\n      return t * (1 - r) + e * r;\n    }\n\n    var nr = Object.freeze({\n      __proto__: null,\n      number: rr,\n      color: function (t, e, r) {\n        return new ce(rr(t.r, e.r, r), rr(t.g, e.g, r), rr(t.b, e.b, r), rr(t.a, e.a, r));\n      },\n      array: function (t, e, r) {\n        return t.map((t, n) => rr(t, e[n], r));\n      }\n    });\n    const ir = .95047,\n          sr = 1.08883,\n          ar = 4 / 29,\n          or = 6 / 29,\n          lr = 3 * or * or,\n          ur = Math.PI / 180,\n          cr = 180 / Math.PI;\n\n    function hr(t) {\n      return t > .008856451679035631 ? Math.pow(t, 1 / 3) : t / lr + ar;\n    }\n\n    function pr(t) {\n      return t > or ? t * t * t : lr * (t - ar);\n    }\n\n    function fr(t) {\n      return 255 * (t <= .0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055);\n    }\n\n    function dr(t) {\n      return (t /= 255) <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4);\n    }\n\n    function yr(t) {\n      const e = dr(t.r),\n            r = dr(t.g),\n            n = dr(t.b),\n            i = hr((.4124564 * e + .3575761 * r + .1804375 * n) / ir),\n            s = hr((.2126729 * e + .7151522 * r + .072175 * n) / 1);\n      return {\n        l: 116 * s - 16,\n        a: 500 * (i - s),\n        b: 200 * (s - hr((.0193339 * e + .119192 * r + .9503041 * n) / sr)),\n        alpha: t.a\n      };\n    }\n\n    function mr(t) {\n      let e = (t.l + 16) / 116,\n          r = isNaN(t.a) ? e : e + t.a / 500,\n          n = isNaN(t.b) ? e : e - t.b / 200;\n      return e = 1 * pr(e), r = ir * pr(r), n = sr * pr(n), new ce(fr(3.2404542 * r - 1.5371385 * e - .4985314 * n), fr(-.969266 * r + 1.8760108 * e + .041556 * n), fr(.0556434 * r - .2040259 * e + 1.0572252 * n), t.alpha);\n    }\n\n    function gr(t, e, r) {\n      const n = e - t;\n      return t + r * (n > 180 || n < -180 ? n - 360 * Math.round(n / 360) : n);\n    }\n\n    const xr = {\n      forward: yr,\n      reverse: mr,\n      interpolate: function (t, e, r) {\n        return {\n          l: rr(t.l, e.l, r),\n          a: rr(t.a, e.a, r),\n          b: rr(t.b, e.b, r),\n          alpha: rr(t.alpha, e.alpha, r)\n        };\n      }\n    },\n          vr = {\n      forward: function (t) {\n        const {\n          l: e,\n          a: r,\n          b: n\n        } = yr(t),\n              i = Math.atan2(n, r) * cr;\n        return {\n          h: i < 0 ? i + 360 : i,\n          c: Math.sqrt(r * r + n * n),\n          l: e,\n          alpha: t.a\n        };\n      },\n      reverse: function (t) {\n        const e = t.h * ur,\n              r = t.c;\n        return mr({\n          l: t.l,\n          a: Math.cos(e) * r,\n          b: Math.sin(e) * r,\n          alpha: t.alpha\n        });\n      },\n      interpolate: function (t, e, r) {\n        return {\n          h: gr(t.h, e.h, r),\n          c: rr(t.c, e.c, r),\n          l: rr(t.l, e.l, r),\n          alpha: rr(t.alpha, e.alpha, r)\n        };\n      }\n    };\n    var br = Object.freeze({\n      __proto__: null,\n      lab: xr,\n      hcl: vr\n    });\n\n    class _r {\n      constructor(t, e, r, n, i) {\n        this.type = t, this.operator = e, this.interpolation = r, this.input = n, this.labels = [], this.outputs = [];\n\n        for (const [t, e] of i) this.labels.push(t), this.outputs.push(e);\n      }\n\n      static interpolationFactor(t, e, n, i) {\n        let s = 0;\n        if (\"exponential\" === t.name) s = wr(e, t.base, n, i);else if (\"linear\" === t.name) s = wr(e, 1, n, i);else if (\"cubic-bezier\" === t.name) {\n          const a = t.controlPoints;\n          s = new r(a[0], a[1], a[2], a[3]).solve(wr(e, 1, n, i));\n        }\n        return s;\n      }\n\n      static parse(t, e) {\n        let [r, n, i, ...s] = t;\n        if (!Array.isArray(n) || 0 === n.length) return e.error(\"Expected an interpolation type expression.\", 1);\n        if (\"linear\" === n[0]) n = {\n          name: \"linear\"\n        };else if (\"exponential\" === n[0]) {\n          const t = n[1];\n          if (\"number\" != typeof t) return e.error(\"Exponential interpolation requires a numeric base.\", 1, 1);\n          n = {\n            name: \"exponential\",\n            base: t\n          };\n        } else {\n          if (\"cubic-bezier\" !== n[0]) return e.error(`Unknown interpolation type ${String(n[0])}`, 1, 0);\n          {\n            const t = n.slice(1);\n            if (4 !== t.length || t.some(t => \"number\" != typeof t || t < 0 || t > 1)) return e.error(\"Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.\", 1);\n            n = {\n              name: \"cubic-bezier\",\n              controlPoints: t\n            };\n          }\n        }\n        if (t.length - 1 < 4) return e.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);\n        if ((t.length - 1) % 2 != 0) return e.error(\"Expected an even number of arguments.\");\n        if (i = e.parse(i, 2, Xt), !i) return null;\n        const a = [];\n        let o = null;\n        \"interpolate-hcl\" === r || \"interpolate-lab\" === r ? o = Ht : e.expectedType && \"value\" !== e.expectedType.kind && (o = e.expectedType);\n\n        for (let t = 0; t < s.length; t += 2) {\n          const r = s[t],\n                n = s[t + 1],\n                i = t + 3,\n                l = t + 4;\n          if (\"number\" != typeof r) return e.error('Input/output pairs for \"interpolate\" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i);\n          if (a.length && a[a.length - 1][0] >= r) return e.error('Input/output pairs for \"interpolate\" expressions must be arranged with input values in strictly ascending order.', i);\n          const u = e.parse(n, l, o);\n          if (!u) return null;\n          o = o || u.type, a.push([r, u]);\n        }\n\n        return \"number\" === o.kind || \"color\" === o.kind || \"array\" === o.kind && \"number\" === o.itemType.kind && \"number\" == typeof o.N ? new _r(o, r, n, i, a) : e.error(`Type ${ne(o)} is not interpolatable.`);\n      }\n\n      evaluate(t) {\n        const e = this.labels,\n              r = this.outputs;\n        if (1 === e.length) return r[0].evaluate(t);\n        const n = this.input.evaluate(t);\n        if (n <= e[0]) return r[0].evaluate(t);\n        const i = e.length;\n        if (n >= e[i - 1]) return r[i - 1].evaluate(t);\n\n        const s = tr(e, n),\n              a = _r.interpolationFactor(this.interpolation, n, e[s], e[s + 1]),\n              o = r[s].evaluate(t),\n              l = r[s + 1].evaluate(t);\n\n        return \"interpolate\" === this.operator ? nr[this.type.kind.toLowerCase()](o, l, a) : \"interpolate-hcl\" === this.operator ? vr.reverse(vr.interpolate(vr.forward(o), vr.forward(l), a)) : xr.reverse(xr.interpolate(xr.forward(o), xr.forward(l), a));\n      }\n\n      eachChild(t) {\n        t(this.input);\n\n        for (const e of this.outputs) t(e);\n      }\n\n      outputDefined() {\n        return this.outputs.every(t => t.outputDefined());\n      }\n\n      serialize() {\n        let t;\n        t = \"linear\" === this.interpolation.name ? [\"linear\"] : \"exponential\" === this.interpolation.name ? 1 === this.interpolation.base ? [\"linear\"] : [\"exponential\", this.interpolation.base] : [\"cubic-bezier\"].concat(this.interpolation.controlPoints);\n        const e = [this.operator, t, this.input.serialize()];\n\n        for (let t = 0; t < this.labels.length; t++) e.push(this.labels[t], this.outputs[t].serialize());\n\n        return e;\n      }\n\n    }\n\n    function wr(t, e, r, n) {\n      const i = n - r,\n            s = t - r;\n      return 0 === i ? 0 : 1 === e ? s / i : (Math.pow(e, s) - 1) / (Math.pow(e, i) - 1);\n    }\n\n    class Ar {\n      constructor(t, e) {\n        this.type = t, this.args = e;\n      }\n\n      static parse(t, e) {\n        if (t.length < 2) return e.error(\"Expectected at least one argument.\");\n        let r = null;\n        const n = e.expectedType;\n        n && \"value\" !== n.kind && (r = n);\n        const i = [];\n\n        for (const n of t.slice(1)) {\n          const t = e.parse(n, 1 + i.length, r, void 0, {\n            typeAnnotation: \"omit\"\n          });\n          if (!t) return null;\n          r = r || t.type, i.push(t);\n        }\n\n        const s = n && i.some(t => se(n, t.type));\n        return new Ar(s ? Jt : r, i);\n      }\n\n      evaluate(t) {\n        let e,\n            r = null,\n            n = 0;\n\n        for (const i of this.args) {\n          if (n++, r = i.evaluate(t), r && r instanceof de && !r.available && (e || (e = r), r = null, n === this.args.length)) return e;\n          if (null !== r) break;\n        }\n\n        return r;\n      }\n\n      eachChild(t) {\n        this.args.forEach(t);\n      }\n\n      outputDefined() {\n        return this.args.every(t => t.outputDefined());\n      }\n\n      serialize() {\n        const t = [\"coalesce\"];\n        return this.eachChild(e => {\n          t.push(e.serialize());\n        }), t;\n      }\n\n    }\n\n    class kr {\n      constructor(t, e) {\n        this.type = e.type, this.bindings = [].concat(t), this.result = e;\n      }\n\n      evaluate(t) {\n        return this.result.evaluate(t);\n      }\n\n      eachChild(t) {\n        for (const e of this.bindings) t(e[1]);\n\n        t(this.result);\n      }\n\n      static parse(t, e) {\n        if (t.length < 4) return e.error(`Expected at least 3 arguments, but found ${t.length - 1} instead.`);\n        const r = [];\n\n        for (let n = 1; n < t.length - 1; n += 2) {\n          const i = t[n];\n          if (\"string\" != typeof i) return e.error(`Expected string, but found ${typeof i} instead.`, n);\n          if (/[^a-zA-Z0-9_]/.test(i)) return e.error(\"Variable names must contain only alphanumeric characters or '_'.\", n);\n          const s = e.parse(t[n + 1], n + 1);\n          if (!s) return null;\n          r.push([i, s]);\n        }\n\n        const n = e.parse(t[t.length - 1], t.length - 1, e.expectedType, r);\n        return n ? new kr(r, n) : null;\n      }\n\n      outputDefined() {\n        return this.result.outputDefined();\n      }\n\n      serialize() {\n        const t = [\"let\"];\n\n        for (const [e, r] of this.bindings) t.push(e, r.serialize());\n\n        return t.push(this.result.serialize()), t;\n      }\n\n    }\n\n    class Sr {\n      constructor(t, e, r) {\n        this.type = t, this.index = e, this.input = r;\n      }\n\n      static parse(t, e) {\n        if (3 !== t.length) return e.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);\n        const r = e.parse(t[1], 1, Xt),\n              n = e.parse(t[2], 2, re(e.expectedType || Jt));\n        return r && n ? new Sr(n.type.itemType, r, n) : null;\n      }\n\n      evaluate(t) {\n        const e = this.index.evaluate(t),\n              r = this.input.evaluate(t);\n        if (e < 0) throw new be(`Array index out of bounds: ${e} < 0.`);\n        if (e >= r.length) throw new be(`Array index out of bounds: ${e} > ${r.length - 1}.`);\n        if (e !== Math.floor(e)) throw new be(`Array index must be an integer, but found ${e} instead.`);\n        return r[e];\n      }\n\n      eachChild(t) {\n        t(this.index), t(this.input);\n      }\n\n      outputDefined() {\n        return !1;\n      }\n\n      serialize() {\n        return [\"at\", this.index.serialize(), this.input.serialize()];\n      }\n\n    }\n\n    class Ir {\n      constructor(t, e) {\n        this.type = Yt, this.needle = t, this.haystack = e;\n      }\n\n      static parse(t, e) {\n        if (3 !== t.length) return e.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);\n        const r = e.parse(t[1], 1, Jt),\n              n = e.parse(t[2], 2, Jt);\n        return r && n ? ae(r.type, [Yt, Kt, Xt, Zt, Jt]) ? new Ir(r, n) : e.error(`Expected first argument to be of type boolean, string, number or null, but found ${ne(r.type)} instead`) : null;\n      }\n\n      evaluate(t) {\n        const e = this.needle.evaluate(t),\n              r = this.haystack.evaluate(t);\n        if (null == r) return !1;\n        if (!oe(e, [\"boolean\", \"string\", \"number\", \"null\"])) throw new be(`Expected first argument to be of type boolean, string, number or null, but found ${ne(ge(e))} instead.`);\n        if (!oe(r, [\"string\", \"array\"])) throw new be(`Expected second argument to be of type array or string, but found ${ne(ge(r))} instead.`);\n        return r.indexOf(e) >= 0;\n      }\n\n      eachChild(t) {\n        t(this.needle), t(this.haystack);\n      }\n\n      outputDefined() {\n        return !0;\n      }\n\n      serialize() {\n        return [\"in\", this.needle.serialize(), this.haystack.serialize()];\n      }\n\n    }\n\n    class Mr {\n      constructor(t, e, r) {\n        this.type = Xt, this.needle = t, this.haystack = e, this.fromIndex = r;\n      }\n\n      static parse(t, e) {\n        if (t.length <= 2 || t.length >= 5) return e.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);\n        const r = e.parse(t[1], 1, Jt),\n              n = e.parse(t[2], 2, Jt);\n        if (!r || !n) return null;\n        if (!ae(r.type, [Yt, Kt, Xt, Zt, Jt])) return e.error(`Expected first argument to be of type boolean, string, number or null, but found ${ne(r.type)} instead`);\n\n        if (4 === t.length) {\n          const i = e.parse(t[3], 3, Xt);\n          return i ? new Mr(r, n, i) : null;\n        }\n\n        return new Mr(r, n);\n      }\n\n      evaluate(t) {\n        const e = this.needle.evaluate(t),\n              r = this.haystack.evaluate(t);\n        if (!oe(e, [\"boolean\", \"string\", \"number\", \"null\"])) throw new be(`Expected first argument to be of type boolean, string, number or null, but found ${ne(ge(e))} instead.`);\n        if (!oe(r, [\"string\", \"array\"])) throw new be(`Expected second argument to be of type array or string, but found ${ne(ge(r))} instead.`);\n\n        if (this.fromIndex) {\n          const n = this.fromIndex.evaluate(t);\n          return r.indexOf(e, n);\n        }\n\n        return r.indexOf(e);\n      }\n\n      eachChild(t) {\n        t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex);\n      }\n\n      outputDefined() {\n        return !1;\n      }\n\n      serialize() {\n        if (null != this.fromIndex && void 0 !== this.fromIndex) {\n          const t = this.fromIndex.serialize();\n          return [\"index-of\", this.needle.serialize(), this.haystack.serialize(), t];\n        }\n\n        return [\"index-of\", this.needle.serialize(), this.haystack.serialize()];\n      }\n\n    }\n\n    class Tr {\n      constructor(t, e, r, n, i, s) {\n        this.inputType = t, this.type = e, this.input = r, this.cases = n, this.outputs = i, this.otherwise = s;\n      }\n\n      static parse(t, e) {\n        if (t.length < 5) return e.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);\n        if (t.length % 2 != 1) return e.error(\"Expected an even number of arguments.\");\n        let r, n;\n        e.expectedType && \"value\" !== e.expectedType.kind && (n = e.expectedType);\n        const i = {},\n              s = [];\n\n        for (let a = 2; a < t.length - 1; a += 2) {\n          let o = t[a];\n          const l = t[a + 1];\n          Array.isArray(o) || (o = [o]);\n          const u = e.concat(a);\n          if (0 === o.length) return u.error(\"Expected at least one branch label.\");\n\n          for (const t of o) {\n            if (\"number\" != typeof t && \"string\" != typeof t) return u.error(\"Branch labels must be numbers or strings.\");\n            if (\"number\" == typeof t && Math.abs(t) > Number.MAX_SAFE_INTEGER) return u.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);\n            if (\"number\" == typeof t && Math.floor(t) !== t) return u.error(\"Numeric branch labels must be integer values.\");\n\n            if (r) {\n              if (u.checkSubtype(r, ge(t))) return null;\n            } else r = ge(t);\n\n            if (void 0 !== i[String(t)]) return u.error(\"Branch labels must be unique.\");\n            i[String(t)] = s.length;\n          }\n\n          const c = e.parse(l, a, n);\n          if (!c) return null;\n          n = n || c.type, s.push(c);\n        }\n\n        const a = e.parse(t[1], 1, Jt);\n        if (!a) return null;\n        const o = e.parse(t[t.length - 1], t.length - 1, n);\n        return o ? \"value\" !== a.type.kind && e.concat(1).checkSubtype(r, a.type) ? null : new Tr(r, n, a, i, s, o) : null;\n      }\n\n      evaluate(t) {\n        const e = this.input.evaluate(t);\n        return (ge(e) === this.inputType && this.outputs[this.cases[e]] || this.otherwise).evaluate(t);\n      }\n\n      eachChild(t) {\n        t(this.input), this.outputs.forEach(t), t(this.otherwise);\n      }\n\n      outputDefined() {\n        return this.outputs.every(t => t.outputDefined()) && this.otherwise.outputDefined();\n      }\n\n      serialize() {\n        const t = [\"match\", this.input.serialize()],\n              e = Object.keys(this.cases).sort(),\n              r = [],\n              n = {};\n\n        for (const t of e) {\n          const e = n[this.cases[t]];\n          void 0 === e ? (n[this.cases[t]] = r.length, r.push([this.cases[t], [t]])) : r[e][1].push(t);\n        }\n\n        const i = t => \"number\" === this.inputType.kind ? Number(t) : t;\n\n        for (const [e, n] of r) t.push(1 === n.length ? i(n[0]) : n.map(i)), t.push(this.outputs[e].serialize());\n\n        return t.push(this.otherwise.serialize()), t;\n      }\n\n    }\n\n    class zr {\n      constructor(t, e, r) {\n        this.type = t, this.branches = e, this.otherwise = r;\n      }\n\n      static parse(t, e) {\n        if (t.length < 4) return e.error(`Expected at least 3 arguments, but found only ${t.length - 1}.`);\n        if (t.length % 2 != 0) return e.error(\"Expected an odd number of arguments.\");\n        let r;\n        e.expectedType && \"value\" !== e.expectedType.kind && (r = e.expectedType);\n        const n = [];\n\n        for (let i = 1; i < t.length - 1; i += 2) {\n          const s = e.parse(t[i], i, Yt);\n          if (!s) return null;\n          const a = e.parse(t[i + 1], i + 1, r);\n          if (!a) return null;\n          n.push([s, a]), r = r || a.type;\n        }\n\n        const i = e.parse(t[t.length - 1], t.length - 1, r);\n        return i ? new zr(r, n, i) : null;\n      }\n\n      evaluate(t) {\n        for (const [e, r] of this.branches) if (e.evaluate(t)) return r.evaluate(t);\n\n        return this.otherwise.evaluate(t);\n      }\n\n      eachChild(t) {\n        for (const [e, r] of this.branches) t(e), t(r);\n\n        t(this.otherwise);\n      }\n\n      outputDefined() {\n        return this.branches.every(([t, e]) => e.outputDefined()) && this.otherwise.outputDefined();\n      }\n\n      serialize() {\n        const t = [\"case\"];\n        return this.eachChild(e => {\n          t.push(e.serialize());\n        }), t;\n      }\n\n    }\n\n    class Br {\n      constructor(t, e, r, n) {\n        this.type = t, this.input = e, this.beginIndex = r, this.endIndex = n;\n      }\n\n      static parse(t, e) {\n        if (t.length <= 2 || t.length >= 5) return e.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);\n        const r = e.parse(t[1], 1, Jt),\n              n = e.parse(t[2], 2, Xt);\n        if (!r || !n) return null;\n        if (!ae(r.type, [re(Jt), Kt, Jt])) return e.error(`Expected first argument to be of type array or string, but found ${ne(r.type)} instead`);\n\n        if (4 === t.length) {\n          const i = e.parse(t[3], 3, Xt);\n          return i ? new Br(r.type, r, n, i) : null;\n        }\n\n        return new Br(r.type, r, n);\n      }\n\n      evaluate(t) {\n        const e = this.input.evaluate(t),\n              r = this.beginIndex.evaluate(t);\n        if (!oe(e, [\"string\", \"array\"])) throw new be(`Expected first argument to be of type array or string, but found ${ne(ge(e))} instead.`);\n\n        if (this.endIndex) {\n          const n = this.endIndex.evaluate(t);\n          return e.slice(r, n);\n        }\n\n        return e.slice(r);\n      }\n\n      eachChild(t) {\n        t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex);\n      }\n\n      outputDefined() {\n        return !1;\n      }\n\n      serialize() {\n        if (null != this.endIndex && void 0 !== this.endIndex) {\n          const t = this.endIndex.serialize();\n          return [\"slice\", this.input.serialize(), this.beginIndex.serialize(), t];\n        }\n\n        return [\"slice\", this.input.serialize(), this.beginIndex.serialize()];\n      }\n\n    }\n\n    function Er(t, e) {\n      return \"==\" === t || \"!=\" === t ? \"boolean\" === e.kind || \"string\" === e.kind || \"number\" === e.kind || \"null\" === e.kind || \"value\" === e.kind : \"string\" === e.kind || \"number\" === e.kind || \"value\" === e.kind;\n    }\n\n    function Cr(t, e, r, n) {\n      return 0 === n.compare(e, r);\n    }\n\n    function Dr(t, e, r) {\n      const n = \"==\" !== t && \"!=\" !== t;\n      return class i {\n        constructor(t, e, r) {\n          this.type = Yt, this.lhs = t, this.rhs = e, this.collator = r, this.hasUntypedArgument = \"value\" === t.type.kind || \"value\" === e.type.kind;\n        }\n\n        static parse(t, e) {\n          if (3 !== t.length && 4 !== t.length) return e.error(\"Expected two or three arguments.\");\n          const r = t[0];\n          let s = e.parse(t[1], 1, Jt);\n          if (!s) return null;\n          if (!Er(r, s.type)) return e.concat(1).error(`\"${r}\" comparisons are not supported for type '${ne(s.type)}'.`);\n          let a = e.parse(t[2], 2, Jt);\n          if (!a) return null;\n          if (!Er(r, a.type)) return e.concat(2).error(`\"${r}\" comparisons are not supported for type '${ne(a.type)}'.`);\n          if (s.type.kind !== a.type.kind && \"value\" !== s.type.kind && \"value\" !== a.type.kind) return e.error(`Cannot compare types '${ne(s.type)}' and '${ne(a.type)}'.`);\n          n && (\"value\" === s.type.kind && \"value\" !== a.type.kind ? s = new we(a.type, [s]) : \"value\" !== s.type.kind && \"value\" === a.type.kind && (a = new we(s.type, [a])));\n          let o = null;\n\n          if (4 === t.length) {\n            if (\"string\" !== s.type.kind && \"string\" !== a.type.kind && \"value\" !== s.type.kind && \"value\" !== a.type.kind) return e.error(\"Cannot use collator to compare non-string types.\");\n            if (o = e.parse(t[3], 3, Qt), !o) return null;\n          }\n\n          return new i(s, a, o);\n        }\n\n        evaluate(i) {\n          const s = this.lhs.evaluate(i),\n                a = this.rhs.evaluate(i);\n\n          if (n && this.hasUntypedArgument) {\n            const e = ge(s),\n                  r = ge(a);\n            if (e.kind !== r.kind || \"string\" !== e.kind && \"number\" !== e.kind) throw new be(`Expected arguments for \"${t}\" to be (string, string) or (number, number), but found (${e.kind}, ${r.kind}) instead.`);\n          }\n\n          if (this.collator && !n && this.hasUntypedArgument) {\n            const t = ge(s),\n                  r = ge(a);\n            if (\"string\" !== t.kind || \"string\" !== r.kind) return e(i, s, a);\n          }\n\n          return this.collator ? r(i, s, a, this.collator.evaluate(i)) : e(i, s, a);\n        }\n\n        eachChild(t) {\n          t(this.lhs), t(this.rhs), this.collator && t(this.collator);\n        }\n\n        outputDefined() {\n          return !0;\n        }\n\n        serialize() {\n          const e = [t];\n          return this.eachChild(t => {\n            e.push(t.serialize());\n          }), e;\n        }\n\n      };\n    }\n\n    const Pr = Dr(\"==\", function (t, e, r) {\n      return e === r;\n    }, Cr),\n          Vr = Dr(\"!=\", function (t, e, r) {\n      return e !== r;\n    }, function (t, e, r, n) {\n      return !Cr(0, e, r, n);\n    }),\n          Fr = Dr(\"<\", function (t, e, r) {\n      return e < r;\n    }, function (t, e, r, n) {\n      return n.compare(e, r) < 0;\n    }),\n          Lr = Dr(\">\", function (t, e, r) {\n      return e > r;\n    }, function (t, e, r, n) {\n      return n.compare(e, r) > 0;\n    }),\n          Rr = Dr(\"<=\", function (t, e, r) {\n      return e <= r;\n    }, function (t, e, r, n) {\n      return n.compare(e, r) <= 0;\n    }),\n          Ur = Dr(\">=\", function (t, e, r) {\n      return e >= r;\n    }, function (t, e, r, n) {\n      return n.compare(e, r) >= 0;\n    });\n\n    class $r {\n      constructor(t, e, r, n, i) {\n        this.type = Kt, this.number = t, this.locale = e, this.currency = r, this.minFractionDigits = n, this.maxFractionDigits = i;\n      }\n\n      static parse(t, e) {\n        if (3 !== t.length) return e.error(\"Expected two arguments.\");\n        const r = e.parse(t[1], 1, Xt);\n        if (!r) return null;\n        const n = t[2];\n        if (\"object\" != typeof n || Array.isArray(n)) return e.error(\"NumberFormat options argument must be an object.\");\n        let i = null;\n        if (n.locale && (i = e.parse(n.locale, 1, Kt), !i)) return null;\n        let s = null;\n        if (n.currency && (s = e.parse(n.currency, 1, Kt), !s)) return null;\n        let a = null;\n        if (n[\"min-fraction-digits\"] && (a = e.parse(n[\"min-fraction-digits\"], 1, Xt), !a)) return null;\n        let o = null;\n        return n[\"max-fraction-digits\"] && (o = e.parse(n[\"max-fraction-digits\"], 1, Xt), !o) ? null : new $r(r, i, s, a, o);\n      }\n\n      evaluate(t) {\n        return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], {\n          style: this.currency ? \"currency\" : \"decimal\",\n          currency: this.currency ? this.currency.evaluate(t) : void 0,\n          minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0,\n          maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0\n        }).format(this.number.evaluate(t));\n      }\n\n      eachChild(t) {\n        t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits);\n      }\n\n      outputDefined() {\n        return !1;\n      }\n\n      serialize() {\n        const t = {};\n        return this.locale && (t.locale = this.locale.serialize()), this.currency && (t.currency = this.currency.serialize()), this.minFractionDigits && (t[\"min-fraction-digits\"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t[\"max-fraction-digits\"] = this.maxFractionDigits.serialize()), [\"number-format\", this.number.serialize(), t];\n      }\n\n    }\n\n    class jr {\n      constructor(t) {\n        this.type = Xt, this.input = t;\n      }\n\n      static parse(t, e) {\n        if (2 !== t.length) return e.error(`Expected 1 argument, but found ${t.length - 1} instead.`);\n        const r = e.parse(t[1], 1);\n        return r ? \"array\" !== r.type.kind && \"string\" !== r.type.kind && \"value\" !== r.type.kind ? e.error(`Expected argument of type string or array, but found ${ne(r.type)} instead.`) : new jr(r) : null;\n      }\n\n      evaluate(t) {\n        const e = this.input.evaluate(t);\n        if (\"string\" == typeof e) return e.length;\n        if (Array.isArray(e)) return e.length;\n        throw new be(`Expected value to be of type string or array, but found ${ne(ge(e))} instead.`);\n      }\n\n      eachChild(t) {\n        t(this.input);\n      }\n\n      outputDefined() {\n        return !1;\n      }\n\n      serialize() {\n        const t = [\"length\"];\n        return this.eachChild(e => {\n          t.push(e.serialize());\n        }), t;\n      }\n\n    }\n\n    const Or = {\n      \"==\": Pr,\n      \"!=\": Vr,\n      \">\": Lr,\n      \"<\": Fr,\n      \">=\": Ur,\n      \"<=\": Rr,\n      array: we,\n      at: Sr,\n      boolean: we,\n      case: zr,\n      coalesce: Ar,\n      collator: Be,\n      format: Ae,\n      image: ke,\n      in: Ir,\n      \"index-of\": Mr,\n      interpolate: _r,\n      \"interpolate-hcl\": _r,\n      \"interpolate-lab\": _r,\n      length: jr,\n      let: kr,\n      literal: ve,\n      match: Tr,\n      number: we,\n      \"number-format\": $r,\n      object: we,\n      slice: Br,\n      step: er,\n      string: we,\n      \"to-boolean\": Ie,\n      \"to-color\": Ie,\n      \"to-number\": Ie,\n      \"to-string\": Ie,\n      var: We,\n      within: Xe\n    };\n\n    function qr(t, [e, r, n, i]) {\n      e = e.evaluate(t), r = r.evaluate(t), n = n.evaluate(t);\n      const s = i ? i.evaluate(t) : 1,\n            a = ye(e, r, n, s);\n      if (a) throw new be(a);\n      return new ce(e / 255 * s, r / 255 * s, n / 255 * s, s);\n    }\n\n    function Nr(t, e) {\n      return t in e;\n    }\n\n    function Gr(t, e) {\n      const r = e[t];\n      return void 0 === r ? null : r;\n    }\n\n    function Zr(t) {\n      return {\n        type: t\n      };\n    }\n\n    function Xr(t) {\n      return {\n        result: \"success\",\n        value: t\n      };\n    }\n\n    function Kr(t) {\n      return {\n        result: \"error\",\n        value: t\n      };\n    }\n\n    function Yr(t) {\n      return \"data-driven\" === t[\"property-type\"] || \"cross-faded-data-driven\" === t[\"property-type\"];\n    }\n\n    function Hr(t) {\n      return !!t.expression && t.expression.parameters.indexOf(\"zoom\") > -1;\n    }\n\n    function Wr(t) {\n      return !!t.expression && t.expression.interpolated;\n    }\n\n    function Jr(t) {\n      return t instanceof Number ? \"number\" : t instanceof String ? \"string\" : t instanceof Boolean ? \"boolean\" : Array.isArray(t) ? \"array\" : null === t ? \"null\" : typeof t;\n    }\n\n    function Qr(t) {\n      return \"object\" == typeof t && null !== t && !Array.isArray(t);\n    }\n\n    function tn(t) {\n      return t;\n    }\n\n    function en(t, e) {\n      const r = \"color\" === e.type,\n            n = t.stops && \"object\" == typeof t.stops[0][0],\n            i = n || !(n || void 0 !== t.property),\n            s = t.type || (Wr(e) ? \"exponential\" : \"interval\");\n      if (r && ((t = jt({}, t)).stops && (t.stops = t.stops.map(t => [t[0], ce.parse(t[1])])), t.default = ce.parse(t.default ? t.default : e.default)), t.colorSpace && \"rgb\" !== t.colorSpace && !br[t.colorSpace]) throw new Error(`Unknown color space: ${t.colorSpace}`);\n      let a, o, l;\n      if (\"exponential\" === s) a = an;else if (\"interval\" === s) a = sn;else if (\"categorical\" === s) {\n        a = nn, o = Object.create(null);\n\n        for (const e of t.stops) o[e[0]] = e[1];\n\n        l = typeof t.stops[0][0];\n      } else {\n        if (\"identity\" !== s) throw new Error(`Unknown function type \"${s}\"`);\n        a = on;\n      }\n\n      if (n) {\n        const r = {},\n              n = [];\n\n        for (let e = 0; e < t.stops.length; e++) {\n          const i = t.stops[e],\n                s = i[0].zoom;\n          void 0 === r[s] && (r[s] = {\n            zoom: s,\n            type: t.type,\n            property: t.property,\n            default: t.default,\n            stops: []\n          }, n.push(s)), r[s].stops.push([i[0].value, i[1]]);\n        }\n\n        const i = [];\n\n        for (const t of n) i.push([r[t].zoom, en(r[t], e)]);\n\n        const s = {\n          name: \"linear\"\n        };\n        return {\n          kind: \"composite\",\n          interpolationType: s,\n          interpolationFactor: _r.interpolationFactor.bind(void 0, s),\n          zoomStops: i.map(t => t[0]),\n          evaluate: ({\n            zoom: r\n          }, n) => an({\n            stops: i,\n            base: t.base\n          }, e, r).evaluate(r, n)\n        };\n      }\n\n      if (i) {\n        const r = \"exponential\" === s ? {\n          name: \"exponential\",\n          base: void 0 !== t.base ? t.base : 1\n        } : null;\n        return {\n          kind: \"camera\",\n          interpolationType: r,\n          interpolationFactor: _r.interpolationFactor.bind(void 0, r),\n          zoomStops: t.stops.map(t => t[0]),\n          evaluate: ({\n            zoom: r\n          }) => a(t, e, r, o, l)\n        };\n      }\n\n      return {\n        kind: \"source\",\n\n        evaluate(r, n) {\n          const i = n && n.properties ? n.properties[t.property] : void 0;\n          return void 0 === i ? rn(t.default, e.default) : a(t, e, i, o, l);\n        }\n\n      };\n    }\n\n    function rn(t, e, r) {\n      return void 0 !== t ? t : void 0 !== e ? e : void 0 !== r ? r : void 0;\n    }\n\n    function nn(t, e, r, n, i) {\n      return rn(typeof r === i ? n[r] : void 0, t.default, e.default);\n    }\n\n    function sn(t, e, r) {\n      if (\"number\" !== Jr(r)) return rn(t.default, e.default);\n      const n = t.stops.length;\n      if (1 === n) return t.stops[0][1];\n      if (r <= t.stops[0][0]) return t.stops[0][1];\n      if (r >= t.stops[n - 1][0]) return t.stops[n - 1][1];\n      const i = tr(t.stops.map(t => t[0]), r);\n      return t.stops[i][1];\n    }\n\n    function an(t, e, r) {\n      const n = void 0 !== t.base ? t.base : 1;\n      if (\"number\" !== Jr(r)) return rn(t.default, e.default);\n      const i = t.stops.length;\n      if (1 === i) return t.stops[0][1];\n      if (r <= t.stops[0][0]) return t.stops[0][1];\n      if (r >= t.stops[i - 1][0]) return t.stops[i - 1][1];\n\n      const s = tr(t.stops.map(t => t[0]), r),\n            a = function (t, e, r, n) {\n        const i = n - r,\n              s = t - r;\n        return 0 === i ? 0 : 1 === e ? s / i : (Math.pow(e, s) - 1) / (Math.pow(e, i) - 1);\n      }(r, n, t.stops[s][0], t.stops[s + 1][0]),\n            o = t.stops[s][1],\n            l = t.stops[s + 1][1];\n\n      let u = nr[e.type] || tn;\n\n      if (t.colorSpace && \"rgb\" !== t.colorSpace) {\n        const e = br[t.colorSpace];\n\n        u = (t, r) => e.reverse(e.interpolate(e.forward(t), e.forward(r), a));\n      }\n\n      return \"function\" == typeof o.evaluate ? {\n        evaluate(...t) {\n          const e = o.evaluate.apply(void 0, t),\n                r = l.evaluate.apply(void 0, t);\n          if (void 0 !== e && void 0 !== r) return u(e, r, a);\n        }\n\n      } : u(o, l, a);\n    }\n\n    function on(t, e, r) {\n      return \"color\" === e.type ? r = ce.parse(r) : \"formatted\" === e.type ? r = fe.fromString(r.toString()) : \"resolvedImage\" === e.type ? r = de.fromString(r.toString()) : Jr(r) === e.type || \"enum\" === e.type && e.values[r] || (r = void 0), rn(r, t.default, e.default);\n    }\n\n    ze.register(Or, {\n      error: [{\n        kind: \"error\"\n      }, [Kt], (t, [e]) => {\n        throw new be(e.evaluate(t));\n      }],\n      typeof: [Kt, [Jt], (t, [e]) => ne(ge(e.evaluate(t)))],\n      \"to-rgba\": [re(Xt, 4), [Ht], (t, [e]) => e.evaluate(t).toArray()],\n      rgb: [Ht, [Xt, Xt, Xt], qr],\n      rgba: [Ht, [Xt, Xt, Xt, Xt], qr],\n      has: {\n        type: Yt,\n        overloads: [[[Kt], (t, [e]) => Nr(e.evaluate(t), t.properties())], [[Kt, Wt], (t, [e, r]) => Nr(e.evaluate(t), r.evaluate(t))]]\n      },\n      get: {\n        type: Jt,\n        overloads: [[[Kt], (t, [e]) => Gr(e.evaluate(t), t.properties())], [[Kt, Wt], (t, [e, r]) => Gr(e.evaluate(t), r.evaluate(t))]]\n      },\n      \"feature-state\": [Jt, [Kt], (t, [e]) => Gr(e.evaluate(t), t.featureState || {})],\n      properties: [Wt, [], t => t.properties()],\n      \"geometry-type\": [Kt, [], t => t.geometryType()],\n      id: [Jt, [], t => t.id()],\n      zoom: [Xt, [], t => t.globals.zoom],\n      pitch: [Xt, [], t => t.globals.pitch || 0],\n      \"distance-from-center\": [Xt, [], t => t.distanceFromCenter()],\n      \"heatmap-density\": [Xt, [], t => t.globals.heatmapDensity || 0],\n      \"line-progress\": [Xt, [], t => t.globals.lineProgress || 0],\n      \"sky-radial-progress\": [Xt, [], t => t.globals.skyRadialProgress || 0],\n      accumulated: [Jt, [], t => void 0 === t.globals.accumulated ? null : t.globals.accumulated],\n      \"+\": [Xt, Zr(Xt), (t, e) => {\n        let r = 0;\n\n        for (const n of e) r += n.evaluate(t);\n\n        return r;\n      }],\n      \"*\": [Xt, Zr(Xt), (t, e) => {\n        let r = 1;\n\n        for (const n of e) r *= n.evaluate(t);\n\n        return r;\n      }],\n      \"-\": {\n        type: Xt,\n        overloads: [[[Xt, Xt], (t, [e, r]) => e.evaluate(t) - r.evaluate(t)], [[Xt], (t, [e]) => -e.evaluate(t)]]\n      },\n      \"/\": [Xt, [Xt, Xt], (t, [e, r]) => e.evaluate(t) / r.evaluate(t)],\n      \"%\": [Xt, [Xt, Xt], (t, [e, r]) => e.evaluate(t) % r.evaluate(t)],\n      ln2: [Xt, [], () => Math.LN2],\n      pi: [Xt, [], () => Math.PI],\n      e: [Xt, [], () => Math.E],\n      \"^\": [Xt, [Xt, Xt], (t, [e, r]) => Math.pow(e.evaluate(t), r.evaluate(t))],\n      sqrt: [Xt, [Xt], (t, [e]) => Math.sqrt(e.evaluate(t))],\n      log10: [Xt, [Xt], (t, [e]) => Math.log(e.evaluate(t)) / Math.LN10],\n      ln: [Xt, [Xt], (t, [e]) => Math.log(e.evaluate(t))],\n      log2: [Xt, [Xt], (t, [e]) => Math.log(e.evaluate(t)) / Math.LN2],\n      sin: [Xt, [Xt], (t, [e]) => Math.sin(e.evaluate(t))],\n      cos: [Xt, [Xt], (t, [e]) => Math.cos(e.evaluate(t))],\n      tan: [Xt, [Xt], (t, [e]) => Math.tan(e.evaluate(t))],\n      asin: [Xt, [Xt], (t, [e]) => Math.asin(e.evaluate(t))],\n      acos: [Xt, [Xt], (t, [e]) => Math.acos(e.evaluate(t))],\n      atan: [Xt, [Xt], (t, [e]) => Math.atan(e.evaluate(t))],\n      min: [Xt, Zr(Xt), (t, e) => Math.min(...e.map(e => e.evaluate(t)))],\n      max: [Xt, Zr(Xt), (t, e) => Math.max(...e.map(e => e.evaluate(t)))],\n      abs: [Xt, [Xt], (t, [e]) => Math.abs(e.evaluate(t))],\n      round: [Xt, [Xt], (t, [e]) => {\n        const r = e.evaluate(t);\n        return r < 0 ? -Math.round(-r) : Math.round(r);\n      }],\n      floor: [Xt, [Xt], (t, [e]) => Math.floor(e.evaluate(t))],\n      ceil: [Xt, [Xt], (t, [e]) => Math.ceil(e.evaluate(t))],\n      \"filter-==\": [Yt, [Kt, Jt], (t, [e, r]) => t.properties()[e.value] === r.value],\n      \"filter-id-==\": [Yt, [Jt], (t, [e]) => t.id() === e.value],\n      \"filter-type-==\": [Yt, [Kt], (t, [e]) => t.geometryType() === e.value],\n      \"filter-<\": [Yt, [Kt, Jt], (t, [e, r]) => {\n        const n = t.properties()[e.value],\n              i = r.value;\n        return typeof n == typeof i && n < i;\n      }],\n      \"filter-id-<\": [Yt, [Jt], (t, [e]) => {\n        const r = t.id(),\n              n = e.value;\n        return typeof r == typeof n && r < n;\n      }],\n      \"filter->\": [Yt, [Kt, Jt], (t, [e, r]) => {\n        const n = t.properties()[e.value],\n              i = r.value;\n        return typeof n == typeof i && n > i;\n      }],\n      \"filter-id->\": [Yt, [Jt], (t, [e]) => {\n        const r = t.id(),\n              n = e.value;\n        return typeof r == typeof n && r > n;\n      }],\n      \"filter-<=\": [Yt, [Kt, Jt], (t, [e, r]) => {\n        const n = t.properties()[e.value],\n              i = r.value;\n        return typeof n == typeof i && n <= i;\n      }],\n      \"filter-id-<=\": [Yt, [Jt], (t, [e]) => {\n        const r = t.id(),\n              n = e.value;\n        return typeof r == typeof n && r <= n;\n      }],\n      \"filter->=\": [Yt, [Kt, Jt], (t, [e, r]) => {\n        const n = t.properties()[e.value],\n              i = r.value;\n        return typeof n == typeof i && n >= i;\n      }],\n      \"filter-id->=\": [Yt, [Jt], (t, [e]) => {\n        const r = t.id(),\n              n = e.value;\n        return typeof r == typeof n && r >= n;\n      }],\n      \"filter-has\": [Yt, [Jt], (t, [e]) => e.value in t.properties()],\n      \"filter-has-id\": [Yt, [], t => null !== t.id() && void 0 !== t.id()],\n      \"filter-type-in\": [Yt, [re(Kt)], (t, [e]) => e.value.indexOf(t.geometryType()) >= 0],\n      \"filter-id-in\": [Yt, [re(Jt)], (t, [e]) => e.value.indexOf(t.id()) >= 0],\n      \"filter-in-small\": [Yt, [Kt, re(Jt)], (t, [e, r]) => r.value.indexOf(t.properties()[e.value]) >= 0],\n      \"filter-in-large\": [Yt, [Kt, re(Jt)], (t, [e, r]) => function (t, e, r, n) {\n        for (; r <= n;) {\n          const i = r + n >> 1;\n          if (e[i] === t) return !0;\n          e[i] > t ? n = i - 1 : r = i + 1;\n        }\n\n        return !1;\n      }(t.properties()[e.value], r.value, 0, r.value.length - 1)],\n      all: {\n        type: Yt,\n        overloads: [[[Yt, Yt], (t, [e, r]) => e.evaluate(t) && r.evaluate(t)], [Zr(Yt), (t, e) => {\n          for (const r of e) if (!r.evaluate(t)) return !1;\n\n          return !0;\n        }]]\n      },\n      any: {\n        type: Yt,\n        overloads: [[[Yt, Yt], (t, [e, r]) => e.evaluate(t) || r.evaluate(t)], [Zr(Yt), (t, e) => {\n          for (const r of e) if (r.evaluate(t)) return !0;\n\n          return !1;\n        }]]\n      },\n      \"!\": [Yt, [Yt], (t, [e]) => !e.evaluate(t)],\n      \"is-supported-script\": [Yt, [Kt], (t, [e]) => {\n        const r = t.globals && t.globals.isSupportedScript;\n        return !r || r(e.evaluate(t));\n      }],\n      upcase: [Kt, [Kt], (t, [e]) => e.evaluate(t).toUpperCase()],\n      downcase: [Kt, [Kt], (t, [e]) => e.evaluate(t).toLowerCase()],\n      concat: [Kt, Zr(Jt), (t, e) => e.map(e => xe(e.evaluate(t))).join(\"\")],\n      \"resolved-locale\": [Kt, [Qt], (t, [e]) => e.evaluate(t).resolvedLocale()]\n    });\n\n    class ln {\n      constructor(t, e) {\n        this.expression = t, this._warningHistory = {}, this._evaluator = new Te(), this._defaultValue = e ? function (t) {\n          return \"color\" === t.type && Qr(t.default) ? new ce(0, 0, 0, 0) : \"color\" === t.type ? ce.parse(t.default) || null : void 0 === t.default ? null : t.default;\n        }(e) : null, this._enumValues = e && \"enum\" === e.type ? e.values : null;\n      }\n\n      evaluateWithoutErrorHandling(t, e, r, n, i, s, a, o) {\n        return this._evaluator.globals = t, this._evaluator.feature = e, this._evaluator.featureState = r, this._evaluator.canonical = n || null, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = s, this._evaluator.featureTileCoord = a || null, this._evaluator.featureDistanceData = o || null, this.expression.evaluate(this._evaluator);\n      }\n\n      evaluate(t, e, r, n, i, s, a, o) {\n        this._evaluator.globals = t, this._evaluator.feature = e || null, this._evaluator.featureState = r || null, this._evaluator.canonical = n || null, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = s || null, this._evaluator.featureTileCoord = a || null, this._evaluator.featureDistanceData = o || null;\n\n        try {\n          const t = this.expression.evaluate(this._evaluator);\n          if (null == t || \"number\" == typeof t && t != t) return this._defaultValue;\n          if (this._enumValues && !(t in this._enumValues)) throw new be(`Expected value to be one of ${Object.keys(this._enumValues).map(t => JSON.stringify(t)).join(\", \")}, but found ${JSON.stringify(t)} instead.`);\n          return t;\n        } catch (t) {\n          return this._warningHistory[t.message] || (this._warningHistory[t.message] = !0, \"undefined\" != typeof console && console.warn(t.message)), this._defaultValue;\n        }\n      }\n\n    }\n\n    function un(t) {\n      return Array.isArray(t) && t.length > 0 && \"string\" == typeof t[0] && t[0] in Or;\n    }\n\n    function cn(t, e) {\n      const r = new Je(Or, [], e ? function (t) {\n        const e = {\n          color: Ht,\n          string: Kt,\n          number: Xt,\n          enum: Kt,\n          boolean: Yt,\n          formatted: te,\n          resolvedImage: ee\n        };\n        return \"array\" === t.type ? re(e[t.value] || Jt, t.length) : e[t.type];\n      }(e) : void 0),\n            n = r.parse(t, void 0, void 0, void 0, e && \"string\" === e.type ? {\n        typeAnnotation: \"coerce\"\n      } : void 0);\n      return n ? Xr(new ln(n, e)) : Kr(r.errors);\n    }\n\n    class hn {\n      constructor(t, e) {\n        this.kind = t, this._styleExpression = e, this.isStateDependent = \"constant\" !== t && !Ye(e.expression);\n      }\n\n      evaluateWithoutErrorHandling(t, e, r, n, i, s) {\n        return this._styleExpression.evaluateWithoutErrorHandling(t, e, r, n, i, s);\n      }\n\n      evaluate(t, e, r, n, i, s) {\n        return this._styleExpression.evaluate(t, e, r, n, i, s);\n      }\n\n    }\n\n    class pn {\n      constructor(t, e, r, n) {\n        this.kind = t, this.zoomStops = r, this._styleExpression = e, this.isStateDependent = \"camera\" !== t && !Ye(e.expression), this.interpolationType = n;\n      }\n\n      evaluateWithoutErrorHandling(t, e, r, n, i, s) {\n        return this._styleExpression.evaluateWithoutErrorHandling(t, e, r, n, i, s);\n      }\n\n      evaluate(t, e, r, n, i, s) {\n        return this._styleExpression.evaluate(t, e, r, n, i, s);\n      }\n\n      interpolationFactor(t, e, r) {\n        return this.interpolationType ? _r.interpolationFactor(this.interpolationType, t, e, r) : 0;\n      }\n\n    }\n\n    function fn(t, e) {\n      if (\"error\" === (t = cn(t, e)).result) return t;\n      const r = t.value.expression,\n            n = Ke(r);\n      if (!n && !Yr(e)) return Kr([new Nt(\"\", \"data expressions not supported\")]);\n      const i = He(r, [\"zoom\", \"pitch\", \"distance-from-center\"]);\n      if (!i && !Hr(e)) return Kr([new Nt(\"\", \"zoom expressions not supported\")]);\n      const s = yn(r);\n      return s || i ? s instanceof Nt ? Kr([s]) : s instanceof _r && !Wr(e) ? Kr([new Nt(\"\", '\"interpolate\" expressions cannot be used with this property')]) : Xr(s ? new pn(n ? \"camera\" : \"composite\", t.value, s.labels, s instanceof _r ? s.interpolation : void 0) : new hn(n ? \"constant\" : \"source\", t.value)) : Kr([new Nt(\"\", '\"zoom\" expression may only be used as input to a top-level \"step\" or \"interpolate\" expression.')]);\n    }\n\n    class dn {\n      constructor(t, e) {\n        this._parameters = t, this._specification = e, jt(this, en(this._parameters, this._specification));\n      }\n\n      static deserialize(t) {\n        return new dn(t._parameters, t._specification);\n      }\n\n      static serialize(t) {\n        return {\n          _parameters: t._parameters,\n          _specification: t._specification\n        };\n      }\n\n    }\n\n    function yn(t) {\n      let e = null;\n      if (t instanceof kr) e = yn(t.result);else if (t instanceof Ar) {\n        for (const r of t.args) if (e = yn(r), e) break;\n      } else (t instanceof er || t instanceof _r) && t.input instanceof ze && \"zoom\" === t.input.name && (e = t);\n      return e instanceof Nt || t.eachChild(t => {\n        const r = yn(t);\n        r instanceof Nt ? e = r : !e && r ? e = new Nt(\"\", '\"zoom\" expression may only be used as input to a top-level \"step\" or \"interpolate\" expression.') : e && r && e !== r && (e = new Nt(\"\", 'Only one zoom-based \"step\" or \"interpolate\" subexpression may be used in an expression.'));\n      }), e;\n    }\n\n    class mn {\n      constructor(t, e, r, n) {\n        this.message = (t ? `${t}: ` : \"\") + r, n && (this.identifier = n), null != e && e.__line__ && (this.line = e.__line__);\n      }\n\n    }\n\n    function gn(t) {\n      const e = t.key,\n            r = t.value,\n            n = t.valueSpec || {},\n            i = t.objectElementValidators || {},\n            s = t.style,\n            a = t.styleSpec;\n      let o = [];\n      const l = Jr(r);\n      if (\"object\" !== l) return [new mn(e, r, `object expected, ${l} found`)];\n\n      for (const t in r) {\n        const l = t.split(\".\")[0],\n              u = n[l] || n[\"*\"];\n        let c;\n        i[l] ? c = i[l] : n[l] ? c = Hn : i[\"*\"] ? c = i[\"*\"] : n[\"*\"] && (c = Hn), c ? o = o.concat(c({\n          key: (e ? `${e}.` : e) + t,\n          value: r[t],\n          valueSpec: u,\n          style: s,\n          styleSpec: a,\n          object: r,\n          objectKey: t\n        }, r)) : o.push(new mn(e, r[t], `unknown property \"${t}\"`));\n      }\n\n      for (const t in n) i[t] || n[t].required && void 0 === n[t].default && void 0 === r[t] && o.push(new mn(e, r, `missing required property \"${t}\"`));\n\n      return o;\n    }\n\n    function xn(t) {\n      const e = t.value,\n            r = t.valueSpec,\n            n = t.style,\n            i = t.styleSpec,\n            s = t.key,\n            a = t.arrayElementValidator || Hn;\n      if (\"array\" !== Jr(e)) return [new mn(s, e, `array expected, ${Jr(e)} found`)];\n      if (r.length && e.length !== r.length) return [new mn(s, e, `array length ${r.length} expected, length ${e.length} found`)];\n      if (r[\"min-length\"] && e.length < r[\"min-length\"]) return [new mn(s, e, `array length at least ${r[\"min-length\"]} expected, length ${e.length} found`)];\n      let o = {\n        type: r.value,\n        values: r.values,\n        minimum: r.minimum,\n        maximum: r.maximum,\n        function: void 0\n      };\n      i.$version < 7 && (o.function = r.function), \"object\" === Jr(r.value) && (o = r.value);\n      let l = [];\n\n      for (let t = 0; t < e.length; t++) l = l.concat(a({\n        array: e,\n        arrayIndex: t,\n        value: e[t],\n        valueSpec: o,\n        style: n,\n        styleSpec: i,\n        key: `${s}[${t}]`\n      }));\n\n      return l;\n    }\n\n    function vn(t) {\n      const e = t.key,\n            r = t.value,\n            n = t.valueSpec;\n      let i = Jr(r);\n      if (\"number\" === i && r != r && (i = \"NaN\"), \"number\" !== i) return [new mn(e, r, `number expected, ${i} found`)];\n\n      if (\"minimum\" in n) {\n        let i = n.minimum;\n        if (\"array\" === Jr(n.minimum) && (i = n.minimum[t.arrayIndex]), r < i) return [new mn(e, r, `${r} is less than the minimum value ${i}`)];\n      }\n\n      if (\"maximum\" in n) {\n        let i = n.maximum;\n        if (\"array\" === Jr(n.maximum) && (i = n.maximum[t.arrayIndex]), r > i) return [new mn(e, r, `${r} is greater than the maximum value ${i}`)];\n      }\n\n      return [];\n    }\n\n    function bn(t) {\n      const e = t.valueSpec,\n            r = Ot(t.value.type);\n      let n,\n          i,\n          s,\n          a = {};\n      const o = \"categorical\" !== r && void 0 === t.value.property,\n            l = !o,\n            u = \"array\" === Jr(t.value.stops) && \"array\" === Jr(t.value.stops[0]) && \"object\" === Jr(t.value.stops[0][0]),\n            c = gn({\n        key: t.key,\n        value: t.value,\n        valueSpec: t.styleSpec.function,\n        style: t.style,\n        styleSpec: t.styleSpec,\n        objectElementValidators: {\n          stops: function (t) {\n            if (\"identity\" === r) return [new mn(t.key, t.value, 'identity function may not have a \"stops\" property')];\n            let e = [];\n            const n = t.value;\n            return e = e.concat(xn({\n              key: t.key,\n              value: n,\n              valueSpec: t.valueSpec,\n              style: t.style,\n              styleSpec: t.styleSpec,\n              arrayElementValidator: h\n            })), \"array\" === Jr(n) && 0 === n.length && e.push(new mn(t.key, n, \"array must have at least one stop\")), e;\n          },\n          default: function (t) {\n            return Hn({\n              key: t.key,\n              value: t.value,\n              valueSpec: e,\n              style: t.style,\n              styleSpec: t.styleSpec\n            });\n          }\n        }\n      });\n      return \"identity\" === r && o && c.push(new mn(t.key, t.value, 'missing required property \"property\"')), \"identity\" === r || t.value.stops || c.push(new mn(t.key, t.value, 'missing required property \"stops\"')), \"exponential\" === r && t.valueSpec.expression && !Wr(t.valueSpec) && c.push(new mn(t.key, t.value, \"exponential functions not supported\")), t.styleSpec.$version >= 8 && (l && !Yr(t.valueSpec) ? c.push(new mn(t.key, t.value, \"property functions not supported\")) : o && !Hr(t.valueSpec) && c.push(new mn(t.key, t.value, \"zoom functions not supported\"))), \"categorical\" !== r && !u || void 0 !== t.value.property || c.push(new mn(t.key, t.value, '\"property\" property is required')), c;\n\n      function h(t) {\n        let r = [];\n        const n = t.value,\n              o = t.key;\n        if (\"array\" !== Jr(n)) return [new mn(o, n, `array expected, ${Jr(n)} found`)];\n        if (2 !== n.length) return [new mn(o, n, `array length 2 expected, length ${n.length} found`)];\n\n        if (u) {\n          if (\"object\" !== Jr(n[0])) return [new mn(o, n, `object expected, ${Jr(n[0])} found`)];\n          if (void 0 === n[0].zoom) return [new mn(o, n, \"object stop key must have zoom\")];\n          if (void 0 === n[0].value) return [new mn(o, n, \"object stop key must have value\")];\n          const e = Ot(n[0].zoom);\n          if (\"number\" != typeof e) return [new mn(o, n[0].zoom, \"stop zoom values must be numbers\")];\n          if (s && s > e) return [new mn(o, n[0].zoom, \"stop zoom values must appear in ascending order\")];\n          e !== s && (s = e, i = void 0, a = {}), r = r.concat(gn({\n            key: `${o}[0]`,\n            value: n[0],\n            valueSpec: {\n              zoom: {}\n            },\n            style: t.style,\n            styleSpec: t.styleSpec,\n            objectElementValidators: {\n              zoom: vn,\n              value: p\n            }\n          }));\n        } else r = r.concat(p({\n          key: `${o}[0]`,\n          value: n[0],\n          valueSpec: {},\n          style: t.style,\n          styleSpec: t.styleSpec\n        }, n));\n\n        return un(qt(n[1])) ? r.concat([new mn(`${o}[1]`, n[1], \"expressions are not allowed in function stops.\")]) : r.concat(Hn({\n          key: `${o}[1]`,\n          value: n[1],\n          valueSpec: e,\n          style: t.style,\n          styleSpec: t.styleSpec\n        }));\n      }\n\n      function p(t, s) {\n        const o = Jr(t.value),\n              l = Ot(t.value),\n              u = null !== t.value ? t.value : s;\n\n        if (n) {\n          if (o !== n) return [new mn(t.key, u, `${o} stop domain type must match previous stop domain type ${n}`)];\n        } else n = o;\n\n        if (\"number\" !== o && \"string\" !== o && \"boolean\" !== o && \"number\" != typeof l && \"string\" != typeof l && \"boolean\" != typeof l) return [new mn(t.key, u, \"stop domain value must be a number, string, or boolean\")];\n\n        if (\"number\" !== o && \"categorical\" !== r) {\n          let n = `number expected, ${o} found`;\n          return Yr(e) && void 0 === r && (n += '\\nIf you intended to use a categorical function, specify `\"type\": \"categorical\"`.'), [new mn(t.key, u, n)];\n        }\n\n        return \"categorical\" !== r || \"number\" !== o || \"number\" == typeof l && isFinite(l) && Math.floor(l) === l ? \"categorical\" !== r && \"number\" === o && \"number\" == typeof l && \"number\" == typeof i && void 0 !== i && l < i ? [new mn(t.key, u, \"stop domain values must appear in ascending order\")] : (i = l, \"categorical\" === r && l in a ? [new mn(t.key, u, \"stop domain values must be unique\")] : (a[l] = !0, [])) : [new mn(t.key, u, `integer expected, found ${String(l)}`)];\n      }\n    }\n\n    function _n(t) {\n      const e = (\"property\" === t.expressionContext ? fn : cn)(qt(t.value), t.valueSpec);\n      if (\"error\" === e.result) return e.value.map(e => new mn(`${t.key}${e.key}`, t.value, e.message));\n      const r = e.value.expression || e.value._styleExpression.expression;\n      if (\"property\" === t.expressionContext && \"text-font\" === t.propertyKey && !r.outputDefined()) return [new mn(t.key, t.value, `Invalid data expression for \"${t.propertyKey}\". Output values must be contained as literals within the expression.`)];\n      if (\"property\" === t.expressionContext && \"layout\" === t.propertyType && !Ye(r)) return [new mn(t.key, t.value, '\"feature-state\" data expressions are not supported with layout properties.')];\n      if (\"filter\" === t.expressionContext) return wn(r, t);\n\n      if (t.expressionContext && 0 === t.expressionContext.indexOf(\"cluster\")) {\n        if (!He(r, [\"zoom\", \"feature-state\"])) return [new mn(t.key, t.value, '\"zoom\" and \"feature-state\" expressions are not supported with cluster properties.')];\n        if (\"cluster-initial\" === t.expressionContext && !Ke(r)) return [new mn(t.key, t.value, \"Feature data expressions are not supported with initial expression part of cluster properties.\")];\n      }\n\n      return [];\n    }\n\n    function wn(t, e) {\n      const r = new Set([\"zoom\", \"feature-state\", \"pitch\", \"distance-from-center\"]);\n      if (e.valueSpec && e.valueSpec.expression) for (const t of e.valueSpec.expression.parameters) r.delete(t);\n      if (0 === r.size) return [];\n      const n = [];\n      return t instanceof ze && r.has(t.name) ? [new mn(e.key, e.value, `[\"${t.name}\"] expression is not supported in a filter for a ${e.object.type} layer with id: ${e.object.id}`)] : (t.eachChild(t => {\n        n.push(...wn(t, e));\n      }), n);\n    }\n\n    function An(t) {\n      const e = t.key,\n            r = t.value,\n            n = t.valueSpec,\n            i = [];\n      return Array.isArray(n.values) ? -1 === n.values.indexOf(Ot(r)) && i.push(new mn(e, r, `expected one of [${n.values.join(\", \")}], ${JSON.stringify(r)} found`)) : -1 === Object.keys(n.values).indexOf(Ot(r)) && i.push(new mn(e, r, `expected one of [${Object.keys(n.values).join(\", \")}], ${JSON.stringify(r)} found`)), i;\n    }\n\n    function kn(t) {\n      if (!0 === t || !1 === t) return !0;\n      if (!Array.isArray(t) || 0 === t.length) return !1;\n\n      switch (t[0]) {\n        case \"has\":\n          return t.length >= 2 && \"$id\" !== t[1] && \"$type\" !== t[1];\n\n        case \"in\":\n          return t.length >= 3 && (\"string\" != typeof t[1] || Array.isArray(t[2]));\n\n        case \"!in\":\n        case \"!has\":\n        case \"none\":\n          return !1;\n\n        case \"==\":\n        case \"!=\":\n        case \">\":\n        case \">=\":\n        case \"<\":\n        case \"<=\":\n          return 3 !== t.length || Array.isArray(t[1]) || Array.isArray(t[2]);\n\n        case \"any\":\n        case \"all\":\n          for (const e of t.slice(1)) if (!kn(e) && \"boolean\" != typeof e) return !1;\n\n          return !0;\n\n        default:\n          return !0;\n      }\n    }\n\n    function Sn(t, e = \"fill\") {\n      if (null == t) return {\n        filter: () => !0,\n        needGeometry: !1,\n        needFeature: !1\n      };\n      kn(t) || (t = Cn(t));\n      const r = t;\n      let n = !0;\n\n      try {\n        n = function (t) {\n          if (!Tn(t)) return t;\n          let e = qt(t);\n          return Mn(e), e = In(e), e;\n        }(r);\n      } catch (t) {\n        console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.\\nThis is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md\\nand paste the contents of this message in the report.\\nThank you!\\nFilter Expression:\\n${JSON.stringify(r, null, 2)}\\n        `);\n      }\n\n      const i = $t[`filter_${e}`],\n            s = cn(n, i);\n      let a = null;\n      if (\"error\" === s.result) throw new Error(s.value.map(t => `${t.key}: ${t.message}`).join(\", \"));\n\n      a = (t, e, r) => s.value.evaluate(t, e, {}, r);\n\n      let o = null,\n          l = null;\n\n      if (n !== r) {\n        const t = cn(r, i);\n        if (\"error\" === t.result) throw new Error(t.value.map(t => `${t.key}: ${t.message}`).join(\", \"));\n        o = (e, r, n, i, s) => t.value.evaluate(e, r, {}, n, void 0, void 0, i, s), l = !Ke(t.value.expression);\n      }\n\n      return a = a, {\n        filter: a,\n        dynamicFilter: o || void 0,\n        needGeometry: En(n),\n        needFeature: !!l\n      };\n    }\n\n    function In(t) {\n      if (!Array.isArray(t)) return t;\n\n      const e = function (t) {\n        if (zn.has(t[0])) for (let e = 1; e < t.length; e++) if (Tn(t[e])) return !0;\n        return t;\n      }(t);\n\n      return !0 === e ? e : e.map(t => In(t));\n    }\n\n    function Mn(t) {\n      let e = !1;\n      const r = [];\n\n      if (\"case\" === t[0]) {\n        for (let n = 1; n < t.length - 1; n += 2) e = e || Tn(t[n]), r.push(t[n + 1]);\n\n        r.push(t[t.length - 1]);\n      } else if (\"match\" === t[0]) {\n        e = e || Tn(t[1]);\n\n        for (let e = 2; e < t.length - 1; e += 2) r.push(t[e + 1]);\n\n        r.push(t[t.length - 1]);\n      } else if (\"step\" === t[0]) {\n        e = e || Tn(t[1]);\n\n        for (let e = 1; e < t.length - 1; e += 2) r.push(t[e + 1]);\n      }\n\n      e && (t.length = 0, t.push(\"any\", ...r));\n\n      for (let e = 1; e < t.length; e++) Mn(t[e]);\n    }\n\n    function Tn(t) {\n      if (!Array.isArray(t)) return !1;\n      if (\"pitch\" === (e = t[0]) || \"distance-from-center\" === e) return !0;\n      var e;\n\n      for (let e = 1; e < t.length; e++) if (Tn(t[e])) return !0;\n\n      return !1;\n    }\n\n    const zn = new Set([\"in\", \"==\", \"!=\", \">\", \">=\", \"<\", \"<=\", \"to-boolean\"]);\n\n    function Bn(t, e) {\n      return t < e ? -1 : t > e ? 1 : 0;\n    }\n\n    function En(t) {\n      if (!Array.isArray(t)) return !1;\n      if (\"within\" === t[0]) return !0;\n\n      for (let e = 1; e < t.length; e++) if (En(t[e])) return !0;\n\n      return !1;\n    }\n\n    function Cn(t) {\n      if (!t) return !0;\n      const e = t[0];\n      return t.length <= 1 ? \"any\" !== e : \"==\" === e ? Dn(t[1], t[2], \"==\") : \"!=\" === e ? Fn(Dn(t[1], t[2], \"==\")) : \"<\" === e || \">\" === e || \"<=\" === e || \">=\" === e ? Dn(t[1], t[2], e) : \"any\" === e ? (r = t.slice(1), [\"any\"].concat(r.map(Cn))) : \"all\" === e ? [\"all\"].concat(t.slice(1).map(Cn)) : \"none\" === e ? [\"all\"].concat(t.slice(1).map(Cn).map(Fn)) : \"in\" === e ? Pn(t[1], t.slice(2)) : \"!in\" === e ? Fn(Pn(t[1], t.slice(2))) : \"has\" === e ? Vn(t[1]) : \"!has\" === e ? Fn(Vn(t[1])) : \"within\" !== e || t;\n      var r;\n    }\n\n    function Dn(t, e, r) {\n      switch (t) {\n        case \"$type\":\n          return [`filter-type-${r}`, e];\n\n        case \"$id\":\n          return [`filter-id-${r}`, e];\n\n        default:\n          return [`filter-${r}`, t, e];\n      }\n    }\n\n    function Pn(t, e) {\n      if (0 === e.length) return !1;\n\n      switch (t) {\n        case \"$type\":\n          return [\"filter-type-in\", [\"literal\", e]];\n\n        case \"$id\":\n          return [\"filter-id-in\", [\"literal\", e]];\n\n        default:\n          return e.length > 200 && !e.some(t => typeof t != typeof e[0]) ? [\"filter-in-large\", t, [\"literal\", e.sort(Bn)]] : [\"filter-in-small\", t, [\"literal\", e]];\n      }\n    }\n\n    function Vn(t) {\n      switch (t) {\n        case \"$type\":\n          return !0;\n\n        case \"$id\":\n          return [\"filter-has-id\"];\n\n        default:\n          return [\"filter-has\", t];\n      }\n    }\n\n    function Fn(t) {\n      return [\"!\", t];\n    }\n\n    function Ln(t) {\n      return kn(qt(t.value)) ? _n(jt({}, t, {\n        expressionContext: \"filter\",\n        valueSpec: t.styleSpec[`filter_${t.layerType || \"fill\"}`]\n      })) : Rn(t);\n    }\n\n    function Rn(t) {\n      const e = t.value,\n            r = t.key;\n      if (\"array\" !== Jr(e)) return [new mn(r, e, `array expected, ${Jr(e)} found`)];\n      const n = t.styleSpec;\n      let i,\n          s = [];\n      if (e.length < 1) return [new mn(r, e, \"filter array must have at least 1 element\")];\n\n      switch (s = s.concat(An({\n        key: `${r}[0]`,\n        value: e[0],\n        valueSpec: n.filter_operator,\n        style: t.style,\n        styleSpec: t.styleSpec\n      })), Ot(e[0])) {\n        case \"<\":\n        case \"<=\":\n        case \">\":\n        case \">=\":\n          e.length >= 2 && \"$type\" === Ot(e[1]) && s.push(new mn(r, e, `\"$type\" cannot be use with operator \"${e[0]}\"`));\n\n        case \"==\":\n        case \"!=\":\n          3 !== e.length && s.push(new mn(r, e, `filter array for operator \"${e[0]}\" must have 3 elements`));\n\n        case \"in\":\n        case \"!in\":\n          e.length >= 2 && (i = Jr(e[1]), \"string\" !== i && s.push(new mn(`${r}[1]`, e[1], `string expected, ${i} found`)));\n\n          for (let a = 2; a < e.length; a++) i = Jr(e[a]), \"$type\" === Ot(e[1]) ? s = s.concat(An({\n            key: `${r}[${a}]`,\n            value: e[a],\n            valueSpec: n.geometry_type,\n            style: t.style,\n            styleSpec: t.styleSpec\n          })) : \"string\" !== i && \"number\" !== i && \"boolean\" !== i && s.push(new mn(`${r}[${a}]`, e[a], `string, number, or boolean expected, ${i} found`));\n\n          break;\n\n        case \"any\":\n        case \"all\":\n        case \"none\":\n          for (let n = 1; n < e.length; n++) s = s.concat(Rn({\n            key: `${r}[${n}]`,\n            value: e[n],\n            style: t.style,\n            styleSpec: t.styleSpec\n          }));\n\n          break;\n\n        case \"has\":\n        case \"!has\":\n          i = Jr(e[1]), 2 !== e.length ? s.push(new mn(r, e, `filter array for \"${e[0]}\" operator must have 2 elements`)) : \"string\" !== i && s.push(new mn(`${r}[1]`, e[1], `string expected, ${i} found`));\n          break;\n\n        case \"within\":\n          i = Jr(e[1]), 2 !== e.length ? s.push(new mn(r, e, `filter array for \"${e[0]}\" operator must have 2 elements`)) : \"object\" !== i && s.push(new mn(`${r}[1]`, e[1], `object expected, ${i} found`));\n      }\n\n      return s;\n    }\n\n    function Un(t, e) {\n      const r = t.key,\n            n = t.style,\n            i = t.styleSpec,\n            s = t.value,\n            a = t.objectKey,\n            o = i[`${e}_${t.layerType}`];\n      if (!o) return [];\n      const l = a.match(/^(.*)-transition$/);\n      if (\"paint\" === e && l && o[l[1]] && o[l[1]].transition) return Hn({\n        key: r,\n        value: s,\n        valueSpec: i.transition,\n        style: n,\n        styleSpec: i\n      });\n      const u = t.valueSpec || o[a];\n      if (!u) return [new mn(r, s, `unknown property \"${a}\"`)];\n      let c;\n      if (\"string\" === Jr(s) && Yr(u) && !u.tokens && (c = /^{([^}]+)}$/.exec(s))) return [new mn(r, s, `\"${a}\" does not support interpolation syntax\\nUse an identity property function instead: \\`{ \"type\": \"identity\", \"property\": ${JSON.stringify(c[1])} }\\`.`)];\n      const h = [];\n      return \"symbol\" === t.layerType && (\"text-field\" === a && n && !n.glyphs && h.push(new mn(r, s, 'use of \"text-field\" requires a style \"glyphs\" property')), \"text-font\" === a && Qr(qt(s)) && \"identity\" === Ot(s.type) && h.push(new mn(r, s, '\"text-font\" does not support identity functions'))), h.concat(Hn({\n        key: t.key,\n        value: s,\n        valueSpec: u,\n        style: n,\n        styleSpec: i,\n        expressionContext: \"property\",\n        propertyType: e,\n        propertyKey: a\n      }));\n    }\n\n    function $n(t) {\n      return Un(t, \"paint\");\n    }\n\n    function jn(t) {\n      return Un(t, \"layout\");\n    }\n\n    function On(t) {\n      let e = [];\n      const r = t.value,\n            n = t.key,\n            i = t.style,\n            s = t.styleSpec;\n      r.type || r.ref || e.push(new mn(n, r, 'either \"type\" or \"ref\" is required'));\n      let a = Ot(r.type);\n      const o = Ot(r.ref);\n\n      if (r.id) {\n        const s = Ot(r.id);\n\n        for (let a = 0; a < t.arrayIndex; a++) {\n          const t = i.layers[a];\n          Ot(t.id) === s && e.push(new mn(n, r.id, `duplicate layer id \"${r.id}\", previously used at line ${t.id.__line__}`));\n        }\n      }\n\n      if (\"ref\" in r) {\n        let t;\n        [\"type\", \"source\", \"source-layer\", \"filter\", \"layout\"].forEach(t => {\n          t in r && e.push(new mn(n, r[t], `\"${t}\" is prohibited for ref layers`));\n        }), i.layers.forEach(e => {\n          Ot(e.id) === o && (t = e);\n        }), t ? t.ref ? e.push(new mn(n, r.ref, \"ref cannot reference another ref layer\")) : a = Ot(t.type) : \"string\" == typeof o && e.push(new mn(n, r.ref, `ref layer \"${o}\" not found`));\n      } else if (\"background\" !== a && \"sky\" !== a) if (r.source) {\n        const t = i.sources && i.sources[r.source],\n              s = t && Ot(t.type);\n        t ? \"vector\" === s && \"raster\" === a ? e.push(new mn(n, r.source, `layer \"${r.id}\" requires a raster source`)) : \"raster\" === s && \"raster\" !== a ? e.push(new mn(n, r.source, `layer \"${r.id}\" requires a vector source`)) : \"vector\" !== s || r[\"source-layer\"] ? \"raster-dem\" === s && \"hillshade\" !== a ? e.push(new mn(n, r.source, \"raster-dem source can only be used with layer type 'hillshade'.\")) : \"line\" !== a || !r.paint || !r.paint[\"line-gradient\"] || \"geojson\" === s && t.lineMetrics || e.push(new mn(n, r, `layer \"${r.id}\" specifies a line-gradient, which requires a GeoJSON source with \\`lineMetrics\\` enabled.`)) : e.push(new mn(n, r, `layer \"${r.id}\" must specify a \"source-layer\"`)) : e.push(new mn(n, r.source, `source \"${r.source}\" not found`));\n      } else e.push(new mn(n, r, 'missing required property \"source\"'));\n\n      return e = e.concat(gn({\n        key: n,\n        value: r,\n        valueSpec: s.layer,\n        style: t.style,\n        styleSpec: t.styleSpec,\n        objectElementValidators: {\n          \"*\": () => [],\n          type: () => Hn({\n            key: `${n}.type`,\n            value: r.type,\n            valueSpec: s.layer.type,\n            style: t.style,\n            styleSpec: t.styleSpec,\n            object: r,\n            objectKey: \"type\"\n          }),\n          filter: t => Ln(jt({\n            layerType: a\n          }, t)),\n          layout: t => gn({\n            layer: r,\n            key: t.key,\n            value: t.value,\n            valueSpec: {},\n            style: t.style,\n            styleSpec: t.styleSpec,\n            objectElementValidators: {\n              \"*\": t => jn(jt({\n                layerType: a\n              }, t))\n            }\n          }),\n          paint: t => gn({\n            layer: r,\n            key: t.key,\n            value: t.value,\n            valueSpec: {},\n            style: t.style,\n            styleSpec: t.styleSpec,\n            objectElementValidators: {\n              \"*\": t => $n(jt({\n                layerType: a\n              }, t))\n            }\n          })\n        }\n      })), e;\n    }\n\n    function qn(t) {\n      const e = t.value,\n            r = t.key,\n            n = Jr(e);\n      return \"string\" !== n ? [new mn(r, e, `string expected, ${n} found`)] : [];\n    }\n\n    const Nn = {\n      promoteId: function ({\n        key: t,\n        value: e\n      }) {\n        if (\"string\" === Jr(e)) return qn({\n          key: t,\n          value: e\n        });\n        {\n          const r = [];\n\n          for (const n in e) r.push(...qn({\n            key: `${t}.${n}`,\n            value: e[n]\n          }));\n\n          return r;\n        }\n      }\n    };\n\n    function Gn(t) {\n      const e = t.value,\n            r = t.key,\n            n = t.styleSpec,\n            i = t.style;\n      if (!e.type) return [new mn(r, e, '\"type\" is required')];\n      const s = Ot(e.type);\n      let a;\n\n      switch (s) {\n        case \"vector\":\n        case \"raster\":\n        case \"raster-dem\":\n          return a = gn({\n            key: r,\n            value: e,\n            valueSpec: n[`source_${s.replace(\"-\", \"_\")}`],\n            style: t.style,\n            styleSpec: n,\n            objectElementValidators: Nn\n          }), a;\n\n        case \"geojson\":\n          if (a = gn({\n            key: r,\n            value: e,\n            valueSpec: n.source_geojson,\n            style: i,\n            styleSpec: n,\n            objectElementValidators: Nn\n          }), e.cluster) for (const t in e.clusterProperties) {\n            const [n, i] = e.clusterProperties[t],\n                  s = \"string\" == typeof n ? [n, [\"accumulated\"], [\"get\", t]] : n;\n            a.push(..._n({\n              key: `${r}.${t}.map`,\n              value: i,\n              expressionContext: \"cluster-map\"\n            })), a.push(..._n({\n              key: `${r}.${t}.reduce`,\n              value: s,\n              expressionContext: \"cluster-reduce\"\n            }));\n          }\n          return a;\n\n        case \"video\":\n          return gn({\n            key: r,\n            value: e,\n            valueSpec: n.source_video,\n            style: i,\n            styleSpec: n\n          });\n\n        case \"image\":\n          return gn({\n            key: r,\n            value: e,\n            valueSpec: n.source_image,\n            style: i,\n            styleSpec: n\n          });\n\n        case \"canvas\":\n          return [new mn(r, null, \"Please use runtime APIs to add canvas sources, rather than including them in stylesheets.\", \"source.canvas\")];\n\n        default:\n          return An({\n            key: `${r}.type`,\n            value: e.type,\n            valueSpec: {\n              values: [\"vector\", \"raster\", \"raster-dem\", \"geojson\", \"video\", \"image\"]\n            },\n            style: i,\n            styleSpec: n\n          });\n      }\n    }\n\n    function Zn(t) {\n      const e = t.value,\n            r = t.styleSpec,\n            n = r.light,\n            i = t.style;\n      let s = [];\n      const a = Jr(e);\n      if (void 0 === e) return s;\n      if (\"object\" !== a) return s = s.concat([new mn(\"light\", e, `object expected, ${a} found`)]), s;\n\n      for (const t in e) {\n        const a = t.match(/^(.*)-transition$/);\n        s = s.concat(a && n[a[1]] && n[a[1]].transition ? Hn({\n          key: t,\n          value: e[t],\n          valueSpec: r.transition,\n          style: i,\n          styleSpec: r\n        }) : n[t] ? Hn({\n          key: t,\n          value: e[t],\n          valueSpec: n[t],\n          style: i,\n          styleSpec: r\n        }) : [new mn(t, e[t], `unknown property \"${t}\"`)]);\n      }\n\n      return s;\n    }\n\n    function Xn(t) {\n      const e = t.value,\n            r = t.key,\n            n = t.style,\n            i = t.styleSpec,\n            s = i.terrain;\n      let a = [];\n      const o = Jr(e);\n      if (void 0 === e) return a;\n      if (\"object\" !== o) return a = a.concat([new mn(\"terrain\", e, `object expected, ${o} found`)]), a;\n\n      for (const t in e) {\n        const r = t.match(/^(.*)-transition$/);\n        a = a.concat(r && s[r[1]] && s[r[1]].transition ? Hn({\n          key: t,\n          value: e[t],\n          valueSpec: i.transition,\n          style: n,\n          styleSpec: i\n        }) : s[t] ? Hn({\n          key: t,\n          value: e[t],\n          valueSpec: s[t],\n          style: n,\n          styleSpec: i\n        }) : [new mn(t, e[t], `unknown property \"${t}\"`)]);\n      }\n\n      if (e.source) {\n        const t = n.sources && n.sources[e.source],\n              i = t && Ot(t.type);\n        t ? \"raster-dem\" !== i && a.push(new mn(r, e.source, `terrain cannot be used with a source of type ${String(i)}, it only be used with a \"raster-dem\" source type`)) : a.push(new mn(r, e.source, `source \"${e.source}\" not found`));\n      } else a.push(new mn(r, e, 'terrain is missing required property \"source\"'));\n\n      return a;\n    }\n\n    function Kn(t) {\n      const e = t.value,\n            r = t.style,\n            n = t.styleSpec,\n            i = n.fog;\n      let s = [];\n      const a = Jr(e);\n      if (void 0 === e) return s;\n      if (\"object\" !== a) return s = s.concat([new mn(\"fog\", e, `object expected, ${a} found`)]), s;\n\n      for (const t in e) {\n        const a = t.match(/^(.*)-transition$/);\n        s = s.concat(a && i[a[1]] && i[a[1]].transition ? Hn({\n          key: t,\n          value: e[t],\n          valueSpec: n.transition,\n          style: r,\n          styleSpec: n\n        }) : i[t] ? Hn({\n          key: t,\n          value: e[t],\n          valueSpec: i[t],\n          style: r,\n          styleSpec: n\n        }) : [new mn(t, e[t], `unknown property \"${t}\"`)]);\n      }\n\n      return s;\n    }\n\n    const Yn = {\n      \"*\": () => [],\n      array: xn,\n      boolean: function (t) {\n        const e = t.value,\n              r = t.key,\n              n = Jr(e);\n        return \"boolean\" !== n ? [new mn(r, e, `boolean expected, ${n} found`)] : [];\n      },\n      number: vn,\n      color: function (t) {\n        const e = t.key,\n              r = t.value,\n              n = Jr(r);\n        return \"string\" !== n ? [new mn(e, r, `color expected, ${n} found`)] : null === ue.parseCSSColor(r) ? [new mn(e, r, `color expected, \"${r}\" found`)] : [];\n      },\n      enum: An,\n      filter: Ln,\n      function: bn,\n      layer: On,\n      object: gn,\n      source: Gn,\n      light: Zn,\n      terrain: Xn,\n      fog: Kn,\n      string: qn,\n      formatted: function (t) {\n        return 0 === qn(t).length ? [] : _n(t);\n      },\n      resolvedImage: function (t) {\n        return 0 === qn(t).length ? [] : _n(t);\n      },\n      projection: function (t) {\n        const e = t.value,\n              r = t.styleSpec,\n              n = r.projection,\n              i = t.style;\n        let s = [];\n        const a = Jr(e);\n        if (\"object\" === a) for (const t in e) s = s.concat(Hn({\n          key: t,\n          value: e[t],\n          valueSpec: n[t],\n          style: i,\n          styleSpec: r\n        }));else \"string\" !== a && (s = s.concat([new mn(\"projection\", e, `object or string expected, ${a} found`)]));\n        return s;\n      }\n    };\n\n    function Hn(t) {\n      const e = t.value,\n            r = t.valueSpec,\n            n = t.styleSpec;\n      return r.expression && Qr(Ot(e)) ? bn(t) : r.expression && un(qt(e)) ? _n(t) : r.type && Yn[r.type] ? Yn[r.type](t) : gn(jt({}, t, {\n        valueSpec: r.type ? n[r.type] : r\n      }));\n    }\n\n    function Wn(t) {\n      const e = t.value,\n            r = t.key,\n            n = qn(t);\n      return n.length || (-1 === e.indexOf(\"{fontstack}\") && n.push(new mn(r, e, '\"glyphs\" url must include a \"{fontstack}\" token')), -1 === e.indexOf(\"{range}\") && n.push(new mn(r, e, '\"glyphs\" url must include a \"{range}\" token'))), n;\n    }\n\n    function Jn(t, e = $t) {\n      return ei(Hn({\n        key: \"\",\n        value: t,\n        valueSpec: e.$root,\n        styleSpec: e,\n        style: t,\n        objectElementValidators: {\n          glyphs: Wn,\n          \"*\": () => []\n        }\n      }));\n    }\n\n    const Qn = t => ei($n(t)),\n          ti = t => ei(jn(t));\n\n    function ei(t) {\n      return t.slice().sort((t, e) => t.line && e.line ? t.line - e.line : 0);\n    }\n\n    function ri(t, e) {\n      let r = !1;\n      if (e && e.length) for (const n of e) t.fire(new Rt(new Error(n.message))), r = !0;\n      return r;\n    }\n\n    var ni = ii;\n\n    function ii(t, e, r) {\n      var n = this.cells = [];\n\n      if (t instanceof ArrayBuffer) {\n        this.arrayBuffer = t;\n        var i = new Int32Array(this.arrayBuffer);\n        t = i[0], this.d = (e = i[1]) + 2 * (r = i[2]);\n\n        for (var s = 0; s < this.d * this.d; s++) {\n          var a = i[3 + s],\n              o = i[3 + s + 1];\n          n.push(a === o ? null : i.subarray(a, o));\n        }\n\n        var l = i[3 + n.length + 1];\n        this.keys = i.subarray(i[3 + n.length], l), this.bboxes = i.subarray(l), this.insert = this._insertReadonly;\n      } else {\n        this.d = e + 2 * r;\n\n        for (var u = 0; u < this.d * this.d; u++) n.push([]);\n\n        this.keys = [], this.bboxes = [];\n      }\n\n      this.n = e, this.extent = t, this.padding = r, this.scale = e / t, this.uid = 0;\n      var c = r / e * t;\n      this.min = -c, this.max = t + c;\n    }\n\n    ii.prototype.insert = function (t, e, r, n, i) {\n      this._forEachCell(e, r, n, i, this._insertCell, this.uid++), this.keys.push(t), this.bboxes.push(e), this.bboxes.push(r), this.bboxes.push(n), this.bboxes.push(i);\n    }, ii.prototype._insertReadonly = function () {\n      throw \"Cannot insert into a GridIndex created from an ArrayBuffer.\";\n    }, ii.prototype._insertCell = function (t, e, r, n, i, s) {\n      this.cells[i].push(s);\n    }, ii.prototype.query = function (t, e, r, n, i) {\n      var s = this.min,\n          a = this.max;\n      if (t <= s && e <= s && a <= r && a <= n && !i) return Array.prototype.slice.call(this.keys);\n      var o = [];\n      return this._forEachCell(t, e, r, n, this._queryCell, o, {}, i), o;\n    }, ii.prototype._queryCell = function (t, e, r, n, i, s, a, o) {\n      var l = this.cells[i];\n      if (null !== l) for (var u = this.keys, c = this.bboxes, h = 0; h < l.length; h++) {\n        var p = l[h];\n\n        if (void 0 === a[p]) {\n          var f = 4 * p;\n          (o ? o(c[f + 0], c[f + 1], c[f + 2], c[f + 3]) : t <= c[f + 2] && e <= c[f + 3] && r >= c[f + 0] && n >= c[f + 1]) ? (a[p] = !0, s.push(u[p])) : a[p] = !1;\n        }\n      }\n    }, ii.prototype._forEachCell = function (t, e, r, n, i, s, a, o) {\n      for (var l = this._convertToCellCoord(t), u = this._convertToCellCoord(e), c = this._convertToCellCoord(r), h = this._convertToCellCoord(n), p = l; p <= c; p++) for (var f = u; f <= h; f++) {\n        var d = this.d * f + p;\n        if ((!o || o(this._convertFromCellCoord(p), this._convertFromCellCoord(f), this._convertFromCellCoord(p + 1), this._convertFromCellCoord(f + 1))) && i.call(this, t, e, r, n, d, s, a, o)) return;\n      }\n    }, ii.prototype._convertFromCellCoord = function (t) {\n      return (t - this.padding) / this.scale;\n    }, ii.prototype._convertToCellCoord = function (t) {\n      return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding));\n    }, ii.prototype.toArrayBuffer = function () {\n      if (this.arrayBuffer) return this.arrayBuffer;\n\n      for (var t = this.cells, e = 3 + this.cells.length + 1 + 1, r = 0, n = 0; n < this.cells.length; n++) r += this.cells[n].length;\n\n      var i = new Int32Array(e + r + this.keys.length + this.bboxes.length);\n      i[0] = this.extent, i[1] = this.n, i[2] = this.padding;\n\n      for (var s = e, a = 0; a < t.length; a++) {\n        var o = t[a];\n        i[3 + a] = s, i.set(o, s), s += o.length;\n      }\n\n      return i[3 + t.length] = s, i.set(this.keys, s), i[3 + t.length + 1] = s += this.keys.length, i.set(this.bboxes, s), s += this.bboxes.length, i.buffer;\n    };\n    const si = {};\n\n    function ai(t, e = {}) {\n      si[t.name] = {\n        klass: t,\n        omit: e.omit || []\n      };\n    }\n\n    ai(Object), ni.serialize = function (t, e) {\n      const r = t.toArrayBuffer();\n      return e && e.push(r), {\n        buffer: r\n      };\n    }, ni.deserialize = function (t) {\n      return new ni(t.buffer);\n    }, ai(ni), ai(ce), ai(Error), ai(kt), ai(de), ai(dn), ai(ln, {\n      omit: [\"_evaluator\"]\n    }), ai(pn), ai(hn), ai(ze, {\n      omit: [\"_evaluate\"]\n    });\n\n    for (const t in Or) si[Or[t].name] || ai(Or[t]);\n\n    function oi(t) {\n      return t && \"undefined\" != typeof ArrayBuffer && (t instanceof ArrayBuffer || t.constructor && \"ArrayBuffer\" === t.constructor.name);\n    }\n\n    function li(t) {\n      return a.ImageBitmap && t instanceof a.ImageBitmap;\n    }\n\n    function ui(t, e) {\n      if (null == t || \"boolean\" == typeof t || \"number\" == typeof t || \"string\" == typeof t || t instanceof Boolean || t instanceof Number || t instanceof String || t instanceof Date || t instanceof RegExp) return t;\n      if (oi(t) || li(t)) return e && e.push(t), t;\n\n      if (ArrayBuffer.isView(t)) {\n        const r = t;\n        return e && e.push(r.buffer), r;\n      }\n\n      if (t instanceof a.ImageData) return e && e.push(t.data.buffer), t;\n\n      if (Array.isArray(t)) {\n        const r = [];\n\n        for (const n of t) r.push(ui(n, e));\n\n        return r;\n      }\n\n      if (\"object\" == typeof t) {\n        const r = t.constructor,\n              n = r.name;\n        if (!si[n]) throw new Error(`can't serialize object of unregistered class ${n}`);\n        const i = r.serialize ? r.serialize(t, e) : {};\n\n        if (!r.serialize) {\n          for (const r in t) t.hasOwnProperty(r) && (si[n].omit.indexOf(r) >= 0 || (i[r] = ui(t[r], e)));\n\n          t instanceof Error && (i.message = t.message);\n        }\n\n        if (i.$name) throw new Error(\"$name property is reserved for worker serialization logic.\");\n        return \"Object\" !== n && (i.$name = n), i;\n      }\n\n      throw new Error(\"can't serialize object of type \" + typeof t);\n    }\n\n    function ci(t) {\n      if (null == t || \"boolean\" == typeof t || \"number\" == typeof t || \"string\" == typeof t || t instanceof Boolean || t instanceof Number || t instanceof String || t instanceof Date || t instanceof RegExp || oi(t) || li(t) || ArrayBuffer.isView(t) || t instanceof a.ImageData) return t;\n      if (Array.isArray(t)) return t.map(ci);\n\n      if (\"object\" == typeof t) {\n        const e = t.$name || \"Object\",\n              {\n          klass: r\n        } = si[e];\n        if (!r) throw new Error(`can't deserialize unregistered class ${e}`);\n        if (r.deserialize) return r.deserialize(t);\n        const n = Object.create(r.prototype);\n\n        for (const e of Object.keys(t)) \"$name\" !== e && (n[e] = ci(t[e]));\n\n        return n;\n      }\n\n      throw new Error(\"can't deserialize object of type \" + typeof t);\n    }\n\n    class hi {\n      constructor() {\n        this.first = !0;\n      }\n\n      update(t, e) {\n        const r = Math.floor(t);\n        return this.first ? (this.first = !1, this.lastIntegerZoom = r, this.lastIntegerZoomTime = 0, this.lastZoom = t, this.lastFloorZoom = r, !0) : (this.lastFloorZoom > r ? (this.lastIntegerZoom = r + 1, this.lastIntegerZoomTime = e) : this.lastFloorZoom < r && (this.lastIntegerZoom = r, this.lastIntegerZoomTime = e), t !== this.lastZoom && (this.lastZoom = t, this.lastFloorZoom = r, !0));\n      }\n\n    }\n\n    const pi = t => t >= 1536 && t <= 1791,\n          fi = t => t >= 1872 && t <= 1919,\n          di = t => t >= 2208 && t <= 2303,\n          yi = t => t >= 11904 && t <= 12031,\n          mi = t => t >= 12032 && t <= 12255,\n          gi = t => t >= 12272 && t <= 12287,\n          xi = t => t >= 12288 && t <= 12351,\n          vi = t => t >= 12352 && t <= 12447,\n          bi = t => t >= 12448 && t <= 12543,\n          _i = t => t >= 12544 && t <= 12591,\n          wi = t => t >= 12704 && t <= 12735,\n          Ai = t => t >= 12736 && t <= 12783,\n          ki = t => t >= 12784 && t <= 12799,\n          Si = t => t >= 12800 && t <= 13055,\n          Ii = t => t >= 13056 && t <= 13311,\n          Mi = t => t >= 13312 && t <= 19903,\n          Ti = t => t >= 19968 && t <= 40959,\n          zi = t => t >= 40960 && t <= 42127,\n          Bi = t => t >= 42128 && t <= 42191,\n          Ei = t => t >= 44032 && t <= 55215,\n          Ci = t => t >= 63744 && t <= 64255,\n          Di = t => t >= 64336 && t <= 65023,\n          Pi = t => t >= 65040 && t <= 65055,\n          Vi = t => t >= 65072 && t <= 65103,\n          Fi = t => t >= 65104 && t <= 65135,\n          Li = t => t >= 65136 && t <= 65279,\n          Ri = t => t >= 65280 && t <= 65519;\n\n    function Ui(t) {\n      for (const e of t) if (Oi(e.charCodeAt(0))) return !0;\n\n      return !1;\n    }\n\n    function $i(t) {\n      for (const e of t) if (!ji(e.charCodeAt(0))) return !1;\n\n      return !0;\n    }\n\n    function ji(t) {\n      return !(pi(t) || fi(t) || di(t) || Di(t) || Li(t));\n    }\n\n    function Oi(t) {\n      return !(746 !== t && 747 !== t && (t < 4352 || !(wi(t) || _i(t) || Vi(t) && !(t >= 65097 && t <= 65103) || Ci(t) || Ii(t) || yi(t) || Ai(t) || !(!xi(t) || t >= 12296 && t <= 12305 || t >= 12308 && t <= 12319 || 12336 === t) || Mi(t) || Ti(t) || Si(t) || (t => t >= 12592 && t <= 12687)(t) || (t => t >= 43360 && t <= 43391)(t) || (t => t >= 55216 && t <= 55295)(t) || (t => t >= 4352 && t <= 4607)(t) || Ei(t) || vi(t) || gi(t) || (t => t >= 12688 && t <= 12703)(t) || mi(t) || ki(t) || bi(t) && 12540 !== t || !(!Ri(t) || 65288 === t || 65289 === t || 65293 === t || t >= 65306 && t <= 65310 || 65339 === t || 65341 === t || 65343 === t || t >= 65371 && t <= 65503 || 65507 === t || t >= 65512 && t <= 65519) || !(!Fi(t) || t >= 65112 && t <= 65118 || t >= 65123 && t <= 65126) || (t => t >= 5120 && t <= 5759)(t) || (t => t >= 6320 && t <= 6399)(t) || Pi(t) || (t => t >= 19904 && t <= 19967)(t) || zi(t) || Bi(t))));\n    }\n\n    function qi(t) {\n      return !(Oi(t) || function (t) {\n        return !!((t => t >= 128 && t <= 255)(t) && (167 === t || 169 === t || 174 === t || 177 === t || 188 === t || 189 === t || 190 === t || 215 === t || 247 === t) || (t => t >= 8192 && t <= 8303)(t) && (8214 === t || 8224 === t || 8225 === t || 8240 === t || 8241 === t || 8251 === t || 8252 === t || 8258 === t || 8263 === t || 8264 === t || 8265 === t || 8273 === t) || (t => t >= 8448 && t <= 8527)(t) || (t => t >= 8528 && t <= 8591)(t) || (t => t >= 8960 && t <= 9215)(t) && (t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || 9003 === t || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || 9167 === t || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215) || (t => t >= 9216 && t <= 9279)(t) && 9251 !== t || (t => t >= 9280 && t <= 9311)(t) || (t => t >= 9312 && t <= 9471)(t) || (t => t >= 9632 && t <= 9727)(t) || (t => t >= 9728 && t <= 9983)(t) && !(t >= 9754 && t <= 9759) || (t => t >= 11008 && t <= 11263)(t) && (t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243) || xi(t) || bi(t) || (t => t >= 57344 && t <= 63743)(t) || Vi(t) || Fi(t) || Ri(t) || 8734 === t || 8756 === t || 8757 === t || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || 65532 === t || 65533 === t);\n      }(t));\n    }\n\n    function Ni(t) {\n      return t >= 1424 && t <= 2303 || Di(t) || Li(t);\n    }\n\n    function Gi(t, e) {\n      return !(!e && Ni(t) || t >= 2304 && t <= 3583 || t >= 3840 && t <= 4255 || (t => t >= 6016 && t <= 6143)(t));\n    }\n\n    function Zi(t) {\n      for (const e of t) if (Ni(e.charCodeAt(0))) return !0;\n\n      return !1;\n    }\n\n    const Xi = \"deferred\",\n          Ki = \"loading\",\n          Yi = \"loaded\";\n    let Hi = null,\n        Wi = \"unavailable\",\n        Ji = null;\n\n    const Qi = function (t) {\n      t && \"string\" == typeof t && t.indexOf(\"NetworkError\") > -1 && (Wi = \"error\"), Hi && Hi(t);\n    };\n\n    function ts() {\n      es.fire(new Lt(\"pluginStateChange\", {\n        pluginStatus: Wi,\n        pluginURL: Ji\n      }));\n    }\n\n    const es = new Ut(),\n          rs = function () {\n      return Wi;\n    },\n          ns = function () {\n      if (Wi !== Xi || !Ji) throw new Error(\"rtl-text-plugin cannot be downloaded unless a pluginURL is specified\");\n      Wi = Ki, ts(), Ji && Mt({\n        url: Ji\n      }, t => {\n        t ? Qi(t) : (Wi = Yi, ts());\n      });\n    },\n          is = {\n      applyArabicShaping: null,\n      processBidirectionalText: null,\n      processStyledBidirectionalText: null,\n      isLoaded: () => Wi === Yi || null != is.applyArabicShaping,\n      isLoading: () => Wi === Ki,\n\n      setState(t) {\n        Wi = t.pluginStatus, Ji = t.pluginURL;\n      },\n\n      isParsed: () => null != is.applyArabicShaping && null != is.processBidirectionalText && null != is.processStyledBidirectionalText,\n      getPluginURL: () => Ji\n    };\n\n    class ss {\n      constructor(t, e) {\n        this.zoom = t, e ? (this.now = e.now, this.fadeDuration = e.fadeDuration, this.zoomHistory = e.zoomHistory, this.transition = e.transition, this.pitch = e.pitch) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new hi(), this.transition = {}, this.pitch = 0);\n      }\n\n      isSupportedScript(t) {\n        return function (t, e) {\n          for (const r of t) if (!Gi(r.charCodeAt(0), e)) return !1;\n\n          return !0;\n        }(t, is.isLoaded());\n      }\n\n      crossFadingFactor() {\n        return 0 === this.fadeDuration ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);\n      }\n\n      getCrossfadeParameters() {\n        const t = this.zoom,\n              e = t - Math.floor(t),\n              r = this.crossFadingFactor();\n        return t > this.zoomHistory.lastIntegerZoom ? {\n          fromScale: 2,\n          toScale: 1,\n          t: e + (1 - e) * r\n        } : {\n          fromScale: .5,\n          toScale: 1,\n          t: 1 - (1 - r) * e\n        };\n      }\n\n    }\n\n    class as {\n      constructor(t, e) {\n        this.property = t, this.value = e, this.expression = function (t, e) {\n          if (Qr(t)) return new dn(t, e);\n\n          if (un(t)) {\n            const r = fn(t, e);\n            if (\"error\" === r.result) throw new Error(r.value.map(t => `${t.key}: ${t.message}`).join(\", \"));\n            return r.value;\n          }\n\n          {\n            let r = t;\n            return \"string\" == typeof t && \"color\" === e.type && (r = ce.parse(t)), {\n              kind: \"constant\",\n              evaluate: () => r\n            };\n          }\n        }(void 0 === e ? t.specification.default : e, t.specification);\n      }\n\n      isDataDriven() {\n        return \"source\" === this.expression.kind || \"composite\" === this.expression.kind;\n      }\n\n      possiblyEvaluate(t, e, r) {\n        return this.property.possiblyEvaluate(this, t, e, r);\n      }\n\n    }\n\n    class os {\n      constructor(t) {\n        this.property = t, this.value = new as(t, void 0);\n      }\n\n      transitioned(t, e) {\n        return new us(this.property, this.value, e, b({}, t.transition, this.transition), t.now);\n      }\n\n      untransitioned() {\n        return new us(this.property, this.value, null, {}, 0);\n      }\n\n    }\n\n    class ls {\n      constructor(t) {\n        this._properties = t, this._values = Object.create(t.defaultTransitionablePropertyValues);\n      }\n\n      getValue(t) {\n        return B(this._values[t].value.value);\n      }\n\n      setValue(t, e) {\n        this._values.hasOwnProperty(t) || (this._values[t] = new os(this._values[t].property)), this._values[t].value = new as(this._values[t].property, null === e ? void 0 : B(e));\n      }\n\n      getTransition(t) {\n        return B(this._values[t].transition);\n      }\n\n      setTransition(t, e) {\n        this._values.hasOwnProperty(t) || (this._values[t] = new os(this._values[t].property)), this._values[t].transition = B(e) || void 0;\n      }\n\n      serialize() {\n        const t = {};\n\n        for (const e of Object.keys(this._values)) {\n          const r = this.getValue(e);\n          void 0 !== r && (t[e] = r);\n          const n = this.getTransition(e);\n          void 0 !== n && (t[`${e}-transition`] = n);\n        }\n\n        return t;\n      }\n\n      transitioned(t, e) {\n        const r = new cs(this._properties);\n\n        for (const n of Object.keys(this._values)) r._values[n] = this._values[n].transitioned(t, e._values[n]);\n\n        return r;\n      }\n\n      untransitioned() {\n        const t = new cs(this._properties);\n\n        for (const e of Object.keys(this._values)) t._values[e] = this._values[e].untransitioned();\n\n        return t;\n      }\n\n    }\n\n    class us {\n      constructor(t, e, r, n, i) {\n        const s = n.delay || 0,\n              a = n.duration || 0;\n        i = i || 0, this.property = t, this.value = e, this.begin = i + s, this.end = this.begin + a, t.specification.transition && (n.delay || n.duration) && (this.prior = r);\n      }\n\n      possiblyEvaluate(t, e, r) {\n        const n = t.now || 0,\n              i = this.value.possiblyEvaluate(t, e, r),\n              s = this.prior;\n\n        if (s) {\n          if (n > this.end) return this.prior = null, i;\n          if (this.value.isDataDriven()) return this.prior = null, i;\n          if (n < this.begin) return s.possiblyEvaluate(t, e, r);\n          {\n            const a = (n - this.begin) / (this.end - this.begin);\n            return this.property.interpolate(s.possiblyEvaluate(t, e, r), i, p(a));\n          }\n        }\n\n        return i;\n      }\n\n    }\n\n    class cs {\n      constructor(t) {\n        this._properties = t, this._values = Object.create(t.defaultTransitioningPropertyValues);\n      }\n\n      possiblyEvaluate(t, e, r) {\n        const n = new fs(this._properties);\n\n        for (const i of Object.keys(this._values)) n._values[i] = this._values[i].possiblyEvaluate(t, e, r);\n\n        return n;\n      }\n\n      hasTransition() {\n        for (const t of Object.keys(this._values)) if (this._values[t].prior) return !0;\n\n        return !1;\n      }\n\n    }\n\n    class hs {\n      constructor(t) {\n        this._properties = t, this._values = Object.create(t.defaultPropertyValues);\n      }\n\n      getValue(t) {\n        return B(this._values[t].value);\n      }\n\n      setValue(t, e) {\n        this._values[t] = new as(this._values[t].property, null === e ? void 0 : B(e));\n      }\n\n      serialize() {\n        const t = {};\n\n        for (const e of Object.keys(this._values)) {\n          const r = this.getValue(e);\n          void 0 !== r && (t[e] = r);\n        }\n\n        return t;\n      }\n\n      possiblyEvaluate(t, e, r) {\n        const n = new fs(this._properties);\n\n        for (const i of Object.keys(this._values)) n._values[i] = this._values[i].possiblyEvaluate(t, e, r);\n\n        return n;\n      }\n\n    }\n\n    class ps {\n      constructor(t, e, r) {\n        this.property = t, this.value = e, this.parameters = r;\n      }\n\n      isConstant() {\n        return \"constant\" === this.value.kind;\n      }\n\n      constantOr(t) {\n        return \"constant\" === this.value.kind ? this.value.value : t;\n      }\n\n      evaluate(t, e, r, n) {\n        return this.property.evaluate(this.value, this.parameters, t, e, r, n);\n      }\n\n    }\n\n    class fs {\n      constructor(t) {\n        this._properties = t, this._values = Object.create(t.defaultPossiblyEvaluatedValues);\n      }\n\n      get(t) {\n        return this._values[t];\n      }\n\n    }\n\n    class ds {\n      constructor(t) {\n        this.specification = t;\n      }\n\n      possiblyEvaluate(t, e) {\n        return t.expression.evaluate(e);\n      }\n\n      interpolate(t, e, r) {\n        const n = nr[this.specification.type];\n        return n ? n(t, e, r) : t;\n      }\n\n    }\n\n    class ys {\n      constructor(t, e) {\n        this.specification = t, this.overrides = e;\n      }\n\n      possiblyEvaluate(t, e, r, n) {\n        return new ps(this, \"constant\" === t.expression.kind || \"camera\" === t.expression.kind ? {\n          kind: \"constant\",\n          value: t.expression.evaluate(e, null, {}, r, n)\n        } : t.expression, e);\n      }\n\n      interpolate(t, e, r) {\n        if (\"constant\" !== t.value.kind || \"constant\" !== e.value.kind) return t;\n        if (void 0 === t.value.value || void 0 === e.value.value) return new ps(this, {\n          kind: \"constant\",\n          value: void 0\n        }, t.parameters);\n        const n = nr[this.specification.type];\n        return n ? new ps(this, {\n          kind: \"constant\",\n          value: n(t.value.value, e.value.value, r)\n        }, t.parameters) : t;\n      }\n\n      evaluate(t, e, r, n, i, s) {\n        return \"constant\" === t.kind ? t.value : t.evaluate(e, r, n, i, s);\n      }\n\n    }\n\n    class ms extends ys {\n      possiblyEvaluate(t, e, r, n) {\n        if (void 0 === t.value) return new ps(this, {\n          kind: \"constant\",\n          value: void 0\n        }, e);\n\n        if (\"constant\" === t.expression.kind) {\n          const i = t.expression.evaluate(e, null, {}, r, n),\n                s = \"resolvedImage\" === t.property.specification.type && \"string\" != typeof i ? i.name : i,\n                a = this._calculate(s, s, s, e);\n\n          return new ps(this, {\n            kind: \"constant\",\n            value: a\n          }, e);\n        }\n\n        if (\"camera\" === t.expression.kind) {\n          const r = this._calculate(t.expression.evaluate({\n            zoom: e.zoom - 1\n          }), t.expression.evaluate({\n            zoom: e.zoom\n          }), t.expression.evaluate({\n            zoom: e.zoom + 1\n          }), e);\n\n          return new ps(this, {\n            kind: \"constant\",\n            value: r\n          }, e);\n        }\n\n        return new ps(this, t.expression, e);\n      }\n\n      evaluate(t, e, r, n, i, s) {\n        if (\"source\" === t.kind) {\n          const a = t.evaluate(e, r, n, i, s);\n          return this._calculate(a, a, a, e);\n        }\n\n        return \"composite\" === t.kind ? this._calculate(t.evaluate({\n          zoom: Math.floor(e.zoom) - 1\n        }, r, n), t.evaluate({\n          zoom: Math.floor(e.zoom)\n        }, r, n), t.evaluate({\n          zoom: Math.floor(e.zoom) + 1\n        }, r, n), e) : t.value;\n      }\n\n      _calculate(t, e, r, n) {\n        return n.zoom > n.zoomHistory.lastIntegerZoom ? {\n          from: t,\n          to: e,\n          other: r\n        } : {\n          from: r,\n          to: e,\n          other: t\n        };\n      }\n\n      interpolate(t) {\n        return t;\n      }\n\n    }\n\n    class gs {\n      constructor(t) {\n        this.specification = t;\n      }\n\n      possiblyEvaluate(t, e, r, n) {\n        if (void 0 !== t.value) {\n          if (\"constant\" === t.expression.kind) {\n            const i = t.expression.evaluate(e, null, {}, r, n);\n            return this._calculate(i, i, i, e);\n          }\n\n          return this._calculate(t.expression.evaluate(new ss(Math.floor(e.zoom - 1), e)), t.expression.evaluate(new ss(Math.floor(e.zoom), e)), t.expression.evaluate(new ss(Math.floor(e.zoom + 1), e)), e);\n        }\n      }\n\n      _calculate(t, e, r, n) {\n        return n.zoom > n.zoomHistory.lastIntegerZoom ? {\n          from: t,\n          to: e\n        } : {\n          from: r,\n          to: e\n        };\n      }\n\n      interpolate(t) {\n        return t;\n      }\n\n    }\n\n    class xs {\n      constructor(t) {\n        this.specification = t;\n      }\n\n      possiblyEvaluate(t, e, r, n) {\n        return !!t.expression.evaluate(e, null, {}, r, n);\n      }\n\n      interpolate() {\n        return !1;\n      }\n\n    }\n\n    class vs {\n      constructor(t) {\n        this.properties = t, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];\n\n        for (const e in t) {\n          const r = t[e];\n          r.specification.overridable && this.overridableProperties.push(e);\n          const n = this.defaultPropertyValues[e] = new as(r, void 0),\n                i = this.defaultTransitionablePropertyValues[e] = new os(r);\n          this.defaultTransitioningPropertyValues[e] = i.untransitioned(), this.defaultPossiblyEvaluatedValues[e] = n.possiblyEvaluate({});\n        }\n      }\n\n    }\n\n    function bs(t, e) {\n      return 256 * (t = y(Math.floor(t), 0, 255)) + y(Math.floor(e), 0, 255);\n    }\n\n    ai(ys), ai(ds), ai(ms), ai(gs), ai(xs);\n    const _s = {\n      Int8: Int8Array,\n      Uint8: Uint8Array,\n      Int16: Int16Array,\n      Uint16: Uint16Array,\n      Int32: Int32Array,\n      Uint32: Uint32Array,\n      Float32: Float32Array\n    };\n\n    class ws {\n      constructor(t, e) {\n        this._structArray = t, this._pos1 = e * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;\n      }\n\n    }\n\n    class As {\n      constructor() {\n        this.isTransferred = !1, this.capacity = -1, this.resize(0);\n      }\n\n      static serialize(t, e) {\n        return t._trim(), e && (t.isTransferred = !0, e.push(t.arrayBuffer)), {\n          length: t.length,\n          arrayBuffer: t.arrayBuffer\n        };\n      }\n\n      static deserialize(t) {\n        const e = Object.create(this.prototype);\n        return e.arrayBuffer = t.arrayBuffer, e.length = t.length, e.capacity = t.arrayBuffer.byteLength / e.bytesPerElement, e._refreshViews(), e;\n      }\n\n      _trim() {\n        this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());\n      }\n\n      clear() {\n        this.length = 0;\n      }\n\n      resize(t) {\n        this.reserve(t), this.length = t;\n      }\n\n      reserve(t) {\n        if (t > this.capacity) {\n          this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);\n          const e = this.uint8;\n          this._refreshViews(), e && this.uint8.set(e);\n        }\n      }\n\n      _refreshViews() {\n        throw new Error(\"_refreshViews() must be implemented by each concrete StructArray layout\");\n      }\n\n      destroy() {\n        this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null, this.arrayBuffer = null;\n      }\n\n    }\n\n    function ks(t, e = 1) {\n      let r = 0,\n          n = 0;\n      return {\n        members: t.map(t => {\n          const i = _s[t.type].BYTES_PER_ELEMENT,\n                s = r = Ss(r, Math.max(e, i)),\n                a = t.components || 1;\n          return n = Math.max(n, i), r += i * a, {\n            name: t.name,\n            type: t.type,\n            components: a,\n            offset: s\n          };\n        }),\n        size: Ss(r, Math.max(n, e)),\n        alignment: e\n      };\n    }\n\n    function Ss(t, e) {\n      return Math.ceil(t / e) * e;\n    }\n\n    class Is extends As {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t, e) {\n        const r = this.length;\n        return this.resize(r + 1), this.emplace(r, t, e);\n      }\n\n      emplace(t, e, r) {\n        const n = 2 * t;\n        return this.int16[n + 0] = e, this.int16[n + 1] = r, t;\n      }\n\n    }\n\n    Is.prototype.bytesPerElement = 4, ai(Is);\n\n    class Ms extends As {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t, e, r) {\n        const n = this.length;\n        return this.resize(n + 1), this.emplace(n, t, e, r);\n      }\n\n      emplace(t, e, r, n) {\n        const i = 3 * t;\n        return this.int16[i + 0] = e, this.int16[i + 1] = r, this.int16[i + 2] = n, t;\n      }\n\n    }\n\n    Ms.prototype.bytesPerElement = 6, ai(Ms);\n\n    class Ts extends As {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t, e, r, n) {\n        const i = this.length;\n        return this.resize(i + 1), this.emplace(i, t, e, r, n);\n      }\n\n      emplace(t, e, r, n, i) {\n        const s = 4 * t;\n        return this.int16[s + 0] = e, this.int16[s + 1] = r, this.int16[s + 2] = n, this.int16[s + 3] = i, t;\n      }\n\n    }\n\n    Ts.prototype.bytesPerElement = 8, ai(Ts);\n\n    class zs extends As {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t, e, r, n, i, s, a) {\n        const o = this.length;\n        return this.resize(o + 1), this.emplace(o, t, e, r, n, i, s, a);\n      }\n\n      emplace(t, e, r, n, i, s, a, o) {\n        const l = 6 * t,\n              u = 12 * t,\n              c = 3 * t;\n        return this.int16[l + 0] = e, this.int16[l + 1] = r, this.uint8[u + 4] = n, this.uint8[u + 5] = i, this.uint8[u + 6] = s, this.uint8[u + 7] = a, this.float32[c + 2] = o, t;\n      }\n\n    }\n\n    zs.prototype.bytesPerElement = 12, ai(zs);\n\n    class Bs extends As {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t, e, r) {\n        const n = this.length;\n        return this.resize(n + 1), this.emplace(n, t, e, r);\n      }\n\n      emplace(t, e, r, n) {\n        const i = 3 * t;\n        return this.float32[i + 0] = e, this.float32[i + 1] = r, this.float32[i + 2] = n, t;\n      }\n\n    }\n\n    Bs.prototype.bytesPerElement = 12, ai(Bs);\n\n    class Es extends As {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t, e, r, n, i, s, a, o, l, u) {\n        const c = this.length;\n        return this.resize(c + 1), this.emplace(c, t, e, r, n, i, s, a, o, l, u);\n      }\n\n      emplace(t, e, r, n, i, s, a, o, l, u, c) {\n        const h = 10 * t;\n        return this.uint16[h + 0] = e, this.uint16[h + 1] = r, this.uint16[h + 2] = n, this.uint16[h + 3] = i, this.uint16[h + 4] = s, this.uint16[h + 5] = a, this.uint16[h + 6] = o, this.uint16[h + 7] = l, this.uint16[h + 8] = u, this.uint16[h + 9] = c, t;\n      }\n\n    }\n\n    Es.prototype.bytesPerElement = 20, ai(Es);\n\n    class Cs extends As {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t, e, r, n, i, s, a, o) {\n        const l = this.length;\n        return this.resize(l + 1), this.emplace(l, t, e, r, n, i, s, a, o);\n      }\n\n      emplace(t, e, r, n, i, s, a, o, l) {\n        const u = 8 * t;\n        return this.uint16[u + 0] = e, this.uint16[u + 1] = r, this.uint16[u + 2] = n, this.uint16[u + 3] = i, this.uint16[u + 4] = s, this.uint16[u + 5] = a, this.uint16[u + 6] = o, this.uint16[u + 7] = l, t;\n      }\n\n    }\n\n    Cs.prototype.bytesPerElement = 16, ai(Cs);\n\n    class Ds extends As {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t, e, r, n, i, s) {\n        const a = this.length;\n        return this.resize(a + 1), this.emplace(a, t, e, r, n, i, s);\n      }\n\n      emplace(t, e, r, n, i, s, a) {\n        const o = 6 * t;\n        return this.int16[o + 0] = e, this.int16[o + 1] = r, this.int16[o + 2] = n, this.int16[o + 3] = i, this.int16[o + 4] = s, this.int16[o + 5] = a, t;\n      }\n\n    }\n\n    Ds.prototype.bytesPerElement = 12, ai(Ds);\n\n    class Ps extends As {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y) {\n        const m = this.length;\n        return this.resize(m + 1), this.emplace(m, t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y);\n      }\n\n      emplace(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m) {\n        const g = 16 * t;\n        return this.int16[g + 0] = e, this.int16[g + 1] = r, this.int16[g + 2] = n, this.int16[g + 3] = i, this.uint16[g + 4] = s, this.uint16[g + 5] = a, this.uint16[g + 6] = o, this.uint16[g + 7] = l, this.int16[g + 8] = u, this.int16[g + 9] = c, this.int16[g + 10] = h, this.int16[g + 11] = p, this.int16[g + 12] = f, this.int16[g + 13] = d, this.int16[g + 14] = y, this.int16[g + 15] = m, t;\n      }\n\n    }\n\n    Ps.prototype.bytesPerElement = 32, ai(Ps);\n\n    class Vs extends As {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t) {\n        const e = this.length;\n        return this.resize(e + 1), this.emplace(e, t);\n      }\n\n      emplace(t, e) {\n        return this.uint32[1 * t + 0] = e, t;\n      }\n\n    }\n\n    Vs.prototype.bytesPerElement = 4, ai(Vs);\n\n    class Fs extends As {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t, e, r, n, i, s, a, o, l, u, c, h, p) {\n        const f = this.length;\n        return this.resize(f + 1), this.emplace(f, t, e, r, n, i, s, a, o, l, u, c, h, p);\n      }\n\n      emplace(t, e, r, n, i, s, a, o, l, u, c, h, p, f) {\n        const d = 20 * t,\n              y = 10 * t;\n        return this.int16[d + 0] = e, this.int16[d + 1] = r, this.int16[d + 2] = n, this.int16[d + 3] = i, this.int16[d + 4] = s, this.float32[y + 3] = a, this.float32[y + 4] = o, this.float32[y + 5] = l, this.float32[y + 6] = u, this.int16[d + 14] = c, this.uint32[y + 8] = h, this.uint16[d + 18] = p, this.uint16[d + 19] = f, t;\n      }\n\n    }\n\n    Fs.prototype.bytesPerElement = 40, ai(Fs);\n\n    class Ls extends As {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t, e, r, n, i, s, a) {\n        const o = this.length;\n        return this.resize(o + 1), this.emplace(o, t, e, r, n, i, s, a);\n      }\n\n      emplace(t, e, r, n, i, s, a, o) {\n        const l = 8 * t;\n        return this.int16[l + 0] = e, this.int16[l + 1] = r, this.int16[l + 2] = n, this.int16[l + 4] = i, this.int16[l + 5] = s, this.int16[l + 6] = a, this.int16[l + 7] = o, t;\n      }\n\n    }\n\n    Ls.prototype.bytesPerElement = 16, ai(Ls);\n\n    class Rs extends As {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t, e, r, n, i) {\n        const s = this.length;\n        return this.resize(s + 1), this.emplace(s, t, e, r, n, i);\n      }\n\n      emplace(t, e, r, n, i, s) {\n        const a = 4 * t,\n              o = 8 * t;\n        return this.float32[a + 0] = e, this.float32[a + 1] = r, this.float32[a + 2] = n, this.int16[o + 6] = i, this.int16[o + 7] = s, t;\n      }\n\n    }\n\n    Rs.prototype.bytesPerElement = 16, ai(Rs);\n\n    class Us extends As {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t, e, r, n) {\n        const i = this.length;\n        return this.resize(i + 1), this.emplace(i, t, e, r, n);\n      }\n\n      emplace(t, e, r, n, i) {\n        const s = 12 * t,\n              a = 3 * t;\n        return this.uint8[s + 0] = e, this.uint8[s + 1] = r, this.float32[a + 1] = n, this.float32[a + 2] = i, t;\n      }\n\n    }\n\n    Us.prototype.bytesPerElement = 12, ai(Us);\n\n    class $s extends As {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t, e, r) {\n        const n = this.length;\n        return this.resize(n + 1), this.emplace(n, t, e, r);\n      }\n\n      emplace(t, e, r, n) {\n        const i = 3 * t;\n        return this.uint16[i + 0] = e, this.uint16[i + 1] = r, this.uint16[i + 2] = n, t;\n      }\n\n    }\n\n    $s.prototype.bytesPerElement = 6, ai($s);\n\n    class js extends As {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b) {\n        const _ = this.length;\n        return this.resize(_ + 1), this.emplace(_, t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b);\n      }\n\n      emplace(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b, _) {\n        const w = 30 * t,\n              A = 15 * t,\n              k = 60 * t;\n        return this.int16[w + 0] = e, this.int16[w + 1] = r, this.int16[w + 2] = n, this.float32[A + 2] = i, this.float32[A + 3] = s, this.uint16[w + 8] = a, this.uint16[w + 9] = o, this.uint32[A + 5] = l, this.uint32[A + 6] = u, this.uint32[A + 7] = c, this.uint16[w + 16] = h, this.uint16[w + 17] = p, this.uint16[w + 18] = f, this.float32[A + 10] = d, this.float32[A + 11] = y, this.uint8[k + 48] = m, this.uint8[k + 49] = g, this.uint8[k + 50] = x, this.uint32[A + 13] = v, this.int16[w + 28] = b, this.uint8[k + 58] = _, t;\n      }\n\n    }\n\n    js.prototype.bytesPerElement = 60, ai(js);\n\n    class Os extends As {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b, _, w, A, k, S, I, M, T, z) {\n        const B = this.length;\n        return this.resize(B + 1), this.emplace(B, t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b, _, w, A, k, S, I, M, T, z);\n      }\n\n      emplace(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b, _, w, A, k, S, I, M, T, z, B) {\n        const E = 38 * t,\n              C = 19 * t;\n        return this.int16[E + 0] = e, this.int16[E + 1] = r, this.int16[E + 2] = n, this.float32[C + 2] = i, this.float32[C + 3] = s, this.int16[E + 8] = a, this.int16[E + 9] = o, this.int16[E + 10] = l, this.int16[E + 11] = u, this.int16[E + 12] = c, this.int16[E + 13] = h, this.uint16[E + 14] = p, this.uint16[E + 15] = f, this.uint16[E + 16] = d, this.uint16[E + 17] = y, this.uint16[E + 18] = m, this.uint16[E + 19] = g, this.uint16[E + 20] = x, this.uint16[E + 21] = v, this.uint16[E + 22] = b, this.uint16[E + 23] = _, this.uint16[E + 24] = w, this.uint16[E + 25] = A, this.uint16[E + 26] = k, this.uint16[E + 27] = S, this.uint16[E + 28] = I, this.uint32[C + 15] = M, this.float32[C + 16] = T, this.float32[C + 17] = z, this.float32[C + 18] = B, t;\n      }\n\n    }\n\n    Os.prototype.bytesPerElement = 76, ai(Os);\n\n    class qs extends As {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t) {\n        const e = this.length;\n        return this.resize(e + 1), this.emplace(e, t);\n      }\n\n      emplace(t, e) {\n        return this.float32[1 * t + 0] = e, t;\n      }\n\n    }\n\n    qs.prototype.bytesPerElement = 4, ai(qs);\n\n    class Ns extends As {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t, e, r, n, i, s, a) {\n        const o = this.length;\n        return this.resize(o + 1), this.emplace(o, t, e, r, n, i, s, a);\n      }\n\n      emplace(t, e, r, n, i, s, a, o) {\n        const l = 7 * t;\n        return this.float32[l + 0] = e, this.float32[l + 1] = r, this.float32[l + 2] = n, this.float32[l + 3] = i, this.float32[l + 4] = s, this.float32[l + 5] = a, this.float32[l + 6] = o, t;\n      }\n\n    }\n\n    Ns.prototype.bytesPerElement = 28, ai(Ns);\n\n    class Gs extends As {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t, e, r, n, i) {\n        const s = this.length;\n        return this.resize(s + 1), this.emplace(s, t, e, r, n, i);\n      }\n\n      emplace(t, e, r, n, i, s) {\n        const a = 5 * t;\n        return this.float32[a + 0] = e, this.float32[a + 1] = r, this.float32[a + 2] = n, this.float32[a + 3] = i, this.float32[a + 4] = s, t;\n      }\n\n    }\n\n    Gs.prototype.bytesPerElement = 20, ai(Gs);\n\n    class Zs extends As {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t, e, r, n) {\n        const i = this.length;\n        return this.resize(i + 1), this.emplace(i, t, e, r, n);\n      }\n\n      emplace(t, e, r, n, i) {\n        const s = 6 * t;\n        return this.uint32[3 * t + 0] = e, this.uint16[s + 2] = r, this.uint16[s + 3] = n, this.uint16[s + 4] = i, t;\n      }\n\n    }\n\n    Zs.prototype.bytesPerElement = 12, ai(Zs);\n\n    class Xs extends As {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t, e) {\n        const r = this.length;\n        return this.resize(r + 1), this.emplace(r, t, e);\n      }\n\n      emplace(t, e, r) {\n        const n = 2 * t;\n        return this.uint16[n + 0] = e, this.uint16[n + 1] = r, t;\n      }\n\n    }\n\n    Xs.prototype.bytesPerElement = 4, ai(Xs);\n\n    class Ks extends As {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t) {\n        const e = this.length;\n        return this.resize(e + 1), this.emplace(e, t);\n      }\n\n      emplace(t, e) {\n        return this.uint16[1 * t + 0] = e, t;\n      }\n\n    }\n\n    Ks.prototype.bytesPerElement = 2, ai(Ks);\n\n    class Ys extends As {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t, e) {\n        const r = this.length;\n        return this.resize(r + 1), this.emplace(r, t, e);\n      }\n\n      emplace(t, e, r) {\n        const n = 2 * t;\n        return this.float32[n + 0] = e, this.float32[n + 1] = r, t;\n      }\n\n    }\n\n    Ys.prototype.bytesPerElement = 8, ai(Ys);\n\n    class Hs extends As {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t, e, r, n) {\n        const i = this.length;\n        return this.resize(i + 1), this.emplace(i, t, e, r, n);\n      }\n\n      emplace(t, e, r, n, i) {\n        const s = 4 * t;\n        return this.float32[s + 0] = e, this.float32[s + 1] = r, this.float32[s + 2] = n, this.float32[s + 3] = i, t;\n      }\n\n    }\n\n    Hs.prototype.bytesPerElement = 16, ai(Hs);\n\n    class Ws extends As {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t, e, r, n, i, s, a) {\n        const o = this.length;\n        return this.resize(o + 1), this.emplace(o, t, e, r, n, i, s, a);\n      }\n\n      emplace(t, e, r, n, i, s, a, o) {\n        const l = 8 * t,\n              u = 4 * t;\n        return this.int16[l + 0] = e, this.int16[l + 1] = r, this.int16[l + 2] = n, this.int16[l + 3] = i, this.int16[l + 4] = s, this.int16[l + 5] = a, this.float32[u + 3] = o, t;\n      }\n\n    }\n\n    Ws.prototype.bytesPerElement = 16, ai(Ws);\n\n    class Js extends ws {\n      get a_pos_30() {\n        return this._structArray.int16[this._pos2 + 0];\n      }\n\n      get a_pos_31() {\n        return this._structArray.int16[this._pos2 + 1];\n      }\n\n      get a_pos_32() {\n        return this._structArray.int16[this._pos2 + 2];\n      }\n\n      get a_pos_normal_30() {\n        return this._structArray.int16[this._pos2 + 3];\n      }\n\n      get a_pos_normal_31() {\n        return this._structArray.int16[this._pos2 + 4];\n      }\n\n      get a_pos_normal_32() {\n        return this._structArray.int16[this._pos2 + 5];\n      }\n\n    }\n\n    Js.prototype.size = 12;\n\n    class Qs extends Ds {\n      get(t) {\n        return new Js(this, t);\n      }\n\n    }\n\n    ai(Qs);\n\n    class ta extends ws {\n      get projectedAnchorX() {\n        return this._structArray.int16[this._pos2 + 0];\n      }\n\n      get projectedAnchorY() {\n        return this._structArray.int16[this._pos2 + 1];\n      }\n\n      get projectedAnchorZ() {\n        return this._structArray.int16[this._pos2 + 2];\n      }\n\n      get tileAnchorX() {\n        return this._structArray.int16[this._pos2 + 3];\n      }\n\n      get tileAnchorY() {\n        return this._structArray.int16[this._pos2 + 4];\n      }\n\n      get x1() {\n        return this._structArray.float32[this._pos4 + 3];\n      }\n\n      get y1() {\n        return this._structArray.float32[this._pos4 + 4];\n      }\n\n      get x2() {\n        return this._structArray.float32[this._pos4 + 5];\n      }\n\n      get y2() {\n        return this._structArray.float32[this._pos4 + 6];\n      }\n\n      get padding() {\n        return this._structArray.int16[this._pos2 + 14];\n      }\n\n      get featureIndex() {\n        return this._structArray.uint32[this._pos4 + 8];\n      }\n\n      get sourceLayerIndex() {\n        return this._structArray.uint16[this._pos2 + 18];\n      }\n\n      get bucketIndex() {\n        return this._structArray.uint16[this._pos2 + 19];\n      }\n\n    }\n\n    ta.prototype.size = 40;\n\n    class ea extends Fs {\n      get(t) {\n        return new ta(this, t);\n      }\n\n    }\n\n    ai(ea);\n\n    class ra extends ws {\n      get projectedAnchorX() {\n        return this._structArray.int16[this._pos2 + 0];\n      }\n\n      get projectedAnchorY() {\n        return this._structArray.int16[this._pos2 + 1];\n      }\n\n      get projectedAnchorZ() {\n        return this._structArray.int16[this._pos2 + 2];\n      }\n\n      get tileAnchorX() {\n        return this._structArray.float32[this._pos4 + 2];\n      }\n\n      get tileAnchorY() {\n        return this._structArray.float32[this._pos4 + 3];\n      }\n\n      get glyphStartIndex() {\n        return this._structArray.uint16[this._pos2 + 8];\n      }\n\n      get numGlyphs() {\n        return this._structArray.uint16[this._pos2 + 9];\n      }\n\n      get vertexStartIndex() {\n        return this._structArray.uint32[this._pos4 + 5];\n      }\n\n      get lineStartIndex() {\n        return this._structArray.uint32[this._pos4 + 6];\n      }\n\n      get lineLength() {\n        return this._structArray.uint32[this._pos4 + 7];\n      }\n\n      get segment() {\n        return this._structArray.uint16[this._pos2 + 16];\n      }\n\n      get lowerSize() {\n        return this._structArray.uint16[this._pos2 + 17];\n      }\n\n      get upperSize() {\n        return this._structArray.uint16[this._pos2 + 18];\n      }\n\n      get lineOffsetX() {\n        return this._structArray.float32[this._pos4 + 10];\n      }\n\n      get lineOffsetY() {\n        return this._structArray.float32[this._pos4 + 11];\n      }\n\n      get writingMode() {\n        return this._structArray.uint8[this._pos1 + 48];\n      }\n\n      get placedOrientation() {\n        return this._structArray.uint8[this._pos1 + 49];\n      }\n\n      set placedOrientation(t) {\n        this._structArray.uint8[this._pos1 + 49] = t;\n      }\n\n      get hidden() {\n        return this._structArray.uint8[this._pos1 + 50];\n      }\n\n      set hidden(t) {\n        this._structArray.uint8[this._pos1 + 50] = t;\n      }\n\n      get crossTileID() {\n        return this._structArray.uint32[this._pos4 + 13];\n      }\n\n      set crossTileID(t) {\n        this._structArray.uint32[this._pos4 + 13] = t;\n      }\n\n      get associatedIconIndex() {\n        return this._structArray.int16[this._pos2 + 28];\n      }\n\n      get flipState() {\n        return this._structArray.uint8[this._pos1 + 58];\n      }\n\n      set flipState(t) {\n        this._structArray.uint8[this._pos1 + 58] = t;\n      }\n\n    }\n\n    ra.prototype.size = 60;\n\n    class na extends js {\n      get(t) {\n        return new ra(this, t);\n      }\n\n    }\n\n    ai(na);\n\n    class ia extends ws {\n      get projectedAnchorX() {\n        return this._structArray.int16[this._pos2 + 0];\n      }\n\n      get projectedAnchorY() {\n        return this._structArray.int16[this._pos2 + 1];\n      }\n\n      get projectedAnchorZ() {\n        return this._structArray.int16[this._pos2 + 2];\n      }\n\n      get tileAnchorX() {\n        return this._structArray.float32[this._pos4 + 2];\n      }\n\n      get tileAnchorY() {\n        return this._structArray.float32[this._pos4 + 3];\n      }\n\n      get rightJustifiedTextSymbolIndex() {\n        return this._structArray.int16[this._pos2 + 8];\n      }\n\n      get centerJustifiedTextSymbolIndex() {\n        return this._structArray.int16[this._pos2 + 9];\n      }\n\n      get leftJustifiedTextSymbolIndex() {\n        return this._structArray.int16[this._pos2 + 10];\n      }\n\n      get verticalPlacedTextSymbolIndex() {\n        return this._structArray.int16[this._pos2 + 11];\n      }\n\n      get placedIconSymbolIndex() {\n        return this._structArray.int16[this._pos2 + 12];\n      }\n\n      get verticalPlacedIconSymbolIndex() {\n        return this._structArray.int16[this._pos2 + 13];\n      }\n\n      get key() {\n        return this._structArray.uint16[this._pos2 + 14];\n      }\n\n      get textBoxStartIndex() {\n        return this._structArray.uint16[this._pos2 + 15];\n      }\n\n      get textBoxEndIndex() {\n        return this._structArray.uint16[this._pos2 + 16];\n      }\n\n      get verticalTextBoxStartIndex() {\n        return this._structArray.uint16[this._pos2 + 17];\n      }\n\n      get verticalTextBoxEndIndex() {\n        return this._structArray.uint16[this._pos2 + 18];\n      }\n\n      get iconBoxStartIndex() {\n        return this._structArray.uint16[this._pos2 + 19];\n      }\n\n      get iconBoxEndIndex() {\n        return this._structArray.uint16[this._pos2 + 20];\n      }\n\n      get verticalIconBoxStartIndex() {\n        return this._structArray.uint16[this._pos2 + 21];\n      }\n\n      get verticalIconBoxEndIndex() {\n        return this._structArray.uint16[this._pos2 + 22];\n      }\n\n      get featureIndex() {\n        return this._structArray.uint16[this._pos2 + 23];\n      }\n\n      get numHorizontalGlyphVertices() {\n        return this._structArray.uint16[this._pos2 + 24];\n      }\n\n      get numVerticalGlyphVertices() {\n        return this._structArray.uint16[this._pos2 + 25];\n      }\n\n      get numIconVertices() {\n        return this._structArray.uint16[this._pos2 + 26];\n      }\n\n      get numVerticalIconVertices() {\n        return this._structArray.uint16[this._pos2 + 27];\n      }\n\n      get useRuntimeCollisionCircles() {\n        return this._structArray.uint16[this._pos2 + 28];\n      }\n\n      get crossTileID() {\n        return this._structArray.uint32[this._pos4 + 15];\n      }\n\n      set crossTileID(t) {\n        this._structArray.uint32[this._pos4 + 15] = t;\n      }\n\n      get textOffset0() {\n        return this._structArray.float32[this._pos4 + 16];\n      }\n\n      get textOffset1() {\n        return this._structArray.float32[this._pos4 + 17];\n      }\n\n      get collisionCircleDiameter() {\n        return this._structArray.float32[this._pos4 + 18];\n      }\n\n    }\n\n    ia.prototype.size = 76;\n\n    class sa extends Os {\n      get(t) {\n        return new ia(this, t);\n      }\n\n    }\n\n    ai(sa);\n\n    class aa extends qs {\n      getoffsetX(t) {\n        return this.float32[1 * t + 0];\n      }\n\n    }\n\n    ai(aa);\n\n    class oa extends Ms {\n      getx(t) {\n        return this.int16[3 * t + 0];\n      }\n\n      gety(t) {\n        return this.int16[3 * t + 1];\n      }\n\n      gettileUnitDistanceFromAnchor(t) {\n        return this.int16[3 * t + 2];\n      }\n\n    }\n\n    ai(oa);\n\n    class la extends ws {\n      get featureIndex() {\n        return this._structArray.uint32[this._pos4 + 0];\n      }\n\n      get sourceLayerIndex() {\n        return this._structArray.uint16[this._pos2 + 2];\n      }\n\n      get bucketIndex() {\n        return this._structArray.uint16[this._pos2 + 3];\n      }\n\n      get layoutVertexArrayOffset() {\n        return this._structArray.uint16[this._pos2 + 4];\n      }\n\n    }\n\n    la.prototype.size = 12;\n\n    class ua extends Zs {\n      get(t) {\n        return new la(this, t);\n      }\n\n    }\n\n    ai(ua);\n\n    class ca extends ws {\n      get a_centroid_pos0() {\n        return this._structArray.uint16[this._pos2 + 0];\n      }\n\n      get a_centroid_pos1() {\n        return this._structArray.uint16[this._pos2 + 1];\n      }\n\n    }\n\n    ca.prototype.size = 4;\n\n    class ha extends Xs {\n      get(t) {\n        return new ca(this, t);\n      }\n\n    }\n\n    ai(ha);\n\n    class pa extends ws {\n      get a_pos_30() {\n        return this._structArray.int16[this._pos2 + 0];\n      }\n\n      get a_pos_31() {\n        return this._structArray.int16[this._pos2 + 1];\n      }\n\n      get a_pos_32() {\n        return this._structArray.int16[this._pos2 + 2];\n      }\n\n      get a_pos_normal_30() {\n        return this._structArray.int16[this._pos2 + 3];\n      }\n\n      get a_pos_normal_31() {\n        return this._structArray.int16[this._pos2 + 4];\n      }\n\n      get a_pos_normal_32() {\n        return this._structArray.int16[this._pos2 + 5];\n      }\n\n      get a_scale() {\n        return this._structArray.float32[this._pos4 + 3];\n      }\n\n    }\n\n    pa.prototype.size = 16;\n\n    class fa extends Ws {\n      get(t) {\n        return new pa(this, t);\n      }\n\n    }\n\n    ai(fa);\n    const da = ks([{\n      name: \"a_pattern_to\",\n      components: 4,\n      type: \"Uint16\"\n    }, {\n      name: \"a_pattern_from\",\n      components: 4,\n      type: \"Uint16\"\n    }, {\n      name: \"a_pixel_ratio_to\",\n      components: 1,\n      type: \"Uint16\"\n    }, {\n      name: \"a_pixel_ratio_from\",\n      components: 1,\n      type: \"Uint16\"\n    }]),\n          ya = ks([{\n      name: \"a_dash_to\",\n      components: 4,\n      type: \"Uint16\"\n    }, {\n      name: \"a_dash_from\",\n      components: 4,\n      type: \"Uint16\"\n    }]);\n    var ma = le(function (t) {\n      t.exports = function (t, e) {\n        var r, n, i, s, a, o, l, u;\n\n        for (n = t.length - (r = 3 & t.length), i = e, a = 3432918353, o = 461845907, u = 0; u < n;) l = 255 & t.charCodeAt(u) | (255 & t.charCodeAt(++u)) << 8 | (255 & t.charCodeAt(++u)) << 16 | (255 & t.charCodeAt(++u)) << 24, ++u, i = 27492 + (65535 & (s = 5 * (65535 & (i = (i ^= l = (65535 & (l = (l = (65535 & l) * a + (((l >>> 16) * a & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * o + (((l >>> 16) * o & 65535) << 16) & 4294967295) << 13 | i >>> 19)) + ((5 * (i >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s >>> 16) & 65535) << 16);\n\n        switch (l = 0, r) {\n          case 3:\n            l ^= (255 & t.charCodeAt(u + 2)) << 16;\n\n          case 2:\n            l ^= (255 & t.charCodeAt(u + 1)) << 8;\n\n          case 1:\n            i ^= l = (65535 & (l = (l = (65535 & (l ^= 255 & t.charCodeAt(u))) * a + (((l >>> 16) * a & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * o + (((l >>> 16) * o & 65535) << 16) & 4294967295;\n        }\n\n        return i ^= t.length, i = 2246822507 * (65535 & (i ^= i >>> 16)) + ((2246822507 * (i >>> 16) & 65535) << 16) & 4294967295, i = 3266489909 * (65535 & (i ^= i >>> 13)) + ((3266489909 * (i >>> 16) & 65535) << 16) & 4294967295, (i ^= i >>> 16) >>> 0;\n      };\n    }),\n        ga = le(function (t) {\n      t.exports = function (t, e) {\n        for (var r, n = t.length, i = e ^ n, s = 0; n >= 4;) r = 1540483477 * (65535 & (r = 255 & t.charCodeAt(s) | (255 & t.charCodeAt(++s)) << 8 | (255 & t.charCodeAt(++s)) << 16 | (255 & t.charCodeAt(++s)) << 24)) + ((1540483477 * (r >>> 16) & 65535) << 16), i = 1540483477 * (65535 & i) + ((1540483477 * (i >>> 16) & 65535) << 16) ^ (r = 1540483477 * (65535 & (r ^= r >>> 24)) + ((1540483477 * (r >>> 16) & 65535) << 16)), n -= 4, ++s;\n\n        switch (n) {\n          case 3:\n            i ^= (255 & t.charCodeAt(s + 2)) << 16;\n\n          case 2:\n            i ^= (255 & t.charCodeAt(s + 1)) << 8;\n\n          case 1:\n            i = 1540483477 * (65535 & (i ^= 255 & t.charCodeAt(s))) + ((1540483477 * (i >>> 16) & 65535) << 16);\n        }\n\n        return i = 1540483477 * (65535 & (i ^= i >>> 13)) + ((1540483477 * (i >>> 16) & 65535) << 16), (i ^= i >>> 15) >>> 0;\n      };\n    }),\n        xa = ma,\n        va = ga;\n    xa.murmur3 = ma, xa.murmur2 = va;\n\n    class ba {\n      constructor() {\n        this.ids = [], this.positions = [], this.indexed = !1;\n      }\n\n      add(t, e, r, n) {\n        this.ids.push(_a(t)), this.positions.push(e, r, n);\n      }\n\n      getPositions(t) {\n        const e = _a(t);\n\n        let r = 0,\n            n = this.ids.length - 1;\n\n        for (; r < n;) {\n          const t = r + n >> 1;\n          this.ids[t] >= e ? n = t : r = t + 1;\n        }\n\n        const i = [];\n\n        for (; this.ids[r] === e;) i.push({\n          index: this.positions[3 * r],\n          start: this.positions[3 * r + 1],\n          end: this.positions[3 * r + 2]\n        }), r++;\n\n        return i;\n      }\n\n      static serialize(t, e) {\n        const r = new Float64Array(t.ids),\n              n = new Uint32Array(t.positions);\n        return wa(r, n, 0, r.length - 1), e && e.push(r.buffer, n.buffer), {\n          ids: r,\n          positions: n\n        };\n      }\n\n      static deserialize(t) {\n        const e = new ba();\n        return e.ids = t.ids, e.positions = t.positions, e.indexed = !0, e;\n      }\n\n    }\n\n    function _a(t) {\n      const e = +t;\n      return !isNaN(e) && Number.MIN_SAFE_INTEGER <= e && e <= Number.MAX_SAFE_INTEGER ? e : xa(String(t));\n    }\n\n    function wa(t, e, r, n) {\n      for (; r < n;) {\n        const i = t[r + n >> 1];\n        let s = r - 1,\n            a = n + 1;\n\n        for (;;) {\n          do {\n            s++;\n          } while (t[s] < i);\n\n          do {\n            a--;\n          } while (t[a] > i);\n\n          if (s >= a) break;\n          Aa(t, s, a), Aa(e, 3 * s, 3 * a), Aa(e, 3 * s + 1, 3 * a + 1), Aa(e, 3 * s + 2, 3 * a + 2);\n        }\n\n        a - r < n - a ? (wa(t, e, r, a), r = a + 1) : (wa(t, e, a + 1, n), n = a);\n      }\n    }\n\n    function Aa(t, e, r) {\n      const n = t[e];\n      t[e] = t[r], t[r] = n;\n    }\n\n    ai(ba);\n\n    class ka {\n      constructor(t, e) {\n        this.gl = t.gl, this.location = e;\n      }\n\n    }\n\n    class Sa extends ka {\n      constructor(t, e) {\n        super(t, e), this.current = 0;\n      }\n\n      set(t) {\n        this.current !== t && (this.current = t, this.gl.uniform1f(this.location, t));\n      }\n\n    }\n\n    class Ia extends ka {\n      constructor(t, e) {\n        super(t, e), this.current = [0, 0, 0, 0];\n      }\n\n      set(t) {\n        t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] && t[3] === this.current[3] || (this.current = t, this.gl.uniform4f(this.location, t[0], t[1], t[2], t[3]));\n      }\n\n    }\n\n    class Ma extends ka {\n      constructor(t, e) {\n        super(t, e), this.current = ce.transparent;\n      }\n\n      set(t) {\n        t.r === this.current.r && t.g === this.current.g && t.b === this.current.b && t.a === this.current.a || (this.current = t, this.gl.uniform4f(this.location, t.r, t.g, t.b, t.a));\n      }\n\n    }\n\n    const Ta = new Float32Array(16),\n          za = new Float32Array(9),\n          Ba = new Float32Array(4);\n\n    function Ea(t) {\n      return [bs(255 * t.r, 255 * t.g), bs(255 * t.b, 255 * t.a)];\n    }\n\n    class Ca {\n      constructor(t, e, r) {\n        this.value = t, this.uniformNames = e.map(t => `u_${t}`), this.type = r;\n      }\n\n      setUniform(t, e, r) {\n        t.set(r.constantOr(this.value));\n      }\n\n      getBinding(t, e, r) {\n        return \"color\" === this.type ? new Ma(t, e) : new Sa(t, e);\n      }\n\n    }\n\n    class Da {\n      constructor(t, e) {\n        this.uniformNames = e.map(t => `u_${t}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;\n      }\n\n      setConstantPatternPositions(t, e) {\n        this.pixelRatioFrom = e.pixelRatio || 1, this.pixelRatioTo = t.pixelRatio || 1, this.patternFrom = e.tl.concat(e.br), this.patternTo = t.tl.concat(t.br);\n      }\n\n      setUniform(t, e, r, n) {\n        const i = \"u_pattern_to\" === n || \"u_dash_to\" === n ? this.patternTo : \"u_pattern_from\" === n || \"u_dash_from\" === n ? this.patternFrom : \"u_pixel_ratio_to\" === n ? this.pixelRatioTo : \"u_pixel_ratio_from\" === n ? this.pixelRatioFrom : null;\n        i && t.set(i);\n      }\n\n      getBinding(t, e, r) {\n        return \"u_pattern_from\" === r || \"u_pattern_to\" === r || \"u_dash_from\" === r || \"u_dash_to\" === r ? new Ia(t, e) : new Sa(t, e);\n      }\n\n    }\n\n    class Pa {\n      constructor(t, e, r, n) {\n        this.expression = t, this.type = r, this.maxValue = 0, this.paintVertexAttributes = e.map(t => ({\n          name: `a_${t}`,\n          type: \"Float32\",\n          components: \"color\" === r ? 2 : 1,\n          offset: 0\n        })), this.paintVertexArray = new n();\n      }\n\n      populatePaintArray(t, e, r, n, i, s) {\n        const a = this.paintVertexArray.length,\n              o = this.expression.evaluate(new ss(0), e, {}, i, n, s);\n        this.paintVertexArray.resize(t), this._setPaintValue(a, t, o);\n      }\n\n      updatePaintArray(t, e, r, n, i) {\n        const s = this.expression.evaluate({\n          zoom: 0\n        }, r, n, void 0, i);\n\n        this._setPaintValue(t, e, s);\n      }\n\n      _setPaintValue(t, e, r) {\n        if (\"color\" === this.type) {\n          const n = Ea(r);\n\n          for (let r = t; r < e; r++) this.paintVertexArray.emplace(r, n[0], n[1]);\n        } else {\n          for (let n = t; n < e; n++) this.paintVertexArray.emplace(n, r);\n\n          this.maxValue = Math.max(this.maxValue, Math.abs(r));\n        }\n      }\n\n      upload(t) {\n        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));\n      }\n\n      destroy() {\n        this.paintVertexBuffer && this.paintVertexBuffer.destroy();\n      }\n\n    }\n\n    class Va {\n      constructor(t, e, r, n, i, s) {\n        this.expression = t, this.uniformNames = e.map(t => `u_${t}_t`), this.type = r, this.useIntegerZoom = n, this.zoom = i, this.maxValue = 0, this.paintVertexAttributes = e.map(t => ({\n          name: `a_${t}`,\n          type: \"Float32\",\n          components: \"color\" === r ? 4 : 2,\n          offset: 0\n        })), this.paintVertexArray = new s();\n      }\n\n      populatePaintArray(t, e, r, n, i, s) {\n        const a = this.expression.evaluate(new ss(this.zoom), e, {}, i, n, s),\n              o = this.expression.evaluate(new ss(this.zoom + 1), e, {}, i, n, s),\n              l = this.paintVertexArray.length;\n        this.paintVertexArray.resize(t), this._setPaintValue(l, t, a, o);\n      }\n\n      updatePaintArray(t, e, r, n, i) {\n        const s = this.expression.evaluate({\n          zoom: this.zoom\n        }, r, n, void 0, i),\n              a = this.expression.evaluate({\n          zoom: this.zoom + 1\n        }, r, n, void 0, i);\n\n        this._setPaintValue(t, e, s, a);\n      }\n\n      _setPaintValue(t, e, r, n) {\n        if (\"color\" === this.type) {\n          const i = Ea(r),\n                s = Ea(n);\n\n          for (let r = t; r < e; r++) this.paintVertexArray.emplace(r, i[0], i[1], s[0], s[1]);\n        } else {\n          for (let i = t; i < e; i++) this.paintVertexArray.emplace(i, r, n);\n\n          this.maxValue = Math.max(this.maxValue, Math.abs(r), Math.abs(n));\n        }\n      }\n\n      upload(t) {\n        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));\n      }\n\n      destroy() {\n        this.paintVertexBuffer && this.paintVertexBuffer.destroy();\n      }\n\n      setUniform(t, e) {\n        const r = this.useIntegerZoom ? Math.floor(e.zoom) : e.zoom,\n              n = y(this.expression.interpolationFactor(r, this.zoom, this.zoom + 1), 0, 1);\n        t.set(n);\n      }\n\n      getBinding(t, e, r) {\n        return new Sa(t, e);\n      }\n\n    }\n\n    class Fa {\n      constructor(t, e, r, n, i, s, a) {\n        this.expression = t, this.type = r, this.useIntegerZoom = n, this.zoom = i, this.layerId = a, this.paintVertexAttributes = (\"array\" === r ? ya : da).members;\n\n        for (let t = 0; t < e.length; ++t);\n\n        this.zoomInPaintVertexArray = new s(), this.zoomOutPaintVertexArray = new s();\n      }\n\n      populatePaintArray(t, e, r) {\n        const n = this.zoomInPaintVertexArray.length;\n        this.zoomInPaintVertexArray.resize(t), this.zoomOutPaintVertexArray.resize(t), this._setPaintValues(n, t, e.patterns && e.patterns[this.layerId], r);\n      }\n\n      updatePaintArray(t, e, r, n, i, s) {\n        this._setPaintValues(t, e, r.patterns && r.patterns[this.layerId], s);\n      }\n\n      _setPaintValues(t, e, r, n) {\n        if (!n || !r) return;\n        const {\n          min: i,\n          mid: s,\n          max: a\n        } = r,\n              o = n[i],\n              l = n[s],\n              u = n[a];\n        if (o && l && u) for (let r = t; r < e; r++) this._setPaintValue(this.zoomInPaintVertexArray, r, l, o), this._setPaintValue(this.zoomOutPaintVertexArray, r, l, u);\n      }\n\n      _setPaintValue(t, e, r, n) {\n        t.emplace(e, r.tl[0], r.tl[1], r.br[0], r.br[1], n.tl[0], n.tl[1], n.br[0], n.br[1], r.pixelRatio, n.pixelRatio);\n      }\n\n      upload(t) {\n        this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t.createVertexBuffer(this.zoomInPaintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t.createVertexBuffer(this.zoomOutPaintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));\n      }\n\n      destroy() {\n        this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();\n      }\n\n    }\n\n    class La {\n      constructor(t, e, r = () => !0) {\n        this.binders = {}, this._buffers = [];\n        const n = [];\n\n        for (const i in t.paint._values) {\n          if (!r(i)) continue;\n          const s = t.paint.get(i);\n          if (!(s instanceof ps && Yr(s.property.specification))) continue;\n          const a = $a(i, t.type),\n                o = s.value,\n                l = s.property.specification.type,\n                u = s.property.useIntegerZoom,\n                c = s.property.specification[\"property-type\"],\n                h = \"cross-faded\" === c || \"cross-faded-data-driven\" === c,\n                p = \"line-dasharray\" === String(i) && \"constant\" !== t.layout.get(\"line-cap\").value.kind;\n          if (\"constant\" !== o.kind || p) {\n            if (\"source\" === o.kind || p || h) {\n              const r = qa(i, l, \"source\");\n              this.binders[i] = h ? new Fa(o, a, l, u, e, r, t.id) : new Pa(o, a, l, r), n.push(`/a_${i}`);\n            } else {\n              const t = qa(i, l, \"composite\");\n              this.binders[i] = new Va(o, a, l, u, e, t), n.push(`/z_${i}`);\n            }\n          } else this.binders[i] = h ? new Da(o.value, a) : new Ca(o.value, a, l), n.push(`/u_${i}`);\n        }\n\n        this.cacheKey = n.sort().join(\"\");\n      }\n\n      getMaxValue(t) {\n        const e = this.binders[t];\n        return e instanceof Pa || e instanceof Va ? e.maxValue : 0;\n      }\n\n      populatePaintArrays(t, e, r, n, i, s) {\n        for (const a in this.binders) {\n          const o = this.binders[a];\n          (o instanceof Pa || o instanceof Va || o instanceof Fa) && o.populatePaintArray(t, e, r, n, i, s);\n        }\n      }\n\n      setConstantPatternPositions(t, e) {\n        for (const r in this.binders) {\n          const n = this.binders[r];\n          n instanceof Da && n.setConstantPatternPositions(t, e);\n        }\n      }\n\n      updatePaintArrays(t, e, r, n, i, s) {\n        let a = !1;\n\n        for (const o in t) {\n          const l = e.getPositions(o);\n\n          for (const e of l) {\n            const l = r.feature(e.index);\n\n            for (const r in this.binders) {\n              const u = this.binders[r];\n\n              if ((u instanceof Pa || u instanceof Va || u instanceof Fa) && !0 === u.expression.isStateDependent) {\n                const c = n.paint.get(r);\n                u.expression = c.value, u.updatePaintArray(e.start, e.end, l, t[o], i, s), a = !0;\n              }\n            }\n          }\n        }\n\n        return a;\n      }\n\n      defines() {\n        const t = [];\n\n        for (const e in this.binders) {\n          const r = this.binders[e];\n          (r instanceof Ca || r instanceof Da) && t.push(...r.uniformNames.map(t => `#define HAS_UNIFORM_${t}`));\n        }\n\n        return t;\n      }\n\n      getBinderAttributes() {\n        const t = [];\n\n        for (const e in this.binders) {\n          const r = this.binders[e];\n          if (r instanceof Pa || r instanceof Va || r instanceof Fa) for (let e = 0; e < r.paintVertexAttributes.length; e++) t.push(r.paintVertexAttributes[e].name);\n        }\n\n        return t;\n      }\n\n      getBinderUniforms() {\n        const t = [];\n\n        for (const e in this.binders) {\n          const r = this.binders[e];\n          if (r instanceof Ca || r instanceof Da || r instanceof Va) for (const e of r.uniformNames) t.push(e);\n        }\n\n        return t;\n      }\n\n      getPaintVertexBuffers() {\n        return this._buffers;\n      }\n\n      getUniforms(t, e) {\n        const r = [];\n\n        for (const n in this.binders) {\n          const i = this.binders[n];\n          if (i instanceof Ca || i instanceof Da || i instanceof Va) for (const s of i.uniformNames) if (e[s]) {\n            const a = i.getBinding(t, e[s], s);\n            r.push({\n              name: s,\n              property: n,\n              binding: a\n            });\n          }\n        }\n\n        return r;\n      }\n\n      setUniforms(t, e, r, n) {\n        for (const {\n          name: t,\n          property: i,\n          binding: s\n        } of e) this.binders[i].setUniform(s, n, r.get(i), t);\n      }\n\n      updatePaintBuffers(t) {\n        this._buffers = [];\n\n        for (const e in this.binders) {\n          const r = this.binders[e];\n\n          if (t && r instanceof Fa) {\n            const e = 2 === t.fromScale ? r.zoomInPaintVertexBuffer : r.zoomOutPaintVertexBuffer;\n            e && this._buffers.push(e);\n          } else (r instanceof Pa || r instanceof Va) && r.paintVertexBuffer && this._buffers.push(r.paintVertexBuffer);\n        }\n      }\n\n      upload(t) {\n        for (const e in this.binders) {\n          const r = this.binders[e];\n          (r instanceof Pa || r instanceof Va || r instanceof Fa) && r.upload(t);\n        }\n\n        this.updatePaintBuffers();\n      }\n\n      destroy() {\n        for (const t in this.binders) {\n          const e = this.binders[t];\n          (e instanceof Pa || e instanceof Va || e instanceof Fa) && e.destroy();\n        }\n      }\n\n    }\n\n    class Ra {\n      constructor(t, e, r = () => !0) {\n        this.programConfigurations = {};\n\n        for (const n of t) this.programConfigurations[n.id] = new La(n, e, r);\n\n        this.needsUpload = !1, this._featureMap = new ba(), this._bufferOffset = 0;\n      }\n\n      populatePaintArrays(t, e, r, n, i, s, a) {\n        for (const r in this.programConfigurations) this.programConfigurations[r].populatePaintArrays(t, e, n, i, s, a);\n\n        void 0 !== e.id && this._featureMap.add(e.id, r, this._bufferOffset, t), this._bufferOffset = t, this.needsUpload = !0;\n      }\n\n      updatePaintArrays(t, e, r, n, i) {\n        for (const s of r) this.needsUpload = this.programConfigurations[s.id].updatePaintArrays(t, this._featureMap, e, s, n, i) || this.needsUpload;\n      }\n\n      get(t) {\n        return this.programConfigurations[t];\n      }\n\n      upload(t) {\n        if (this.needsUpload) {\n          for (const e in this.programConfigurations) this.programConfigurations[e].upload(t);\n\n          this.needsUpload = !1;\n        }\n      }\n\n      destroy() {\n        for (const t in this.programConfigurations) this.programConfigurations[t].destroy();\n      }\n\n    }\n\n    const Ua = {\n      \"text-opacity\": [\"opacity\"],\n      \"icon-opacity\": [\"opacity\"],\n      \"text-color\": [\"fill_color\"],\n      \"icon-color\": [\"fill_color\"],\n      \"text-halo-color\": [\"halo_color\"],\n      \"icon-halo-color\": [\"halo_color\"],\n      \"text-halo-blur\": [\"halo_blur\"],\n      \"icon-halo-blur\": [\"halo_blur\"],\n      \"text-halo-width\": [\"halo_width\"],\n      \"icon-halo-width\": [\"halo_width\"],\n      \"line-gap-width\": [\"gapwidth\"],\n      \"line-pattern\": [\"pattern_to\", \"pattern_from\", \"pixel_ratio_to\", \"pixel_ratio_from\"],\n      \"fill-pattern\": [\"pattern_to\", \"pattern_from\", \"pixel_ratio_to\", \"pixel_ratio_from\"],\n      \"fill-extrusion-pattern\": [\"pattern_to\", \"pattern_from\", \"pixel_ratio_to\", \"pixel_ratio_from\"],\n      \"line-dasharray\": [\"dash_to\", \"dash_from\"]\n    };\n\n    function $a(t, e) {\n      return Ua[t] || [t.replace(`${e}-`, \"\").replace(/-/g, \"_\")];\n    }\n\n    const ja = {\n      \"line-pattern\": {\n        source: Es,\n        composite: Es\n      },\n      \"fill-pattern\": {\n        source: Es,\n        composite: Es\n      },\n      \"fill-extrusion-pattern\": {\n        source: Es,\n        composite: Es\n      },\n      \"line-dasharray\": {\n        source: Cs,\n        composite: Cs\n      }\n    },\n          Oa = {\n      color: {\n        source: Ys,\n        composite: Hs\n      },\n      number: {\n        source: qs,\n        composite: Ys\n      }\n    };\n\n    function qa(t, e, r) {\n      const n = ja[t];\n      return n && n[r] || Oa[e][r];\n    }\n\n    ai(Ca), ai(Da), ai(Pa), ai(Fa), ai(Va), ai(La, {\n      omit: [\"_buffers\"]\n    }), ai(Ra);\n    const Na = \"-transition\";\n\n    class Ga extends Ut {\n      constructor(t, e) {\n        if (super(), this.id = t.id, this.type = t.type, this._featureFilter = {\n          filter: () => !0,\n          needGeometry: !1,\n          needFeature: !1\n        }, this._filterCompiled = !1, \"custom\" !== t.type && (this.metadata = (t = t).metadata, this.minzoom = t.minzoom, this.maxzoom = t.maxzoom, \"background\" !== t.type && \"sky\" !== t.type && (this.source = t.source, this.sourceLayer = t[\"source-layer\"], this.filter = t.filter), e.layout && (this._unevaluatedLayout = new hs(e.layout)), e.paint)) {\n          this._transitionablePaint = new ls(e.paint);\n\n          for (const e in t.paint) this.setPaintProperty(e, t.paint[e], {\n            validate: !1\n          });\n\n          for (const e in t.layout) this.setLayoutProperty(e, t.layout[e], {\n            validate: !1\n          });\n\n          this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new fs(e.paint);\n        }\n      }\n\n      getCrossfadeParameters() {\n        return this._crossfadeParameters;\n      }\n\n      getLayoutProperty(t) {\n        return \"visibility\" === t ? this.visibility : this._unevaluatedLayout.getValue(t);\n      }\n\n      setLayoutProperty(t, e, r = {}) {\n        null != e && this._validate(ti, `layers.${this.id}.layout.${t}`, t, e, r) || (\"visibility\" !== t ? this._unevaluatedLayout.setValue(t, e) : this.visibility = e);\n      }\n\n      getPaintProperty(t) {\n        return M(t, Na) ? this._transitionablePaint.getTransition(t.slice(0, -Na.length)) : this._transitionablePaint.getValue(t);\n      }\n\n      setPaintProperty(t, e, r = {}) {\n        if (null != e && this._validate(Qn, `layers.${this.id}.paint.${t}`, t, e, r)) return !1;\n        if (M(t, Na)) return this._transitionablePaint.setTransition(t.slice(0, -Na.length), e || void 0), !1;\n        {\n          const r = this._transitionablePaint._values[t],\n                n = \"cross-faded-data-driven\" === r.property.specification[\"property-type\"],\n                i = r.value.isDataDriven(),\n                s = r.value;\n          this._transitionablePaint.setValue(t, e), this._handleSpecialPaintPropertyUpdate(t);\n          const a = this._transitionablePaint._values[t].value;\n          return a.isDataDriven() || i || n || this._handleOverridablePaintPropertyUpdate(t, s, a);\n        }\n      }\n\n      _handleSpecialPaintPropertyUpdate(t) {}\n\n      getProgramIds() {\n        return null;\n      }\n\n      getProgramConfiguration(t) {\n        return null;\n      }\n\n      _handleOverridablePaintPropertyUpdate(t, e, r) {\n        return !1;\n      }\n\n      isHidden(t) {\n        return !!(this.minzoom && t < this.minzoom) || !!(this.maxzoom && t >= this.maxzoom) || \"none\" === this.visibility;\n      }\n\n      updateTransitions(t) {\n        this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint);\n      }\n\n      hasTransition() {\n        return this._transitioningPaint.hasTransition();\n      }\n\n      recalculate(t, e) {\n        t.getCrossfadeParameters && (this._crossfadeParameters = t.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, e)), this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, e);\n      }\n\n      serialize() {\n        const t = {\n          id: this.id,\n          type: this.type,\n          source: this.source,\n          \"source-layer\": this.sourceLayer,\n          metadata: this.metadata,\n          minzoom: this.minzoom,\n          maxzoom: this.maxzoom,\n          filter: this.filter,\n          layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),\n          paint: this._transitionablePaint && this._transitionablePaint.serialize()\n        };\n        return this.visibility && (t.layout = t.layout || {}, t.layout.visibility = this.visibility), z(t, (t, e) => !(void 0 === t || \"layout\" === e && !Object.keys(t).length || \"paint\" === e && !Object.keys(t).length));\n      }\n\n      _validate(t, e, r, n, i = {}) {\n        return (!i || !1 !== i.validate) && ri(this, t.call(Jn, {\n          key: e,\n          layerType: this.type,\n          objectKey: r,\n          value: n,\n          styleSpec: $t,\n          style: {\n            glyphs: !0,\n            sprite: !0\n          }\n        }));\n      }\n\n      is3D() {\n        return !1;\n      }\n\n      isSky() {\n        return !1;\n      }\n\n      isTileClipped() {\n        return !1;\n      }\n\n      hasOffscreenPass() {\n        return !1;\n      }\n\n      resize() {}\n\n      isStateDependent() {\n        for (const t in this.paint._values) {\n          const e = this.paint.get(t);\n          if (e instanceof ps && Yr(e.property.specification) && (\"source\" === e.value.kind || \"composite\" === e.value.kind) && e.value.isStateDependent) return !0;\n        }\n\n        return !1;\n      }\n\n      compileFilter() {\n        this._filterCompiled || (this._featureFilter = Sn(this.filter), this._filterCompiled = !0);\n      }\n\n      invalidateCompiledFilter() {\n        this._filterCompiled = !1;\n      }\n\n      dynamicFilter() {\n        return this._featureFilter.dynamicFilter;\n      }\n\n      dynamicFilterNeedsFeature() {\n        return this._featureFilter.needFeature;\n      }\n\n    }\n\n    const Za = ks([{\n      name: \"a_pos\",\n      components: 2,\n      type: \"Int16\"\n    }], 4),\n          Xa = ks([{\n      name: \"a_pos_3\",\n      components: 3,\n      type: \"Int16\"\n    }, {\n      name: \"a_pos_normal_3\",\n      components: 3,\n      type: \"Int16\"\n    }, {\n      name: \"a_scale\",\n      components: 1,\n      type: \"Float32\"\n    }]);\n\n    class Ka {\n      constructor(t = []) {\n        this.segments = t;\n      }\n\n      prepareSegment(t, e, r, n) {\n        let i = this.segments[this.segments.length - 1];\n        return t > Ka.MAX_VERTEX_ARRAY_LENGTH && C(`Max vertices per segment is ${Ka.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}`), (!i || i.vertexLength + t > Ka.MAX_VERTEX_ARRAY_LENGTH || i.sortKey !== n) && (i = {\n          vertexOffset: e.length,\n          primitiveOffset: r.length,\n          vertexLength: 0,\n          primitiveLength: 0\n        }, void 0 !== n && (i.sortKey = n), this.segments.push(i)), i;\n      }\n\n      get() {\n        return this.segments;\n      }\n\n      destroy() {\n        for (const t of this.segments) for (const e in t.vaos) t.vaos[e].destroy();\n      }\n\n      static simpleSegment(t, e, r, n) {\n        return new Ka([{\n          vertexOffset: t,\n          primitiveOffset: e,\n          vertexLength: r,\n          primitiveLength: n,\n          vaos: {},\n          sortKey: 0\n        }]);\n      }\n\n    }\n\n    Ka.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, ai(Ka);\n    var Ya = 8192;\n\n    class Ha {\n      constructor(t, e) {\n        t && (e ? this.setSouthWest(t).setNorthEast(e) : 4 === t.length ? this.setSouthWest([t[0], t[1]]).setNorthEast([t[2], t[3]]) : this.setSouthWest(t[0]).setNorthEast(t[1]));\n      }\n\n      setNorthEast(t) {\n        return this._ne = t instanceof Ja ? new Ja(t.lng, t.lat) : Ja.convert(t), this;\n      }\n\n      setSouthWest(t) {\n        return this._sw = t instanceof Ja ? new Ja(t.lng, t.lat) : Ja.convert(t), this;\n      }\n\n      extend(t) {\n        const e = this._sw,\n              r = this._ne;\n        let n, i;\n        if (t instanceof Ja) n = t, i = t;else {\n          if (!(t instanceof Ha)) return Array.isArray(t) ? 4 === t.length || t.every(Array.isArray) ? this.extend(Ha.convert(t)) : this.extend(Ja.convert(t)) : this;\n          if (n = t._sw, i = t._ne, !n || !i) return this;\n        }\n        return e || r ? (e.lng = Math.min(n.lng, e.lng), e.lat = Math.min(n.lat, e.lat), r.lng = Math.max(i.lng, r.lng), r.lat = Math.max(i.lat, r.lat)) : (this._sw = new Ja(n.lng, n.lat), this._ne = new Ja(i.lng, i.lat)), this;\n      }\n\n      getCenter() {\n        return new Ja((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);\n      }\n\n      getSouthWest() {\n        return this._sw;\n      }\n\n      getNorthEast() {\n        return this._ne;\n      }\n\n      getNorthWest() {\n        return new Ja(this.getWest(), this.getNorth());\n      }\n\n      getSouthEast() {\n        return new Ja(this.getEast(), this.getSouth());\n      }\n\n      getWest() {\n        return this._sw.lng;\n      }\n\n      getSouth() {\n        return this._sw.lat;\n      }\n\n      getEast() {\n        return this._ne.lng;\n      }\n\n      getNorth() {\n        return this._ne.lat;\n      }\n\n      toArray() {\n        return [this._sw.toArray(), this._ne.toArray()];\n      }\n\n      toString() {\n        return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;\n      }\n\n      isEmpty() {\n        return !(this._sw && this._ne);\n      }\n\n      contains(t) {\n        const {\n          lng: e,\n          lat: r\n        } = Ja.convert(t);\n        let n = this._sw.lng <= e && e <= this._ne.lng;\n        return this._sw.lng > this._ne.lng && (n = this._sw.lng >= e && e >= this._ne.lng), this._sw.lat <= r && r <= this._ne.lat && n;\n      }\n\n      static convert(t) {\n        return !t || t instanceof Ha ? t : new Ha(t);\n      }\n\n    }\n\n    const Wa = 6371008.8;\n\n    class Ja {\n      constructor(t, e) {\n        if (isNaN(t) || isNaN(e)) throw new Error(`Invalid LngLat object: (${t}, ${e})`);\n        if (this.lng = +t, this.lat = +e, this.lat > 90 || this.lat < -90) throw new Error(\"Invalid LngLat latitude value: must be between -90 and 90\");\n      }\n\n      wrap() {\n        return new Ja(g(this.lng, -180, 180), this.lat);\n      }\n\n      toArray() {\n        return [this.lng, this.lat];\n      }\n\n      toString() {\n        return `LngLat(${this.lng}, ${this.lat})`;\n      }\n\n      distanceTo(t) {\n        const e = Math.PI / 180,\n              r = this.lat * e,\n              n = t.lat * e,\n              i = Math.sin(r) * Math.sin(n) + Math.cos(r) * Math.cos(n) * Math.cos((t.lng - this.lng) * e);\n        return Wa * Math.acos(Math.min(i, 1));\n      }\n\n      toBounds(t = 0) {\n        const e = 360 * t / 40075017,\n              r = e / Math.cos(Math.PI / 180 * this.lat);\n        return new Ha(new Ja(this.lng - r, this.lat - e), new Ja(this.lng + r, this.lat + e));\n      }\n\n      static convert(t) {\n        if (t instanceof Ja) return t;\n        if (Array.isArray(t) && (2 === t.length || 3 === t.length)) return new Ja(Number(t[0]), Number(t[1]));\n        if (!Array.isArray(t) && \"object\" == typeof t && null !== t) return new Ja(Number(\"lng\" in t ? t.lng : t.lon), Number(t.lat));\n        throw new Error(\"`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]\");\n      }\n\n    }\n\n    const Qa = 2 * Math.PI * Wa;\n\n    function to(t) {\n      return Qa * Math.cos(t * Math.PI / 180);\n    }\n\n    function eo(t) {\n      return (180 + t) / 360;\n    }\n\n    function ro(t) {\n      return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t * Math.PI / 360))) / 360;\n    }\n\n    function no(t, e) {\n      return t / to(e);\n    }\n\n    function io(t) {\n      return 360 * t - 180;\n    }\n\n    function so(t) {\n      return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t) * Math.PI / 180)) - 90;\n    }\n\n    function ao(t, e) {\n      return t * to(so(e));\n    }\n\n    const oo = 85.051129;\n\n    class lo {\n      constructor(t, e, r = 0) {\n        this.x = +t, this.y = +e, this.z = +r;\n      }\n\n      static fromLngLat(t, e = 0) {\n        const r = Ja.convert(t);\n        return new lo(eo(r.lng), ro(r.lat), no(e, r.lat));\n      }\n\n      toLngLat() {\n        return new Ja(io(this.x), so(this.y));\n      }\n\n      toAltitude() {\n        return ao(this.z, this.y);\n      }\n\n      meterInMercatorCoordinateUnits() {\n        return 1 / Qa * (t = so(this.y), 1 / Math.cos(t * Math.PI / 180));\n        var t;\n      }\n\n    }\n\n    function uo(t, e, r, n, s, a, o, l, u) {\n      const c = (e + n) / 2,\n            h = (r + s) / 2,\n            p = new i(c, h);\n      l(p), function (t, e, r, n, i, s) {\n        const a = r - i,\n              o = n - s;\n        return Math.abs((n - e) * a - (r - t) * o) / Math.hypot(a, o);\n      }(p.x, p.y, a.x, a.y, o.x, o.y) >= u ? (uo(t, e, r, c, h, a, p, l, u), uo(t, c, h, n, s, p, o, l, u)) : t.push(o);\n    }\n\n    function co(t, e, r) {\n      let n = t[0],\n          i = n.x,\n          s = n.y;\n      e(n);\n      const a = [n];\n\n      for (let o = 1; o < t.length; o++) {\n        const l = t[o],\n              {\n          x: u,\n          y: c\n        } = l;\n        e(l), uo(a, i, s, u, c, n, l, e, r), i = u, s = c, n = l;\n      }\n\n      return a;\n    }\n\n    const ho = Math.pow(2, 14) - 1,\n          po = -ho - 1;\n\n    function fo(t, e) {\n      const r = Math.round(t.x * e),\n            n = Math.round(t.y * e);\n      return t.x = y(r, po, ho), t.y = y(n, po, ho), (r < t.x || r > t.x + 1 || n < t.y || n > t.y + 1) && C(\"Geometry exceeds allowed extent, reduce your vector tile buffer size\"), t;\n    }\n\n    function yo(t, e, r) {\n      const n = t.loadGeometry(),\n            i = t.extent,\n            s = Ya / i;\n\n      if (e && r && r.projection.isReprojectedInTileSpace) {\n        const s = 1 << e.z,\n              {\n          scale: a,\n          x: o,\n          y: l,\n          projection: u\n        } = r,\n              c = t => {\n          const r = io((e.x + t.x / i) / s),\n                n = so((e.y + t.y / i) / s),\n                c = u.project(r, n);\n          t.x = (c.x * a - o) * i, t.y = (c.y * a - l) * i;\n        };\n\n        for (let e = 0; e < n.length; e++) if (1 !== t.type) n[e] = co(n[e], c, 1);else {\n          const t = [];\n\n          for (const r of n[e]) r.x < 0 || r.x >= i || r.y < 0 || r.y >= i || (c(r), t.push(r));\n\n          n[e] = t;\n        }\n      }\n\n      for (const t of n) for (const e of t) fo(e, s);\n\n      return n;\n    }\n\n    function mo(t, e) {\n      return {\n        type: t.type,\n        id: t.id,\n        properties: t.properties,\n        geometry: e ? yo(t) : []\n      };\n    }\n\n    function go(t, e, r, n, i) {\n      t.emplaceBack(2 * e + (n + 1) / 2, 2 * r + (i + 1) / 2);\n    }\n\n    function xo(t, e, r, n) {\n      const i = 16384;\n      t.emplaceBack(e.x, e.y, e.z, r[0] * i, r[1] * i, r[2] * i, n);\n    }\n\n    class vo {\n      constructor(t) {\n        this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(t => t.id), this.index = t.index, this.hasPattern = !1, this.projection = t.projection, this.layoutVertexArray = new Is(), this.indexArray = new $s(), this.segments = new Ka(), this.programConfigurations = new Ra(t.layers, t.zoom), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id);\n      }\n\n      populate(t, e, r, n) {\n        const i = this.layers[0],\n              s = [];\n        let a = null;\n        \"circle\" === i.type && (a = i.layout.get(\"circle-sort-key\"));\n\n        for (const {\n          feature: e,\n          id: i,\n          index: o,\n          sourceLayerIndex: l\n        } of t) {\n          const t = this.layers[0]._featureFilter.needGeometry,\n                u = mo(e, t);\n          if (!this.layers[0]._featureFilter.filter(new ss(this.zoom), u, r)) continue;\n          const c = a ? a.evaluate(u, {}, r) : void 0,\n                h = {\n            id: i,\n            properties: e.properties,\n            type: e.type,\n            sourceLayerIndex: l,\n            index: o,\n            geometry: t ? u.geometry : yo(e, r, n),\n            patterns: {},\n            sortKey: c\n          };\n          s.push(h);\n        }\n\n        a && s.sort((t, e) => t.sortKey - e.sortKey);\n        let o = null;\n        \"globe\" === n.projection.name && (this.globeExtVertexArray = new fa(), o = n.projection);\n\n        for (const n of s) {\n          const {\n            geometry: i,\n            index: s,\n            sourceLayerIndex: a\n          } = n,\n                l = t[s].feature;\n          this.addFeature(n, i, s, e.availableImages, r, o), e.featureIndex.insert(l, i, s, a, this.index);\n        }\n      }\n\n      update(t, e, r, n) {\n        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r, n);\n      }\n\n      isEmpty() {\n        return 0 === this.layoutVertexArray.length;\n      }\n\n      uploadPending() {\n        return !this.uploaded || this.programConfigurations.needsUpload;\n      }\n\n      upload(t) {\n        this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Za.members), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.globeExtVertexArray && (this.globeExtVertexBuffer = t.createVertexBuffer(this.globeExtVertexArray, Xa.members))), this.programConfigurations.upload(t), this.uploaded = !0;\n      }\n\n      destroy() {\n        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());\n      }\n\n      addFeature(t, e, r, n, i, s) {\n        for (const r of e) for (const e of r) {\n          const r = e.x,\n                n = e.y;\n          if (r < 0 || r >= Ya || n < 0 || n >= Ya) continue;\n\n          if (s) {\n            const t = s.projectTilePoint(r, n, i),\n                  e = s.upVector(i, r, n),\n                  a = so((n / Ya + i.y) / (1 << i.z)),\n                  o = s.pixelsPerMeter(a, 1) / no(1, a),\n                  l = this.globeExtVertexArray;\n            xo(l, t, e, o), xo(l, t, e, o), xo(l, t, e, o), xo(l, t, e, o);\n          }\n\n          const a = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t.sortKey),\n                o = a.vertexLength;\n          go(this.layoutVertexArray, r, n, -1, -1), go(this.layoutVertexArray, r, n, 1, -1), go(this.layoutVertexArray, r, n, 1, 1), go(this.layoutVertexArray, r, n, -1, 1), this.indexArray.emplaceBack(o, o + 1, o + 2), this.indexArray.emplaceBack(o, o + 3, o + 2), a.vertexLength += 4, a.primitiveLength += 2;\n        }\n\n        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, {}, n, i);\n      }\n\n    }\n\n    function bo(t, e) {\n      for (let r = 0; r < t.length; r++) if (zo(e, t[r])) return !0;\n\n      for (let r = 0; r < e.length; r++) if (zo(t, e[r])) return !0;\n\n      return !!ko(t, e);\n    }\n\n    function _o(t, e, r) {\n      return !!zo(t, e) || !!Io(e, t, r);\n    }\n\n    function wo(t, e) {\n      if (1 === t.length) return To(e, t[0]);\n\n      for (let r = 0; r < e.length; r++) {\n        const n = e[r];\n\n        for (let e = 0; e < n.length; e++) if (zo(t, n[e])) return !0;\n      }\n\n      for (let r = 0; r < t.length; r++) if (To(e, t[r])) return !0;\n\n      for (let r = 0; r < e.length; r++) if (ko(t, e[r])) return !0;\n\n      return !1;\n    }\n\n    function Ao(t, e, r) {\n      if (t.length > 1) {\n        if (ko(t, e)) return !0;\n\n        for (let n = 0; n < e.length; n++) if (Io(e[n], t, r)) return !0;\n      }\n\n      for (let n = 0; n < t.length; n++) if (Io(t[n], e, r)) return !0;\n\n      return !1;\n    }\n\n    function ko(t, e) {\n      if (0 === t.length || 0 === e.length) return !1;\n\n      for (let r = 0; r < t.length - 1; r++) {\n        const n = t[r],\n              i = t[r + 1];\n\n        for (let t = 0; t < e.length - 1; t++) if (So(n, i, e[t], e[t + 1])) return !0;\n      }\n\n      return !1;\n    }\n\n    function So(t, e, r, n) {\n      return D(t, r, n) !== D(e, r, n) && D(t, e, r) !== D(t, e, n);\n    }\n\n    function Io(t, e, r) {\n      const n = r * r;\n      if (1 === e.length) return t.distSqr(e[0]) < n;\n\n      for (let r = 1; r < e.length; r++) if (Mo(t, e[r - 1], e[r]) < n) return !0;\n\n      return !1;\n    }\n\n    function Mo(t, e, r) {\n      const n = e.distSqr(r);\n      if (0 === n) return t.distSqr(e);\n      const i = ((t.x - e.x) * (r.x - e.x) + (t.y - e.y) * (r.y - e.y)) / n;\n      return t.distSqr(i < 0 ? e : i > 1 ? r : r.sub(e)._mult(i)._add(e));\n    }\n\n    function To(t, e) {\n      let r,\n          n,\n          i,\n          s = !1;\n\n      for (let a = 0; a < t.length; a++) {\n        r = t[a];\n\n        for (let t = 0, a = r.length - 1; t < r.length; a = t++) n = r[t], i = r[a], n.y > e.y != i.y > e.y && e.x < (i.x - n.x) * (e.y - n.y) / (i.y - n.y) + n.x && (s = !s);\n      }\n\n      return s;\n    }\n\n    function zo(t, e) {\n      let r = !1;\n\n      for (let n = 0, i = t.length - 1; n < t.length; i = n++) {\n        const s = t[n],\n              a = t[i];\n        s.y > e.y != a.y > e.y && e.x < (a.x - s.x) * (e.y - s.y) / (a.y - s.y) + s.x && (r = !r);\n      }\n\n      return r;\n    }\n\n    function Bo(t, e, r, n, s) {\n      for (const i of t) if (e <= i.x && r <= i.y && n >= i.x && s >= i.y) return !0;\n\n      const a = [new i(e, r), new i(e, s), new i(n, s), new i(n, r)];\n      if (t.length > 2) for (const e of a) if (zo(t, e)) return !0;\n\n      for (let e = 0; e < t.length - 1; e++) if (Eo(t[e], t[e + 1], a)) return !0;\n\n      return !1;\n    }\n\n    function Eo(t, e, r) {\n      const n = r[0],\n            i = r[2];\n      if (t.x < n.x && e.x < n.x || t.x > i.x && e.x > i.x || t.y < n.y && e.y < n.y || t.y > i.y && e.y > i.y) return !1;\n      const s = D(t, e, r[0]);\n      return s !== D(t, e, r[1]) || s !== D(t, e, r[2]) || s !== D(t, e, r[3]);\n    }\n\n    function Co(t, e, r) {\n      const n = e.paint.get(t).value;\n      return \"constant\" === n.kind ? n.value : r.programConfigurations.get(e.id).getMaxValue(t);\n    }\n\n    function Do(t) {\n      return Math.sqrt(t[0] * t[0] + t[1] * t[1]);\n    }\n\n    function Po(t, e, r, n, s) {\n      if (!e[0] && !e[1]) return t;\n\n      const a = i.convert(e)._mult(s);\n\n      \"viewport\" === r && a._rotate(-n);\n      const o = [];\n\n      for (let e = 0; e < t.length; e++) o.push(t[e].sub(a));\n\n      return o;\n    }\n\n    function Vo(t, e, r, n) {\n      const s = i.convert(t)._mult(n);\n\n      return \"viewport\" === e && s._rotate(-r), s;\n    }\n\n    ai(vo, {\n      omit: [\"layers\"]\n    });\n    const Fo = new vs({\n      \"circle-sort-key\": new ys($t.layout_circle[\"circle-sort-key\"])\n    });\n    var Lo = {\n      paint: new vs({\n        \"circle-radius\": new ys($t.paint_circle[\"circle-radius\"]),\n        \"circle-color\": new ys($t.paint_circle[\"circle-color\"]),\n        \"circle-blur\": new ys($t.paint_circle[\"circle-blur\"]),\n        \"circle-opacity\": new ys($t.paint_circle[\"circle-opacity\"]),\n        \"circle-translate\": new ds($t.paint_circle[\"circle-translate\"]),\n        \"circle-translate-anchor\": new ds($t.paint_circle[\"circle-translate-anchor\"]),\n        \"circle-pitch-scale\": new ds($t.paint_circle[\"circle-pitch-scale\"]),\n        \"circle-pitch-alignment\": new ds($t.paint_circle[\"circle-pitch-alignment\"]),\n        \"circle-stroke-width\": new ys($t.paint_circle[\"circle-stroke-width\"]),\n        \"circle-stroke-color\": new ys($t.paint_circle[\"circle-stroke-color\"]),\n        \"circle-stroke-opacity\": new ys($t.paint_circle[\"circle-stroke-opacity\"])\n      }),\n      layout: Fo\n    },\n        Ro = 1e-6,\n        Uo = \"undefined\" != typeof Float32Array ? Float32Array : Array;\n\n    function $o() {\n      var t = new Uo(9);\n      return Uo != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[5] = 0, t[6] = 0, t[7] = 0), t[0] = 1, t[4] = 1, t[8] = 1, t;\n    }\n\n    function jo(t) {\n      return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;\n    }\n\n    function Oo(t, e, r) {\n      var n = e[0],\n          i = e[1],\n          s = e[2],\n          a = e[3],\n          o = e[4],\n          l = e[5],\n          u = e[6],\n          c = e[7],\n          h = e[8],\n          p = e[9],\n          f = e[10],\n          d = e[11],\n          y = e[12],\n          m = e[13],\n          g = e[14],\n          x = e[15],\n          v = r[0],\n          b = r[1],\n          _ = r[2],\n          w = r[3];\n      return t[0] = v * n + b * o + _ * h + w * y, t[1] = v * i + b * l + _ * p + w * m, t[2] = v * s + b * u + _ * f + w * g, t[3] = v * a + b * c + _ * d + w * x, t[4] = (v = r[4]) * n + (b = r[5]) * o + (_ = r[6]) * h + (w = r[7]) * y, t[5] = v * i + b * l + _ * p + w * m, t[6] = v * s + b * u + _ * f + w * g, t[7] = v * a + b * c + _ * d + w * x, t[8] = (v = r[8]) * n + (b = r[9]) * o + (_ = r[10]) * h + (w = r[11]) * y, t[9] = v * i + b * l + _ * p + w * m, t[10] = v * s + b * u + _ * f + w * g, t[11] = v * a + b * c + _ * d + w * x, t[12] = (v = r[12]) * n + (b = r[13]) * o + (_ = r[14]) * h + (w = r[15]) * y, t[13] = v * i + b * l + _ * p + w * m, t[14] = v * s + b * u + _ * f + w * g, t[15] = v * a + b * c + _ * d + w * x, t;\n    }\n\n    function qo(t, e, r) {\n      var n,\n          i,\n          s,\n          a,\n          o,\n          l,\n          u,\n          c,\n          h,\n          p,\n          f,\n          d,\n          y = r[0],\n          m = r[1],\n          g = r[2];\n      return e === t ? (t[12] = e[0] * y + e[4] * m + e[8] * g + e[12], t[13] = e[1] * y + e[5] * m + e[9] * g + e[13], t[14] = e[2] * y + e[6] * m + e[10] * g + e[14], t[15] = e[3] * y + e[7] * m + e[11] * g + e[15]) : (i = e[1], s = e[2], a = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8], p = e[9], f = e[10], d = e[11], t[0] = n = e[0], t[1] = i, t[2] = s, t[3] = a, t[4] = o, t[5] = l, t[6] = u, t[7] = c, t[8] = h, t[9] = p, t[10] = f, t[11] = d, t[12] = n * y + o * m + h * g + e[12], t[13] = i * y + l * m + p * g + e[13], t[14] = s * y + u * m + f * g + e[14], t[15] = a * y + c * m + d * g + e[15]), t;\n    }\n\n    function No(t, e, r) {\n      var n = r[0],\n          i = r[1],\n          s = r[2];\n      return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t[3] = e[3] * n, t[4] = e[4] * i, t[5] = e[5] * i, t[6] = e[6] * i, t[7] = e[7] * i, t[8] = e[8] * s, t[9] = e[9] * s, t[10] = e[10] * s, t[11] = e[11] * s, t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t;\n    }\n\n    function Go(t, e, r) {\n      var n = Math.sin(r),\n          i = Math.cos(r),\n          s = e[4],\n          a = e[5],\n          o = e[6],\n          l = e[7],\n          u = e[8],\n          c = e[9],\n          h = e[10],\n          p = e[11];\n      return e !== t && (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[4] = s * i + u * n, t[5] = a * i + c * n, t[6] = o * i + h * n, t[7] = l * i + p * n, t[8] = u * i - s * n, t[9] = c * i - a * n, t[10] = h * i - o * n, t[11] = p * i - l * n, t;\n    }\n\n    function Zo(t, e, r) {\n      var n = Math.sin(r),\n          i = Math.cos(r),\n          s = e[0],\n          a = e[1],\n          o = e[2],\n          l = e[3],\n          u = e[8],\n          c = e[9],\n          h = e[10],\n          p = e[11];\n      return e !== t && (t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = s * i - u * n, t[1] = a * i - c * n, t[2] = o * i - h * n, t[3] = l * i - p * n, t[8] = s * n + u * i, t[9] = a * n + c * i, t[10] = o * n + h * i, t[11] = l * n + p * i, t;\n    }\n\n    Math.hypot || (Math.hypot = function () {\n      for (var t = 0, e = arguments.length; e--;) t += arguments[e] * arguments[e];\n\n      return Math.sqrt(t);\n    });\n    var Xo = Oo;\n\n    function Ko() {\n      var t = new Uo(3);\n      return Uo != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t;\n    }\n\n    function Yo(t) {\n      var e = new Uo(3);\n      return e[0] = t[0], e[1] = t[1], e[2] = t[2], e;\n    }\n\n    function Ho(t) {\n      return Math.hypot(t[0], t[1], t[2]);\n    }\n\n    function Wo(t, e, r) {\n      var n = new Uo(3);\n      return n[0] = t, n[1] = e, n[2] = r, n;\n    }\n\n    function Jo(t, e, r) {\n      return t[0] = e[0] + r[0], t[1] = e[1] + r[1], t[2] = e[2] + r[2], t;\n    }\n\n    function Qo(t, e, r) {\n      return t[0] = e[0] - r[0], t[1] = e[1] - r[1], t[2] = e[2] - r[2], t;\n    }\n\n    function tl(t, e, r) {\n      return t[0] = e[0] * r[0], t[1] = e[1] * r[1], t[2] = e[2] * r[2], t;\n    }\n\n    function el(t, e, r) {\n      return t[0] = Math.min(e[0], r[0]), t[1] = Math.min(e[1], r[1]), t[2] = Math.min(e[2], r[2]), t;\n    }\n\n    function rl(t, e, r) {\n      return t[0] = Math.max(e[0], r[0]), t[1] = Math.max(e[1], r[1]), t[2] = Math.max(e[2], r[2]), t;\n    }\n\n    function nl(t, e, r) {\n      return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t;\n    }\n\n    function il(t, e, r, n) {\n      return t[0] = e[0] + r[0] * n, t[1] = e[1] + r[1] * n, t[2] = e[2] + r[2] * n, t;\n    }\n\n    function sl(t, e) {\n      var r = e[0],\n          n = e[1],\n          i = e[2],\n          s = r * r + n * n + i * i;\n      return s > 0 && (s = 1 / Math.sqrt(s)), t[0] = e[0] * s, t[1] = e[1] * s, t[2] = e[2] * s, t;\n    }\n\n    function al(t, e) {\n      return t[0] * e[0] + t[1] * e[1] + t[2] * e[2];\n    }\n\n    function ol(t, e, r) {\n      var n = e[0],\n          i = e[1],\n          s = e[2],\n          a = r[0],\n          o = r[1],\n          l = r[2];\n      return t[0] = i * l - s * o, t[1] = s * a - n * l, t[2] = n * o - i * a, t;\n    }\n\n    function ll(t, e, r) {\n      var n = e[0],\n          i = e[1],\n          s = e[2],\n          a = r[3] * n + r[7] * i + r[11] * s + r[15];\n      return t[0] = (r[0] * n + r[4] * i + r[8] * s + r[12]) / (a = a || 1), t[1] = (r[1] * n + r[5] * i + r[9] * s + r[13]) / a, t[2] = (r[2] * n + r[6] * i + r[10] * s + r[14]) / a, t;\n    }\n\n    function ul(t, e, r) {\n      var n = r[0],\n          i = r[1],\n          s = r[2],\n          a = e[0],\n          o = e[1],\n          l = e[2],\n          u = i * l - s * o,\n          c = s * a - n * l,\n          h = n * o - i * a,\n          p = i * h - s * c,\n          f = s * u - n * h,\n          d = n * c - i * u,\n          y = 2 * r[3];\n      return c *= y, h *= y, f *= 2, d *= 2, t[0] = a + (u *= y) + (p *= 2), t[1] = o + c + f, t[2] = l + h + d, t;\n    }\n\n    var cl,\n        hl = Qo,\n        pl = tl,\n        fl = Ho;\n\n    function dl(t, e, r) {\n      var n = e[0],\n          i = e[1],\n          s = e[2],\n          a = e[3];\n      return t[0] = r[0] * n + r[4] * i + r[8] * s + r[12] * a, t[1] = r[1] * n + r[5] * i + r[9] * s + r[13] * a, t[2] = r[2] * n + r[6] * i + r[10] * s + r[14] * a, t[3] = r[3] * n + r[7] * i + r[11] * s + r[15] * a, t;\n    }\n\n    function yl() {\n      var t = new Uo(4);\n      return Uo != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t[3] = 1, t;\n    }\n\n    function ml(t) {\n      return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t;\n    }\n\n    function gl(t, e, r) {\n      r *= .5;\n      var n = e[0],\n          i = e[1],\n          s = e[2],\n          a = e[3],\n          o = Math.sin(r),\n          l = Math.cos(r);\n      return t[0] = n * l + a * o, t[1] = i * l + s * o, t[2] = s * l - i * o, t[3] = a * l - n * o, t;\n    }\n\n    Ko(), cl = new Uo(4), Uo != Float32Array && (cl[0] = 0, cl[1] = 0, cl[2] = 0, cl[3] = 0), Ko(), Wo(1, 0, 0), Wo(0, 1, 0), yl(), yl(), $o();\n\n    class xl {\n      constructor(t, e) {\n        this.points = t, this.planes = e;\n      }\n\n      static fromInvProjectionMatrix(t, e, r, n) {\n        const i = Math.pow(2, r),\n              s = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map(r => {\n          const s = dl([], r, t),\n                a = 1 / s[3] / e * i;\n          return function (t, e, r) {\n            return t[0] = e[0] * r[0], t[1] = e[1] * r[1], t[2] = e[2] * r[2], t[3] = e[3] * r[3], t;\n          }(s, s, [a, a, n ? 1 / s[3] : a, a]);\n        }),\n              a = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map(t => {\n          const e = sl([], ol([], hl([], s[t[0]], s[t[1]]), hl([], s[t[2]], s[t[1]]))),\n                r = -al(e, s[t[1]]);\n          return e.concat(r);\n        });\n        return new xl(s, a);\n      }\n\n    }\n\n    class vl {\n      constructor(t, e) {\n        this.min = t, this.max = e, this.center = nl([], Jo([], this.min, this.max), .5);\n      }\n\n      quadrant(t) {\n        const e = [t % 2 == 0, t < 2],\n              r = Yo(this.min),\n              n = Yo(this.max);\n\n        for (let t = 0; t < e.length; t++) r[t] = e[t] ? this.min[t] : this.center[t], n[t] = e[t] ? this.center[t] : this.max[t];\n\n        return n[2] = this.max[2], new vl(r, n);\n      }\n\n      distanceX(t) {\n        return Math.max(Math.min(this.max[0], t[0]), this.min[0]) - t[0];\n      }\n\n      distanceY(t) {\n        return Math.max(Math.min(this.max[1], t[1]), this.min[1]) - t[1];\n      }\n\n      distanceZ(t) {\n        return Math.max(Math.min(this.max[2], t[2]), this.min[2]) - t[2];\n      }\n\n      getCorners() {\n        const t = this.min,\n              e = this.max;\n        return [[t[0], t[1], t[2]], [e[0], t[1], t[2]], [e[0], e[1], t[2]], [t[0], e[1], t[2]], [t[0], t[1], e[2]], [e[0], t[1], e[2]], [e[0], e[1], e[2]], [t[0], e[1], e[2]]];\n      }\n\n      intersects(t) {\n        const e = this.getCorners();\n        let r = !0;\n\n        for (let n = 0; n < t.planes.length; n++) {\n          const i = t.planes[n];\n          let s = 0;\n\n          for (let t = 0; t < e.length; t++) s += al(i, e[t]) + i[3] >= 0;\n\n          if (0 === s) return 0;\n          s !== e.length && (r = !1);\n        }\n\n        if (r) return 2;\n\n        for (let e = 0; e < 3; e++) {\n          let r = Number.MAX_VALUE,\n              n = -Number.MAX_VALUE;\n\n          for (let i = 0; i < t.points.length; i++) {\n            const s = t.points[i][e] - this.min[e];\n            r = Math.min(r, s), n = Math.max(n, s);\n          }\n\n          if (n < 0 || r > this.max[e] - this.min[e]) return 0;\n        }\n\n        return 1;\n      }\n\n    }\n\n    function bl(t, e, r, n, i, s, a, o, l) {\n      if (s && t.queryGeometry.isAboveHorizon) return !1;\n      s && (l *= t.pixelToTileUnitsFactor);\n\n      for (const u of e) for (const e of u) {\n        const u = e.add(o),\n              c = i && r.elevation ? r.elevation.exaggeration() * i.getElevationAt(u.x, u.y, !0) : 0,\n              h = s ? u : _l(u, c, n),\n              p = s ? t.tilespaceRays.map(t => kl(t, c)) : t.queryGeometry.screenGeometry,\n              f = dl([], [e.x, e.y, c, 1], n);\n        if (!a && s ? l *= f[3] / r.cameraToCenterDistance : a && !s && (l *= r.cameraToCenterDistance / f[3]), _o(p, h, l)) return !0;\n      }\n\n      return !1;\n    }\n\n    function _l(t, e, r) {\n      const n = dl([], [t.x, t.y, e, 1], r);\n      return new i(n[0] / n[3], n[1] / n[3]);\n    }\n\n    const wl = Wo(0, 0, 0),\n          Al = Wo(0, 0, 1);\n\n    function kl(t, e) {\n      const r = Ko();\n      return wl[2] = e, t.intersectsPlane(wl, Al, r), new i(r[0], r[1]);\n    }\n\n    class Sl extends vo {}\n\n    function Il(t, {\n      width: e,\n      height: r\n    }, n, i) {\n      if (i) {\n        if (i instanceof Uint8ClampedArray) i = new Uint8Array(i.buffer);else if (i.length !== e * r * n) throw new RangeError(\"mismatched image size\");\n      } else i = new Uint8Array(e * r * n);\n\n      return t.width = e, t.height = r, t.data = i, t;\n    }\n\n    function Ml(t, e, r) {\n      const {\n        width: n,\n        height: i\n      } = e;\n      n === t.width && i === t.height || (Tl(t, e, {\n        x: 0,\n        y: 0\n      }, {\n        x: 0,\n        y: 0\n      }, {\n        width: Math.min(t.width, n),\n        height: Math.min(t.height, i)\n      }, r), t.width = n, t.height = i, t.data = e.data);\n    }\n\n    function Tl(t, e, r, n, i, s) {\n      if (0 === i.width || 0 === i.height) return e;\n      if (i.width > t.width || i.height > t.height || r.x > t.width - i.width || r.y > t.height - i.height) throw new RangeError(\"out of range source coordinates for image copy\");\n      if (i.width > e.width || i.height > e.height || n.x > e.width - i.width || n.y > e.height - i.height) throw new RangeError(\"out of range destination coordinates for image copy\");\n      const a = t.data,\n            o = e.data;\n\n      for (let l = 0; l < i.height; l++) {\n        const u = ((r.y + l) * t.width + r.x) * s,\n              c = ((n.y + l) * e.width + n.x) * s;\n\n        for (let t = 0; t < i.width * s; t++) o[c + t] = a[u + t];\n      }\n\n      return e;\n    }\n\n    ai(Sl, {\n      omit: [\"layers\"]\n    });\n\n    class zl {\n      constructor(t, e) {\n        Il(this, t, 1, e);\n      }\n\n      resize(t) {\n        Ml(this, new zl(t), 1);\n      }\n\n      clone() {\n        return new zl({\n          width: this.width,\n          height: this.height\n        }, new Uint8Array(this.data));\n      }\n\n      static copy(t, e, r, n, i) {\n        Tl(t, e, r, n, i, 1);\n      }\n\n    }\n\n    class Bl {\n      constructor(t, e) {\n        Il(this, t, 4, e);\n      }\n\n      resize(t) {\n        Ml(this, new Bl(t), 4);\n      }\n\n      replace(t, e) {\n        e ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t;\n      }\n\n      clone() {\n        return new Bl({\n          width: this.width,\n          height: this.height\n        }, new Uint8Array(this.data));\n      }\n\n      static copy(t, e, r, n, i) {\n        Tl(t, e, r, n, i, 4);\n      }\n\n    }\n\n    ai(zl), ai(Bl);\n    var El = {\n      paint: new vs({\n        \"heatmap-radius\": new ys($t.paint_heatmap[\"heatmap-radius\"]),\n        \"heatmap-weight\": new ys($t.paint_heatmap[\"heatmap-weight\"]),\n        \"heatmap-intensity\": new ds($t.paint_heatmap[\"heatmap-intensity\"]),\n        \"heatmap-color\": new xs($t.paint_heatmap[\"heatmap-color\"]),\n        \"heatmap-opacity\": new ds($t.paint_heatmap[\"heatmap-opacity\"])\n      })\n    };\n\n    function Cl(t) {\n      const e = {},\n            r = t.resolution || 256,\n            n = t.clips ? t.clips.length : 1,\n            i = t.image || new Bl({\n        width: r,\n        height: n\n      }),\n            s = (r, n, s) => {\n        e[t.evaluationKey] = s;\n        const a = t.expression.evaluate(e);\n        i.data[r + n + 0] = Math.floor(255 * a.r / a.a), i.data[r + n + 1] = Math.floor(255 * a.g / a.a), i.data[r + n + 2] = Math.floor(255 * a.b / a.a), i.data[r + n + 3] = Math.floor(255 * a.a);\n      };\n\n      if (t.clips) for (let e = 0, i = 0; e < n; ++e, i += 4 * r) for (let n = 0, a = 0; n < r; n++, a += 4) {\n        const o = n / (r - 1),\n              {\n          start: l,\n          end: u\n        } = t.clips[e];\n        s(i, a, l * (1 - o) + u * o);\n      } else for (let t = 0, e = 0; t < r; t++, e += 4) s(0, e, t / (r - 1));\n      return i;\n    }\n\n    var Dl = {\n      paint: new vs({\n        \"hillshade-illumination-direction\": new ds($t.paint_hillshade[\"hillshade-illumination-direction\"]),\n        \"hillshade-illumination-anchor\": new ds($t.paint_hillshade[\"hillshade-illumination-anchor\"]),\n        \"hillshade-exaggeration\": new ds($t.paint_hillshade[\"hillshade-exaggeration\"]),\n        \"hillshade-shadow-color\": new ds($t.paint_hillshade[\"hillshade-shadow-color\"]),\n        \"hillshade-highlight-color\": new ds($t.paint_hillshade[\"hillshade-highlight-color\"]),\n        \"hillshade-accent-color\": new ds($t.paint_hillshade[\"hillshade-accent-color\"])\n      })\n    };\n    const Pl = ks([{\n      name: \"a_pos\",\n      components: 2,\n      type: \"Int16\"\n    }], 4),\n          {\n      members: Vl\n    } = Pl;\n    var Fl = Rl,\n        Ll = Rl;\n\n    function Rl(t, e, r) {\n      r = r || 2;\n      var n,\n          i,\n          s,\n          a,\n          o,\n          l,\n          u,\n          c = e && e.length,\n          h = c ? e[0] * r : t.length,\n          p = Ul(t, 0, h, r, !0),\n          f = [];\n      if (!p || p.next === p.prev) return f;\n\n      if (c && (p = function (t, e, r, n) {\n        var i,\n            s,\n            a,\n            o = [];\n\n        for (i = 0, s = e.length; i < s; i++) (a = Ul(t, e[i] * n, i < s - 1 ? e[i + 1] * n : t.length, n, !1)) === a.next && (a.steiner = !0), o.push(Hl(a));\n\n        for (o.sort(Zl), i = 0; i < o.length; i++) r = $l(r = Xl(o[i], r), r.next);\n\n        return r;\n      }(t, e, p, r)), t.length > 80 * r) {\n        n = s = t[0], i = a = t[1];\n\n        for (var d = r; d < h; d += r) (o = t[d]) < n && (n = o), (l = t[d + 1]) < i && (i = l), o > s && (s = o), l > a && (a = l);\n\n        u = 0 !== (u = Math.max(s - n, a - i)) ? 1 / u : 0;\n      }\n\n      return jl(p, f, r, n, i, u), f;\n    }\n\n    function Ul(t, e, r, n, i) {\n      var s, a;\n      if (i === uu(t, e, r, n) > 0) for (s = e; s < r; s += n) a = au(s, t[s], t[s + 1], a);else for (s = r - n; s >= e; s -= n) a = au(s, t[s], t[s + 1], a);\n      return a && tu(a, a.next) && (ou(a), a = a.next), a;\n    }\n\n    function $l(t, e) {\n      if (!t) return t;\n      e || (e = t);\n      var r,\n          n = t;\n\n      do {\n        if (r = !1, n.steiner || !tu(n, n.next) && 0 !== Ql(n.prev, n, n.next)) n = n.next;else {\n          if (ou(n), (n = e = n.prev) === n.next) break;\n          r = !0;\n        }\n      } while (r || n !== e);\n\n      return e;\n    }\n\n    function jl(t, e, r, n, i, s, a) {\n      if (t) {\n        !a && s && function (t, e, r, n) {\n          var i = t;\n\n          do {\n            null === i.z && (i.z = Yl(i.x, i.y, e, r, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;\n          } while (i !== t);\n\n          i.prevZ.nextZ = null, i.prevZ = null, function (t) {\n            var e,\n                r,\n                n,\n                i,\n                s,\n                a,\n                o,\n                l,\n                u = 1;\n\n            do {\n              for (r = t, t = null, s = null, a = 0; r;) {\n                for (a++, n = r, o = 0, e = 0; e < u && (o++, n = n.nextZ); e++);\n\n                for (l = u; o > 0 || l > 0 && n;) 0 !== o && (0 === l || !n || r.z <= n.z) ? (i = r, r = r.nextZ, o--) : (i = n, n = n.nextZ, l--), s ? s.nextZ = i : t = i, i.prevZ = s, s = i;\n\n                r = n;\n              }\n\n              s.nextZ = null, u *= 2;\n            } while (a > 1);\n          }(i);\n        }(t, n, i, s);\n\n        for (var o, l, u = t; t.prev !== t.next;) if (o = t.prev, l = t.next, s ? ql(t, n, i, s) : Ol(t)) e.push(o.i / r), e.push(t.i / r), e.push(l.i / r), ou(t), t = l.next, u = l.next;else if ((t = l) === u) {\n          a ? 1 === a ? jl(t = Nl($l(t), e, r), e, r, n, i, s, 2) : 2 === a && Gl(t, e, r, n, i, s) : jl($l(t), e, r, n, i, s, 1);\n          break;\n        }\n      }\n    }\n\n    function Ol(t) {\n      var e = t.prev,\n          r = t,\n          n = t.next;\n      if (Ql(e, r, n) >= 0) return !1;\n\n      for (var i = t.next.next; i !== t.prev;) {\n        if (Wl(e.x, e.y, r.x, r.y, n.x, n.y, i.x, i.y) && Ql(i.prev, i, i.next) >= 0) return !1;\n        i = i.next;\n      }\n\n      return !0;\n    }\n\n    function ql(t, e, r, n) {\n      var i = t.prev,\n          s = t,\n          a = t.next;\n      if (Ql(i, s, a) >= 0) return !1;\n\n      for (var o = i.x > s.x ? i.x > a.x ? i.x : a.x : s.x > a.x ? s.x : a.x, l = i.y > s.y ? i.y > a.y ? i.y : a.y : s.y > a.y ? s.y : a.y, u = Yl(i.x < s.x ? i.x < a.x ? i.x : a.x : s.x < a.x ? s.x : a.x, i.y < s.y ? i.y < a.y ? i.y : a.y : s.y < a.y ? s.y : a.y, e, r, n), c = Yl(o, l, e, r, n), h = t.prevZ, p = t.nextZ; h && h.z >= u && p && p.z <= c;) {\n        if (h !== t.prev && h !== t.next && Wl(i.x, i.y, s.x, s.y, a.x, a.y, h.x, h.y) && Ql(h.prev, h, h.next) >= 0) return !1;\n        if (h = h.prevZ, p !== t.prev && p !== t.next && Wl(i.x, i.y, s.x, s.y, a.x, a.y, p.x, p.y) && Ql(p.prev, p, p.next) >= 0) return !1;\n        p = p.nextZ;\n      }\n\n      for (; h && h.z >= u;) {\n        if (h !== t.prev && h !== t.next && Wl(i.x, i.y, s.x, s.y, a.x, a.y, h.x, h.y) && Ql(h.prev, h, h.next) >= 0) return !1;\n        h = h.prevZ;\n      }\n\n      for (; p && p.z <= c;) {\n        if (p !== t.prev && p !== t.next && Wl(i.x, i.y, s.x, s.y, a.x, a.y, p.x, p.y) && Ql(p.prev, p, p.next) >= 0) return !1;\n        p = p.nextZ;\n      }\n\n      return !0;\n    }\n\n    function Nl(t, e, r) {\n      var n = t;\n\n      do {\n        var i = n.prev,\n            s = n.next.next;\n        !tu(i, s) && eu(i, n, n.next, s) && iu(i, s) && iu(s, i) && (e.push(i.i / r), e.push(n.i / r), e.push(s.i / r), ou(n), ou(n.next), n = t = s), n = n.next;\n      } while (n !== t);\n\n      return $l(n);\n    }\n\n    function Gl(t, e, r, n, i, s) {\n      var a = t;\n\n      do {\n        for (var o = a.next.next; o !== a.prev;) {\n          if (a.i !== o.i && Jl(a, o)) {\n            var l = su(a, o);\n            return a = $l(a, a.next), l = $l(l, l.next), jl(a, e, r, n, i, s), void jl(l, e, r, n, i, s);\n          }\n\n          o = o.next;\n        }\n\n        a = a.next;\n      } while (a !== t);\n    }\n\n    function Zl(t, e) {\n      return t.x - e.x;\n    }\n\n    function Xl(t, e) {\n      var r = function (t, e) {\n        var r,\n            n = e,\n            i = t.x,\n            s = t.y,\n            a = -1 / 0;\n\n        do {\n          if (s <= n.y && s >= n.next.y && n.next.y !== n.y) {\n            var o = n.x + (s - n.y) * (n.next.x - n.x) / (n.next.y - n.y);\n\n            if (o <= i && o > a) {\n              if (a = o, o === i) {\n                if (s === n.y) return n;\n                if (s === n.next.y) return n.next;\n              }\n\n              r = n.x < n.next.x ? n : n.next;\n            }\n          }\n\n          n = n.next;\n        } while (n !== e);\n\n        if (!r) return null;\n        if (i === a) return r;\n        var l,\n            u = r,\n            c = r.x,\n            h = r.y,\n            p = 1 / 0;\n        n = r;\n\n        do {\n          i >= n.x && n.x >= c && i !== n.x && Wl(s < h ? i : a, s, c, h, s < h ? a : i, s, n.x, n.y) && (l = Math.abs(s - n.y) / (i - n.x), iu(n, t) && (l < p || l === p && (n.x > r.x || n.x === r.x && Kl(r, n))) && (r = n, p = l)), n = n.next;\n        } while (n !== u);\n\n        return r;\n      }(t, e);\n\n      if (!r) return e;\n      var n = su(r, t),\n          i = $l(r, r.next);\n      return $l(n, n.next), e === r ? i : e;\n    }\n\n    function Kl(t, e) {\n      return Ql(t.prev, t, e.prev) < 0 && Ql(e.next, t, t.next) < 0;\n    }\n\n    function Yl(t, e, r, n, i) {\n      return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - r) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1;\n    }\n\n    function Hl(t) {\n      var e = t,\n          r = t;\n\n      do {\n        (e.x < r.x || e.x === r.x && e.y < r.y) && (r = e), e = e.next;\n      } while (e !== t);\n\n      return r;\n    }\n\n    function Wl(t, e, r, n, i, s, a, o) {\n      return (i - a) * (e - o) - (t - a) * (s - o) >= 0 && (t - a) * (n - o) - (r - a) * (e - o) >= 0 && (r - a) * (s - o) - (i - a) * (n - o) >= 0;\n    }\n\n    function Jl(t, e) {\n      return t.next.i !== e.i && t.prev.i !== e.i && !function (t, e) {\n        var r = t;\n\n        do {\n          if (r.i !== t.i && r.next.i !== t.i && r.i !== e.i && r.next.i !== e.i && eu(r, r.next, t, e)) return !0;\n          r = r.next;\n        } while (r !== t);\n\n        return !1;\n      }(t, e) && (iu(t, e) && iu(e, t) && function (t, e) {\n        var r = t,\n            n = !1,\n            i = (t.x + e.x) / 2,\n            s = (t.y + e.y) / 2;\n\n        do {\n          r.y > s != r.next.y > s && r.next.y !== r.y && i < (r.next.x - r.x) * (s - r.y) / (r.next.y - r.y) + r.x && (n = !n), r = r.next;\n        } while (r !== t);\n\n        return n;\n      }(t, e) && (Ql(t.prev, t, e.prev) || Ql(t, e.prev, e)) || tu(t, e) && Ql(t.prev, t, t.next) > 0 && Ql(e.prev, e, e.next) > 0);\n    }\n\n    function Ql(t, e, r) {\n      return (e.y - t.y) * (r.x - e.x) - (e.x - t.x) * (r.y - e.y);\n    }\n\n    function tu(t, e) {\n      return t.x === e.x && t.y === e.y;\n    }\n\n    function eu(t, e, r, n) {\n      var i = nu(Ql(t, e, r)),\n          s = nu(Ql(t, e, n)),\n          a = nu(Ql(r, n, t)),\n          o = nu(Ql(r, n, e));\n      return i !== s && a !== o || !(0 !== i || !ru(t, r, e)) || !(0 !== s || !ru(t, n, e)) || !(0 !== a || !ru(r, t, n)) || !(0 !== o || !ru(r, e, n));\n    }\n\n    function ru(t, e, r) {\n      return e.x <= Math.max(t.x, r.x) && e.x >= Math.min(t.x, r.x) && e.y <= Math.max(t.y, r.y) && e.y >= Math.min(t.y, r.y);\n    }\n\n    function nu(t) {\n      return t > 0 ? 1 : t < 0 ? -1 : 0;\n    }\n\n    function iu(t, e) {\n      return Ql(t.prev, t, t.next) < 0 ? Ql(t, e, t.next) >= 0 && Ql(t, t.prev, e) >= 0 : Ql(t, e, t.prev) < 0 || Ql(t, t.next, e) < 0;\n    }\n\n    function su(t, e) {\n      var r = new lu(t.i, t.x, t.y),\n          n = new lu(e.i, e.x, e.y),\n          i = t.next,\n          s = e.prev;\n      return t.next = e, e.prev = t, r.next = i, i.prev = r, n.next = r, r.prev = n, s.next = n, n.prev = s, n;\n    }\n\n    function au(t, e, r, n) {\n      var i = new lu(t, e, r);\n      return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i;\n    }\n\n    function ou(t) {\n      t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ);\n    }\n\n    function lu(t, e, r) {\n      this.i = t, this.x = e, this.y = r, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1;\n    }\n\n    function uu(t, e, r, n) {\n      for (var i = 0, s = e, a = r - n; s < r; s += n) i += (t[a] - t[s]) * (t[s + 1] + t[a + 1]), a = s;\n\n      return i;\n    }\n\n    function cu(t, e, r, n, i) {\n      hu(t, e, r || 0, n || t.length - 1, i || fu);\n    }\n\n    function hu(t, e, r, n, i) {\n      for (; n > r;) {\n        if (n - r > 600) {\n          var s = n - r + 1,\n              a = e - r + 1,\n              o = Math.log(s),\n              l = .5 * Math.exp(2 * o / 3),\n              u = .5 * Math.sqrt(o * l * (s - l) / s) * (a - s / 2 < 0 ? -1 : 1);\n          hu(t, e, Math.max(r, Math.floor(e - a * l / s + u)), Math.min(n, Math.floor(e + (s - a) * l / s + u)), i);\n        }\n\n        var c = t[e],\n            h = r,\n            p = n;\n\n        for (pu(t, r, e), i(t[n], c) > 0 && pu(t, r, n); h < p;) {\n          for (pu(t, h, p), h++, p--; i(t[h], c) < 0;) h++;\n\n          for (; i(t[p], c) > 0;) p--;\n        }\n\n        0 === i(t[r], c) ? pu(t, r, p) : pu(t, ++p, n), p <= e && (r = p + 1), e <= p && (n = p - 1);\n      }\n    }\n\n    function pu(t, e, r) {\n      var n = t[e];\n      t[e] = t[r], t[r] = n;\n    }\n\n    function fu(t, e) {\n      return t < e ? -1 : t > e ? 1 : 0;\n    }\n\n    function du(t, e) {\n      const r = t.length;\n      if (r <= 1) return [t];\n      const n = [];\n      let i, s;\n\n      for (let e = 0; e < r; e++) {\n        const r = P(t[e]);\n        0 !== r && (t[e].area = Math.abs(r), void 0 === s && (s = r < 0), s === r < 0 ? (i && n.push(i), i = [t[e]]) : i.push(t[e]));\n      }\n\n      if (i && n.push(i), e > 1) for (let t = 0; t < n.length; t++) n[t].length <= e || (cu(n[t], e, 1, n[t].length - 1, yu), n[t] = n[t].slice(0, e));\n      return n;\n    }\n\n    function yu(t, e) {\n      return e.area - t.area;\n    }\n\n    function mu(t, e, r) {\n      const n = r.patternDependencies;\n      let i = !1;\n\n      for (const r of e) {\n        const e = r.paint.get(`${t}-pattern`);\n        e.isConstant() || (i = !0);\n        const s = e.constantOr(null);\n        s && (i = !0, n[s.to] = !0, n[s.from] = !0);\n      }\n\n      return i;\n    }\n\n    function gu(t, e, r, n, i) {\n      const s = i.patternDependencies;\n\n      for (const a of e) {\n        const e = a.paint.get(`${t}-pattern`).value;\n\n        if (\"constant\" !== e.kind) {\n          let t = e.evaluate({\n            zoom: n - 1\n          }, r, {}, i.availableImages),\n              o = e.evaluate({\n            zoom: n\n          }, r, {}, i.availableImages),\n              l = e.evaluate({\n            zoom: n + 1\n          }, r, {}, i.availableImages);\n          t = t && t.name ? t.name : t, o = o && o.name ? o.name : o, l = l && l.name ? l.name : l, s[t] = !0, s[o] = !0, s[l] = !0, r.patterns[a.id] = {\n            min: t,\n            mid: o,\n            max: l\n          };\n        }\n      }\n\n      return r;\n    }\n\n    Rl.deviation = function (t, e, r, n) {\n      var i = e && e.length,\n          s = Math.abs(uu(t, 0, i ? e[0] * r : t.length, r));\n      if (i) for (var a = 0, o = e.length; a < o; a++) s -= Math.abs(uu(t, e[a] * r, a < o - 1 ? e[a + 1] * r : t.length, r));\n      var l = 0;\n\n      for (a = 0; a < n.length; a += 3) {\n        var u = n[a] * r,\n            c = n[a + 1] * r,\n            h = n[a + 2] * r;\n        l += Math.abs((t[u] - t[h]) * (t[c + 1] - t[u + 1]) - (t[u] - t[c]) * (t[h + 1] - t[u + 1]));\n      }\n\n      return 0 === s && 0 === l ? 0 : Math.abs((l - s) / s);\n    }, Rl.flatten = function (t) {\n      for (var e = t[0][0].length, r = {\n        vertices: [],\n        holes: [],\n        dimensions: e\n      }, n = 0, i = 0; i < t.length; i++) {\n        for (var s = 0; s < t[i].length; s++) for (var a = 0; a < e; a++) r.vertices.push(t[i][s][a]);\n\n        i > 0 && r.holes.push(n += t[i - 1].length);\n      }\n\n      return r;\n    }, Fl.default = Ll;\n\n    class xu {\n      constructor(t) {\n        this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(t => t.id), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new Is(), this.indexArray = new $s(), this.indexArray2 = new Xs(), this.programConfigurations = new Ra(t.layers, t.zoom), this.segments = new Ka(), this.segments2 = new Ka(), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id), this.projection = t.projection;\n      }\n\n      populate(t, e, r, n) {\n        this.hasPattern = mu(\"fill\", this.layers, e);\n        const i = this.layers[0].layout.get(\"fill-sort-key\"),\n              s = [];\n\n        for (const {\n          feature: a,\n          id: o,\n          index: l,\n          sourceLayerIndex: u\n        } of t) {\n          const t = this.layers[0]._featureFilter.needGeometry,\n                c = mo(a, t);\n          if (!this.layers[0]._featureFilter.filter(new ss(this.zoom), c, r)) continue;\n          const h = i ? i.evaluate(c, {}, r, e.availableImages) : void 0,\n                p = {\n            id: o,\n            properties: a.properties,\n            type: a.type,\n            sourceLayerIndex: u,\n            index: l,\n            geometry: t ? c.geometry : yo(a, r, n),\n            patterns: {},\n            sortKey: h\n          };\n          s.push(p);\n        }\n\n        i && s.sort((t, e) => t.sortKey - e.sortKey);\n\n        for (const n of s) {\n          const {\n            geometry: i,\n            index: s,\n            sourceLayerIndex: a\n          } = n;\n\n          if (this.hasPattern) {\n            const t = gu(\"fill\", this.layers, n, this.zoom, e);\n            this.patternFeatures.push(t);\n          } else this.addFeature(n, i, s, r, {}, e.availableImages);\n\n          e.featureIndex.insert(t[s].feature, i, s, a, this.index);\n        }\n      }\n\n      update(t, e, r, n) {\n        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r, n);\n      }\n\n      addFeatures(t, e, r, n, i) {\n        for (const t of this.patternFeatures) this.addFeature(t, t.geometry, t.index, e, r, n);\n      }\n\n      isEmpty() {\n        return 0 === this.layoutVertexArray.length;\n      }\n\n      uploadPending() {\n        return !this.uploaded || this.programConfigurations.needsUpload;\n      }\n\n      upload(t) {\n        this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Vl), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t), this.uploaded = !0;\n      }\n\n      destroy() {\n        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());\n      }\n\n      addFeature(t, e, r, n, i, s = []) {\n        for (const t of du(e, 500)) {\n          let e = 0;\n\n          for (const r of t) e += r.length;\n\n          const r = this.segments.prepareSegment(e, this.layoutVertexArray, this.indexArray),\n                n = r.vertexLength,\n                i = [],\n                s = [];\n\n          for (const e of t) {\n            if (0 === e.length) continue;\n            e !== t[0] && s.push(i.length / 2);\n            const r = this.segments2.prepareSegment(e.length, this.layoutVertexArray, this.indexArray2),\n                  n = r.vertexLength;\n            this.layoutVertexArray.emplaceBack(e[0].x, e[0].y), this.indexArray2.emplaceBack(n + e.length - 1, n), i.push(e[0].x), i.push(e[0].y);\n\n            for (let t = 1; t < e.length; t++) this.layoutVertexArray.emplaceBack(e[t].x, e[t].y), this.indexArray2.emplaceBack(n + t - 1, n + t), i.push(e[t].x), i.push(e[t].y);\n\n            r.vertexLength += e.length, r.primitiveLength += e.length;\n          }\n\n          const a = Fl(i, s);\n\n          for (let t = 0; t < a.length; t += 3) this.indexArray.emplaceBack(n + a[t], n + a[t + 1], n + a[t + 2]);\n\n          r.vertexLength += e, r.primitiveLength += a.length / 3;\n        }\n\n        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, i, s, n);\n      }\n\n    }\n\n    ai(xu, {\n      omit: [\"layers\", \"patternFeatures\"]\n    });\n    const vu = new vs({\n      \"fill-sort-key\": new ys($t.layout_fill[\"fill-sort-key\"])\n    });\n    var bu = {\n      paint: new vs({\n        \"fill-antialias\": new ds($t.paint_fill[\"fill-antialias\"]),\n        \"fill-opacity\": new ys($t.paint_fill[\"fill-opacity\"]),\n        \"fill-color\": new ys($t.paint_fill[\"fill-color\"]),\n        \"fill-outline-color\": new ys($t.paint_fill[\"fill-outline-color\"]),\n        \"fill-translate\": new ds($t.paint_fill[\"fill-translate\"]),\n        \"fill-translate-anchor\": new ds($t.paint_fill[\"fill-translate-anchor\"]),\n        \"fill-pattern\": new ms($t.paint_fill[\"fill-pattern\"])\n      }),\n      layout: vu\n    };\n\n    const _u = ks([{\n      name: \"a_pos_normal_ed\",\n      components: 4,\n      type: \"Int16\"\n    }]),\n          wu = ks([{\n      name: \"a_centroid_pos\",\n      components: 2,\n      type: \"Uint16\"\n    }]),\n          Au = ks([{\n      name: \"a_pos_3\",\n      components: 3,\n      type: \"Int16\"\n    }, {\n      name: \"a_pos_normal_3\",\n      components: 3,\n      type: \"Int16\"\n    }]),\n          {\n      members: ku\n    } = _u;\n\n    var Su = Iu;\n\n    function Iu(t, e, r, n, i) {\n      this.properties = {}, this.extent = r, this.type = 0, this._pbf = t, this._geometry = -1, this._keys = n, this._values = i, t.readFields(Mu, this, e);\n    }\n\n    function Mu(t, e, r) {\n      1 == t ? e.id = r.readVarint() : 2 == t ? function (t, e) {\n        for (var r = t.readVarint() + t.pos; t.pos < r;) {\n          var n = e._keys[t.readVarint()],\n              i = e._values[t.readVarint()];\n\n          e.properties[n] = i;\n        }\n      }(r, e) : 3 == t ? e.type = r.readVarint() : 4 == t && (e._geometry = r.pos);\n    }\n\n    function Tu(t) {\n      for (var e, r, n = 0, i = 0, s = t.length, a = s - 1; i < s; a = i++) n += ((r = t[a]).x - (e = t[i]).x) * (e.y + r.y);\n\n      return n;\n    }\n\n    Iu.types = [\"Unknown\", \"Point\", \"LineString\", \"Polygon\"], Iu.prototype.loadGeometry = function () {\n      var t = this._pbf;\n      t.pos = this._geometry;\n\n      for (var e, r = t.readVarint() + t.pos, n = 1, s = 0, a = 0, o = 0, l = []; t.pos < r;) {\n        if (s <= 0) {\n          var u = t.readVarint();\n          n = 7 & u, s = u >> 3;\n        }\n\n        if (s--, 1 === n || 2 === n) a += t.readSVarint(), o += t.readSVarint(), 1 === n && (e && l.push(e), e = []), e.push(new i(a, o));else {\n          if (7 !== n) throw new Error(\"unknown command \" + n);\n          e && e.push(e[0].clone());\n        }\n      }\n\n      return e && l.push(e), l;\n    }, Iu.prototype.bbox = function () {\n      var t = this._pbf;\n      t.pos = this._geometry;\n\n      for (var e = t.readVarint() + t.pos, r = 1, n = 0, i = 0, s = 0, a = 1 / 0, o = -1 / 0, l = 1 / 0, u = -1 / 0; t.pos < e;) {\n        if (n <= 0) {\n          var c = t.readVarint();\n          r = 7 & c, n = c >> 3;\n        }\n\n        if (n--, 1 === r || 2 === r) (i += t.readSVarint()) < a && (a = i), i > o && (o = i), (s += t.readSVarint()) < l && (l = s), s > u && (u = s);else if (7 !== r) throw new Error(\"unknown command \" + r);\n      }\n\n      return [a, l, o, u];\n    }, Iu.prototype.toGeoJSON = function (t, e, r) {\n      var n,\n          i,\n          s = this.extent * Math.pow(2, r),\n          a = this.extent * t,\n          o = this.extent * e,\n          l = this.loadGeometry(),\n          u = Iu.types[this.type];\n\n      function c(t) {\n        for (var e = 0; e < t.length; e++) {\n          var r = t[e];\n          t[e] = [360 * (r.x + a) / s - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r.y + o) / s) * Math.PI / 180)) - 90];\n        }\n      }\n\n      switch (this.type) {\n        case 1:\n          var h = [];\n\n          for (n = 0; n < l.length; n++) h[n] = l[n][0];\n\n          c(l = h);\n          break;\n\n        case 2:\n          for (n = 0; n < l.length; n++) c(l[n]);\n\n          break;\n\n        case 3:\n          for (l = function (t) {\n            var e = t.length;\n            if (e <= 1) return [t];\n\n            for (var r, n, i = [], s = 0; s < e; s++) {\n              var a = Tu(t[s]);\n              0 !== a && (void 0 === n && (n = a < 0), n === a < 0 ? (r && i.push(r), r = [t[s]]) : r.push(t[s]));\n            }\n\n            return r && i.push(r), i;\n          }(l), n = 0; n < l.length; n++) for (i = 0; i < l[n].length; i++) c(l[n][i]);\n\n      }\n\n      1 === l.length ? l = l[0] : u = \"Multi\" + u;\n      var p = {\n        type: \"Feature\",\n        geometry: {\n          type: u,\n          coordinates: l\n        },\n        properties: this.properties\n      };\n      return \"id\" in this && (p.id = this.id), p;\n    };\n    var zu = Bu;\n\n    function Bu(t, e) {\n      this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t, this._keys = [], this._values = [], this._features = [], t.readFields(Eu, this, e), this.length = this._features.length;\n    }\n\n    function Eu(t, e, r) {\n      15 === t ? e.version = r.readVarint() : 1 === t ? e.name = r.readString() : 5 === t ? e.extent = r.readVarint() : 2 === t ? e._features.push(r.pos) : 3 === t ? e._keys.push(r.readString()) : 4 === t && e._values.push(function (t) {\n        for (var e = null, r = t.readVarint() + t.pos; t.pos < r;) {\n          var n = t.readVarint() >> 3;\n          e = 1 === n ? t.readString() : 2 === n ? t.readFloat() : 3 === n ? t.readDouble() : 4 === n ? t.readVarint64() : 5 === n ? t.readVarint() : 6 === n ? t.readSVarint() : 7 === n ? t.readBoolean() : null;\n        }\n\n        return e;\n      }(r));\n    }\n\n    function Cu(t, e, r) {\n      if (3 === t) {\n        var n = new zu(r, r.readVarint() + r.pos);\n        n.length && (e[n.name] = n);\n      }\n    }\n\n    Bu.prototype.feature = function (t) {\n      if (t < 0 || t >= this._features.length) throw new Error(\"feature index out of bounds\");\n      this._pbf.pos = this._features[t];\n\n      var e = this._pbf.readVarint() + this._pbf.pos;\n\n      return new Su(this._pbf, e, this.extent, this._keys, this._values);\n    };\n\n    var Du = {\n      VectorTile: function (t, e) {\n        this.layers = t.readFields(Cu, {}, e);\n      },\n      VectorTileFeature: Su,\n      VectorTileLayer: zu\n    };\n\n    function Pu(t, e, r, n) {\n      const s = [],\n            a = 0 === n ? (t, e, r, n, s, a) => {\n        t.push(new i(a, r + (a - e) / (n - e) * (s - r)));\n      } : (t, e, r, n, s, a) => {\n        t.push(new i(e + (a - r) / (s - r) * (n - e), a));\n      };\n\n      for (const i of t) {\n        const t = [];\n\n        for (const s of i) {\n          if (s.length <= 2) continue;\n          const i = [];\n\n          for (let t = 0; t < s.length - 1; t++) {\n            const o = s[t].x,\n                  l = s[t].y,\n                  u = s[t + 1].x,\n                  c = s[t + 1].y,\n                  h = 0 === n ? o : l,\n                  p = 0 === n ? u : c;\n            h < e ? p > e && a(i, o, l, u, c, e) : h > r ? p < r && a(i, o, l, u, c, r) : i.push(s[t]), p < e && h >= e && a(i, o, l, u, c, e), p > r && h <= r && a(i, o, l, u, c, r);\n          }\n\n          let o = s[s.length - 1];\n          const l = 0 === n ? o.x : o.y;\n          l >= e && l <= r && i.push(o), i.length && (o = i[i.length - 1], i[0].x === o.x && i[0].y === o.y || i.push(i[0]), t.push(i));\n        }\n\n        t.length && s.push(t);\n      }\n\n      return s;\n    }\n\n    const Vu = Du.VectorTileFeature.types,\n          Fu = Math.pow(2, 13);\n\n    function Lu(t, e, r, n, i, s, a, o) {\n      t.emplaceBack((e << 1) + a, (r << 1) + s, (Math.floor(n * Fu) << 1) + i, Math.round(o));\n    }\n\n    function Ru(t, e, r) {\n      const n = 16384;\n      t.emplaceBack(e.x, e.y, e.z, r[0] * n, r[1] * n, r[2] * n);\n    }\n\n    class Uu {\n      constructor() {\n        this.acc = new i(0, 0), this.polyCount = [];\n      }\n\n      startRing(t) {\n        this.currentPolyCount = {\n          edges: 0,\n          top: 0\n        }, this.polyCount.push(this.currentPolyCount), this.min || (this.min = new i(t.x, t.y), this.max = new i(t.x, t.y));\n      }\n\n      append(t, e) {\n        this.currentPolyCount.edges++, this.acc._add(t);\n        const r = this.min,\n              n = this.max;\n        t.x < r.x ? r.x = t.x : t.x > n.x && (n.x = t.x), t.y < r.y ? r.y = t.y : t.y > n.y && (n.y = t.y), ((0 === t.x || t.x === Ya) && t.x === e.x) != ((0 === t.y || t.y === Ya) && t.y === e.y) && this.processBorderOverlap(t, e), e.x < 0 != t.x < 0 && this.addBorderIntersection(0, rr(e.y, t.y, (0 - e.x) / (t.x - e.x))), e.x > Ya != t.x > Ya && this.addBorderIntersection(1, rr(e.y, t.y, (Ya - e.x) / (t.x - e.x))), e.y < 0 != t.y < 0 && this.addBorderIntersection(2, rr(e.x, t.x, (0 - e.y) / (t.y - e.y))), e.y > Ya != t.y > Ya && this.addBorderIntersection(3, rr(e.x, t.x, (Ya - e.y) / (t.y - e.y)));\n      }\n\n      addBorderIntersection(t, e) {\n        this.borders || (this.borders = [[Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE]]);\n        const r = this.borders[t];\n        e < r[0] && (r[0] = e), e > r[1] && (r[1] = e);\n      }\n\n      processBorderOverlap(t, e) {\n        if (t.x === e.x) {\n          if (t.y === e.y) return;\n          const r = 0 === t.x ? 0 : 1;\n          this.addBorderIntersection(r, e.y), this.addBorderIntersection(r, t.y);\n        } else {\n          const r = 0 === t.y ? 2 : 3;\n          this.addBorderIntersection(r, e.x), this.addBorderIntersection(r, t.x);\n        }\n      }\n\n      centroid() {\n        const t = this.polyCount.reduce((t, e) => t + e.edges, 0);\n        return 0 !== t ? this.acc.div(t)._round() : new i(0, 0);\n      }\n\n      span() {\n        return new i(this.max.x - this.min.x, this.max.y - this.min.y);\n      }\n\n      intersectsCount() {\n        return this.borders.reduce((t, e) => t + +(e[0] !== Number.MAX_VALUE), 0);\n      }\n\n    }\n\n    class $u {\n      constructor(t) {\n        this.zoom = t.zoom, this.canonical = t.canonical, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(t => t.id), this.index = t.index, this.hasPattern = !1, this.projection = t.projection, this.layoutVertexArray = new Ts(), this.centroidVertexArray = new ha(), this.indexArray = new $s(), this.programConfigurations = new Ra(t.layers, t.zoom), this.segments = new Ka(), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id), this.enableTerrain = t.enableTerrain;\n      }\n\n      populate(t, e, r, n) {\n        this.features = [], this.hasPattern = mu(\"fill-extrusion\", this.layers, e), this.featuresOnBorder = [], this.borders = [[], [], [], []], this.borderDoneWithNeighborZ = [-1, -1, -1, -1], this.tileToMeter = function (t) {\n          const e = Math.exp(Math.PI * (1 - t.y / (1 << t.z) * 2));\n          return 80150034 * e / (e * e + 1) / Ya / (1 << t.z);\n        }(r);\n\n        for (const {\n          feature: i,\n          id: s,\n          index: a,\n          sourceLayerIndex: o\n        } of t) {\n          const t = this.layers[0]._featureFilter.needGeometry,\n                l = mo(i, t);\n          if (!this.layers[0]._featureFilter.filter(new ss(this.zoom), l, r)) continue;\n          const u = {\n            id: s,\n            sourceLayerIndex: o,\n            index: a,\n            geometry: t ? l.geometry : yo(i, r, n),\n            properties: i.properties,\n            type: i.type,\n            patterns: {}\n          },\n                c = this.layoutVertexArray.length;\n          this.hasPattern ? this.features.push(gu(\"fill-extrusion\", this.layers, u, this.zoom, e)) : this.addFeature(u, u.geometry, a, r, {}, e.availableImages, n), e.featureIndex.insert(i, u.geometry, a, o, this.index, c);\n        }\n\n        this.sortBorders();\n      }\n\n      addFeatures(t, e, r, n, i) {\n        for (const t of this.features) {\n          const {\n            geometry: s\n          } = t;\n          this.addFeature(t, s, t.index, e, r, n, i);\n        }\n\n        this.sortBorders();\n      }\n\n      update(t, e, r, n) {\n        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r, n);\n      }\n\n      isEmpty() {\n        return 0 === this.layoutVertexArray.length;\n      }\n\n      uploadPending() {\n        return !this.uploaded || this.programConfigurations.needsUpload;\n      }\n\n      upload(t) {\n        this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, ku), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.layoutVertexExtArray && (this.layoutVertexExtBuffer = t.createVertexBuffer(this.layoutVertexExtArray, Au.members, !0))), this.programConfigurations.upload(t), this.uploaded = !0;\n      }\n\n      uploadCentroid(t) {\n        0 !== this.centroidVertexArray.length && (this.centroidVertexBuffer ? this.needsCentroidUpdate && this.centroidVertexBuffer.updateData(this.centroidVertexArray) : this.centroidVertexBuffer = t.createVertexBuffer(this.centroidVertexArray, wu.members, !0), this.needsCentroidUpdate = !1);\n      }\n\n      destroy() {\n        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());\n      }\n\n      addFeature(t, e, r, n, s, a, o) {\n        const l = [new i(0, 0), new i(Ya, Ya)],\n              u = o.projection,\n              c = \"globe\" === u.name,\n              h = this.enableTerrain && !c ? new Uu() : null;\n        c && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new Qs());\n        const p = du(e, 500);\n\n        for (let t = p.length - 1; t >= 0; t--) {\n          const e = p[t];\n          (0 === e.length || (f = e[0]).every(t => t.x <= 0) || f.every(t => t.x >= Ya) || f.every(t => t.y <= 0) || f.every(t => t.y >= Ya)) && p.splice(t, 1);\n        }\n\n        var f;\n        let d;\n\n        if (c) {\n          const t = 11.25,\n                e = 1 << n.z,\n                r = io(n.x / e),\n                s = io((n.x + 1) / e),\n                a = so(n.y / e),\n                o = so((n.y + 1) / e);\n\n          d = function (t, e, r, n, s = 0, a) {\n            const o = [];\n            if (!t.length || !r || !n) return o;\n\n            const l = (t, e) => {\n              for (const r of t) o.push({\n                polygon: r,\n                bounds: e\n              });\n            },\n                  u = Math.ceil(Math.log2(r)),\n                  c = Math.ceil(Math.log2(n)),\n                  h = u - c,\n                  p = [];\n\n            for (let t = 0; t < Math.abs(h); t++) p.push(h > 0 ? 0 : 1);\n\n            for (let t = 0; t < Math.min(u, c); t++) p.push(0), p.push(1);\n\n            let f = t;\n            if (f = Pu(f, e[0].y - s, e[1].y + s, 1), f = Pu(f, e[0].x - s, e[1].x + s, 0), !f.length) return o;\n            const d = [];\n\n            for (p.length ? d.push({\n              polygons: f,\n              bounds: e,\n              depth: 0\n            }) : l(f, e); d.length;) {\n              const t = d.pop(),\n                    e = t.depth,\n                    r = p[e],\n                    n = t.bounds[0],\n                    o = t.bounds[1],\n                    u = 0 === r ? n.x : n.y,\n                    c = 0 === r ? o.x : o.y,\n                    h = a ? a(r, u, c) : .5 * (u + c),\n                    f = Pu(t.polygons, u - s, h + s, r),\n                    y = Pu(t.polygons, h - s, c + s, r);\n\n              if (f.length) {\n                const t = [n, new i(0 === r ? h : o.x, 1 === r ? h : o.y)];\n                p.length > e + 1 ? d.push({\n                  polygons: f,\n                  bounds: t,\n                  depth: e + 1\n                }) : l(f, t);\n              }\n\n              if (y.length) {\n                const t = [new i(0 === r ? h : n.x, 1 === r ? h : n.y), o];\n                p.length > e + 1 ? d.push({\n                  polygons: y,\n                  bounds: t,\n                  depth: e + 1\n                }) : l(y, t);\n              }\n            }\n\n            return o;\n          }(p, l, Math.ceil((s - r) / t), Math.ceil((a - o) / t), 1, (t, r, i) => {\n            if (0 === t) return .5 * (r + i);\n            {\n              const t = so((n.y + r / Ya) / e);\n              return (ro(.5 * (so((n.y + i / Ya) / e) + t)) * e - n.y) * Ya;\n            }\n          });\n        } else {\n          d = [];\n\n          for (const t of p) d.push({\n            polygon: t,\n            bounds: l\n          });\n        }\n\n        for (const e of d) {\n          const r = e.polygon;\n          let i = 0,\n              s = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);\n\n          for (let t = 0; t < r.length; t++) {\n            const a = r[t];\n            if (0 === a.length) continue;\n            i += a.length;\n            let o = 0;\n            h && h.startRing(a[0]);\n\n            for (let t = 0; t < a.length; t++) {\n              const r = a[t];\n\n              if (t >= 1) {\n                const i = a[t - 1];\n\n                if (!ju(r, i, e.bounds)) {\n                  h && h.append(r, i), s.vertexLength + 4 > Ka.MAX_VERTEX_ARRAY_LENGTH && (s = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));\n\n                  const t = r.sub(i)._perp(),\n                        e = t.x / (Math.abs(t.x) + Math.abs(t.y)),\n                        a = t.y > 0 ? 1 : 0,\n                        l = i.dist(r);\n\n                  o + l > 32768 && (o = 0), Lu(this.layoutVertexArray, r.x, r.y, e, a, 0, 0, o), Lu(this.layoutVertexArray, r.x, r.y, e, a, 0, 1, o), o += l, Lu(this.layoutVertexArray, i.x, i.y, e, a, 0, 0, o), Lu(this.layoutVertexArray, i.x, i.y, e, a, 0, 1, o);\n                  const p = s.vertexLength;\n\n                  if (this.indexArray.emplaceBack(p, p + 2, p + 1), this.indexArray.emplaceBack(p + 1, p + 2, p + 3), s.vertexLength += 4, s.primitiveLength += 2, c) {\n                    const t = this.layoutVertexExtArray,\n                          e = u.projectTilePoint(r.x, r.y, n),\n                          s = u.projectTilePoint(i.x, i.y, n),\n                          a = u.upVector(n, r.x, r.y),\n                          o = u.upVector(n, i.x, i.y);\n                    Ru(t, e, a), Ru(t, e, a), Ru(t, s, o), Ru(t, s, o);\n                  }\n                }\n              }\n            }\n          }\n\n          if (s.vertexLength + i > Ka.MAX_VERTEX_ARRAY_LENGTH && (s = this.segments.prepareSegment(i, this.layoutVertexArray, this.indexArray)), \"Polygon\" !== Vu[t.type]) continue;\n          const a = [],\n                o = [],\n                l = s.vertexLength;\n\n          for (let t = 0; t < r.length; t++) {\n            const e = r[t];\n\n            if (0 !== e.length) {\n              e !== r[0] && o.push(a.length / 2);\n\n              for (let t = 0; t < e.length; t++) {\n                const r = e[t];\n                Lu(this.layoutVertexArray, r.x, r.y, 0, 0, 1, 1, 0), a.push(r.x), a.push(r.y), h && h.currentPolyCount.top++, c && Ru(this.layoutVertexExtArray, u.projectTilePoint(r.x, r.y, n), u.upVector(n, r.x, r.y));\n              }\n            }\n          }\n\n          const p = Fl(a, o);\n\n          for (let t = 0; t < p.length; t += 3) this.indexArray.emplaceBack(l + p[t], l + p[t + 2], l + p[t + 1]);\n\n          s.primitiveLength += p.length / 3, s.vertexLength += i;\n        }\n\n        if (h && h.polyCount.length > 0) {\n          if (h.borders) {\n            h.vertexArrayOffset = this.centroidVertexArray.length;\n            const t = h.borders,\n                  e = this.featuresOnBorder.push(h) - 1;\n\n            for (let r = 0; r < 4; r++) t[r][0] !== Number.MAX_VALUE && this.borders[r].push(e);\n          }\n\n          this.encodeCentroid(h.borders ? void 0 : h.centroid(), h);\n        }\n\n        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, s, a, n);\n      }\n\n      sortBorders() {\n        for (let t = 0; t < 4; t++) this.borders[t].sort((e, r) => this.featuresOnBorder[e].borders[t][0] - this.featuresOnBorder[r].borders[t][0]);\n      }\n\n      encodeCentroid(t, e, r = !0) {\n        let n, i;\n        if (t) {\n          if (0 !== t.y) {\n            const r = e.span()._mult(this.tileToMeter);\n\n            n = (Math.max(t.x, 1) << 3) + Math.min(7, Math.round(r.x / 10)), i = (Math.max(t.y, 1) << 3) + Math.min(7, Math.round(r.y / 10));\n          } else n = Math.ceil(7 * (t.x + 450)), i = 0;\n        } else n = 0, i = +r;\n        let s = r ? this.centroidVertexArray.length : e.vertexArrayOffset;\n\n        for (const t of e.polyCount) {\n          r && this.centroidVertexArray.resize(this.centroidVertexArray.length + 4 * t.edges + t.top);\n\n          for (let e = 0; e < 2 * t.edges; e++) this.centroidVertexArray.emplace(s++, 0, i), this.centroidVertexArray.emplace(s++, n, i);\n\n          for (let e = 0; e < t.top; e++) this.centroidVertexArray.emplace(s++, n, i);\n        }\n      }\n\n    }\n\n    function ju(t, e, r) {\n      return t.x === e.x && (t.x < r[0].x || t.x > r[1].x) || t.y === e.y && (t.y < r[0].y || t.y > r[1].y);\n    }\n\n    ai($u, {\n      omit: [\"layers\", \"features\"]\n    }), ai(Uu);\n    var Ou = {\n      paint: new vs({\n        \"fill-extrusion-opacity\": new ds($t[\"paint_fill-extrusion\"][\"fill-extrusion-opacity\"]),\n        \"fill-extrusion-color\": new ys($t[\"paint_fill-extrusion\"][\"fill-extrusion-color\"]),\n        \"fill-extrusion-translate\": new ds($t[\"paint_fill-extrusion\"][\"fill-extrusion-translate\"]),\n        \"fill-extrusion-translate-anchor\": new ds($t[\"paint_fill-extrusion\"][\"fill-extrusion-translate-anchor\"]),\n        \"fill-extrusion-pattern\": new ms($t[\"paint_fill-extrusion\"][\"fill-extrusion-pattern\"]),\n        \"fill-extrusion-height\": new ys($t[\"paint_fill-extrusion\"][\"fill-extrusion-height\"]),\n        \"fill-extrusion-base\": new ys($t[\"paint_fill-extrusion\"][\"fill-extrusion-base\"]),\n        \"fill-extrusion-vertical-gradient\": new ds($t[\"paint_fill-extrusion\"][\"fill-extrusion-vertical-gradient\"])\n      })\n    };\n\n    function qu(t, e) {\n      return t.x * e.x + t.y * e.y;\n    }\n\n    function Nu(t, e) {\n      if (1 === t.length) {\n        let r = 0;\n        const n = e[r++];\n        let i;\n\n        for (; !i || n.equals(i);) if (i = e[r++], !i) return 1 / 0;\n\n        for (; r < e.length; r++) {\n          const s = e[r],\n                a = t[0],\n                o = i.sub(n),\n                l = s.sub(n),\n                u = a.sub(n),\n                c = qu(o, o),\n                h = qu(o, l),\n                p = qu(l, l),\n                f = qu(u, o),\n                d = qu(u, l),\n                y = c * p - h * h,\n                m = (p * f - h * d) / y,\n                g = (c * d - h * f) / y,\n                x = n.z * (1 - m - g) + i.z * m + s.z * g;\n          if (isFinite(x)) return x;\n        }\n\n        return 1 / 0;\n      }\n\n      {\n        let t = 1 / 0;\n\n        for (const r of e) t = Math.min(t, r.z);\n\n        return t;\n      }\n    }\n\n    function Gu(t) {\n      const e = new i(t[0], t[1]);\n      return e.z = t[2], e;\n    }\n\n    function Zu(t, e, r, n, i, s, a, o) {\n      const l = a * i.getElevationAt(t, e, !0, !0),\n            u = 0 !== s[0],\n            c = u ? 0 === s[1] ? a * (s[0] / 7 - 450) : a * function (t, e, r) {\n        const n = Math.floor(e[0] / 8),\n              i = Math.floor(e[1] / 8),\n              s = 10 * (e[0] - 8 * n),\n              a = 10 * (e[1] - 8 * i),\n              o = t.getElevationAt(n, i, !0, !0),\n              l = t.getMeterToDEM(r),\n              u = Math.floor(.5 * (s * l - 1)),\n              c = Math.floor(.5 * (a * l - 1)),\n              h = t.tileCoordToPixel(n, i),\n              p = 2 * u + 1,\n              f = 2 * c + 1,\n              d = function (t, e, r, n, i) {\n          return [t.getElevationAtPixel(e, r, !0), t.getElevationAtPixel(e + i, r, !0), t.getElevationAtPixel(e, r + i, !0), t.getElevationAtPixel(e + n, r + i, !0)];\n        }(t, h.x - u, h.y - c, p, f),\n              y = Math.abs(d[0] - d[1]),\n              m = Math.abs(d[2] - d[3]),\n              g = Math.abs(d[0] - d[2]) + Math.abs(d[1] - d[3]),\n              x = Math.min(.25, .5 * l * (y + m) / p),\n              v = Math.min(.25, .5 * l * g / f);\n\n        return o + Math.max(x * s, v * a);\n      }(i, s, o) : l;\n      return {\n        base: l + (0 === r) ? -1 : r,\n        top: u ? Math.max(c + n, l + r + 2) : l + n\n      };\n    }\n\n    const Xu = ks([{\n      name: \"a_pos_normal\",\n      components: 2,\n      type: \"Int16\"\n    }, {\n      name: \"a_data\",\n      components: 4,\n      type: \"Uint8\"\n    }, {\n      name: \"a_linesofar\",\n      components: 1,\n      type: \"Float32\"\n    }], 4),\n          {\n      members: Ku\n    } = Xu,\n          Yu = ks([{\n      name: \"a_packed\",\n      components: 3,\n      type: \"Float32\"\n    }]),\n          {\n      members: Hu\n    } = Yu,\n          Wu = Du.VectorTileFeature.types,\n          Ju = Math.cos(Math.PI / 180 * 37.5);\n\n    class Qu {\n      constructor(t) {\n        this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(t => t.id), this.index = t.index, this.projection = t.projection, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(t => {\n          this.gradients[t.id] = {};\n        }), this.layoutVertexArray = new zs(), this.layoutVertexArray2 = new Bs(), this.indexArray = new $s(), this.programConfigurations = new Ra(t.layers, t.zoom), this.segments = new Ka(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id);\n      }\n\n      populate(t, e, r, n) {\n        this.hasPattern = mu(\"line\", this.layers, e);\n        const i = this.layers[0].layout.get(\"line-sort-key\"),\n              s = [];\n\n        for (const {\n          feature: e,\n          id: a,\n          index: o,\n          sourceLayerIndex: l\n        } of t) {\n          const t = this.layers[0]._featureFilter.needGeometry,\n                u = mo(e, t);\n          if (!this.layers[0]._featureFilter.filter(new ss(this.zoom), u, r)) continue;\n          const c = i ? i.evaluate(u, {}, r) : void 0,\n                h = {\n            id: a,\n            properties: e.properties,\n            type: e.type,\n            sourceLayerIndex: l,\n            index: o,\n            geometry: t ? u.geometry : yo(e, r, n),\n            patterns: {},\n            sortKey: c\n          };\n          s.push(h);\n        }\n\n        i && s.sort((t, e) => t.sortKey - e.sortKey);\n        const {\n          lineAtlas: a,\n          featureIndex: o\n        } = e,\n              l = this.addConstantDashes(a);\n\n        for (const n of s) {\n          const {\n            geometry: i,\n            index: s,\n            sourceLayerIndex: u\n          } = n;\n\n          if (l && this.addFeatureDashes(n, a), this.hasPattern) {\n            const t = gu(\"line\", this.layers, n, this.zoom, e);\n            this.patternFeatures.push(t);\n          } else this.addFeature(n, i, s, r, a.positions, e.availableImages);\n\n          o.insert(t[s].feature, i, s, u, this.index);\n        }\n      }\n\n      addConstantDashes(t) {\n        let e = !1;\n\n        for (const r of this.layers) {\n          const n = r.paint.get(\"line-dasharray\").value,\n                i = r.layout.get(\"line-cap\").value;\n          if (\"constant\" !== n.kind || \"constant\" !== i.kind) e = !0;else {\n            const e = i.value,\n                  r = n.value;\n            if (!r) continue;\n            t.addDash(r.from, e), t.addDash(r.to, e), r.other && t.addDash(r.other, e);\n          }\n        }\n\n        return e;\n      }\n\n      addFeatureDashes(t, e) {\n        const r = this.zoom;\n\n        for (const n of this.layers) {\n          const i = n.paint.get(\"line-dasharray\").value,\n                s = n.layout.get(\"line-cap\").value;\n          if (\"constant\" === i.kind && \"constant\" === s.kind) continue;\n          let a, o, l, u, c, h;\n\n          if (\"constant\" === i.kind) {\n            const t = i.value;\n            if (!t) continue;\n            a = t.other || t.to, o = t.to, l = t.from;\n          } else a = i.evaluate({\n            zoom: r - 1\n          }, t), o = i.evaluate({\n            zoom: r\n          }, t), l = i.evaluate({\n            zoom: r + 1\n          }, t);\n\n          \"constant\" === s.kind ? u = c = h = s.value : (u = s.evaluate({\n            zoom: r - 1\n          }, t), c = s.evaluate({\n            zoom: r\n          }, t), h = s.evaluate({\n            zoom: r + 1\n          }, t)), e.addDash(a, u), e.addDash(o, c), e.addDash(l, h);\n          const p = e.getKey(a, u),\n                f = e.getKey(o, c),\n                d = e.getKey(l, h);\n          t.patterns[n.id] = {\n            min: p,\n            mid: f,\n            max: d\n          };\n        }\n      }\n\n      update(t, e, r, n) {\n        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r, n);\n      }\n\n      addFeatures(t, e, r, n, i) {\n        for (const t of this.patternFeatures) this.addFeature(t, t.geometry, t.index, e, r, n);\n      }\n\n      isEmpty() {\n        return 0 === this.layoutVertexArray.length;\n      }\n\n      uploadPending() {\n        return !this.uploaded || this.programConfigurations.needsUpload;\n      }\n\n      upload(t) {\n        this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, Hu)), this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Ku), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;\n      }\n\n      destroy() {\n        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());\n      }\n\n      lineFeatureClips(t) {\n        if (t.properties && t.properties.hasOwnProperty(\"mapbox_clip_start\") && t.properties.hasOwnProperty(\"mapbox_clip_end\")) return {\n          start: +t.properties.mapbox_clip_start,\n          end: +t.properties.mapbox_clip_end\n        };\n      }\n\n      addFeature(t, e, r, n, i, s) {\n        const a = this.layers[0].layout,\n              o = a.get(\"line-join\").evaluate(t, {}),\n              l = a.get(\"line-cap\").evaluate(t, {}),\n              u = a.get(\"line-miter-limit\"),\n              c = a.get(\"line-round-limit\");\n        this.lineClips = this.lineFeatureClips(t);\n\n        for (const r of e) this.addLine(r, t, o, l, u, c);\n\n        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, i, s, n);\n      }\n\n      addLine(t, e, r, n, i, s) {\n        if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineSoFar = 0, this.lineClips) {\n          this.lineClipsArray.push(this.lineClips);\n\n          for (let e = 0; e < t.length - 1; e++) this.totalDistance += t[e].dist(t[e + 1]);\n\n          this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);\n        }\n\n        const a = \"Polygon\" === Wu[e.type];\n        let o = t.length;\n\n        for (; o >= 2 && t[o - 1].equals(t[o - 2]);) o--;\n\n        let l = 0;\n\n        for (; l < o - 1 && t[l].equals(t[l + 1]);) l++;\n\n        if (o < (a ? 3 : 2)) return;\n        \"bevel\" === r && (i = 1.05);\n        const u = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0,\n              c = this.segments.prepareSegment(10 * o, this.layoutVertexArray, this.indexArray);\n        let h, p, f, d, y;\n        this.e1 = this.e2 = -1, a && (h = t[o - 2], y = t[l].sub(h)._unit()._perp());\n\n        for (let e = l; e < o; e++) {\n          if (f = e === o - 1 ? a ? t[l + 1] : void 0 : t[e + 1], f && t[e].equals(f)) continue;\n          y && (d = y), h && (p = h), h = t[e], y = f ? f.sub(h)._unit()._perp() : d, d = d || y;\n          let m = d.add(y);\n          0 === m.x && 0 === m.y || m._unit();\n\n          const g = d.x * y.x + d.y * y.y,\n                x = m.x * y.x + m.y * y.y,\n                v = 0 !== x ? 1 / x : 1 / 0,\n                b = 2 * Math.sqrt(2 - 2 * x),\n                _ = x < Ju && p && f,\n                w = d.x * y.y - d.y * y.x > 0;\n\n          if (_ && e > l) {\n            const t = h.dist(p);\n\n            if (t > 2 * u) {\n              const e = h.sub(h.sub(p)._mult(u / t)._round());\n              this.updateDistance(p, e), this.addCurrentVertex(e, d, 0, 0, c), p = e;\n            }\n          }\n\n          const A = p && f;\n          let k = A ? r : a ? \"butt\" : n;\n          if (A && \"round\" === k && (v < s ? k = \"miter\" : v <= 2 && (k = \"fakeround\")), \"miter\" === k && v > i && (k = \"bevel\"), \"bevel\" === k && (v > 2 && (k = \"flipbevel\"), v < i && (k = \"miter\")), p && this.updateDistance(p, h), \"miter\" === k) m._mult(v), this.addCurrentVertex(h, m, 0, 0, c);else if (\"flipbevel\" === k) {\n            if (v > 100) m = y.mult(-1);else {\n              const t = v * d.add(y).mag() / d.sub(y).mag();\n\n              m._perp()._mult(t * (w ? -1 : 1));\n            }\n            this.addCurrentVertex(h, m, 0, 0, c), this.addCurrentVertex(h, m.mult(-1), 0, 0, c);\n          } else if (\"bevel\" === k || \"fakeround\" === k) {\n            const t = -Math.sqrt(v * v - 1),\n                  e = w ? t : 0,\n                  r = w ? 0 : t;\n\n            if (p && this.addCurrentVertex(h, d, e, r, c), \"fakeround\" === k) {\n              const t = Math.round(180 * b / Math.PI / 20);\n\n              for (let e = 1; e < t; e++) {\n                let r = e / t;\n\n                if (.5 !== r) {\n                  const t = r - .5;\n                  r += r * t * (r - 1) * ((1.0904 + g * (g * (3.55645 - 1.43519 * g) - 3.2452)) * t * t + (.848013 + g * (.215638 * g - 1.06021)));\n                }\n\n                const n = y.sub(d)._mult(r)._add(d)._unit()._mult(w ? -1 : 1);\n\n                this.addHalfVertex(h, n.x, n.y, !1, w, 0, c);\n              }\n            }\n\n            f && this.addCurrentVertex(h, y, -e, -r, c);\n          } else if (\"butt\" === k) this.addCurrentVertex(h, m, 0, 0, c);else if (\"square\" === k) {\n            const t = p ? 1 : -1;\n            p || this.addCurrentVertex(h, m, t, t, c), this.addCurrentVertex(h, m, 0, 0, c), p && this.addCurrentVertex(h, m, t, t, c);\n          } else \"round\" === k && (p && (this.addCurrentVertex(h, d, 0, 0, c), this.addCurrentVertex(h, d, 1, 1, c, !0)), f && (this.addCurrentVertex(h, y, -1, -1, c, !0), this.addCurrentVertex(h, y, 0, 0, c)));\n\n          if (_ && e < o - 1) {\n            const t = h.dist(f);\n\n            if (t > 2 * u) {\n              const e = h.add(f.sub(h)._mult(u / t)._round());\n              this.updateDistance(h, e), this.addCurrentVertex(e, y, 0, 0, c), h = e;\n            }\n          }\n        }\n      }\n\n      addCurrentVertex(t, e, r, n, i, s = !1) {\n        const a = e.y * n - e.x,\n              o = -e.y - e.x * n;\n        this.addHalfVertex(t, e.x + e.y * r, e.y - e.x * r, s, !1, r, i), this.addHalfVertex(t, a, o, s, !0, -n, i);\n      }\n\n      addHalfVertex({\n        x: t,\n        y: e\n      }, r, n, i, s, a, o) {\n        this.layoutVertexArray.emplaceBack((t << 1) + (i ? 1 : 0), (e << 1) + (s ? 1 : 0), Math.round(63 * r) + 128, Math.round(63 * n) + 128, 1 + (0 === a ? 0 : a < 0 ? -1 : 1), 0, this.lineSoFar), this.lineClips && this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, this.lineSoFar);\n        const l = o.vertexLength++;\n        this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, l), o.primitiveLength++), s ? this.e2 = l : this.e1 = l;\n      }\n\n      updateScaledDistance() {\n        if (this.lineClips) {\n          const t = this.totalDistance / (this.lineClips.end - this.lineClips.start);\n          this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = t * this.lineClips.start + this.distance;\n        } else this.lineSoFar = this.distance;\n      }\n\n      updateDistance(t, e) {\n        this.distance += t.dist(e), this.updateScaledDistance();\n      }\n\n    }\n\n    ai(Qu, {\n      omit: [\"layers\", \"patternFeatures\"]\n    });\n    const tc = new vs({\n      \"line-cap\": new ys($t.layout_line[\"line-cap\"]),\n      \"line-join\": new ys($t.layout_line[\"line-join\"]),\n      \"line-miter-limit\": new ds($t.layout_line[\"line-miter-limit\"]),\n      \"line-round-limit\": new ds($t.layout_line[\"line-round-limit\"]),\n      \"line-sort-key\": new ys($t.layout_line[\"line-sort-key\"])\n    });\n    var ec = {\n      paint: new vs({\n        \"line-opacity\": new ys($t.paint_line[\"line-opacity\"]),\n        \"line-color\": new ys($t.paint_line[\"line-color\"]),\n        \"line-translate\": new ds($t.paint_line[\"line-translate\"]),\n        \"line-translate-anchor\": new ds($t.paint_line[\"line-translate-anchor\"]),\n        \"line-width\": new ys($t.paint_line[\"line-width\"]),\n        \"line-gap-width\": new ys($t.paint_line[\"line-gap-width\"]),\n        \"line-offset\": new ys($t.paint_line[\"line-offset\"]),\n        \"line-blur\": new ys($t.paint_line[\"line-blur\"]),\n        \"line-dasharray\": new ms($t.paint_line[\"line-dasharray\"]),\n        \"line-pattern\": new ms($t.paint_line[\"line-pattern\"]),\n        \"line-gradient\": new xs($t.paint_line[\"line-gradient\"])\n      }),\n      layout: tc\n    };\n    const rc = new class extends ys {\n      possiblyEvaluate(t, e) {\n        return e = new ss(Math.floor(e.zoom), {\n          now: e.now,\n          fadeDuration: e.fadeDuration,\n          zoomHistory: e.zoomHistory,\n          transition: e.transition\n        }), super.possiblyEvaluate(t, e);\n      }\n\n      evaluate(t, e, r, n) {\n        return e = b({}, e, {\n          zoom: Math.floor(e.zoom)\n        }), super.evaluate(t, e, r, n);\n      }\n\n    }(ec.paint.properties[\"line-width\"].specification);\n\n    function nc(t, e) {\n      return e > 0 ? e + 2 * t : t;\n    }\n\n    rc.useIntegerZoom = !0;\n    const ic = ks([{\n      name: \"a_pos_offset\",\n      components: 4,\n      type: \"Int16\"\n    }, {\n      name: \"a_tex_size\",\n      components: 4,\n      type: \"Uint16\"\n    }, {\n      name: \"a_pixeloffset\",\n      components: 4,\n      type: \"Int16\"\n    }, {\n      name: \"a_z_tile_anchor\",\n      components: 4,\n      type: \"Int16\"\n    }], 4),\n          sc = ks([{\n      name: \"a_projected_pos\",\n      components: 3,\n      type: \"Float32\"\n    }], 4);\n    ks([{\n      name: \"a_fade_opacity\",\n      components: 1,\n      type: \"Uint32\"\n    }], 4);\n    const ac = ks([{\n      name: \"a_placed\",\n      components: 2,\n      type: \"Uint8\"\n    }, {\n      name: \"a_shift\",\n      components: 2,\n      type: \"Float32\"\n    }]),\n          oc = ks([{\n      name: \"a_size_scale\",\n      components: 1,\n      type: \"Float32\"\n    }, {\n      name: \"a_padding\",\n      components: 2,\n      type: \"Float32\"\n    }]);\n    ks([{\n      type: \"Int16\",\n      name: \"projectedAnchorX\"\n    }, {\n      type: \"Int16\",\n      name: \"projectedAnchorY\"\n    }, {\n      type: \"Int16\",\n      name: \"projectedAnchorZ\"\n    }, {\n      type: \"Int16\",\n      name: \"tileAnchorX\"\n    }, {\n      type: \"Int16\",\n      name: \"tileAnchorY\"\n    }, {\n      type: \"Float32\",\n      name: \"x1\"\n    }, {\n      type: \"Float32\",\n      name: \"y1\"\n    }, {\n      type: \"Float32\",\n      name: \"x2\"\n    }, {\n      type: \"Float32\",\n      name: \"y2\"\n    }, {\n      type: \"Int16\",\n      name: \"padding\"\n    }, {\n      type: \"Uint32\",\n      name: \"featureIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"sourceLayerIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"bucketIndex\"\n    }]);\n    const lc = ks([{\n      name: \"a_pos\",\n      components: 3,\n      type: \"Int16\"\n    }, {\n      name: \"a_anchor_pos\",\n      components: 2,\n      type: \"Int16\"\n    }, {\n      name: \"a_extrude\",\n      components: 2,\n      type: \"Int16\"\n    }], 4),\n          uc = ks([{\n      name: \"a_pos_2f\",\n      components: 2,\n      type: \"Float32\"\n    }, {\n      name: \"a_radius\",\n      components: 1,\n      type: \"Float32\"\n    }, {\n      name: \"a_flags\",\n      components: 2,\n      type: \"Int16\"\n    }], 4);\n    ks([{\n      name: \"triangle\",\n      components: 3,\n      type: \"Uint16\"\n    }]), ks([{\n      type: \"Int16\",\n      name: \"projectedAnchorX\"\n    }, {\n      type: \"Int16\",\n      name: \"projectedAnchorY\"\n    }, {\n      type: \"Int16\",\n      name: \"projectedAnchorZ\"\n    }, {\n      type: \"Float32\",\n      name: \"tileAnchorX\"\n    }, {\n      type: \"Float32\",\n      name: \"tileAnchorY\"\n    }, {\n      type: \"Uint16\",\n      name: \"glyphStartIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"numGlyphs\"\n    }, {\n      type: \"Uint32\",\n      name: \"vertexStartIndex\"\n    }, {\n      type: \"Uint32\",\n      name: \"lineStartIndex\"\n    }, {\n      type: \"Uint32\",\n      name: \"lineLength\"\n    }, {\n      type: \"Uint16\",\n      name: \"segment\"\n    }, {\n      type: \"Uint16\",\n      name: \"lowerSize\"\n    }, {\n      type: \"Uint16\",\n      name: \"upperSize\"\n    }, {\n      type: \"Float32\",\n      name: \"lineOffsetX\"\n    }, {\n      type: \"Float32\",\n      name: \"lineOffsetY\"\n    }, {\n      type: \"Uint8\",\n      name: \"writingMode\"\n    }, {\n      type: \"Uint8\",\n      name: \"placedOrientation\"\n    }, {\n      type: \"Uint8\",\n      name: \"hidden\"\n    }, {\n      type: \"Uint32\",\n      name: \"crossTileID\"\n    }, {\n      type: \"Int16\",\n      name: \"associatedIconIndex\"\n    }, {\n      type: \"Uint8\",\n      name: \"flipState\"\n    }]), ks([{\n      type: \"Int16\",\n      name: \"projectedAnchorX\"\n    }, {\n      type: \"Int16\",\n      name: \"projectedAnchorY\"\n    }, {\n      type: \"Int16\",\n      name: \"projectedAnchorZ\"\n    }, {\n      type: \"Float32\",\n      name: \"tileAnchorX\"\n    }, {\n      type: \"Float32\",\n      name: \"tileAnchorY\"\n    }, {\n      type: \"Int16\",\n      name: \"rightJustifiedTextSymbolIndex\"\n    }, {\n      type: \"Int16\",\n      name: \"centerJustifiedTextSymbolIndex\"\n    }, {\n      type: \"Int16\",\n      name: \"leftJustifiedTextSymbolIndex\"\n    }, {\n      type: \"Int16\",\n      name: \"verticalPlacedTextSymbolIndex\"\n    }, {\n      type: \"Int16\",\n      name: \"placedIconSymbolIndex\"\n    }, {\n      type: \"Int16\",\n      name: \"verticalPlacedIconSymbolIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"key\"\n    }, {\n      type: \"Uint16\",\n      name: \"textBoxStartIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"textBoxEndIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"verticalTextBoxStartIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"verticalTextBoxEndIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"iconBoxStartIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"iconBoxEndIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"verticalIconBoxStartIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"verticalIconBoxEndIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"featureIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"numHorizontalGlyphVertices\"\n    }, {\n      type: \"Uint16\",\n      name: \"numVerticalGlyphVertices\"\n    }, {\n      type: \"Uint16\",\n      name: \"numIconVertices\"\n    }, {\n      type: \"Uint16\",\n      name: \"numVerticalIconVertices\"\n    }, {\n      type: \"Uint16\",\n      name: \"useRuntimeCollisionCircles\"\n    }, {\n      type: \"Uint32\",\n      name: \"crossTileID\"\n    }, {\n      type: \"Float32\",\n      components: 2,\n      name: \"textOffset\"\n    }, {\n      type: \"Float32\",\n      name: \"collisionCircleDiameter\"\n    }]), ks([{\n      type: \"Float32\",\n      name: \"offsetX\"\n    }]), ks([{\n      type: \"Int16\",\n      name: \"x\"\n    }, {\n      type: \"Int16\",\n      name: \"y\"\n    }, {\n      type: \"Int16\",\n      name: \"tileUnitDistanceFromAnchor\"\n    }]);\n    var cc = 24;\n    const hc = 128;\n\n    function pc(t, e) {\n      const {\n        expression: r\n      } = e;\n      if (\"constant\" === r.kind) return {\n        kind: \"constant\",\n        layoutSize: r.evaluate(new ss(t + 1))\n      };\n      if (\"source\" === r.kind) return {\n        kind: \"source\"\n      };\n      {\n        const {\n          zoomStops: e,\n          interpolationType: n\n        } = r;\n        let i = 0;\n\n        for (; i < e.length && e[i] <= t;) i++;\n\n        i = Math.max(0, i - 1);\n        let s = i;\n\n        for (; s < e.length && e[s] < t + 1;) s++;\n\n        s = Math.min(e.length - 1, s);\n        const a = e[i],\n              o = e[s];\n        return \"composite\" === r.kind ? {\n          kind: \"composite\",\n          minZoom: a,\n          maxZoom: o,\n          interpolationType: n\n        } : {\n          kind: \"camera\",\n          minZoom: a,\n          maxZoom: o,\n          minSize: r.evaluate(new ss(a)),\n          maxSize: r.evaluate(new ss(o)),\n          interpolationType: n\n        };\n      }\n    }\n\n    function fc(t, {\n      uSize: e,\n      uSizeT: r\n    }, {\n      lowerSize: n,\n      upperSize: i\n    }) {\n      return \"source\" === t.kind ? n / hc : \"composite\" === t.kind ? rr(n / hc, i / hc, r) : e;\n    }\n\n    function dc(t, e) {\n      let r = 0,\n          n = 0;\n      if (\"constant\" === t.kind) n = t.layoutSize;else if (\"source\" !== t.kind) {\n        const {\n          interpolationType: i,\n          minZoom: s,\n          maxZoom: a\n        } = t,\n              o = i ? y(_r.interpolationFactor(i, e, s, a), 0, 1) : 0;\n        \"camera\" === t.kind ? n = rr(t.minSize, t.maxSize, o) : r = o;\n      }\n      return {\n        uSizeT: r,\n        uSize: n\n      };\n    }\n\n    var yc = Object.freeze({\n      __proto__: null,\n      getSizeData: pc,\n      evaluateSizeForFeature: fc,\n      evaluateSizeForZoom: dc,\n      SIZE_PACK_FACTOR: hc\n    });\n\n    function mc(t, e, r) {\n      return t.sections.forEach(t => {\n        t.text = function (t, e, r) {\n          const n = e.layout.get(\"text-transform\").evaluate(r, {});\n          return \"uppercase\" === n ? t = t.toLocaleUpperCase() : \"lowercase\" === n && (t = t.toLocaleLowerCase()), is.applyArabicShaping && (t = is.applyArabicShaping(t)), t;\n        }(t.text, e, r);\n      }), t;\n    }\n\n    const gc = {\n      \"!\": \"ï¸\",\n      \"#\": \"ï¼\",\n      $: \"ï¼\",\n      \"%\": \"ï¼\",\n      \"&\": \"ï¼\",\n      \"(\": \"ï¸µ\",\n      \")\": \"ï¸¶\",\n      \"*\": \"ï¼\",\n      \"+\": \"ï¼\",\n      \",\": \"ï¸\",\n      \"-\": \"ï¸²\",\n      \".\": \"ã»\",\n      \"/\": \"ï¼\",\n      \":\": \"ï¸\",\n      \";\": \"ï¸\",\n      \"<\": \"ï¸¿\",\n      \"=\": \"ï¼\",\n      \">\": \"ï¹\",\n      \"?\": \"ï¸\",\n      \"@\": \"ï¼ \",\n      \"[\": \"ï¹\",\n      \"\\\\\": \"ï¼¼\",\n      \"]\": \"ï¹\",\n      \"^\": \"ï¼¾\",\n      _: \"ï¸³\",\n      \"`\": \"ï½\",\n      \"{\": \"ï¸·\",\n      \"|\": \"â\",\n      \"}\": \"ï¸¸\",\n      \"~\": \"ï½\",\n      \"Â¢\": \"ï¿ \",\n      \"Â£\": \"ï¿¡\",\n      \"Â¥\": \"ï¿¥\",\n      \"Â¦\": \"ï¿¤\",\n      \"Â¬\": \"ï¿¢\",\n      \"Â¯\": \"ï¿£\",\n      \"â\": \"ï¸²\",\n      \"â\": \"ï¸±\",\n      \"â\": \"ï¹\",\n      \"â\": \"ï¹\",\n      \"â\": \"ï¹\",\n      \"â\": \"ï¹\",\n      \"â¦\": \"ï¸\",\n      \"â§\": \"ã»\",\n      \"â©\": \"ï¿¦\",\n      \"ã\": \"ï¸\",\n      \"ã\": \"ï¸\",\n      \"ã\": \"ï¸¿\",\n      \"ã\": \"ï¹\",\n      \"ã\": \"ï¸½\",\n      \"ã\": \"ï¸¾\",\n      \"ã\": \"ï¹\",\n      \"ã\": \"ï¹\",\n      \"ã\": \"ï¹\",\n      \"ã\": \"ï¹\",\n      \"ã\": \"ï¸»\",\n      \"ã\": \"ï¸¼\",\n      \"ã\": \"ï¸¹\",\n      \"ã\": \"ï¸º\",\n      \"ã\": \"ï¸\",\n      \"ã\": \"ï¸\",\n      \"ï¼\": \"ï¸\",\n      \"ï¼\": \"ï¸µ\",\n      \"ï¼\": \"ï¸¶\",\n      \"ï¼\": \"ï¸\",\n      \"ï¼\": \"ï¸²\",\n      \"ï¼\": \"ã»\",\n      \"ï¼\": \"ï¸\",\n      \"ï¼\": \"ï¸\",\n      \"ï¼\": \"ï¸¿\",\n      \"ï¼\": \"ï¹\",\n      \"ï¼\": \"ï¸\",\n      \"ï¼»\": \"ï¹\",\n      \"ï¼½\": \"ï¹\",\n      \"ï¼¿\": \"ï¸³\",\n      \"ï½\": \"ï¸·\",\n      \"ï½\": \"â\",\n      \"ï½\": \"ï¸¸\",\n      \"ï½\": \"ï¸µ\",\n      \"ï½ \": \"ï¸¶\",\n      \"ï½¡\": \"ï¸\",\n      \"ï½¢\": \"ï¹\",\n      \"ï½£\": \"ï¹\"\n    };\n\n    function xc(t) {\n      return \"ï¸¶\" === t || \"ï¹\" === t || \"ï¸¸\" === t || \"ï¹\" === t || \"ï¹\" === t || \"ï¸¾\" === t || \"ï¸¼\" === t || \"ï¸º\" === t || \"ï¸\" === t || \"ï¹\" === t || \"ï¸\" === t || \"ï¸\" === t || \"ï¸\" === t || \"ï½\" === t || \"ï¿£\" === t || \"ï¸\" === t || \"ï¸\" === t;\n    }\n\n    function vc(t) {\n      return \"ï¸µ\" === t || \"ï¹\" === t || \"ï¸·\" === t || \"ï¹\" === t || \"ï¹\" === t || \"ï¸½\" === t || \"ï¸»\" === t || \"ï¸¹\" === t || \"ï¸\" === t || \"ï¸¿\" === t;\n    }\n\n    var bc = function (t, e, r, n, i) {\n      var s,\n          a,\n          o = 8 * i - n - 1,\n          l = (1 << o) - 1,\n          u = l >> 1,\n          c = -7,\n          h = r ? i - 1 : 0,\n          p = r ? -1 : 1,\n          f = t[e + h];\n\n      for (h += p, s = f & (1 << -c) - 1, f >>= -c, c += o; c > 0; s = 256 * s + t[e + h], h += p, c -= 8);\n\n      for (a = s & (1 << -c) - 1, s >>= -c, c += n; c > 0; a = 256 * a + t[e + h], h += p, c -= 8);\n\n      if (0 === s) s = 1 - u;else {\n        if (s === l) return a ? NaN : 1 / 0 * (f ? -1 : 1);\n        a += Math.pow(2, n), s -= u;\n      }\n      return (f ? -1 : 1) * a * Math.pow(2, s - n);\n    },\n        _c = function (t, e, r, n, i, s) {\n      var a,\n          o,\n          l,\n          u = 8 * s - i - 1,\n          c = (1 << u) - 1,\n          h = c >> 1,\n          p = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0,\n          f = n ? 0 : s - 1,\n          d = n ? 1 : -1,\n          y = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0;\n\n      for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (o = isNaN(e) ? 1 : 0, a = c) : (a = Math.floor(Math.log(e) / Math.LN2), e * (l = Math.pow(2, -a)) < 1 && (a--, l *= 2), (e += a + h >= 1 ? p / l : p * Math.pow(2, 1 - h)) * l >= 2 && (a++, l /= 2), a + h >= c ? (o = 0, a = c) : a + h >= 1 ? (o = (e * l - 1) * Math.pow(2, i), a += h) : (o = e * Math.pow(2, h - 1) * Math.pow(2, i), a = 0)); i >= 8; t[r + f] = 255 & o, f += d, o /= 256, i -= 8);\n\n      for (a = a << i | o, u += i; u > 0; t[r + f] = 255 & a, f += d, a /= 256, u -= 8);\n\n      t[r + f - d] |= 128 * y;\n    },\n        wc = Ac;\n\n    function Ac(t) {\n      this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t) ? t : new Uint8Array(t || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;\n    }\n\n    Ac.Varint = 0, Ac.Fixed64 = 1, Ac.Bytes = 2, Ac.Fixed32 = 5;\n    var kc = 4294967296,\n        Sc = 1 / kc,\n        Ic = \"undefined\" == typeof TextDecoder ? null : new TextDecoder(\"utf8\");\n\n    function Mc(t) {\n      return t.type === Ac.Bytes ? t.readVarint() + t.pos : t.pos + 1;\n    }\n\n    function Tc(t, e, r) {\n      return r ? 4294967296 * e + (t >>> 0) : 4294967296 * (e >>> 0) + (t >>> 0);\n    }\n\n    function zc(t, e, r) {\n      var n = e <= 16383 ? 1 : e <= 2097151 ? 2 : e <= 268435455 ? 3 : Math.floor(Math.log(e) / (7 * Math.LN2));\n      r.realloc(n);\n\n      for (var i = r.pos - 1; i >= t; i--) r.buf[i + n] = r.buf[i];\n    }\n\n    function Bc(t, e) {\n      for (var r = 0; r < t.length; r++) e.writeVarint(t[r]);\n    }\n\n    function Ec(t, e) {\n      for (var r = 0; r < t.length; r++) e.writeSVarint(t[r]);\n    }\n\n    function Cc(t, e) {\n      for (var r = 0; r < t.length; r++) e.writeFloat(t[r]);\n    }\n\n    function Dc(t, e) {\n      for (var r = 0; r < t.length; r++) e.writeDouble(t[r]);\n    }\n\n    function Pc(t, e) {\n      for (var r = 0; r < t.length; r++) e.writeBoolean(t[r]);\n    }\n\n    function Vc(t, e) {\n      for (var r = 0; r < t.length; r++) e.writeFixed32(t[r]);\n    }\n\n    function Fc(t, e) {\n      for (var r = 0; r < t.length; r++) e.writeSFixed32(t[r]);\n    }\n\n    function Lc(t, e) {\n      for (var r = 0; r < t.length; r++) e.writeFixed64(t[r]);\n    }\n\n    function Rc(t, e) {\n      for (var r = 0; r < t.length; r++) e.writeSFixed64(t[r]);\n    }\n\n    function Uc(t, e) {\n      return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + 16777216 * t[e + 3];\n    }\n\n    function $c(t, e, r) {\n      t[r] = e, t[r + 1] = e >>> 8, t[r + 2] = e >>> 16, t[r + 3] = e >>> 24;\n    }\n\n    function jc(t, e) {\n      return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + (t[e + 3] << 24);\n    }\n\n    function Oc(t, e, r) {\n      e.glyphs = [], 1 === t && r.readMessage(qc, e);\n    }\n\n    function qc(t, e, r) {\n      if (3 === t) {\n        const {\n          id: t,\n          bitmap: n,\n          width: i,\n          height: s,\n          left: a,\n          top: o,\n          advance: l\n        } = r.readMessage(Nc, {});\n        e.glyphs.push({\n          id: t,\n          bitmap: new zl({\n            width: i + 6,\n            height: s + 6\n          }, n),\n          metrics: {\n            width: i,\n            height: s,\n            left: a,\n            top: o,\n            advance: l\n          }\n        });\n      } else 4 === t ? e.ascender = r.readSVarint() : 5 === t && (e.descender = r.readSVarint());\n    }\n\n    function Nc(t, e, r) {\n      1 === t ? e.id = r.readVarint() : 2 === t ? e.bitmap = r.readBytes() : 3 === t ? e.width = r.readVarint() : 4 === t ? e.height = r.readVarint() : 5 === t ? e.left = r.readSVarint() : 6 === t ? e.top = r.readSVarint() : 7 === t && (e.advance = r.readVarint());\n    }\n\n    function Gc(t) {\n      let e = 0,\n          r = 0;\n\n      for (const n of t) e += n.w * n.h, r = Math.max(r, n.w);\n\n      t.sort((t, e) => e.h - t.h);\n      const n = [{\n        x: 0,\n        y: 0,\n        w: Math.max(Math.ceil(Math.sqrt(e / .95)), r),\n        h: 1 / 0\n      }];\n      let i = 0,\n          s = 0;\n\n      for (const e of t) for (let t = n.length - 1; t >= 0; t--) {\n        const r = n[t];\n\n        if (!(e.w > r.w || e.h > r.h)) {\n          if (e.x = r.x, e.y = r.y, s = Math.max(s, e.y + e.h), i = Math.max(i, e.x + e.w), e.w === r.w && e.h === r.h) {\n            const e = n.pop();\n            t < n.length && (n[t] = e);\n          } else e.h === r.h ? (r.x += e.w, r.w -= e.w) : e.w === r.w ? (r.y += e.h, r.h -= e.h) : (n.push({\n            x: r.x + e.w,\n            y: r.y,\n            w: r.w - e.w,\n            h: e.h\n          }), r.y += e.h, r.h -= e.h);\n\n          break;\n        }\n      }\n\n      return {\n        w: i,\n        h: s,\n        fill: e / (i * s) || 0\n      };\n    }\n\n    Ac.prototype = {\n      destroy: function () {\n        this.buf = null;\n      },\n      readFields: function (t, e, r) {\n        for (r = r || this.length; this.pos < r;) {\n          var n = this.readVarint(),\n              i = n >> 3,\n              s = this.pos;\n          this.type = 7 & n, t(i, e, this), this.pos === s && this.skip(n);\n        }\n\n        return e;\n      },\n      readMessage: function (t, e) {\n        return this.readFields(t, e, this.readVarint() + this.pos);\n      },\n      readFixed32: function () {\n        var t = Uc(this.buf, this.pos);\n        return this.pos += 4, t;\n      },\n      readSFixed32: function () {\n        var t = jc(this.buf, this.pos);\n        return this.pos += 4, t;\n      },\n      readFixed64: function () {\n        var t = Uc(this.buf, this.pos) + Uc(this.buf, this.pos + 4) * kc;\n        return this.pos += 8, t;\n      },\n      readSFixed64: function () {\n        var t = Uc(this.buf, this.pos) + jc(this.buf, this.pos + 4) * kc;\n        return this.pos += 8, t;\n      },\n      readFloat: function () {\n        var t = bc(this.buf, this.pos, !0, 23, 4);\n        return this.pos += 4, t;\n      },\n      readDouble: function () {\n        var t = bc(this.buf, this.pos, !0, 52, 8);\n        return this.pos += 8, t;\n      },\n      readVarint: function (t) {\n        var e,\n            r,\n            n = this.buf;\n        return e = 127 & (r = n[this.pos++]), r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 7, r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 14, r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 21, r < 128 ? e : function (t, e, r) {\n          var n,\n              i,\n              s = r.buf;\n          if (n = (112 & (i = s[r.pos++])) >> 4, i < 128) return Tc(t, n, e);\n          if (n |= (127 & (i = s[r.pos++])) << 3, i < 128) return Tc(t, n, e);\n          if (n |= (127 & (i = s[r.pos++])) << 10, i < 128) return Tc(t, n, e);\n          if (n |= (127 & (i = s[r.pos++])) << 17, i < 128) return Tc(t, n, e);\n          if (n |= (127 & (i = s[r.pos++])) << 24, i < 128) return Tc(t, n, e);\n          if (n |= (1 & (i = s[r.pos++])) << 31, i < 128) return Tc(t, n, e);\n          throw new Error(\"Expected varint not more than 10 bytes\");\n        }(e |= (15 & (r = n[this.pos])) << 28, t, this))));\n      },\n      readVarint64: function () {\n        return this.readVarint(!0);\n      },\n      readSVarint: function () {\n        var t = this.readVarint();\n        return t % 2 == 1 ? (t + 1) / -2 : t / 2;\n      },\n      readBoolean: function () {\n        return Boolean(this.readVarint());\n      },\n      readString: function () {\n        var t = this.readVarint() + this.pos,\n            e = this.pos;\n        return this.pos = t, t - e >= 12 && Ic ? function (t, e, r) {\n          return Ic.decode(t.subarray(e, r));\n        }(this.buf, e, t) : function (t, e, r) {\n          for (var n = \"\", i = e; i < r;) {\n            var s,\n                a,\n                o,\n                l = t[i],\n                u = null,\n                c = l > 239 ? 4 : l > 223 ? 3 : l > 191 ? 2 : 1;\n            if (i + c > r) break;\n            1 === c ? l < 128 && (u = l) : 2 === c ? 128 == (192 & (s = t[i + 1])) && (u = (31 & l) << 6 | 63 & s) <= 127 && (u = null) : 3 === c ? (a = t[i + 2], 128 == (192 & (s = t[i + 1])) && 128 == (192 & a) && ((u = (15 & l) << 12 | (63 & s) << 6 | 63 & a) <= 2047 || u >= 55296 && u <= 57343) && (u = null)) : 4 === c && (a = t[i + 2], o = t[i + 3], 128 == (192 & (s = t[i + 1])) && 128 == (192 & a) && 128 == (192 & o) && ((u = (15 & l) << 18 | (63 & s) << 12 | (63 & a) << 6 | 63 & o) <= 65535 || u >= 1114112) && (u = null)), null === u ? (u = 65533, c = 1) : u > 65535 && (u -= 65536, n += String.fromCharCode(u >>> 10 & 1023 | 55296), u = 56320 | 1023 & u), n += String.fromCharCode(u), i += c;\n          }\n\n          return n;\n        }(this.buf, e, t);\n      },\n      readBytes: function () {\n        var t = this.readVarint() + this.pos,\n            e = this.buf.subarray(this.pos, t);\n        return this.pos = t, e;\n      },\n      readPackedVarint: function (t, e) {\n        if (this.type !== Ac.Bytes) return t.push(this.readVarint(e));\n        var r = Mc(this);\n\n        for (t = t || []; this.pos < r;) t.push(this.readVarint(e));\n\n        return t;\n      },\n      readPackedSVarint: function (t) {\n        if (this.type !== Ac.Bytes) return t.push(this.readSVarint());\n        var e = Mc(this);\n\n        for (t = t || []; this.pos < e;) t.push(this.readSVarint());\n\n        return t;\n      },\n      readPackedBoolean: function (t) {\n        if (this.type !== Ac.Bytes) return t.push(this.readBoolean());\n        var e = Mc(this);\n\n        for (t = t || []; this.pos < e;) t.push(this.readBoolean());\n\n        return t;\n      },\n      readPackedFloat: function (t) {\n        if (this.type !== Ac.Bytes) return t.push(this.readFloat());\n        var e = Mc(this);\n\n        for (t = t || []; this.pos < e;) t.push(this.readFloat());\n\n        return t;\n      },\n      readPackedDouble: function (t) {\n        if (this.type !== Ac.Bytes) return t.push(this.readDouble());\n        var e = Mc(this);\n\n        for (t = t || []; this.pos < e;) t.push(this.readDouble());\n\n        return t;\n      },\n      readPackedFixed32: function (t) {\n        if (this.type !== Ac.Bytes) return t.push(this.readFixed32());\n        var e = Mc(this);\n\n        for (t = t || []; this.pos < e;) t.push(this.readFixed32());\n\n        return t;\n      },\n      readPackedSFixed32: function (t) {\n        if (this.type !== Ac.Bytes) return t.push(this.readSFixed32());\n        var e = Mc(this);\n\n        for (t = t || []; this.pos < e;) t.push(this.readSFixed32());\n\n        return t;\n      },\n      readPackedFixed64: function (t) {\n        if (this.type !== Ac.Bytes) return t.push(this.readFixed64());\n        var e = Mc(this);\n\n        for (t = t || []; this.pos < e;) t.push(this.readFixed64());\n\n        return t;\n      },\n      readPackedSFixed64: function (t) {\n        if (this.type !== Ac.Bytes) return t.push(this.readSFixed64());\n        var e = Mc(this);\n\n        for (t = t || []; this.pos < e;) t.push(this.readSFixed64());\n\n        return t;\n      },\n      skip: function (t) {\n        var e = 7 & t;\n        if (e === Ac.Varint) for (; this.buf[this.pos++] > 127;);else if (e === Ac.Bytes) this.pos = this.readVarint() + this.pos;else if (e === Ac.Fixed32) this.pos += 4;else {\n          if (e !== Ac.Fixed64) throw new Error(\"Unimplemented type: \" + e);\n          this.pos += 8;\n        }\n      },\n      writeTag: function (t, e) {\n        this.writeVarint(t << 3 | e);\n      },\n      realloc: function (t) {\n        for (var e = this.length || 16; e < this.pos + t;) e *= 2;\n\n        if (e !== this.length) {\n          var r = new Uint8Array(e);\n          r.set(this.buf), this.buf = r, this.length = e;\n        }\n      },\n      finish: function () {\n        return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);\n      },\n      writeFixed32: function (t) {\n        this.realloc(4), $c(this.buf, t, this.pos), this.pos += 4;\n      },\n      writeSFixed32: function (t) {\n        this.realloc(4), $c(this.buf, t, this.pos), this.pos += 4;\n      },\n      writeFixed64: function (t) {\n        this.realloc(8), $c(this.buf, -1 & t, this.pos), $c(this.buf, Math.floor(t * Sc), this.pos + 4), this.pos += 8;\n      },\n      writeSFixed64: function (t) {\n        this.realloc(8), $c(this.buf, -1 & t, this.pos), $c(this.buf, Math.floor(t * Sc), this.pos + 4), this.pos += 8;\n      },\n      writeVarint: function (t) {\n        (t = +t || 0) > 268435455 || t < 0 ? function (t, e) {\n          var r, n;\n          if (t >= 0 ? (r = t % 4294967296 | 0, n = t / 4294967296 | 0) : (n = ~(-t / 4294967296), 4294967295 ^ (r = ~(-t % 4294967296)) ? r = r + 1 | 0 : (r = 0, n = n + 1 | 0)), t >= 0x10000000000000000 || t < -0x10000000000000000) throw new Error(\"Given varint doesn't fit into 10 bytes\");\n          e.realloc(10), function (t, e, r) {\n            r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos++] = 127 & t | 128, r.buf[r.pos] = 127 & (t >>>= 7);\n          }(r, 0, e), function (t, e) {\n            var r = (7 & t) << 4;\n            e.buf[e.pos++] |= r | ((t >>>= 3) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t)))));\n          }(n, e);\n        }(t, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = t >>> 7 & 127))));\n      },\n      writeSVarint: function (t) {\n        this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t);\n      },\n      writeBoolean: function (t) {\n        this.writeVarint(Boolean(t));\n      },\n      writeString: function (t) {\n        t = String(t), this.realloc(4 * t.length), this.pos++;\n        var e = this.pos;\n\n        this.pos = function (t, e, r) {\n          for (var n, i, s = 0; s < e.length; s++) {\n            if ((n = e.charCodeAt(s)) > 55295 && n < 57344) {\n              if (!i) {\n                n > 56319 || s + 1 === e.length ? (t[r++] = 239, t[r++] = 191, t[r++] = 189) : i = n;\n                continue;\n              }\n\n              if (n < 56320) {\n                t[r++] = 239, t[r++] = 191, t[r++] = 189, i = n;\n                continue;\n              }\n\n              n = i - 55296 << 10 | n - 56320 | 65536, i = null;\n            } else i && (t[r++] = 239, t[r++] = 191, t[r++] = 189, i = null);\n\n            n < 128 ? t[r++] = n : (n < 2048 ? t[r++] = n >> 6 | 192 : (n < 65536 ? t[r++] = n >> 12 | 224 : (t[r++] = n >> 18 | 240, t[r++] = n >> 12 & 63 | 128), t[r++] = n >> 6 & 63 | 128), t[r++] = 63 & n | 128);\n          }\n\n          return r;\n        }(this.buf, t, this.pos);\n\n        var r = this.pos - e;\n        r >= 128 && zc(e, r, this), this.pos = e - 1, this.writeVarint(r), this.pos += r;\n      },\n      writeFloat: function (t) {\n        this.realloc(4), _c(this.buf, t, this.pos, !0, 23, 4), this.pos += 4;\n      },\n      writeDouble: function (t) {\n        this.realloc(8), _c(this.buf, t, this.pos, !0, 52, 8), this.pos += 8;\n      },\n      writeBytes: function (t) {\n        var e = t.length;\n        this.writeVarint(e), this.realloc(e);\n\n        for (var r = 0; r < e; r++) this.buf[this.pos++] = t[r];\n      },\n      writeRawMessage: function (t, e) {\n        this.pos++;\n        var r = this.pos;\n        t(e, this);\n        var n = this.pos - r;\n        n >= 128 && zc(r, n, this), this.pos = r - 1, this.writeVarint(n), this.pos += n;\n      },\n      writeMessage: function (t, e, r) {\n        this.writeTag(t, Ac.Bytes), this.writeRawMessage(e, r);\n      },\n      writePackedVarint: function (t, e) {\n        e.length && this.writeMessage(t, Bc, e);\n      },\n      writePackedSVarint: function (t, e) {\n        e.length && this.writeMessage(t, Ec, e);\n      },\n      writePackedBoolean: function (t, e) {\n        e.length && this.writeMessage(t, Pc, e);\n      },\n      writePackedFloat: function (t, e) {\n        e.length && this.writeMessage(t, Cc, e);\n      },\n      writePackedDouble: function (t, e) {\n        e.length && this.writeMessage(t, Dc, e);\n      },\n      writePackedFixed32: function (t, e) {\n        e.length && this.writeMessage(t, Vc, e);\n      },\n      writePackedSFixed32: function (t, e) {\n        e.length && this.writeMessage(t, Fc, e);\n      },\n      writePackedFixed64: function (t, e) {\n        e.length && this.writeMessage(t, Lc, e);\n      },\n      writePackedSFixed64: function (t, e) {\n        e.length && this.writeMessage(t, Rc, e);\n      },\n      writeBytesField: function (t, e) {\n        this.writeTag(t, Ac.Bytes), this.writeBytes(e);\n      },\n      writeFixed32Field: function (t, e) {\n        this.writeTag(t, Ac.Fixed32), this.writeFixed32(e);\n      },\n      writeSFixed32Field: function (t, e) {\n        this.writeTag(t, Ac.Fixed32), this.writeSFixed32(e);\n      },\n      writeFixed64Field: function (t, e) {\n        this.writeTag(t, Ac.Fixed64), this.writeFixed64(e);\n      },\n      writeSFixed64Field: function (t, e) {\n        this.writeTag(t, Ac.Fixed64), this.writeSFixed64(e);\n      },\n      writeVarintField: function (t, e) {\n        this.writeTag(t, Ac.Varint), this.writeVarint(e);\n      },\n      writeSVarintField: function (t, e) {\n        this.writeTag(t, Ac.Varint), this.writeSVarint(e);\n      },\n      writeStringField: function (t, e) {\n        this.writeTag(t, Ac.Bytes), this.writeString(e);\n      },\n      writeFloatField: function (t, e) {\n        this.writeTag(t, Ac.Fixed32), this.writeFloat(e);\n      },\n      writeDoubleField: function (t, e) {\n        this.writeTag(t, Ac.Fixed64), this.writeDouble(e);\n      },\n      writeBooleanField: function (t, e) {\n        this.writeVarintField(t, Boolean(e));\n      }\n    };\n\n    class Zc {\n      constructor(t, {\n        pixelRatio: e,\n        version: r,\n        stretchX: n,\n        stretchY: i,\n        content: s\n      }) {\n        this.paddedRect = t, this.pixelRatio = e, this.stretchX = n, this.stretchY = i, this.content = s, this.version = r;\n      }\n\n      get tl() {\n        return [this.paddedRect.x + 1, this.paddedRect.y + 1];\n      }\n\n      get br() {\n        return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];\n      }\n\n      get displaySize() {\n        return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];\n      }\n\n    }\n\n    class Xc {\n      constructor(t, e) {\n        const r = {},\n              n = {};\n        this.haveRenderCallbacks = [];\n        const i = [];\n        this.addImages(t, r, i), this.addImages(e, n, i);\n        const {\n          w: s,\n          h: a\n        } = Gc(i),\n              o = new Bl({\n          width: s || 1,\n          height: a || 1\n        });\n\n        for (const e in t) {\n          const n = t[e],\n                i = r[e].paddedRect;\n          Bl.copy(n.data, o, {\n            x: 0,\n            y: 0\n          }, {\n            x: i.x + 1,\n            y: i.y + 1\n          }, n.data);\n        }\n\n        for (const t in e) {\n          const r = e[t],\n                i = n[t].paddedRect,\n                s = i.x + 1,\n                a = i.y + 1,\n                l = r.data.width,\n                u = r.data.height;\n          Bl.copy(r.data, o, {\n            x: 0,\n            y: 0\n          }, {\n            x: s,\n            y: a\n          }, r.data), Bl.copy(r.data, o, {\n            x: 0,\n            y: u - 1\n          }, {\n            x: s,\n            y: a - 1\n          }, {\n            width: l,\n            height: 1\n          }), Bl.copy(r.data, o, {\n            x: 0,\n            y: 0\n          }, {\n            x: s,\n            y: a + u\n          }, {\n            width: l,\n            height: 1\n          }), Bl.copy(r.data, o, {\n            x: l - 1,\n            y: 0\n          }, {\n            x: s - 1,\n            y: a\n          }, {\n            width: 1,\n            height: u\n          }), Bl.copy(r.data, o, {\n            x: 0,\n            y: 0\n          }, {\n            x: s + l,\n            y: a\n          }, {\n            width: 1,\n            height: u\n          });\n        }\n\n        this.image = o, this.iconPositions = r, this.patternPositions = n;\n      }\n\n      addImages(t, e, r) {\n        for (const n in t) {\n          const i = t[n],\n                s = {\n            x: 0,\n            y: 0,\n            w: i.data.width + 2,\n            h: i.data.height + 2\n          };\n          r.push(s), e[n] = new Zc(s, i), i.hasRenderCallback && this.haveRenderCallbacks.push(n);\n        }\n      }\n\n      patchUpdatedImages(t, e) {\n        this.haveRenderCallbacks = this.haveRenderCallbacks.filter(e => t.hasImage(e)), t.dispatchRenderCallbacks(this.haveRenderCallbacks);\n\n        for (const r in t.updatedImages) this.patchUpdatedImage(this.iconPositions[r], t.getImage(r), e), this.patchUpdatedImage(this.patternPositions[r], t.getImage(r), e);\n      }\n\n      patchUpdatedImage(t, e, r) {\n        if (!t || !e) return;\n        if (t.version === e.version) return;\n        t.version = e.version;\n        const [n, i] = t.tl;\n        r.update(e.data, void 0, {\n          x: n,\n          y: i\n        });\n      }\n\n    }\n\n    ai(Zc), ai(Xc);\n    const Kc = {\n      horizontal: 1,\n      vertical: 2,\n      horizontalOnly: 3\n    };\n\n    class Yc {\n      constructor() {\n        this.scale = 1, this.fontStack = \"\", this.imageName = null;\n      }\n\n      static forText(t, e) {\n        const r = new Yc();\n        return r.scale = t || 1, r.fontStack = e, r;\n      }\n\n      static forImage(t) {\n        const e = new Yc();\n        return e.imageName = t, e;\n      }\n\n    }\n\n    class Hc {\n      constructor() {\n        this.text = \"\", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;\n      }\n\n      static fromFeature(t, e) {\n        const r = new Hc();\n\n        for (let n = 0; n < t.sections.length; n++) {\n          const i = t.sections[n];\n          i.image ? r.addImageSection(i) : r.addTextSection(i, e);\n        }\n\n        return r;\n      }\n\n      length() {\n        return this.text.length;\n      }\n\n      getSection(t) {\n        return this.sections[this.sectionIndex[t]];\n      }\n\n      getSections() {\n        return this.sections;\n      }\n\n      getSectionIndex(t) {\n        return this.sectionIndex[t];\n      }\n\n      getCharCode(t) {\n        return this.text.charCodeAt(t);\n      }\n\n      verticalizePunctuation(t) {\n        this.text = function (t, e) {\n          let r = \"\";\n\n          for (let n = 0; n < t.length; n++) {\n            const i = t.charCodeAt(n + 1) || null,\n                  s = t.charCodeAt(n - 1) || null;\n            r += !e && (i && qi(i) && !gc[t[n + 1]] || s && qi(s) && !gc[t[n - 1]]) || !gc[t[n]] ? t[n] : gc[t[n]];\n          }\n\n          return r;\n        }(this.text, t);\n      }\n\n      trim() {\n        let t = 0;\n\n        for (let e = 0; e < this.text.length && Jc[this.text.charCodeAt(e)]; e++) t++;\n\n        let e = this.text.length;\n\n        for (let r = this.text.length - 1; r >= 0 && r >= t && Jc[this.text.charCodeAt(r)]; r--) e--;\n\n        this.text = this.text.substring(t, e), this.sectionIndex = this.sectionIndex.slice(t, e);\n      }\n\n      substring(t, e) {\n        const r = new Hc();\n        return r.text = this.text.substring(t, e), r.sectionIndex = this.sectionIndex.slice(t, e), r.sections = this.sections, r;\n      }\n\n      toString() {\n        return this.text;\n      }\n\n      getMaxScale() {\n        return this.sectionIndex.reduce((t, e) => Math.max(t, this.sections[e].scale), 0);\n      }\n\n      addTextSection(t, e) {\n        this.text += t.text, this.sections.push(Yc.forText(t.scale, t.fontStack || e));\n        const r = this.sections.length - 1;\n\n        for (let e = 0; e < t.text.length; ++e) this.sectionIndex.push(r);\n      }\n\n      addImageSection(t) {\n        const e = t.image ? t.image.name : \"\";\n        if (0 === e.length) return void C(\"Can't add FormattedSection with an empty image.\");\n        const r = this.getNextImageSectionCharCode();\n        r ? (this.text += String.fromCharCode(r), this.sections.push(Yc.forImage(e)), this.sectionIndex.push(this.sections.length - 1)) : C(\"Reached maximum number of images 6401\");\n      }\n\n      getNextImageSectionCharCode() {\n        return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);\n      }\n\n    }\n\n    function Wc(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y) {\n      const m = Hc.fromFeature(t, i);\n      let g;\n      h === Kc.vertical && m.verticalizePunctuation(p);\n      const {\n        processBidirectionalText: x,\n        processStyledBidirectionalText: v\n      } = is;\n\n      if (x && 1 === m.sections.length) {\n        g = [];\n        const t = x(m.toString(), sh(m, u, s, e, n, f, d));\n\n        for (const e of t) {\n          const t = new Hc();\n          t.text = e, t.sections = m.sections;\n\n          for (let r = 0; r < e.length; r++) t.sectionIndex.push(0);\n\n          g.push(t);\n        }\n      } else if (v) {\n        g = [];\n        const t = v(m.text, m.sectionIndex, sh(m, u, s, e, n, f, d));\n\n        for (const e of t) {\n          const t = new Hc();\n          t.text = e[0], t.sectionIndex = e[1], t.sections = m.sections, g.push(t);\n        }\n      } else g = function (t, e) {\n        const r = [],\n              n = t.text;\n        let i = 0;\n\n        for (const n of e) r.push(t.substring(i, n)), i = n;\n\n        return i < n.length && r.push(t.substring(i, n.length)), r;\n      }(m, sh(m, u, s, e, n, f, d));\n\n      const b = [],\n            _ = {\n        positionedLines: b,\n        text: m.toString(),\n        top: c[1],\n        bottom: c[1],\n        left: c[0],\n        right: c[0],\n        writingMode: h,\n        iconsInText: !1,\n        verticalizable: !1,\n        hasBaseline: !1\n      };\n      return function (t, e, r, n, i, s, a, o, l, u, c, h) {\n        let p = 0,\n            f = 0,\n            d = 0;\n        const y = \"right\" === o ? 1 : \"left\" === o ? 0 : .5;\n        let m = !1;\n\n        for (const t of i) {\n          const r = t.getSections();\n\n          for (const t of r) {\n            if (t.imageName) continue;\n            const r = e[t.fontStack];\n            if (r && (m = void 0 !== r.ascender && void 0 !== r.descender, !m)) break;\n          }\n\n          if (!m) break;\n        }\n\n        let g = 0;\n\n        for (const a of i) {\n          a.trim();\n          const i = a.getMaxScale(),\n                o = (i - 1) * cc,\n                v = {\n            positionedGlyphs: [],\n            lineOffset: 0\n          };\n          t.positionedLines[g] = v;\n          const b = v.positionedGlyphs;\n          let _ = 0;\n\n          if (!a.length()) {\n            f += s, ++g;\n            continue;\n          }\n\n          let w = 0,\n              A = 0;\n\n          for (let s = 0; s < a.length(); s++) {\n            const o = a.getSection(s),\n                  d = a.getSectionIndex(s),\n                  y = a.getCharCode(s);\n            let g = o.scale,\n                v = null,\n                k = null,\n                S = null,\n                I = cc,\n                M = 0;\n            const T = !(l === Kc.horizontal || !c && !Oi(y) || c && (Jc[y] || (x = y, pi(x) || fi(x) || di(x) || Di(x) || Li(x))));\n\n            if (o.imageName) {\n              const e = n[o.imageName];\n              if (!e) continue;\n              S = o.imageName, t.iconsInText = t.iconsInText || !0, k = e.paddedRect;\n              const r = e.displaySize;\n              g = g * cc / h, v = {\n                width: r[0],\n                height: r[1],\n                left: 1,\n                top: -3,\n                advance: T ? r[1] : r[0],\n                localGlyph: !1\n              }, M = m ? -v.height * g : i * cc - 17 - r[1] * g, I = v.advance;\n              const s = (T ? r[0] : r[1]) * g - cc * i;\n              s > 0 && s > _ && (_ = s);\n            } else {\n              const t = r[o.fontStack];\n              if (!t) continue;\n              t[y] && (k = t[y]);\n              const n = e[o.fontStack];\n              if (!n) continue;\n              const s = n.glyphs[y];\n              if (!s) continue;\n\n              if (v = s.metrics, I = 8203 !== y ? cc : 0, m) {\n                const t = void 0 !== n.ascender ? Math.abs(n.ascender) : 0,\n                      e = void 0 !== n.descender ? Math.abs(n.descender) : 0,\n                      r = (t + e) * g;\n                w < r && (w = r, A = (t - e) / 2 * g), M = -t * g;\n              } else M = (i - g) * cc - 17;\n            }\n\n            T ? (t.verticalizable = !0, b.push({\n              glyph: y,\n              imageName: S,\n              x: p,\n              y: f + M,\n              vertical: T,\n              scale: g,\n              localGlyph: v.localGlyph,\n              fontStack: o.fontStack,\n              sectionIndex: d,\n              metrics: v,\n              rect: k\n            }), p += I * g + u) : (b.push({\n              glyph: y,\n              imageName: S,\n              x: p,\n              y: f + M,\n              vertical: T,\n              scale: g,\n              localGlyph: v.localGlyph,\n              fontStack: o.fontStack,\n              sectionIndex: d,\n              metrics: v,\n              rect: k\n            }), p += v.advance * g + u);\n          }\n\n          0 !== b.length && (d = Math.max(p - u, d), m ? oh(b, y, _, A, s * i / 2) : oh(b, y, _, 0, s / 2)), p = 0;\n          const k = s * i + _;\n          v.lineOffset = Math.max(_, o), f += k, ++g;\n        }\n\n        var x;\n        const v = f,\n              {\n          horizontalAlign: b,\n          verticalAlign: _\n        } = ah(a);\n        (function (t, e, r, n, i, s) {\n          const a = (e - r) * i,\n                o = -s * n;\n\n          for (const e of t) for (const t of e.positionedGlyphs) t.x += a, t.y += o;\n        })(t.positionedLines, y, b, _, d, v), t.top += -_ * v, t.bottom = t.top + v, t.left += -b * d, t.right = t.left + d, t.hasBaseline = m;\n      }(_, e, r, n, g, a, o, l, h, u, p, y), !function (t) {\n        for (const e of t) if (0 !== e.positionedGlyphs.length) return !1;\n\n        return !0;\n      }(b) && _;\n    }\n\n    const Jc = {\n      9: !0,\n      10: !0,\n      11: !0,\n      12: !0,\n      13: !0,\n      32: !0\n    },\n          Qc = {\n      10: !0,\n      32: !0,\n      38: !0,\n      40: !0,\n      41: !0,\n      43: !0,\n      45: !0,\n      47: !0,\n      173: !0,\n      183: !0,\n      8203: !0,\n      8208: !0,\n      8211: !0,\n      8231: !0\n    };\n\n    function th(t, e, r, n, i, s) {\n      if (e.imageName) {\n        const t = n[e.imageName];\n        return t ? t.displaySize[0] * e.scale * cc / s + i : 0;\n      }\n\n      {\n        const n = r[e.fontStack],\n              s = n && n.glyphs[t];\n        return s ? s.metrics.advance * e.scale + i : 0;\n      }\n    }\n\n    function eh(t, e, r, n) {\n      const i = Math.pow(t - e, 2);\n      return n ? t < e ? i / 2 : 2 * i : i + Math.abs(r) * r;\n    }\n\n    function rh(t, e, r) {\n      let n = 0;\n      return 10 === t && (n -= 1e4), r && (n += 150), 40 !== t && 65288 !== t || (n += 50), 41 !== e && 65289 !== e || (n += 50), n;\n    }\n\n    function nh(t, e, r, n, i, s) {\n      let a = null,\n          o = eh(e, r, i, s);\n\n      for (const t of n) {\n        const n = eh(e - t.x, r, i, s) + t.badness;\n        n <= o && (a = t, o = n);\n      }\n\n      return {\n        index: t,\n        x: e,\n        priorBreak: a,\n        badness: o\n      };\n    }\n\n    function ih(t) {\n      return t ? ih(t.priorBreak).concat(t.index) : [];\n    }\n\n    function sh(t, e, r, n, i, s, a) {\n      if (\"point\" !== s) return [];\n      if (!t) return [];\n\n      const o = [],\n            l = function (t, e, r, n, i, s) {\n        let a = 0;\n\n        for (let r = 0; r < t.length(); r++) {\n          const o = t.getSection(r);\n          a += th(t.getCharCode(r), o, n, i, e, s);\n        }\n\n        return a / Math.max(1, Math.ceil(a / r));\n      }(t, e, r, n, i, a),\n            u = t.text.indexOf(\"â\") >= 0;\n\n      let c = 0;\n\n      for (let r = 0; r < t.length(); r++) {\n        const s = t.getSection(r),\n              p = t.getCharCode(r);\n\n        if (Jc[p] || (c += th(p, s, n, i, e, a)), r < t.length() - 1) {\n          const e = !((h = p) < 11904 || !(wi(h) || _i(h) || Vi(h) || Ci(h) || Ii(h) || yi(h) || Ai(h) || xi(h) || Mi(h) || Ti(h) || Si(h) || Ri(h) || vi(h) || gi(h) || mi(h) || ki(h) || bi(h) || Pi(h) || Bi(h) || zi(h)));\n          (Qc[p] || e || s.imageName) && o.push(nh(r + 1, c, l, o, rh(p, t.getCharCode(r + 1), e && u), !1));\n        }\n      }\n\n      var h;\n      return ih(nh(t.length(), c, l, o, 0, !0));\n    }\n\n    function ah(t) {\n      let e = .5,\n          r = .5;\n\n      switch (t) {\n        case \"right\":\n        case \"top-right\":\n        case \"bottom-right\":\n          e = 1;\n          break;\n\n        case \"left\":\n        case \"top-left\":\n        case \"bottom-left\":\n          e = 0;\n      }\n\n      switch (t) {\n        case \"bottom\":\n        case \"bottom-right\":\n        case \"bottom-left\":\n          r = 1;\n          break;\n\n        case \"top\":\n        case \"top-right\":\n        case \"top-left\":\n          r = 0;\n      }\n\n      return {\n        horizontalAlign: e,\n        verticalAlign: r\n      };\n    }\n\n    function oh(t, e, r, n, i) {\n      if (!(e || r || n || i)) return;\n      const s = t.length - 1,\n            a = t[s],\n            o = (a.x + a.metrics.advance * a.scale) * e;\n\n      for (let e = 0; e <= s; e++) t[e].x -= o, t[e].y += r + n + i;\n    }\n\n    function lh(t, e, r) {\n      const {\n        horizontalAlign: n,\n        verticalAlign: i\n      } = ah(r),\n            s = e[0] - t.displaySize[0] * n,\n            a = e[1] - t.displaySize[1] * i;\n      return {\n        image: t,\n        top: a,\n        bottom: a + t.displaySize[1],\n        left: s,\n        right: s + t.displaySize[0]\n      };\n    }\n\n    function uh(t, e, r, n, i, s) {\n      const a = t.image;\n      let o;\n\n      if (a.content) {\n        const t = a.content,\n              e = a.pixelRatio || 1;\n        o = [t[0] / e, t[1] / e, a.displaySize[0] - t[2] / e, a.displaySize[1] - t[3] / e];\n      }\n\n      const l = e.left * s,\n            u = e.right * s;\n      let c, h, p, f;\n      \"width\" === r || \"both\" === r ? (f = i[0] + l - n[3], h = i[0] + u + n[1]) : (f = i[0] + (l + u - a.displaySize[0]) / 2, h = f + a.displaySize[0]);\n      const d = e.top * s,\n            y = e.bottom * s;\n      return \"height\" === r || \"both\" === r ? (c = i[1] + d - n[0], p = i[1] + y + n[2]) : (c = i[1] + (d + y - a.displaySize[1]) / 2, p = c + a.displaySize[1]), {\n        image: a,\n        top: c,\n        right: h,\n        bottom: p,\n        left: f,\n        collisionPadding: o\n      };\n    }\n\n    class ch extends i {\n      constructor(t, e, r, n, i) {\n        super(t, e), this.angle = n, this.z = r, void 0 !== i && (this.segment = i);\n      }\n\n      clone() {\n        return new ch(this.x, this.y, this.z, this.angle, this.segment);\n      }\n\n    }\n\n    function hh(t, e, r, n, i) {\n      if (void 0 === e.segment) return !0;\n      let s = e,\n          a = e.segment + 1,\n          o = 0;\n\n      for (; o > -r / 2;) {\n        if (a--, a < 0) return !1;\n        o -= t[a].dist(s), s = t[a];\n      }\n\n      o += t[a].dist(t[a + 1]), a++;\n      const l = [];\n      let u = 0;\n\n      for (; o < r / 2;) {\n        const e = t[a],\n              r = t[a + 1];\n        if (!r) return !1;\n        let s = t[a - 1].angleTo(e) - e.angleTo(r);\n\n        for (s = Math.abs((s + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l.push({\n          distance: o,\n          angleDelta: s\n        }), u += s; o - l[0].distance > n;) u -= l.shift().angleDelta;\n\n        if (u > i) return !1;\n        a++, o += e.dist(r);\n      }\n\n      return !0;\n    }\n\n    function ph(t) {\n      let e = 0;\n\n      for (let r = 0; r < t.length - 1; r++) e += t[r].dist(t[r + 1]);\n\n      return e;\n    }\n\n    function fh(t, e, r) {\n      return t ? .6 * e * r : 0;\n    }\n\n    function dh(t, e) {\n      return Math.max(t ? t.right - t.left : 0, e ? e.right - e.left : 0);\n    }\n\n    function yh(t, e, r, n, i, s) {\n      const a = fh(r, i, s),\n            o = dh(r, n) * s;\n      let l = 0;\n      const u = ph(t) / 2;\n\n      for (let r = 0; r < t.length - 1; r++) {\n        const n = t[r],\n              i = t[r + 1],\n              s = n.dist(i);\n\n        if (l + s > u) {\n          const c = (u - l) / s,\n                h = rr(n.x, i.x, c),\n                p = rr(n.y, i.y, c),\n                f = new ch(h, p, 0, i.angleTo(n), r);\n          return !a || hh(t, f, o, a, e) ? f : void 0;\n        }\n\n        l += s;\n      }\n    }\n\n    function mh(t, e, r, n, i, s, a, o, l) {\n      const u = fh(n, s, a),\n            c = dh(n, i),\n            h = c * a,\n            p = 0 === t[0].x || t[0].x === l || 0 === t[0].y || t[0].y === l;\n      return e - h < e / 4 && (e = h + e / 4), gh(t, p ? e / 2 * o % e : (c / 2 + 2 * s) * a * o % e, e, u, r, h, p, !1, l);\n    }\n\n    function gh(t, e, r, n, i, s, a, o, l) {\n      const u = s / 2,\n            c = ph(t);\n      let h = 0,\n          p = e - r,\n          f = [];\n\n      for (let e = 0; e < t.length - 1; e++) {\n        const a = t[e],\n              o = t[e + 1],\n              d = a.dist(o),\n              y = o.angleTo(a);\n\n        for (; p + r < h + d;) {\n          p += r;\n          const m = (p - h) / d,\n                g = rr(a.x, o.x, m),\n                x = rr(a.y, o.y, m);\n\n          if (g >= 0 && g < l && x >= 0 && x < l && p - u >= 0 && p + u <= c) {\n            const r = new ch(g, x, 0, y, e);\n            r._round(), n && !hh(t, r, s, n, i) || f.push(r);\n          }\n        }\n\n        h += d;\n      }\n\n      return o || f.length || a || (f = gh(t, h / 2, r, n, i, s, a, !0, l)), f;\n    }\n\n    function xh(t, e, r, n, s) {\n      const a = [];\n\n      for (let o = 0; o < t.length; o++) {\n        const l = t[o];\n        let u;\n\n        for (let t = 0; t < l.length - 1; t++) {\n          let o = l[t],\n              c = l[t + 1];\n          o.x < e && c.x < e || (o.x < e ? o = new i(e, o.y + (e - o.x) / (c.x - o.x) * (c.y - o.y))._round() : c.x < e && (c = new i(e, o.y + (e - o.x) / (c.x - o.x) * (c.y - o.y))._round()), o.y < r && c.y < r || (o.y < r ? o = new i(o.x + (r - o.y) / (c.y - o.y) * (c.x - o.x), r)._round() : c.y < r && (c = new i(o.x + (r - o.y) / (c.y - o.y) * (c.x - o.x), r)._round()), o.x >= n && c.x >= n || (o.x >= n ? o = new i(n, o.y + (n - o.x) / (c.x - o.x) * (c.y - o.y))._round() : c.x >= n && (c = new i(n, o.y + (n - o.x) / (c.x - o.x) * (c.y - o.y))._round()), o.y >= s && c.y >= s || (o.y >= s ? o = new i(o.x + (s - o.y) / (c.y - o.y) * (c.x - o.x), s)._round() : c.y >= s && (c = new i(o.x + (s - o.y) / (c.y - o.y) * (c.x - o.x), s)._round()), u && o.equals(u[u.length - 1]) || (u = [o], a.push(u)), u.push(c)))));\n        }\n      }\n\n      return a;\n    }\n\n    ai(ch);\n    const vh = 1e20;\n\n    function bh(t, e, r, n, i, s, a, o, l) {\n      for (let u = e; u < e + n; u++) _h(t, r * s + u, s, i, a, o, l);\n\n      for (let u = r; u < r + i; u++) _h(t, u * s + e, 1, n, a, o, l);\n    }\n\n    function _h(t, e, r, n, i, s, a) {\n      s[0] = 0, a[0] = -vh, a[1] = vh, i[0] = t[e];\n\n      for (let o = 1, l = 0, u = 0; o < n; o++) {\n        i[o] = t[e + o * r];\n        const n = o * o;\n\n        do {\n          const t = s[l];\n          u = (i[o] - i[t] + n - t * t) / (o - t) / 2;\n        } while (u <= a[l] && --l > -1);\n\n        l++, s[l] = o, a[l] = u, a[l + 1] = vh;\n      }\n\n      for (let o = 0, l = 0; o < n; o++) {\n        for (; a[l + 1] < o;) l++;\n\n        const n = s[l],\n              u = o - n;\n        t[e + o * r] = i[n] + u * u;\n      }\n    }\n\n    const wh = {\n      none: 0,\n      ideographs: 1,\n      all: 2\n    };\n\n    class Ah {\n      constructor(t, e, r) {\n        this.requestManager = t, this.localGlyphMode = e, this.localFontFamily = r, this.entries = {}, this.localGlyphs = {\n          200: {},\n          400: {},\n          500: {},\n          900: {}\n        };\n      }\n\n      setURL(t) {\n        this.url = t;\n      }\n\n      getGlyphs(t, e) {\n        const r = [];\n\n        for (const e in t) for (const n of t[e]) r.push({\n          stack: e,\n          id: n\n        });\n\n        x(r, ({\n          stack: t,\n          id: e\n        }, r) => {\n          let n = this.entries[t];\n          n || (n = this.entries[t] = {\n            glyphs: {},\n            requests: {},\n            ranges: {},\n            ascender: void 0,\n            descender: void 0\n          });\n          let i = n.glyphs[e];\n          if (void 0 !== i) return void r(null, {\n            stack: t,\n            id: e,\n            glyph: i\n          });\n          if (i = this._tinySDF(n, t, e), i) return n.glyphs[e] = i, void r(null, {\n            stack: t,\n            id: e,\n            glyph: i\n          });\n          const s = Math.floor(e / 256);\n          if (256 * s > 65535) return void r(new Error(\"glyphs > 65535 not supported\"));\n          if (n.ranges[s]) return void r(null, {\n            stack: t,\n            id: e,\n            glyph: i\n          });\n          let a = n.requests[s];\n          a || (a = n.requests[s] = [], Ah.loadGlyphRange(t, s, this.url, this.requestManager, (t, e) => {\n            if (e) {\n              n.ascender = e.ascender, n.descender = e.descender;\n\n              for (const t in e.glyphs) this._doesCharSupportLocalGlyph(+t) || (n.glyphs[+t] = e.glyphs[+t]);\n\n              n.ranges[s] = !0;\n            }\n\n            for (const r of a) r(t, e);\n\n            delete n.requests[s];\n          })), a.push((n, i) => {\n            n ? r(n) : i && r(null, {\n              stack: t,\n              id: e,\n              glyph: i.glyphs[e] || null\n            });\n          });\n        }, (t, r) => {\n          if (t) e(t);else if (r) {\n            const t = {};\n\n            for (const {\n              stack: e,\n              id: n,\n              glyph: i\n            } of r) void 0 === t[e] && (t[e] = {}), void 0 === t[e].glyphs && (t[e].glyphs = {}), t[e].glyphs[n] = i && {\n              id: i.id,\n              bitmap: i.bitmap.clone(),\n              metrics: i.metrics\n            }, t[e].ascender = this.entries[e].ascender, t[e].descender = this.entries[e].descender;\n\n            e(null, t);\n          }\n        });\n      }\n\n      _doesCharSupportLocalGlyph(t) {\n        return this.localGlyphMode !== wh.none && (this.localGlyphMode === wh.all ? !!this.localFontFamily : !!this.localFontFamily && (Ti(t) || Ei(t) || vi(t) || bi(t) || xi(t)));\n      }\n\n      _tinySDF(t, e, r) {\n        const n = this.localFontFamily;\n        if (!n || !this._doesCharSupportLocalGlyph(r)) return;\n        let i = t.tinySDF;\n\n        if (!i) {\n          let r = \"400\";\n          /bold/i.test(e) ? r = \"900\" : /medium/i.test(e) ? r = \"500\" : /light/i.test(e) && (r = \"200\"), i = t.tinySDF = new Ah.TinySDF({\n            fontFamily: n,\n            fontWeight: r,\n            fontSize: 48,\n            buffer: 6,\n            radius: 16\n          }), i.fontWeight = r;\n        }\n\n        if (this.localGlyphs[i.fontWeight][r]) return this.localGlyphs[i.fontWeight][r];\n        const s = String.fromCharCode(r),\n              {\n          data: a,\n          width: o,\n          height: l,\n          glyphWidth: u,\n          glyphHeight: c,\n          glyphLeft: h,\n          glyphTop: p,\n          glyphAdvance: f\n        } = i.draw(s);\n        return this.localGlyphs[i.fontWeight][r] = {\n          id: r,\n          bitmap: new zl({\n            width: o,\n            height: l\n          }, a),\n          metrics: {\n            width: u / 2,\n            height: c / 2,\n            left: h / 2,\n            top: p / 2 - 27,\n            advance: f / 2,\n            localGlyph: !0\n          }\n        };\n      }\n\n    }\n\n    function kh(t, e, r, n) {\n      const s = [],\n            a = t.image,\n            o = a.pixelRatio,\n            l = a.paddedRect.w - 2,\n            u = a.paddedRect.h - 2,\n            c = t.right - t.left,\n            h = t.bottom - t.top,\n            p = a.stretchX || [[0, l]],\n            f = a.stretchY || [[0, u]],\n            d = (t, e) => t + e[1] - e[0],\n            y = p.reduce(d, 0),\n            m = f.reduce(d, 0),\n            g = l - y,\n            x = u - m;\n\n      let v = 0,\n          b = y,\n          _ = 0,\n          w = m,\n          A = 0,\n          k = g,\n          S = 0,\n          I = x;\n\n      if (a.content && n) {\n        const t = a.content;\n        v = Sh(p, 0, t[0]), _ = Sh(f, 0, t[1]), b = Sh(p, t[0], t[2]), w = Sh(f, t[1], t[3]), A = t[0] - v, S = t[1] - _, k = t[2] - t[0] - b, I = t[3] - t[1] - w;\n      }\n\n      const M = (n, s, l, u) => {\n        const p = Mh(n.stretch - v, b, c, t.left),\n              f = Th(n.fixed - A, k, n.stretch, y),\n              d = Mh(s.stretch - _, w, h, t.top),\n              g = Th(s.fixed - S, I, s.stretch, m),\n              x = Mh(l.stretch - v, b, c, t.left),\n              M = Th(l.fixed - A, k, l.stretch, y),\n              T = Mh(u.stretch - _, w, h, t.top),\n              z = Th(u.fixed - S, I, u.stretch, m),\n              B = new i(p, d),\n              E = new i(x, d),\n              C = new i(x, T),\n              D = new i(p, T),\n              P = new i(f / o, g / o),\n              V = new i(M / o, z / o),\n              F = e * Math.PI / 180;\n\n        if (F) {\n          const t = Math.sin(F),\n                e = Math.cos(F),\n                r = [e, -t, t, e];\n          B._matMult(r), E._matMult(r), D._matMult(r), C._matMult(r);\n        }\n\n        const L = n.stretch + n.fixed,\n              R = s.stretch + s.fixed;\n        return {\n          tl: B,\n          tr: E,\n          bl: D,\n          br: C,\n          tex: {\n            x: a.paddedRect.x + 1 + L,\n            y: a.paddedRect.y + 1 + R,\n            w: l.stretch + l.fixed - L,\n            h: u.stretch + u.fixed - R\n          },\n          writingMode: void 0,\n          glyphOffset: [0, 0],\n          sectionIndex: 0,\n          pixelOffsetTL: P,\n          pixelOffsetBR: V,\n          minFontScaleX: k / o / c,\n          minFontScaleY: I / o / h,\n          isSDF: r\n        };\n      };\n\n      if (n && (a.stretchX || a.stretchY)) {\n        const t = Ih(p, g, y),\n              e = Ih(f, x, m);\n\n        for (let r = 0; r < t.length - 1; r++) {\n          const n = t[r],\n                i = t[r + 1];\n\n          for (let t = 0; t < e.length - 1; t++) s.push(M(n, e[t], i, e[t + 1]));\n        }\n      } else s.push(M({\n        fixed: 0,\n        stretch: -1\n      }, {\n        fixed: 0,\n        stretch: -1\n      }, {\n        fixed: 0,\n        stretch: l + 1\n      }, {\n        fixed: 0,\n        stretch: u + 1\n      }));\n\n      return s;\n    }\n\n    function Sh(t, e, r) {\n      let n = 0;\n\n      for (const i of t) n += Math.max(e, Math.min(r, i[1])) - Math.max(e, Math.min(r, i[0]));\n\n      return n;\n    }\n\n    function Ih(t, e, r) {\n      const n = [{\n        fixed: -1,\n        stretch: 0\n      }];\n\n      for (const [e, r] of t) {\n        const t = n[n.length - 1];\n        n.push({\n          fixed: e - t.stretch,\n          stretch: t.stretch\n        }), n.push({\n          fixed: e - t.stretch,\n          stretch: t.stretch + (r - e)\n        });\n      }\n\n      return n.push({\n        fixed: e + 1,\n        stretch: r\n      }), n;\n    }\n\n    function Mh(t, e, r, n) {\n      return t / e * r + n;\n    }\n\n    function Th(t, e, r, n) {\n      return t - e * r / n;\n    }\n\n    function zh(t, e, r, n) {\n      const i = e + t.positionedLines[n].lineOffset;\n      return 0 === n ? r + i / 2 : r + (i + (e + t.positionedLines[n - 1].lineOffset)) / 2;\n    }\n\n    Ah.loadGlyphRange = function (t, e, r, n, i) {\n      const s = 256 * e,\n            a = s + 255,\n            o = n.transformRequest(n.normalizeGlyphsURL(r).replace(\"{fontstack}\", t).replace(\"{range}\", `${s}-${a}`), At.Glyphs);\n      Mt(o, (t, e) => {\n        if (t) i(t);else if (e) {\n          const t = {},\n                r = function (t) {\n            return new wc(t).readFields(Oc, {});\n          }(e);\n\n          for (const e of r.glyphs) t[e.id] = e;\n\n          i(null, {\n            glyphs: t,\n            ascender: r.ascender,\n            descender: r.descender\n          });\n        }\n      });\n    }, Ah.TinySDF = class {\n      constructor({\n        fontSize: t = 24,\n        buffer: e = 3,\n        radius: r = 8,\n        cutoff: n = .25,\n        fontFamily: i = \"sans-serif\",\n        fontWeight: s = \"normal\",\n        fontStyle: a = \"normal\"\n      }) {\n        this.buffer = e, this.cutoff = n, this.radius = r;\n\n        const o = this.size = t + 4 * e,\n              l = this._createCanvas(o),\n              u = this.ctx = l.getContext(\"2d\", {\n          willReadFrequently: !0\n        });\n\n        u.font = `${a} ${s} ${t}px ${i}`, u.textBaseline = \"alphabetic\", u.textAlign = \"left\", u.fillStyle = \"black\", this.gridOuter = new Float64Array(o * o), this.gridInner = new Float64Array(o * o), this.f = new Float64Array(o), this.z = new Float64Array(o + 1), this.v = new Uint16Array(o);\n      }\n\n      _createCanvas(t) {\n        const e = document.createElement(\"canvas\");\n        return e.width = e.height = t, e;\n      }\n\n      draw(t) {\n        const {\n          width: e,\n          actualBoundingBoxAscent: r,\n          actualBoundingBoxDescent: n,\n          actualBoundingBoxLeft: i,\n          actualBoundingBoxRight: s\n        } = this.ctx.measureText(t),\n              a = Math.floor(r),\n              o = Math.min(this.size - this.buffer, Math.ceil(s - i)),\n              l = Math.min(this.size - this.buffer, Math.ceil(r) + Math.ceil(n)),\n              u = o + 2 * this.buffer,\n              c = l + 2 * this.buffer,\n              h = u * c,\n              p = new Uint8ClampedArray(h),\n              f = {\n          data: p,\n          width: u,\n          height: c,\n          glyphWidth: o,\n          glyphHeight: l,\n          glyphTop: a,\n          glyphLeft: 0,\n          glyphAdvance: e\n        };\n        if (0 === o || 0 === l) return f;\n        const {\n          ctx: d,\n          buffer: y,\n          gridInner: m,\n          gridOuter: g\n        } = this;\n        d.clearRect(y, y, o, l), d.fillText(t, y, y + a + 1);\n        const x = d.getImageData(y, y, o, l);\n        g.fill(vh, 0, h), m.fill(0, 0, h);\n\n        for (let t = 0; t < l; t++) for (let e = 0; e < o; e++) {\n          const r = x.data[4 * (t * o + e) + 3] / 255;\n          if (0 === r) continue;\n          const n = (t + y) * u + e + y;\n          if (1 === r) g[n] = 0, m[n] = vh;else {\n            const t = .5 - r;\n            g[n] = t > 0 ? t * t : 0, m[n] = t < 0 ? t * t : 0;\n          }\n        }\n\n        bh(g, 0, 0, u, c, u, this.f, this.v, this.z), bh(m, y, y, o, l, u, this.f, this.v, this.z);\n\n        for (let t = 0; t < h; t++) {\n          const e = Math.sqrt(g[t]) - Math.sqrt(m[t]);\n          p[t] = Math.round(255 - 255 * (e / this.radius + this.cutoff));\n        }\n\n        return f;\n      }\n\n    };\n\n    class Bh {\n      constructor(t = [], e = Eh) {\n        if (this.data = t, this.length = this.data.length, this.compare = e, this.length > 0) for (let t = (this.length >> 1) - 1; t >= 0; t--) this._down(t);\n      }\n\n      push(t) {\n        this.data.push(t), this.length++, this._up(this.length - 1);\n      }\n\n      pop() {\n        if (0 === this.length) return;\n        const t = this.data[0],\n              e = this.data.pop();\n        return this.length--, this.length > 0 && (this.data[0] = e, this._down(0)), t;\n      }\n\n      peek() {\n        return this.data[0];\n      }\n\n      _up(t) {\n        const {\n          data: e,\n          compare: r\n        } = this,\n              n = e[t];\n\n        for (; t > 0;) {\n          const i = t - 1 >> 1,\n                s = e[i];\n          if (r(n, s) >= 0) break;\n          e[t] = s, t = i;\n        }\n\n        e[t] = n;\n      }\n\n      _down(t) {\n        const {\n          data: e,\n          compare: r\n        } = this,\n              n = this.length >> 1,\n              i = e[t];\n\n        for (; t < n;) {\n          let n = 1 + (t << 1),\n              s = e[n];\n          const a = n + 1;\n          if (a < this.length && r(e[a], s) < 0 && (n = a, s = e[a]), r(s, i) >= 0) break;\n          e[t] = s, t = n;\n        }\n\n        e[t] = i;\n      }\n\n    }\n\n    function Eh(t, e) {\n      return t < e ? -1 : t > e ? 1 : 0;\n    }\n\n    function Ch(t, e = 1, r = !1) {\n      let n = 1 / 0,\n          s = 1 / 0,\n          a = -1 / 0,\n          o = -1 / 0;\n      const l = t[0];\n\n      for (let t = 0; t < l.length; t++) {\n        const e = l[t];\n        (!t || e.x < n) && (n = e.x), (!t || e.y < s) && (s = e.y), (!t || e.x > a) && (a = e.x), (!t || e.y > o) && (o = e.y);\n      }\n\n      const u = Math.min(a - n, o - s);\n      let c = u / 2;\n      const h = new Bh([], Dh);\n      if (0 === u) return new i(n, s);\n\n      for (let e = n; e < a; e += u) for (let r = s; r < o; r += u) h.push(new Ph(e + c, r + c, c, t));\n\n      let p = function (t) {\n        let e = 0,\n            r = 0,\n            n = 0;\n        const i = t[0];\n\n        for (let t = 0, s = i.length, a = s - 1; t < s; a = t++) {\n          const s = i[t],\n                o = i[a],\n                l = s.x * o.y - o.x * s.y;\n          r += (s.x + o.x) * l, n += (s.y + o.y) * l, e += 3 * l;\n        }\n\n        return new Ph(r / e, n / e, 0, t);\n      }(t),\n          f = h.length;\n\n      for (; h.length;) {\n        const n = h.pop();\n        (n.d > p.d || !p.d) && (p = n, r && console.log(\"found best %d after %d probes\", Math.round(1e4 * n.d) / 1e4, f)), n.max - p.d <= e || (c = n.h / 2, h.push(new Ph(n.p.x - c, n.p.y - c, c, t)), h.push(new Ph(n.p.x + c, n.p.y - c, c, t)), h.push(new Ph(n.p.x - c, n.p.y + c, c, t)), h.push(new Ph(n.p.x + c, n.p.y + c, c, t)), f += 4);\n      }\n\n      return r && (console.log(`num probes: ${f}`), console.log(`best distance: ${p.d}`)), p.p;\n    }\n\n    function Dh(t, e) {\n      return e.max - t.max;\n    }\n\n    function Ph(t, e, r, n) {\n      this.p = new i(t, e), this.h = r, this.d = function (t, e) {\n        let r = !1,\n            n = 1 / 0;\n\n        for (let i = 0; i < e.length; i++) {\n          const s = e[i];\n\n          for (let e = 0, i = s.length, a = i - 1; e < i; a = e++) {\n            const i = s[e],\n                  o = s[a];\n            i.y > t.y != o.y > t.y && t.x < (o.x - i.x) * (t.y - i.y) / (o.y - i.y) + i.x && (r = !r), n = Math.min(n, Mo(t, i, o));\n          }\n        }\n\n        return (r ? 1 : -1) * Math.sqrt(n);\n      }(this.p, n), this.max = this.d + this.h * Math.SQRT2;\n    }\n\n    const Vh = Number.POSITIVE_INFINITY,\n          Fh = Math.sqrt(2);\n\n    function Lh(t, e) {\n      return e[1] !== Vh ? function (t, e, r) {\n        let n = 0,\n            i = 0;\n\n        switch (e = Math.abs(e), r = Math.abs(r), t) {\n          case \"top-right\":\n          case \"top-left\":\n          case \"top\":\n            i = r - 7;\n            break;\n\n          case \"bottom-right\":\n          case \"bottom-left\":\n          case \"bottom\":\n            i = 7 - r;\n        }\n\n        switch (t) {\n          case \"top-right\":\n          case \"bottom-right\":\n          case \"right\":\n            n = -e;\n            break;\n\n          case \"top-left\":\n          case \"bottom-left\":\n          case \"left\":\n            n = e;\n        }\n\n        return [n, i];\n      }(t, e[0], e[1]) : function (t, e) {\n        let r = 0,\n            n = 0;\n        e < 0 && (e = 0);\n        const i = e / Fh;\n\n        switch (t) {\n          case \"top-right\":\n          case \"top-left\":\n            n = i - 7;\n            break;\n\n          case \"bottom-right\":\n          case \"bottom-left\":\n            n = 7 - i;\n            break;\n\n          case \"bottom\":\n            n = 7 - e;\n            break;\n\n          case \"top\":\n            n = e - 7;\n        }\n\n        switch (t) {\n          case \"top-right\":\n          case \"bottom-right\":\n            r = -i;\n            break;\n\n          case \"top-left\":\n          case \"bottom-left\":\n            r = i;\n            break;\n\n          case \"left\":\n            r = e;\n            break;\n\n          case \"right\":\n            r = -e;\n        }\n\n        return [r, n];\n      }(t, e[0]);\n    }\n\n    function Rh(t, e, r, n, i, s, a, o, l, u) {\n      t.createArrays(), t.tilePixelRatio = Ya / (512 * t.overscaling), t.compareText = {}, t.iconsNeedLinear = !1;\n      const c = t.layers[0].layout,\n            h = t.layers[0]._unevaluatedLayout._values,\n            p = {};\n\n      if (\"composite\" === t.textSizeData.kind) {\n        const {\n          minZoom: e,\n          maxZoom: r\n        } = t.textSizeData;\n        p.compositeTextSizes = [h[\"text-size\"].possiblyEvaluate(new ss(e), o), h[\"text-size\"].possiblyEvaluate(new ss(r), o)];\n      }\n\n      if (\"composite\" === t.iconSizeData.kind) {\n        const {\n          minZoom: e,\n          maxZoom: r\n        } = t.iconSizeData;\n        p.compositeIconSizes = [h[\"icon-size\"].possiblyEvaluate(new ss(e), o), h[\"icon-size\"].possiblyEvaluate(new ss(r), o)];\n      }\n\n      p.layoutTextSize = h[\"text-size\"].possiblyEvaluate(new ss(l + 1), o), p.layoutIconSize = h[\"icon-size\"].possiblyEvaluate(new ss(l + 1), o), p.textMaxSize = h[\"text-size\"].possiblyEvaluate(new ss(18), o);\n      const f = \"map\" === c.get(\"text-rotation-alignment\") && \"point\" !== c.get(\"symbol-placement\"),\n            d = c.get(\"text-size\");\n\n      for (const s of t.features) {\n        const l = c.get(\"text-font\").evaluate(s, {}, o).join(\",\"),\n              h = d.evaluate(s, {}, o),\n              y = p.layoutTextSize.evaluate(s, {}, o),\n              m = (p.layoutIconSize.evaluate(s, {}, o), {\n          horizontal: {},\n          vertical: void 0\n        }),\n              g = s.text;\n        let x,\n            v = [0, 0];\n\n        if (g) {\n          const n = g.toString(),\n                a = c.get(\"text-letter-spacing\").evaluate(s, {}, o) * cc,\n                u = c.get(\"text-line-height\").evaluate(s, {}, o) * cc,\n                p = $i(n) ? a : 0,\n                d = c.get(\"text-anchor\").evaluate(s, {}, o),\n                x = c.get(\"text-variable-anchor\");\n\n          if (!x) {\n            const t = c.get(\"text-radial-offset\").evaluate(s, {}, o);\n            v = t ? Lh(d, [t * cc, Vh]) : c.get(\"text-offset\").evaluate(s, {}, o).map(t => t * cc);\n          }\n\n          let b = f ? \"center\" : c.get(\"text-justify\").evaluate(s, {}, o);\n\n          const _ = c.get(\"symbol-placement\"),\n                w = \"point\" === _,\n                A = \"point\" === _ ? c.get(\"text-max-width\").evaluate(s, {}, o) * cc : 0,\n                k = s => {\n            t.allowVerticalPlacement && Ui(n) && (m.vertical = Wc(g, e, r, i, l, A, u, d, s, p, v, Kc.vertical, !0, _, y, h));\n          };\n\n          if (!f && x) {\n            const t = \"auto\" === b ? x.map(t => Uh(t)) : [b];\n            let n = !1;\n\n            for (let s = 0; s < t.length; s++) {\n              const a = t[s];\n              if (!m.horizontal[a]) if (n) m.horizontal[a] = m.horizontal[0];else {\n                const t = Wc(g, e, r, i, l, A, u, \"center\", a, p, v, Kc.horizontal, !1, _, y, h);\n                t && (m.horizontal[a] = t, n = 1 === t.positionedLines.length);\n              }\n            }\n\n            k(\"left\");\n          } else {\n            if (\"auto\" === b && (b = Uh(d)), w || c.get(\"text-writing-mode\").indexOf(\"horizontal\") >= 0 || !Ui(n)) {\n              const t = Wc(g, e, r, i, l, A, u, d, b, p, v, Kc.horizontal, !1, _, y, h);\n              t && (m.horizontal[b] = t);\n            }\n\n            k(\"point\" === _ ? \"left\" : b);\n          }\n        }\n\n        let b = !1;\n\n        if (s.icon && s.icon.name) {\n          const e = n[s.icon.name];\n          e && (x = lh(i[s.icon.name], c.get(\"icon-offset\").evaluate(s, {}, o), c.get(\"icon-anchor\").evaluate(s, {}, o)), b = e.sdf, void 0 === t.sdfIcons ? t.sdfIcons = e.sdf : t.sdfIcons !== e.sdf && C(\"Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer\"), (e.pixelRatio !== t.pixelRatio || 0 !== c.get(\"icon-rotate\").constantOr(1)) && (t.iconsNeedLinear = !0));\n        }\n\n        const _ = qh(m.horizontal) || m.vertical;\n\n        t.iconsInText || (t.iconsInText = !!_ && _.iconsInText), (_ || x) && $h(t, s, m, x, n, p, y, 0, v, b, a, o, u);\n      }\n\n      s && t.generateCollisionDebugBuffers(l, t.collisionBoxArray);\n    }\n\n    function Uh(t) {\n      switch (t) {\n        case \"right\":\n        case \"top-right\":\n        case \"bottom-right\":\n          return \"right\";\n\n        case \"left\":\n        case \"top-left\":\n        case \"bottom-left\":\n          return \"left\";\n      }\n\n      return \"center\";\n    }\n\n    function $h(t, e, r, n, i, s, a, o, l, c, h, p, f) {\n      let d = s.textMaxSize.evaluate(e, {}, p);\n      void 0 === d && (d = a);\n\n      const y = t.layers[0].layout,\n            m = y.get(\"icon-offset\").evaluate(e, {}, p),\n            g = qh(r.horizontal) || r.vertical,\n            x = a / 24,\n            v = t.tilePixelRatio * d / 24,\n            b = (T = t.overscaling, t.zoom > 18 && T > 2 && (T >>= 1), Math.max(Ya / (512 * T), 1) * y.get(\"symbol-spacing\")),\n            _ = y.get(\"text-padding\") * t.tilePixelRatio,\n            w = y.get(\"icon-padding\") * t.tilePixelRatio,\n            A = u(y.get(\"text-max-angle\")),\n            k = \"map\" === y.get(\"text-rotation-alignment\") && \"point\" !== y.get(\"symbol-placement\"),\n            S = \"map\" === y.get(\"icon-rotation-alignment\") && \"point\" !== y.get(\"symbol-placement\"),\n            I = y.get(\"symbol-placement\"),\n            M = b / 2;\n\n      var T;\n      const z = y.get(\"icon-text-fit\");\n      let B;\n      n && \"none\" !== z && (t.allowVerticalPlacement && r.vertical && (B = uh(n, r.vertical, z, y.get(\"icon-text-fit-padding\"), m, x)), g && (n = uh(n, g, z, y.get(\"icon-text-fit-padding\"), m, x)));\n\n      const E = (a, o, u) => {\n        if (o.x < 0 || o.x >= Ya || o.y < 0 || o.y >= Ya) return;\n        const {\n          x: d,\n          y: y,\n          z: g\n        } = f.projectTilePoint(o.x, o.y, u),\n              x = new ch(d, y, g, 0, void 0);\n        !function (t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b, _, w, A, k) {\n          const S = t.addToLineVertexArray(e, n);\n          let I,\n              M,\n              T,\n              z,\n              B,\n              E,\n              D,\n              P = 0,\n              V = 0,\n              F = 0,\n              L = 0,\n              R = -1,\n              U = -1;\n          const $ = {};\n          let j = xa(\"\"),\n              O = 0,\n              q = 0;\n\n          if (void 0 === l._unevaluatedLayout.getValue(\"text-radial-offset\") ? [O, q] = l.layout.get(\"text-offset\").evaluate(b, {}, k).map(t => t * cc) : (O = l.layout.get(\"text-radial-offset\").evaluate(b, {}, k) * cc, q = Vh), t.allowVerticalPlacement && i.vertical) {\n            const t = i.vertical;\n            if (d) E = Gh(t), o && (D = Gh(o));else {\n              const n = l.layout.get(\"text-rotate\").evaluate(b, {}, k) + 90;\n              T = Nh(u, r, e, c, h, p, t, f, n, y), o && (z = Nh(u, r, e, c, h, p, o, g, n));\n            }\n          }\n\n          if (s) {\n            const n = l.layout.get(\"icon-rotate\").evaluate(b, {}, k),\n                  i = \"none\" !== l.layout.get(\"icon-text-fit\"),\n                  a = kh(s, n, w, i),\n                  f = o ? kh(o, n, w, i) : void 0;\n            M = Nh(u, r, e, c, h, p, s, g, n), P = 4 * a.length;\n            const d = t.iconSizeData;\n            let y = null;\n            \"source\" === d.kind ? (y = [hc * l.layout.get(\"icon-size\").evaluate(b, {}, k)], y[0] > jh && C(`${t.layerIds[0]}: Value for \"icon-size\" is >= 255. Reduce your \"icon-size\".`)) : \"composite\" === d.kind && (y = [hc * _.compositeIconSizes[0].evaluate(b, {}, k), hc * _.compositeIconSizes[1].evaluate(b, {}, k)], (y[0] > jh || y[1] > jh) && C(`${t.layerIds[0]}: Value for \"icon-size\" is >= 255. Reduce your \"icon-size\".`)), t.addSymbols(t.icon, a, y, v, x, b, !1, r, e, S.lineStartIndex, S.lineLength, -1, A, k), R = t.icon.placedSymbolArray.length - 1, f && (V = 4 * f.length, t.addSymbols(t.icon, f, y, v, x, b, Kc.vertical, r, e, S.lineStartIndex, S.lineLength, -1, A, k), U = t.icon.placedSymbolArray.length - 1);\n          }\n\n          for (const n in i.horizontal) {\n            const s = i.horizontal[n];\n            I || (j = xa(s.text), d ? B = Gh(s) : I = Nh(u, r, e, c, h, p, s, f, l.layout.get(\"text-rotate\").evaluate(b, {}, k), y));\n            const o = 1 === s.positionedLines.length;\n            if (F += Oh(t, r, e, s, a, l, d, b, y, S, i.vertical ? Kc.horizontal : Kc.horizontalOnly, o ? Object.keys(i.horizontal) : [n], $, R, _, A, k), o) break;\n          }\n\n          i.vertical && (L += Oh(t, r, e, i.vertical, a, l, d, b, y, S, Kc.vertical, [\"vertical\"], $, U, _, A, k));\n          let N = -1;\n\n          const G = (t, e) => t ? Math.max(t, e) : e;\n\n          N = G(B, N), N = G(E, N), N = G(D, N);\n          const Z = N > -1 ? 1 : 0;\n          t.glyphOffsetArray.length >= tp.MAX_GLYPHS && C(\"Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907\"), void 0 !== b.sortKey && t.addToSortKeyRanges(t.symbolInstances.length, b.sortKey), t.symbolInstances.emplaceBack(r.x, r.y, r.z, e.x, e.y, $.right >= 0 ? $.right : -1, $.center >= 0 ? $.center : -1, $.left >= 0 ? $.left : -1, $.vertical >= 0 ? $.vertical : -1, R, U, j, void 0 !== I ? I : t.collisionBoxArray.length, void 0 !== I ? I + 1 : t.collisionBoxArray.length, void 0 !== T ? T : t.collisionBoxArray.length, void 0 !== T ? T + 1 : t.collisionBoxArray.length, void 0 !== M ? M : t.collisionBoxArray.length, void 0 !== M ? M + 1 : t.collisionBoxArray.length, z || t.collisionBoxArray.length, z ? z + 1 : t.collisionBoxArray.length, c, F, L, P, V, Z, 0, O, q, N);\n        }(t, o, x, a, r, n, i, B, t.layers[0], t.collisionBoxArray, e.index, e.sourceLayerIndex, t.index, _, k, l, 0, w, S, m, e, s, c, h, p);\n      };\n\n      if (\"line\" === I) for (const i of xh(e.geometry, 0, 0, Ya, Ya)) {\n        const e = mh(i, b, A, r.vertical || g, n, 24, v, t.overscaling, Ya);\n\n        for (const r of e) {\n          const e = g;\n          e && Zh(t, e.text, M, r) || E(i, r, p);\n        }\n      } else if (\"line-center\" === I) {\n        for (const t of e.geometry) if (t.length > 1) {\n          const e = yh(t, A, r.vertical || g, n, 24, v);\n          e && E(t, e, p);\n        }\n      } else if (\"Polygon\" === e.type) for (const t of du(e.geometry, 0)) {\n        const e = Ch(t, 16);\n        E(t[0], new ch(e.x, e.y, 0, 0, void 0), p);\n      } else if (\"LineString\" === e.type) for (const t of e.geometry) E(t, new ch(t[0].x, t[0].y, 0, 0, void 0), p);else if (\"Point\" === e.type) for (const t of e.geometry) for (const e of t) E([e], new ch(e.x, e.y, 0, 0, void 0), p);\n    }\n\n    const jh = 32640;\n\n    function Oh(t, e, r, n, s, a, o, l, u, c, h, p, f, d, y, m, g) {\n      const x = function (t, e, r, n, s, a, o, l) {\n        const u = [];\n        if (0 === e.positionedLines.length) return u;\n\n        const c = n.layout.get(\"text-rotate\").evaluate(a, {}) * Math.PI / 180,\n              h = function (t) {\n          const e = t[0],\n                r = t[1],\n                n = e * r;\n          return n > 0 ? [e, -r] : n < 0 ? [-e, r] : 0 === e ? [r, e] : [r, -e];\n        }(r);\n\n        let p = Math.abs(e.top - e.bottom);\n\n        for (const t of e.positionedLines) p -= t.lineOffset;\n\n        const f = e.positionedLines.length,\n              d = p / f;\n        let y = e.top - r[1];\n\n        for (let t = 0; t < f; ++t) {\n          const n = e.positionedLines[t];\n          y = zh(e, d, y, t);\n\n          for (const t of n.positionedGlyphs) {\n            if (!t.rect) continue;\n            const n = t.rect || {};\n            let a = 4,\n                p = !0,\n                f = 1,\n                d = 0;\n\n            if (t.imageName) {\n              const e = o[t.imageName];\n              if (!e) continue;\n\n              if (e.sdf) {\n                C(\"SDF images are not supported in formatted text and will be ignored.\");\n                continue;\n              }\n\n              p = !1, f = e.pixelRatio, a = 1 / f;\n            }\n\n            const m = (s || l) && t.vertical,\n                  g = t.metrics.advance * t.scale / 2,\n                  x = t.metrics,\n                  v = t.rect;\n            if (null === v) continue;\n            l && e.verticalizable && (d = t.imageName ? g - t.metrics.width * t.scale / 2 : 0);\n            const b = s ? [t.x + g, t.y] : [0, 0];\n            let _ = [0, 0],\n                w = [0, 0],\n                A = !1;\n            s || (m ? (w = [t.x + g + h[0], t.y + h[1] - d], A = !0) : _ = [t.x + g + r[0], t.y + r[1] - d]);\n            const k = v.w * t.scale / (f * (t.localGlyph ? 2 : 1)),\n                  S = v.h * t.scale / (f * (t.localGlyph ? 2 : 1));\n            let I, M, T, z;\n\n            if (m) {\n              const e = t.y - y,\n                    r = new i(-g, g - e),\n                    n = -Math.PI / 2,\n                    s = new i(...w);\n              I = new i(-g + _[0], _[1]), I._rotateAround(n, r)._add(s), I.x += -e + g, I.y -= (x.left - a) * t.scale;\n              const o = t.imageName ? x.advance * t.scale : cc * t.scale,\n                    l = String.fromCharCode(t.glyph);\n              xc(l) ? I.x += (1 - a) * t.scale : vc(l) ? I.x += o - x.height * t.scale + (-a - 1) * t.scale : I.x += t.imageName || x.width + 2 * a === v.w && x.height + 2 * a === v.h ? (o - S) / 2 : (o - (x.height + 2 * a) * t.scale) / 2, M = new i(I.x, I.y - k), T = new i(I.x + S, I.y), z = new i(I.x + S, I.y - k);\n            } else {\n              const e = (x.left - a) * t.scale - g + _[0],\n                    r = (-x.top - a) * t.scale + _[1],\n                    n = e + k,\n                    s = r + S;\n              I = new i(e, r), M = new i(n, r), T = new i(e, s), z = new i(n, s);\n            }\n\n            if (c) {\n              let t;\n              t = s ? new i(0, 0) : A ? new i(h[0], h[1]) : new i(r[0], r[1]), I._rotateAround(c, t), M._rotateAround(c, t), T._rotateAround(c, t), z._rotateAround(c, t);\n            }\n\n            const B = new i(0, 0),\n                  E = new i(0, 0);\n            u.push({\n              tl: I,\n              tr: M,\n              bl: T,\n              br: z,\n              tex: n,\n              writingMode: e.writingMode,\n              glyphOffset: b,\n              sectionIndex: t.sectionIndex,\n              isSDF: p,\n              pixelOffsetTL: B,\n              pixelOffsetBR: E,\n              minFontScaleX: 0,\n              minFontScaleY: 0\n            });\n          }\n        }\n\n        return u;\n      }(0, n, u, a, o, l, s, t.allowVerticalPlacement),\n            v = t.textSizeData;\n\n      let b = null;\n      \"source\" === v.kind ? (b = [hc * a.layout.get(\"text-size\").evaluate(l, {}, g)], b[0] > jh && C(`${t.layerIds[0]}: Value for \"text-size\" is >= 255. Reduce your \"text-size\".`)) : \"composite\" === v.kind && (b = [hc * y.compositeTextSizes[0].evaluate(l, {}, g), hc * y.compositeTextSizes[1].evaluate(l, {}, g)], (b[0] > jh || b[1] > jh) && C(`${t.layerIds[0]}: Value for \"text-size\" is >= 255. Reduce your \"text-size\".`)), t.addSymbols(t.text, x, b, u, o, l, h, e, r, c.lineStartIndex, c.lineLength, d, m, g);\n\n      for (const e of p) f[e] = t.text.placedSymbolArray.length - 1;\n\n      return 4 * x.length;\n    }\n\n    function qh(t) {\n      for (const e in t) return t[e];\n\n      return null;\n    }\n\n    function Nh(t, e, r, n, s, a, o, l, c, h) {\n      let p = o.top,\n          f = o.bottom,\n          d = o.left,\n          y = o.right;\n      const m = o.collisionPadding;\n\n      if (m && (d -= m[0], p -= m[1], y += m[2], f += m[3]), c) {\n        const t = new i(d, p),\n              e = new i(y, p),\n              r = new i(d, f),\n              n = new i(y, f),\n              s = u(c);\n        let a = new i(0, 0);\n        h && (a = new i(h[0], h[1])), t._rotateAround(s, a), e._rotateAround(s, a), r._rotateAround(s, a), n._rotateAround(s, a), d = Math.min(t.x, e.x, r.x, n.x), y = Math.max(t.x, e.x, r.x, n.x), p = Math.min(t.y, e.y, r.y, n.y), f = Math.max(t.y, e.y, r.y, n.y);\n      }\n\n      return t.emplaceBack(e.x, e.y, e.z, r.x, r.y, d, p, y, f, l, n, s, a), t.length - 1;\n    }\n\n    function Gh(t) {\n      t.collisionPadding && (t.top -= t.collisionPadding[1], t.bottom += t.collisionPadding[3]);\n      const e = t.bottom - t.top;\n      return e > 0 ? Math.max(10, e) : null;\n    }\n\n    function Zh(t, e, r, n) {\n      const i = t.compareText;\n\n      if (e in i) {\n        const t = i[e];\n\n        for (let e = t.length - 1; e >= 0; e--) if (n.dist(t[e]) < r) return !0;\n      } else i[e] = [];\n\n      return i[e].push(n), !1;\n    }\n\n    const Xh = Du.VectorTileFeature.types,\n          Kh = [{\n      name: \"a_fade_opacity\",\n      components: 1,\n      type: \"Uint8\",\n      offset: 0\n    }];\n\n    function Yh(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y) {\n      const m = c ? Math.min(jh, Math.round(c[0])) : 0,\n            g = c ? Math.min(jh, Math.round(c[1])) : 0;\n      t.emplaceBack(e, r, Math.round(32 * a), Math.round(32 * o), l, u, (m << 1) + (h ? 1 : 0), g, 16 * p, 16 * f, 256 * d, 256 * y, n, i, s, 0);\n    }\n\n    function Hh(t, e, r) {\n      t.emplaceBack(e.x, e.y, r), t.emplaceBack(e.x, e.y, r), t.emplaceBack(e.x, e.y, r), t.emplaceBack(e.x, e.y, r);\n    }\n\n    function Wh(t) {\n      for (const e of t.sections) if (Zi(e.text)) return !0;\n\n      return !1;\n    }\n\n    class Jh {\n      constructor(t) {\n        this.layoutVertexArray = new Ps(), this.indexArray = new $s(), this.programConfigurations = t, this.segments = new Ka(), this.dynamicLayoutVertexArray = new Bs(), this.opacityVertexArray = new Vs(), this.placedSymbolArray = new na();\n      }\n\n      isEmpty() {\n        return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length;\n      }\n\n      upload(t, e, r, n) {\n        this.isEmpty() || (r && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, ic.members), this.indexBuffer = t.createIndexBuffer(this.indexArray, e), this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, sc.members, !0), this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, Kh, !0), this.opacityVertexBuffer.itemSize = 1), (r || n) && this.programConfigurations.upload(t));\n      }\n\n      destroy() {\n        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());\n      }\n\n    }\n\n    ai(Jh);\n\n    class Qh {\n      constructor(t, e, r) {\n        this.layoutVertexArray = new t(), this.layoutAttributes = e, this.indexArray = new r(), this.segments = new Ka(), this.collisionVertexArray = new Us(), this.collisionVertexArrayExt = new Bs();\n      }\n\n      upload(t) {\n        this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, ac.members, !0), this.collisionVertexBufferExt = t.createVertexBuffer(this.collisionVertexArrayExt, oc.members, !0);\n      }\n\n      destroy() {\n        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy());\n      }\n\n    }\n\n    ai(Qh);\n\n    class tp {\n      constructor(t) {\n        this.collisionBoxArray = t.collisionBoxArray, this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(t => t.id), this.index = t.index, this.pixelRatio = t.pixelRatio, this.sourceLayerIndex = t.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.fullyClipped = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = jo([]), this.placementViewportMatrix = jo([]);\n        const e = this.layers[0]._unevaluatedLayout._values;\n        this.textSizeData = pc(this.zoom, e[\"text-size\"]), this.iconSizeData = pc(this.zoom, e[\"icon-size\"]);\n        const r = this.layers[0].layout,\n              n = r.get(\"symbol-sort-key\"),\n              i = r.get(\"symbol-z-order\");\n        this.canOverlap = r.get(\"text-allow-overlap\") || r.get(\"icon-allow-overlap\") || r.get(\"text-ignore-placement\") || r.get(\"icon-ignore-placement\"), this.sortFeaturesByKey = \"viewport-y\" !== i && void 0 !== n.constantOr(1), this.sortFeaturesByY = (\"viewport-y\" === i || \"auto\" === i && !this.sortFeaturesByKey) && this.canOverlap, this.writingModes = r.get(\"text-writing-mode\").map(t => Kc[t]), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id), this.sourceID = t.sourceID, this.projection = t.projection;\n      }\n\n      createArrays() {\n        this.text = new Jh(new Ra(this.layers, this.zoom, t => /^text/.test(t))), this.icon = new Jh(new Ra(this.layers, this.zoom, t => /^icon/.test(t))), this.glyphOffsetArray = new aa(), this.lineVertexArray = new oa(), this.symbolInstances = new sa();\n      }\n\n      calculateGlyphDependencies(t, e, r, n, i) {\n        for (let r = 0; r < t.length; r++) if (e[t.charCodeAt(r)] = !0, n && i) {\n          const n = gc[t.charAt(r)];\n          n && (e[n.charCodeAt(0)] = !0);\n        }\n      }\n\n      populate(t, e, r, n) {\n        const i = this.layers[0],\n              s = i.layout,\n              a = s.get(\"text-font\"),\n              o = s.get(\"text-field\"),\n              l = s.get(\"icon-image\"),\n              u = (\"constant\" !== o.value.kind || o.value.value instanceof fe && !o.value.value.isEmpty() || o.value.value.toString().length > 0) && (\"constant\" !== a.value.kind || a.value.value.length > 0),\n              c = \"constant\" !== l.value.kind || !!l.value.value || Object.keys(l.parameters).length > 0,\n              h = s.get(\"symbol-sort-key\");\n        if (this.features = [], !u && !c) return;\n        const p = e.iconDependencies,\n              f = e.glyphDependencies,\n              d = e.availableImages,\n              y = new ss(this.zoom);\n\n        for (const {\n          feature: e,\n          id: o,\n          index: l,\n          sourceLayerIndex: m\n        } of t) {\n          const t = i._featureFilter.needGeometry,\n                g = mo(e, t);\n          if (!i._featureFilter.filter(y, g, r)) continue;\n          let x, v;\n\n          if (t || (g.geometry = yo(e, r, n)), u) {\n            const t = i.getValueAndResolveTokens(\"text-field\", g, r, d),\n                  e = fe.factory(t);\n            Wh(e) && (this.hasRTLText = !0), (!this.hasRTLText || \"unavailable\" === rs() || this.hasRTLText && is.isParsed()) && (x = mc(e, i, g));\n          }\n\n          if (c) {\n            const t = i.getValueAndResolveTokens(\"icon-image\", g, r, d);\n            v = t instanceof de ? t : de.fromString(t);\n          }\n\n          if (!x && !v) continue;\n          const b = this.sortFeaturesByKey ? h.evaluate(g, {}, r) : void 0;\n\n          if (this.features.push({\n            id: o,\n            text: x,\n            icon: v,\n            index: l,\n            sourceLayerIndex: m,\n            geometry: g.geometry,\n            properties: e.properties,\n            type: Xh[e.type],\n            sortKey: b\n          }), v && (p[v.name] = !0), x) {\n            const t = a.evaluate(g, {}, r).join(\",\"),\n                  e = \"map\" === s.get(\"text-rotation-alignment\") && \"point\" !== s.get(\"symbol-placement\");\n            this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(Kc.vertical) >= 0;\n\n            for (const r of x.sections) if (r.image) p[r.image.name] = !0;else {\n              const n = Ui(x.toString()),\n                    i = r.fontStack || t,\n                    s = f[i] = f[i] || {};\n              this.calculateGlyphDependencies(r.text, s, e, this.allowVerticalPlacement, n);\n            }\n          }\n        }\n\n        \"line\" === s.get(\"symbol-placement\") && (this.features = function (t) {\n          const e = {},\n                r = {},\n                n = [];\n          let i = 0;\n\n          function s(e) {\n            n.push(t[e]), i++;\n          }\n\n          function a(t, e, i) {\n            const s = r[t];\n            return delete r[t], r[e] = s, n[s].geometry[0].pop(), n[s].geometry[0] = n[s].geometry[0].concat(i[0]), s;\n          }\n\n          function o(t, r, i) {\n            const s = e[r];\n            return delete e[r], e[t] = s, n[s].geometry[0].shift(), n[s].geometry[0] = i[0].concat(n[s].geometry[0]), s;\n          }\n\n          function l(t, e, r) {\n            const n = r ? e[0][e[0].length - 1] : e[0][0];\n            return `${t}:${n.x}:${n.y}`;\n          }\n\n          for (let u = 0; u < t.length; u++) {\n            const c = t[u],\n                  h = c.geometry,\n                  p = c.text ? c.text.toString() : null;\n\n            if (!p) {\n              s(u);\n              continue;\n            }\n\n            const f = l(p, h),\n                  d = l(p, h, !0);\n\n            if (f in r && d in e && r[f] !== e[d]) {\n              const t = o(f, d, h),\n                    i = a(f, d, n[t].geometry);\n              delete e[f], delete r[d], r[l(p, n[i].geometry, !0)] = i, n[t].geometry = null;\n            } else f in r ? a(f, d, h) : d in e ? o(f, d, h) : (s(u), e[f] = i - 1, r[d] = i - 1);\n          }\n\n          return n.filter(t => t.geometry);\n        }(this.features)), this.sortFeaturesByKey && this.features.sort((t, e) => t.sortKey - e.sortKey);\n      }\n\n      update(t, e, r, n) {\n        this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, e, this.layers, r, n), this.icon.programConfigurations.updatePaintArrays(t, e, this.layers, r, n));\n      }\n\n      isEmpty() {\n        return 0 === this.symbolInstances.length && !this.hasRTLText;\n      }\n\n      uploadPending() {\n        return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;\n      }\n\n      upload(t) {\n        !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)), this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;\n      }\n\n      destroyDebugData() {\n        this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();\n      }\n\n      destroy() {\n        this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();\n      }\n\n      addToLineVertexArray(t, e) {\n        const r = this.lineVertexArray.length,\n              n = t.segment;\n\n        if (void 0 !== n) {\n          let r = t.dist(e[n + 1]),\n              i = t.dist(e[n]);\n          const s = {};\n\n          for (let t = n + 1; t < e.length; t++) s[t] = {\n            x: e[t].x,\n            y: e[t].y,\n            tileUnitDistanceFromAnchor: r\n          }, t < e.length - 1 && (r += e[t + 1].dist(e[t]));\n\n          for (let t = n || 0; t >= 0; t--) s[t] = {\n            x: e[t].x,\n            y: e[t].y,\n            tileUnitDistanceFromAnchor: i\n          }, t > 0 && (i += e[t - 1].dist(e[t]));\n\n          for (let t = 0; t < e.length; t++) {\n            const e = s[t];\n            this.lineVertexArray.emplaceBack(e.x, e.y, e.tileUnitDistanceFromAnchor);\n          }\n        }\n\n        return {\n          lineStartIndex: r,\n          lineLength: this.lineVertexArray.length - r\n        };\n      }\n\n      addSymbols(t, e, r, n, i, s, a, o, l, u, c, h, p, f) {\n        const d = t.indexArray,\n              y = t.layoutVertexArray,\n              m = t.segments.prepareSegment(4 * e.length, y, d, this.canOverlap ? s.sortKey : void 0),\n              g = this.glyphOffsetArray.length,\n              x = m.vertexLength,\n              v = this.allowVerticalPlacement && a === Kc.vertical ? Math.PI / 2 : 0,\n              b = s.text && s.text.sections;\n\n        for (let n = 0; n < e.length; n++) {\n          const {\n            tl: i,\n            tr: a,\n            bl: u,\n            br: c,\n            tex: h,\n            pixelOffsetTL: g,\n            pixelOffsetBR: x,\n            minFontScaleX: _,\n            minFontScaleY: w,\n            glyphOffset: A,\n            isSDF: k,\n            sectionIndex: S\n          } = e[n],\n                I = m.vertexLength,\n                M = A[1];\n          Yh(y, o.x, o.y, o.z, l.x, l.y, i.x, M + i.y, h.x, h.y, r, k, g.x, g.y, _, w), Yh(y, o.x, o.y, o.z, l.x, l.y, a.x, M + a.y, h.x + h.w, h.y, r, k, x.x, g.y, _, w), Yh(y, o.x, o.y, o.z, l.x, l.y, u.x, M + u.y, h.x, h.y + h.h, r, k, g.x, x.y, _, w), Yh(y, o.x, o.y, o.z, l.x, l.y, c.x, M + c.y, h.x + h.w, h.y + h.h, r, k, x.x, x.y, _, w), Hh(t.dynamicLayoutVertexArray, o, v), d.emplaceBack(I, I + 1, I + 2), d.emplaceBack(I + 1, I + 2, I + 3), m.vertexLength += 4, m.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(A[0]), n !== e.length - 1 && S === e[n + 1].sectionIndex || t.programConfigurations.populatePaintArrays(y.length, s, s.index, {}, p, f, b && b[S]);\n        }\n\n        t.placedSymbolArray.emplaceBack(o.x, o.y, o.z, l.x, l.y, g, this.glyphOffsetArray.length - g, x, u, c, l.segment, r ? r[0] : 0, r ? r[1] : 0, n[0], n[1], a, 0, !1, 0, h, 0);\n      }\n\n      _commitLayoutVertex(t, e, r, n, i, s, a) {\n        t.emplaceBack(e, r, n, i, s, Math.round(a.x), Math.round(a.y));\n      }\n\n      _addCollisionDebugVertices(t, e, r, n, s, a, o) {\n        const l = r.segments.prepareSegment(4, r.layoutVertexArray, r.indexArray),\n              u = l.vertexLength,\n              c = o.tileAnchorX,\n              h = o.tileAnchorY;\n\n        for (let t = 0; t < 4; t++) r.collisionVertexArray.emplaceBack(0, 0, 0, 0);\n\n        r.collisionVertexArrayExt.emplaceBack(e, -t.padding, -t.padding), r.collisionVertexArrayExt.emplaceBack(e, t.padding, -t.padding), r.collisionVertexArrayExt.emplaceBack(e, t.padding, t.padding), r.collisionVertexArrayExt.emplaceBack(e, -t.padding, t.padding), this._commitLayoutVertex(r.layoutVertexArray, n, s, a, c, h, new i(t.x1, t.y1)), this._commitLayoutVertex(r.layoutVertexArray, n, s, a, c, h, new i(t.x2, t.y1)), this._commitLayoutVertex(r.layoutVertexArray, n, s, a, c, h, new i(t.x2, t.y2)), this._commitLayoutVertex(r.layoutVertexArray, n, s, a, c, h, new i(t.x1, t.y2)), l.vertexLength += 4;\n        const p = r.indexArray;\n        p.emplaceBack(u, u + 1), p.emplaceBack(u + 1, u + 2), p.emplaceBack(u + 2, u + 3), p.emplaceBack(u + 3, u), l.primitiveLength += 4;\n      }\n\n      _addTextDebugCollisionBoxes(t, e, r, n, i, s) {\n        for (let a = n; a < i; a++) {\n          const n = r.get(a),\n                i = this.getSymbolInstanceTextSize(t, s, e, a);\n\n          this._addCollisionDebugVertices(n, i, this.textCollisionBox, n.projectedAnchorX, n.projectedAnchorY, n.projectedAnchorZ, s);\n        }\n      }\n\n      _addIconDebugCollisionBoxes(t, e, r, n, i, s) {\n        for (let a = n; a < i; a++) {\n          const n = r.get(a),\n                i = this.getSymbolInstanceIconSize(t, e, a);\n\n          this._addCollisionDebugVertices(n, i, this.iconCollisionBox, n.projectedAnchorX, n.projectedAnchorY, n.projectedAnchorZ, s);\n        }\n      }\n\n      generateCollisionDebugBuffers(t, e) {\n        this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Qh(Ls, lc.members, Xs), this.iconCollisionBox = new Qh(Ls, lc.members, Xs);\n        const r = dc(this.iconSizeData, t),\n              n = dc(this.textSizeData, t);\n\n        for (let i = 0; i < this.symbolInstances.length; i++) {\n          const s = this.symbolInstances.get(i);\n          this._addTextDebugCollisionBoxes(n, t, e, s.textBoxStartIndex, s.textBoxEndIndex, s), this._addTextDebugCollisionBoxes(n, t, e, s.verticalTextBoxStartIndex, s.verticalTextBoxEndIndex, s), this._addIconDebugCollisionBoxes(r, t, e, s.iconBoxStartIndex, s.iconBoxEndIndex, s), this._addIconDebugCollisionBoxes(r, t, e, s.verticalIconBoxStartIndex, s.verticalIconBoxEndIndex, s);\n        }\n      }\n\n      getSymbolInstanceTextSize(t, e, r, n) {\n        const i = this.text.placedSymbolArray.get(e.rightJustifiedTextSymbolIndex >= 0 ? e.rightJustifiedTextSymbolIndex : e.centerJustifiedTextSymbolIndex >= 0 ? e.centerJustifiedTextSymbolIndex : e.leftJustifiedTextSymbolIndex >= 0 ? e.leftJustifiedTextSymbolIndex : e.verticalPlacedTextSymbolIndex >= 0 ? e.verticalPlacedTextSymbolIndex : n),\n              s = fc(this.textSizeData, t, i) / cc;\n        return this.tilePixelRatio * s;\n      }\n\n      getSymbolInstanceIconSize(t, e, r) {\n        const n = this.icon.placedSymbolArray.get(r),\n              i = fc(this.iconSizeData, t, n);\n        return this.tilePixelRatio * i;\n      }\n\n      _commitDebugCollisionVertexUpdate(t, e, r) {\n        t.emplaceBack(e, -r, -r), t.emplaceBack(e, r, -r), t.emplaceBack(e, r, r), t.emplaceBack(e, -r, r);\n      }\n\n      _updateTextDebugCollisionBoxes(t, e, r, n, i, s) {\n        for (let a = n; a < i; a++) {\n          const n = r.get(a),\n                i = this.getSymbolInstanceTextSize(t, s, e, a);\n\n          this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, i, n.padding);\n        }\n      }\n\n      _updateIconDebugCollisionBoxes(t, e, r, n, i) {\n        for (let s = n; s < i; s++) {\n          const n = r.get(s),\n                i = this.getSymbolInstanceIconSize(t, e, s);\n\n          this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, i, n.padding);\n        }\n      }\n\n      updateCollisionDebugBuffers(t, e) {\n        if (!this.hasDebugData()) return;\n        this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();\n        const r = dc(this.iconSizeData, t),\n              n = dc(this.textSizeData, t);\n\n        for (let i = 0; i < this.symbolInstances.length; i++) {\n          const s = this.symbolInstances.get(i);\n          this._updateTextDebugCollisionBoxes(n, t, e, s.textBoxStartIndex, s.textBoxEndIndex, s), this._updateTextDebugCollisionBoxes(n, t, e, s.verticalTextBoxStartIndex, s.verticalTextBoxEndIndex, s), this._updateIconDebugCollisionBoxes(r, t, e, s.iconBoxStartIndex, s.iconBoxEndIndex), this._updateIconDebugCollisionBoxes(r, t, e, s.verticalIconBoxStartIndex, s.verticalIconBoxEndIndex);\n        }\n\n        this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt);\n      }\n\n      _deserializeCollisionBoxesForSymbol(t, e, r, n, i, s, a, o, l) {\n        const u = {};\n\n        for (let n = e; n < r; n++) {\n          const e = t.get(n);\n          u.textBox = {\n            x1: e.x1,\n            y1: e.y1,\n            x2: e.x2,\n            y2: e.y2,\n            padding: e.padding,\n            projectedAnchorX: e.projectedAnchorX,\n            projectedAnchorY: e.projectedAnchorY,\n            projectedAnchorZ: e.projectedAnchorZ,\n            tileAnchorX: e.tileAnchorX,\n            tileAnchorY: e.tileAnchorY\n          }, u.textFeatureIndex = e.featureIndex;\n          break;\n        }\n\n        for (let e = n; e < i; e++) {\n          const r = t.get(e);\n          u.verticalTextBox = {\n            x1: r.x1,\n            y1: r.y1,\n            x2: r.x2,\n            y2: r.y2,\n            padding: r.padding,\n            projectedAnchorX: r.projectedAnchorX,\n            projectedAnchorY: r.projectedAnchorY,\n            projectedAnchorZ: r.projectedAnchorZ,\n            tileAnchorX: r.tileAnchorX,\n            tileAnchorY: r.tileAnchorY\n          }, u.verticalTextFeatureIndex = r.featureIndex;\n          break;\n        }\n\n        for (let e = s; e < a; e++) {\n          const r = t.get(e);\n          u.iconBox = {\n            x1: r.x1,\n            y1: r.y1,\n            x2: r.x2,\n            y2: r.y2,\n            padding: r.padding,\n            projectedAnchorX: r.projectedAnchorX,\n            projectedAnchorY: r.projectedAnchorY,\n            projectedAnchorZ: r.projectedAnchorZ,\n            tileAnchorX: r.tileAnchorX,\n            tileAnchorY: r.tileAnchorY\n          }, u.iconFeatureIndex = r.featureIndex;\n          break;\n        }\n\n        for (let e = o; e < l; e++) {\n          const r = t.get(e);\n          u.verticalIconBox = {\n            x1: r.x1,\n            y1: r.y1,\n            x2: r.x2,\n            y2: r.y2,\n            padding: r.padding,\n            projectedAnchorX: r.projectedAnchorX,\n            projectedAnchorY: r.projectedAnchorY,\n            projectedAnchorZ: r.projectedAnchorZ,\n            tileAnchorX: r.tileAnchorX,\n            tileAnchorY: r.tileAnchorY\n          }, u.verticalIconFeatureIndex = r.featureIndex;\n          break;\n        }\n\n        return u;\n      }\n\n      deserializeCollisionBoxes(t) {\n        this.collisionArrays = [];\n\n        for (let e = 0; e < this.symbolInstances.length; e++) {\n          const r = this.symbolInstances.get(e);\n          this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, r.textBoxStartIndex, r.textBoxEndIndex, r.verticalTextBoxStartIndex, r.verticalTextBoxEndIndex, r.iconBoxStartIndex, r.iconBoxEndIndex, r.verticalIconBoxStartIndex, r.verticalIconBoxEndIndex));\n        }\n      }\n\n      hasTextData() {\n        return this.text.segments.get().length > 0;\n      }\n\n      hasIconData() {\n        return this.icon.segments.get().length > 0;\n      }\n\n      hasDebugData() {\n        return this.textCollisionBox && this.iconCollisionBox;\n      }\n\n      hasTextCollisionBoxData() {\n        return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;\n      }\n\n      hasIconCollisionBoxData() {\n        return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;\n      }\n\n      addIndicesForPlacedSymbol(t, e) {\n        const r = t.placedSymbolArray.get(e),\n              n = r.vertexStartIndex + 4 * r.numGlyphs;\n\n        for (let e = r.vertexStartIndex; e < n; e += 4) t.indexArray.emplaceBack(e, e + 1, e + 2), t.indexArray.emplaceBack(e + 1, e + 2, e + 3);\n      }\n\n      getSortedSymbolIndexes(t) {\n        if (this.sortedAngle === t && void 0 !== this.symbolInstanceIndexes) return this.symbolInstanceIndexes;\n        const e = Math.sin(t),\n              r = Math.cos(t),\n              n = [],\n              i = [],\n              s = [];\n\n        for (let t = 0; t < this.symbolInstances.length; ++t) {\n          s.push(t);\n          const a = this.symbolInstances.get(t);\n          n.push(0 | Math.round(e * a.tileAnchorX + r * a.tileAnchorY)), i.push(a.featureIndex);\n        }\n\n        return s.sort((t, e) => n[t] - n[e] || i[e] - i[t]), s;\n      }\n\n      addToSortKeyRanges(t, e) {\n        const r = this.sortKeyRanges[this.sortKeyRanges.length - 1];\n        r && r.sortKey === e ? r.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({\n          sortKey: e,\n          symbolInstanceStart: t,\n          symbolInstanceEnd: t + 1\n        });\n      }\n\n      sortFeatures(t) {\n        if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {\n          this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t), this.sortedAngle = t, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];\n\n          for (const t of this.symbolInstanceIndexes) {\n            const e = this.symbolInstances.get(t);\n            this.featureSortOrder.push(e.featureIndex), [e.rightJustifiedTextSymbolIndex, e.centerJustifiedTextSymbolIndex, e.leftJustifiedTextSymbolIndex].forEach((t, e, r) => {\n              t >= 0 && r.indexOf(t) === e && this.addIndicesForPlacedSymbol(this.text, t);\n            }), e.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, e.verticalPlacedTextSymbolIndex), e.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e.placedIconSymbolIndex), e.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e.verticalPlacedIconSymbolIndex);\n          }\n\n          this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);\n        }\n      }\n\n    }\n\n    ai(tp, {\n      omit: [\"layers\", \"collisionBoxArray\", \"features\", \"compareText\"]\n    }), tp.MAX_GLYPHS = 65535, tp.addDynamicAttributes = Hh;\n    const ep = new vs({\n      \"symbol-placement\": new ds($t.layout_symbol[\"symbol-placement\"]),\n      \"symbol-spacing\": new ds($t.layout_symbol[\"symbol-spacing\"]),\n      \"symbol-avoid-edges\": new ds($t.layout_symbol[\"symbol-avoid-edges\"]),\n      \"symbol-sort-key\": new ys($t.layout_symbol[\"symbol-sort-key\"]),\n      \"symbol-z-order\": new ds($t.layout_symbol[\"symbol-z-order\"]),\n      \"icon-allow-overlap\": new ds($t.layout_symbol[\"icon-allow-overlap\"]),\n      \"icon-ignore-placement\": new ds($t.layout_symbol[\"icon-ignore-placement\"]),\n      \"icon-optional\": new ds($t.layout_symbol[\"icon-optional\"]),\n      \"icon-rotation-alignment\": new ds($t.layout_symbol[\"icon-rotation-alignment\"]),\n      \"icon-size\": new ys($t.layout_symbol[\"icon-size\"]),\n      \"icon-text-fit\": new ds($t.layout_symbol[\"icon-text-fit\"]),\n      \"icon-text-fit-padding\": new ds($t.layout_symbol[\"icon-text-fit-padding\"]),\n      \"icon-image\": new ys($t.layout_symbol[\"icon-image\"]),\n      \"icon-rotate\": new ys($t.layout_symbol[\"icon-rotate\"]),\n      \"icon-padding\": new ds($t.layout_symbol[\"icon-padding\"]),\n      \"icon-keep-upright\": new ds($t.layout_symbol[\"icon-keep-upright\"]),\n      \"icon-offset\": new ys($t.layout_symbol[\"icon-offset\"]),\n      \"icon-anchor\": new ys($t.layout_symbol[\"icon-anchor\"]),\n      \"icon-pitch-alignment\": new ds($t.layout_symbol[\"icon-pitch-alignment\"]),\n      \"text-pitch-alignment\": new ds($t.layout_symbol[\"text-pitch-alignment\"]),\n      \"text-rotation-alignment\": new ds($t.layout_symbol[\"text-rotation-alignment\"]),\n      \"text-field\": new ys($t.layout_symbol[\"text-field\"]),\n      \"text-font\": new ys($t.layout_symbol[\"text-font\"]),\n      \"text-size\": new ys($t.layout_symbol[\"text-size\"]),\n      \"text-max-width\": new ys($t.layout_symbol[\"text-max-width\"]),\n      \"text-line-height\": new ys($t.layout_symbol[\"text-line-height\"]),\n      \"text-letter-spacing\": new ys($t.layout_symbol[\"text-letter-spacing\"]),\n      \"text-justify\": new ys($t.layout_symbol[\"text-justify\"]),\n      \"text-radial-offset\": new ys($t.layout_symbol[\"text-radial-offset\"]),\n      \"text-variable-anchor\": new ds($t.layout_symbol[\"text-variable-anchor\"]),\n      \"text-anchor\": new ys($t.layout_symbol[\"text-anchor\"]),\n      \"text-max-angle\": new ds($t.layout_symbol[\"text-max-angle\"]),\n      \"text-writing-mode\": new ds($t.layout_symbol[\"text-writing-mode\"]),\n      \"text-rotate\": new ys($t.layout_symbol[\"text-rotate\"]),\n      \"text-padding\": new ds($t.layout_symbol[\"text-padding\"]),\n      \"text-keep-upright\": new ds($t.layout_symbol[\"text-keep-upright\"]),\n      \"text-transform\": new ys($t.layout_symbol[\"text-transform\"]),\n      \"text-offset\": new ys($t.layout_symbol[\"text-offset\"]),\n      \"text-allow-overlap\": new ds($t.layout_symbol[\"text-allow-overlap\"]),\n      \"text-ignore-placement\": new ds($t.layout_symbol[\"text-ignore-placement\"]),\n      \"text-optional\": new ds($t.layout_symbol[\"text-optional\"])\n    });\n    var rp = {\n      paint: new vs({\n        \"icon-opacity\": new ys($t.paint_symbol[\"icon-opacity\"]),\n        \"icon-color\": new ys($t.paint_symbol[\"icon-color\"]),\n        \"icon-halo-color\": new ys($t.paint_symbol[\"icon-halo-color\"]),\n        \"icon-halo-width\": new ys($t.paint_symbol[\"icon-halo-width\"]),\n        \"icon-halo-blur\": new ys($t.paint_symbol[\"icon-halo-blur\"]),\n        \"icon-translate\": new ds($t.paint_symbol[\"icon-translate\"]),\n        \"icon-translate-anchor\": new ds($t.paint_symbol[\"icon-translate-anchor\"]),\n        \"text-opacity\": new ys($t.paint_symbol[\"text-opacity\"]),\n        \"text-color\": new ys($t.paint_symbol[\"text-color\"], {\n          runtimeType: Ht,\n          getOverride: t => t.textColor,\n          hasOverride: t => !!t.textColor\n        }),\n        \"text-halo-color\": new ys($t.paint_symbol[\"text-halo-color\"]),\n        \"text-halo-width\": new ys($t.paint_symbol[\"text-halo-width\"]),\n        \"text-halo-blur\": new ys($t.paint_symbol[\"text-halo-blur\"]),\n        \"text-translate\": new ds($t.paint_symbol[\"text-translate\"]),\n        \"text-translate-anchor\": new ds($t.paint_symbol[\"text-translate-anchor\"])\n      }),\n      layout: ep\n    };\n\n    class np {\n      constructor(t) {\n        this.type = t.property.overrides ? t.property.overrides.runtimeType : Zt, this.defaultValue = t;\n      }\n\n      evaluate(t) {\n        if (t.formattedSection) {\n          const e = this.defaultValue.property.overrides;\n          if (e && e.hasOverride(t.formattedSection)) return e.getOverride(t.formattedSection);\n        }\n\n        return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default;\n      }\n\n      eachChild(t) {\n        this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression);\n      }\n\n      outputDefined() {\n        return !1;\n      }\n\n      serialize() {\n        return null;\n      }\n\n    }\n\n    ai(np, {\n      omit: [\"defaultValue\"]\n    });\n\n    class ip extends Ga {\n      constructor(t) {\n        super(t, rp);\n      }\n\n      recalculate(t, e) {\n        super.recalculate(t, e), \"auto\" === this.layout.get(\"icon-rotation-alignment\") && (this.layout._values[\"icon-rotation-alignment\"] = \"point\" !== this.layout.get(\"symbol-placement\") ? \"map\" : \"viewport\"), \"auto\" === this.layout.get(\"text-rotation-alignment\") && (this.layout._values[\"text-rotation-alignment\"] = \"point\" !== this.layout.get(\"symbol-placement\") ? \"map\" : \"viewport\"), \"auto\" === this.layout.get(\"text-pitch-alignment\") && (this.layout._values[\"text-pitch-alignment\"] = this.layout.get(\"text-rotation-alignment\")), \"auto\" === this.layout.get(\"icon-pitch-alignment\") && (this.layout._values[\"icon-pitch-alignment\"] = this.layout.get(\"icon-rotation-alignment\"));\n        const r = this.layout.get(\"text-writing-mode\");\n\n        if (r) {\n          const t = [];\n\n          for (const e of r) t.indexOf(e) < 0 && t.push(e);\n\n          this.layout._values[\"text-writing-mode\"] = t;\n        } else this.layout._values[\"text-writing-mode\"] = \"point\" === this.layout.get(\"symbol-placement\") ? [\"horizontal\"] : [\"horizontal\", \"vertical\"];\n\n        this._setPaintOverrides();\n      }\n\n      getValueAndResolveTokens(t, e, r, n) {\n        const i = this.layout.get(t).evaluate(e, {}, r, n),\n              s = this._unevaluatedLayout._values[t];\n        return s.isDataDriven() || un(s.value) || !i ? i : function (t, e) {\n          return e.replace(/{([^{}]+)}/g, (e, r) => r in t ? String(t[r]) : \"\");\n        }(e.properties, i);\n      }\n\n      createBucket(t) {\n        return new tp(t);\n      }\n\n      queryRadius() {\n        return 0;\n      }\n\n      queryIntersectsFeature() {\n        return !1;\n      }\n\n      _setPaintOverrides() {\n        for (const t of rp.paint.overridableProperties) {\n          if (!ip.hasPaintOverride(this.layout, t)) continue;\n          const e = this.paint.get(t),\n                r = new np(e),\n                n = new ln(r, e.property.specification);\n          let i = null;\n          i = \"constant\" === e.value.kind || \"source\" === e.value.kind ? new hn(\"source\", n) : new pn(\"composite\", n, e.value.zoomStops, e.value._interpolationType), this.paint._values[t] = new ps(e.property, i, e.parameters);\n        }\n      }\n\n      _handleOverridablePaintPropertyUpdate(t, e, r) {\n        return !(!this.layout || e.isDataDriven() || r.isDataDriven()) && ip.hasPaintOverride(this.layout, t);\n      }\n\n      static hasPaintOverride(t, e) {\n        const r = t.get(\"text-field\"),\n              n = rp.paint.properties[e];\n        let i = !1;\n\n        const s = t => {\n          for (const e of t) if (n.overrides && n.overrides.hasOverride(e)) return void (i = !0);\n        };\n\n        if (\"constant\" === r.value.kind && r.value.value instanceof fe) s(r.value.value.sections);else if (\"source\" === r.value.kind) {\n          const t = e => {\n            i || (e instanceof ve && ge(e.value) === te ? s(e.value.sections) : e instanceof Ae ? s(e.sections) : e.eachChild(t));\n          },\n                e = r.value;\n\n          e._styleExpression && t(e._styleExpression.expression);\n        }\n        return i;\n      }\n\n      getProgramConfiguration(t) {\n        return new La(this, t);\n      }\n\n    }\n\n    var sp = {\n      paint: new vs({\n        \"background-color\": new ds($t.paint_background[\"background-color\"]),\n        \"background-pattern\": new gs($t.paint_background[\"background-pattern\"]),\n        \"background-opacity\": new ds($t.paint_background[\"background-opacity\"])\n      })\n    },\n        ap = {\n      paint: new vs({\n        \"raster-opacity\": new ds($t.paint_raster[\"raster-opacity\"]),\n        \"raster-hue-rotate\": new ds($t.paint_raster[\"raster-hue-rotate\"]),\n        \"raster-brightness-min\": new ds($t.paint_raster[\"raster-brightness-min\"]),\n        \"raster-brightness-max\": new ds($t.paint_raster[\"raster-brightness-max\"]),\n        \"raster-saturation\": new ds($t.paint_raster[\"raster-saturation\"]),\n        \"raster-contrast\": new ds($t.paint_raster[\"raster-contrast\"]),\n        \"raster-resampling\": new ds($t.paint_raster[\"raster-resampling\"]),\n        \"raster-fade-duration\": new ds($t.paint_raster[\"raster-fade-duration\"])\n      })\n    };\n\n    class op extends Ga {\n      constructor(t) {\n        super(t, {}), this.implementation = t;\n      }\n\n      is3D() {\n        return \"3d\" === this.implementation.renderingMode;\n      }\n\n      hasOffscreenPass() {\n        return void 0 !== this.implementation.prerender;\n      }\n\n      recalculate() {}\n\n      updateTransitions() {}\n\n      hasTransition() {\n        return !1;\n      }\n\n      serialize() {}\n\n      onAdd(t) {\n        this.implementation.onAdd && this.implementation.onAdd(t, t.painter.context.gl);\n      }\n\n      onRemove(t) {\n        this.implementation.onRemove && this.implementation.onRemove(t, t.painter.context.gl);\n      }\n\n    }\n\n    var lp = {\n      paint: new vs({\n        \"sky-type\": new ds($t.paint_sky[\"sky-type\"]),\n        \"sky-atmosphere-sun\": new ds($t.paint_sky[\"sky-atmosphere-sun\"]),\n        \"sky-atmosphere-sun-intensity\": new ds($t.paint_sky[\"sky-atmosphere-sun-intensity\"]),\n        \"sky-gradient-center\": new ds($t.paint_sky[\"sky-gradient-center\"]),\n        \"sky-gradient-radius\": new ds($t.paint_sky[\"sky-gradient-radius\"]),\n        \"sky-gradient\": new xs($t.paint_sky[\"sky-gradient\"]),\n        \"sky-atmosphere-halo-color\": new ds($t.paint_sky[\"sky-atmosphere-halo-color\"]),\n        \"sky-atmosphere-color\": new ds($t.paint_sky[\"sky-atmosphere-color\"]),\n        \"sky-opacity\": new ds($t.paint_sky[\"sky-opacity\"])\n      })\n    };\n\n    function up(t, e, r) {\n      const n = [0, 0, 1],\n            i = ml([]);\n      return function (t, e, r) {\n        r *= .5;\n        var n = e[0],\n            i = e[1],\n            s = e[2],\n            a = e[3],\n            o = Math.sin(r),\n            l = Math.cos(r);\n        t[0] = n * l - s * o, t[1] = i * l + a * o, t[2] = s * l + n * o, t[3] = a * l - i * o;\n      }(i, i, r ? -u(t) + Math.PI : u(t)), gl(i, i, -u(e)), ul(n, n, i), sl(n, n);\n    }\n\n    const cp = {\n      circle: class extends Ga {\n        constructor(t) {\n          super(t, Lo);\n        }\n\n        createBucket(t) {\n          return new vo(t);\n        }\n\n        queryRadius(t) {\n          const e = t;\n          return Co(\"circle-radius\", this, e) + Co(\"circle-stroke-width\", this, e) + Do(this.paint.get(\"circle-translate\"));\n        }\n\n        queryIntersectsFeature(t, e, r, n, i, s, a, o) {\n          const l = Vo(this.paint.get(\"circle-translate\"), this.paint.get(\"circle-translate-anchor\"), s.angle, t.pixelToTileUnitsFactor),\n                u = this.paint.get(\"circle-radius\").evaluate(e, r) + this.paint.get(\"circle-stroke-width\").evaluate(e, r);\n          return bl(t, n, s, a, o, \"map\" === this.paint.get(\"circle-pitch-alignment\"), \"map\" === this.paint.get(\"circle-pitch-scale\"), l, u);\n        }\n\n        getProgramIds() {\n          return [\"circle\"];\n        }\n\n        getProgramConfiguration(t) {\n          return new La(this, t);\n        }\n\n      },\n      heatmap: class extends Ga {\n        createBucket(t) {\n          return new Sl(t);\n        }\n\n        constructor(t) {\n          super(t, El), this._updateColorRamp();\n        }\n\n        _handleSpecialPaintPropertyUpdate(t) {\n          \"heatmap-color\" === t && this._updateColorRamp();\n        }\n\n        _updateColorRamp() {\n          this.colorRamp = Cl({\n            expression: this._transitionablePaint._values[\"heatmap-color\"].value.expression,\n            evaluationKey: \"heatmapDensity\",\n            image: this.colorRamp\n          }), this.colorRampTexture = null;\n        }\n\n        resize() {\n          this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);\n        }\n\n        queryRadius(t) {\n          return Co(\"heatmap-radius\", this, t);\n        }\n\n        queryIntersectsFeature(t, e, r, n, s, a, o, l) {\n          const u = this.paint.get(\"heatmap-radius\").evaluate(e, r);\n          return bl(t, n, a, o, l, !0, !0, new i(0, 0), u);\n        }\n\n        hasOffscreenPass() {\n          return 0 !== this.paint.get(\"heatmap-opacity\") && \"none\" !== this.visibility;\n        }\n\n        getProgramIds() {\n          return [\"heatmap\", \"heatmapTexture\"];\n        }\n\n        getProgramConfiguration(t) {\n          return new La(this, t);\n        }\n\n      },\n      hillshade: class extends Ga {\n        constructor(t) {\n          super(t, Dl);\n        }\n\n        hasOffscreenPass() {\n          return 0 !== this.paint.get(\"hillshade-exaggeration\") && \"none\" !== this.visibility;\n        }\n\n        getProgramIds() {\n          return [\"hillshade\", \"hillshadePrepare\"];\n        }\n\n      },\n      fill: class extends Ga {\n        constructor(t) {\n          super(t, bu);\n        }\n\n        getProgramIds() {\n          const t = this.paint.get(\"fill-pattern\"),\n                e = t && t.constantOr(1),\n                r = [e ? \"fillPattern\" : \"fill\"];\n          return this.paint.get(\"fill-antialias\") && r.push(e && !this.getPaintProperty(\"fill-outline-color\") ? \"fillOutlinePattern\" : \"fillOutline\"), r;\n        }\n\n        getProgramConfiguration(t) {\n          return new La(this, t);\n        }\n\n        recalculate(t, e) {\n          super.recalculate(t, e);\n          const r = this.paint._values[\"fill-outline-color\"];\n          \"constant\" === r.value.kind && void 0 === r.value.value && (this.paint._values[\"fill-outline-color\"] = this.paint._values[\"fill-color\"]);\n        }\n\n        createBucket(t) {\n          return new xu(t);\n        }\n\n        queryRadius() {\n          return Do(this.paint.get(\"fill-translate\"));\n        }\n\n        queryIntersectsFeature(t, e, r, n, i, s) {\n          return !t.queryGeometry.isAboveHorizon && wo(Po(t.tilespaceGeometry, this.paint.get(\"fill-translate\"), this.paint.get(\"fill-translate-anchor\"), s.angle, t.pixelToTileUnitsFactor), n);\n        }\n\n        isTileClipped() {\n          return !0;\n        }\n\n      },\n      \"fill-extrusion\": class extends Ga {\n        constructor(t) {\n          super(t, Ou);\n        }\n\n        createBucket(t) {\n          return new $u(t);\n        }\n\n        queryRadius() {\n          return Do(this.paint.get(\"fill-extrusion-translate\"));\n        }\n\n        is3D() {\n          return !0;\n        }\n\n        getProgramIds() {\n          return [this.paint.get(\"fill-extrusion-pattern\").constantOr(1) ? \"fillExtrusionPattern\" : \"fillExtrusion\"];\n        }\n\n        getProgramConfiguration(t) {\n          return new La(this, t);\n        }\n\n        queryIntersectsFeature(t, e, r, n, s, a, o, l, u) {\n          const c = Vo(this.paint.get(\"fill-extrusion-translate\"), this.paint.get(\"fill-extrusion-translate-anchor\"), a.angle, t.pixelToTileUnitsFactor),\n                h = this.paint.get(\"fill-extrusion-height\").evaluate(e, r),\n                p = this.paint.get(\"fill-extrusion-base\").evaluate(e, r),\n                f = [0, 0],\n                d = l && a.elevation,\n                y = a.elevation ? a.elevation.exaggeration() : 1,\n                m = t.tile.getBucket(this);\n\n          if (d && m instanceof $u) {\n            const t = m.centroidVertexArray,\n                  e = u + 1;\n\n            if (e < t.length) {\n              const r = t.get(e);\n              f[0] = r.a_centroid_pos0, f[1] = r.a_centroid_pos1;\n            }\n          }\n\n          if (0 === f[0] && 1 === f[1]) return !1;\n\n          const g = function (t, e, r, n, s, a, o, l, u) {\n            return a ? function (t, e, r, n, i, s, a, o, l) {\n              const u = [],\n                    c = [],\n                    h = [0, 0, 0, 1];\n\n              for (const p of t) {\n                const t = [],\n                      f = [];\n\n                for (const u of p) {\n                  const c = u.x + n.x,\n                        p = u.y + n.y,\n                        d = Zu(c, p, e, r, s, a, o, l);\n                  h[0] = c, h[1] = p, h[2] = d.base, h[3] = 1, dl(h, h, i), h[3] = Math.max(h[3], 1e-5);\n                  const y = Gu([h[0] / h[3], h[1] / h[3], h[2] / h[3]]);\n                  h[0] = c, h[1] = p, h[2] = d.top, h[3] = 1, dl(h, h, i), h[3] = Math.max(h[3], 1e-5);\n                  const m = Gu([h[0] / h[3], h[1] / h[3], h[2] / h[3]]);\n                  t.push(y), f.push(m);\n                }\n\n                u.push(t), c.push(f);\n              }\n\n              return [u, c];\n            }(t, e, r, n, s, a, o, l, u) : function (t, e, r, n, s) {\n              const a = [],\n                    o = [],\n                    l = s[8] * e,\n                    u = s[9] * e,\n                    c = s[10] * e,\n                    h = s[11] * e,\n                    p = s[8] * r,\n                    f = s[9] * r,\n                    d = s[10] * r,\n                    y = s[11] * r;\n\n              for (const e of t) {\n                const t = [],\n                      r = [];\n\n                for (const a of e) {\n                  const e = a.x + n.x,\n                        o = a.y + n.y,\n                        m = s[0] * e + s[4] * o + s[12],\n                        g = s[1] * e + s[5] * o + s[13],\n                        x = s[2] * e + s[6] * o + s[14],\n                        v = s[3] * e + s[7] * o + s[15],\n                        b = m + l,\n                        _ = g + u,\n                        w = x + c,\n                        A = Math.max(v + h, 1e-5),\n                        k = m + p,\n                        S = g + f,\n                        I = x + d,\n                        M = Math.max(v + y, 1e-5),\n                        T = new i(b / A, _ / A);\n\n                  T.z = w / A, t.push(T);\n                  const z = new i(k / M, S / M);\n                  z.z = I / M, r.push(z);\n                }\n\n                a.push(t), o.push(r);\n              }\n\n              return [a, o];\n            }(t, e, r, n, s);\n          }(n, p, h, c, o, d ? l : null, f, y, a.center.lat),\n                x = t.queryGeometry;\n\n          return function (t, e, r) {\n            let n = 1 / 0;\n            wo(r, e) && (n = Nu(r, e[0]));\n\n            for (let i = 0; i < e.length; i++) {\n              const s = e[i],\n                    a = t[i];\n\n              for (let t = 0; t < s.length - 1; t++) {\n                const e = s[t],\n                      i = [e, s[t + 1], a[t + 1], a[t], e];\n                bo(r, i) && (n = Math.min(n, Nu(r, i)));\n              }\n            }\n\n            return n !== 1 / 0 && n;\n          }(g[0], g[1], x.isPointQuery() ? x.screenBounds : x.screenGeometry);\n        }\n\n      },\n      line: class extends Ga {\n        constructor(t) {\n          super(t, ec), this.gradientVersion = 0;\n        }\n\n        _handleSpecialPaintPropertyUpdate(t) {\n          if (\"line-gradient\" === t) {\n            const t = this._transitionablePaint._values[\"line-gradient\"].value.expression;\n            this.stepInterpolant = t._styleExpression && t._styleExpression.expression instanceof er, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;\n          }\n        }\n\n        gradientExpression() {\n          return this._transitionablePaint._values[\"line-gradient\"].value.expression;\n        }\n\n        recalculate(t, e) {\n          super.recalculate(t, e), this.paint._values[\"line-floorwidth\"] = rc.possiblyEvaluate(this._transitioningPaint._values[\"line-width\"].value, t);\n        }\n\n        createBucket(t) {\n          return new Qu(t);\n        }\n\n        getProgramIds() {\n          return [this.paint.get(\"line-pattern\").constantOr(1) ? \"linePattern\" : \"line\"];\n        }\n\n        getProgramConfiguration(t) {\n          return new La(this, t);\n        }\n\n        queryRadius(t) {\n          const e = t,\n                r = nc(Co(\"line-width\", this, e), Co(\"line-gap-width\", this, e)),\n                n = Co(\"line-offset\", this, e);\n          return r / 2 + Math.abs(n) + Do(this.paint.get(\"line-translate\"));\n        }\n\n        queryIntersectsFeature(t, e, r, n, s, a) {\n          if (t.queryGeometry.isAboveHorizon) return !1;\n          const o = Po(t.tilespaceGeometry, this.paint.get(\"line-translate\"), this.paint.get(\"line-translate-anchor\"), a.angle, t.pixelToTileUnitsFactor),\n                l = t.pixelToTileUnitsFactor / 2 * nc(this.paint.get(\"line-width\").evaluate(e, r), this.paint.get(\"line-gap-width\").evaluate(e, r)),\n                u = this.paint.get(\"line-offset\").evaluate(e, r);\n          return u && (n = function (t, e) {\n            const r = [],\n                  n = new i(0, 0);\n\n            for (let i = 0; i < t.length; i++) {\n              const s = t[i],\n                    a = [];\n\n              for (let t = 0; t < s.length; t++) {\n                const r = s[t - 1],\n                      i = s[t],\n                      o = s[t + 1],\n                      l = 0 === t ? n : i.sub(r)._unit()._perp(),\n                      u = t === s.length - 1 ? n : o.sub(i)._unit()._perp(),\n                      c = l._add(u)._unit();\n\n                c._mult(1 / (c.x * u.x + c.y * u.y)), a.push(c._mult(e)._add(i));\n              }\n\n              r.push(a);\n            }\n\n            return r;\n          }(n, u * t.pixelToTileUnitsFactor)), function (t, e, r) {\n            for (let n = 0; n < e.length; n++) {\n              const i = e[n];\n              if (t.length >= 3) for (let e = 0; e < i.length; e++) if (zo(t, i[e])) return !0;\n              if (Ao(t, i, r)) return !0;\n            }\n\n            return !1;\n          }(o, n, l);\n        }\n\n        isTileClipped() {\n          return !0;\n        }\n\n      },\n      symbol: ip,\n      background: class extends Ga {\n        constructor(t) {\n          super(t, sp);\n        }\n\n        getProgramIds() {\n          return [this.paint.get(\"background-pattern\") ? \"backgroundPattern\" : \"background\"];\n        }\n\n      },\n      raster: class extends Ga {\n        constructor(t) {\n          super(t, ap);\n        }\n\n        getProgramIds() {\n          return [\"raster\"];\n        }\n\n      },\n      sky: class extends Ga {\n        constructor(t) {\n          super(t, lp), this._updateColorRamp();\n        }\n\n        _handleSpecialPaintPropertyUpdate(t) {\n          \"sky-gradient\" === t ? this._updateColorRamp() : \"sky-atmosphere-sun\" !== t && \"sky-atmosphere-halo-color\" !== t && \"sky-atmosphere-color\" !== t && \"sky-atmosphere-sun-intensity\" !== t || (this._skyboxInvalidated = !0);\n        }\n\n        _updateColorRamp() {\n          this.colorRamp = Cl({\n            expression: this._transitionablePaint._values[\"sky-gradient\"].value.expression,\n            evaluationKey: \"skyRadialProgress\"\n          }), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);\n        }\n\n        needsSkyboxCapture(t) {\n          if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry) return !0;\n\n          if (!this.paint.get(\"sky-atmosphere-sun\")) {\n            const e = t.style.light.properties.get(\"position\");\n            return this._lightPosition.azimuthal !== e.azimuthal || this._lightPosition.polar !== e.polar;\n          }\n\n          return !1;\n        }\n\n        getCenter(t, e) {\n          if (\"atmosphere\" === this.paint.get(\"sky-type\")) {\n            const r = this.paint.get(\"sky-atmosphere-sun\"),\n                  n = !r,\n                  i = t.style.light,\n                  s = i.properties.get(\"position\");\n            return n && \"viewport\" === i.properties.get(\"anchor\") && C(\"The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly.\"), n ? up(s.azimuthal, 90 - s.polar, e) : up(r[0], 90 - r[1], e);\n          }\n\n          const r = this.paint.get(\"sky-gradient-center\");\n          return up(r[0], 90 - r[1], e);\n        }\n\n        is3D() {\n          return !1;\n        }\n\n        isSky() {\n          return !0;\n        }\n\n        markSkyboxValid(t) {\n          this._skyboxInvalidated = !1, this._lightPosition = t.style.light.properties.get(\"position\");\n        }\n\n        hasOffscreenPass() {\n          return !0;\n        }\n\n        getProgramIds() {\n          const t = this.paint.get(\"sky-type\");\n          return \"atmosphere\" === t ? [\"skyboxCapture\", \"skybox\"] : \"gradient\" === t ? [\"skyboxGradient\"] : null;\n        }\n\n      }\n    };\n\n    class hp {\n      constructor(t, e, r, n) {\n        this.context = t, this.format = r, this.texture = t.gl.createTexture(), this.update(e, n);\n      }\n\n      update(t, e, r) {\n        const {\n          width: n,\n          height: i\n        } = t,\n              {\n          context: s\n        } = this,\n              {\n          gl: o\n        } = s,\n              {\n          HTMLImageElement: l,\n          HTMLCanvasElement: u,\n          HTMLVideoElement: c,\n          ImageData: h,\n          ImageBitmap: p\n        } = a;\n\n        if (o.bindTexture(o.TEXTURE_2D, this.texture), s.pixelStoreUnpackFlipY.set(!1), s.pixelStoreUnpack.set(1), s.pixelStoreUnpackPremultiplyAlpha.set(this.format === o.RGBA && (!e || !1 !== e.premultiply)), r || this.size && this.size[0] === n && this.size[1] === i) {\n          const {\n            x: e,\n            y: s\n          } = r || {\n            x: 0,\n            y: 0\n          };\n          t instanceof l || t instanceof u || t instanceof c || t instanceof h || p && t instanceof p ? o.texSubImage2D(o.TEXTURE_2D, 0, e, s, o.RGBA, o.UNSIGNED_BYTE, t) : o.texSubImage2D(o.TEXTURE_2D, 0, e, s, n, i, o.RGBA, o.UNSIGNED_BYTE, t.data);\n        } else this.size = [n, i], t instanceof l || t instanceof u || t instanceof c || t instanceof h || p && t instanceof p ? o.texImage2D(o.TEXTURE_2D, 0, this.format, this.format, o.UNSIGNED_BYTE, t) : o.texImage2D(o.TEXTURE_2D, 0, this.format, n, i, 0, this.format, o.UNSIGNED_BYTE, t.data);\n\n        this.useMipmap = Boolean(e && e.useMipmap && this.isSizePowerOfTwo()), this.useMipmap && o.generateMipmap(o.TEXTURE_2D);\n      }\n\n      bind(t, e) {\n        const {\n          context: r\n        } = this,\n              {\n          gl: n\n        } = r;\n        n.bindTexture(n.TEXTURE_2D, this.texture), t !== this.filter && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, t), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, this.useMipmap ? t === n.NEAREST ? n.NEAREST_MIPMAP_NEAREST : n.LINEAR_MIPMAP_NEAREST : t), this.filter = t), e !== this.wrap && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, e), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, e), this.wrap = e);\n      }\n\n      isSizePowerOfTwo() {\n        return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;\n      }\n\n      destroy() {\n        const {\n          gl: t\n        } = this.context;\n        t.deleteTexture(this.texture), this.texture = null;\n      }\n\n    }\n\n    class pp {\n      constructor(t, e) {\n        this.width = t, this.height = e, this.nextRow = 0, this.image = new zl({\n          width: t,\n          height: e\n        }), this.positions = {}, this.uploaded = !1;\n      }\n\n      getDash(t, e) {\n        const r = this.getKey(t, e);\n        return this.positions[r];\n      }\n\n      trim() {\n        const t = this.width,\n              e = this.height = k(this.nextRow);\n        this.image.resize({\n          width: t,\n          height: e\n        });\n      }\n\n      getKey(t, e) {\n        return t.join(\",\") + e;\n      }\n\n      getDashRanges(t, e, r) {\n        const n = [];\n        let i = t.length % 2 == 1 ? -t[t.length - 1] * r : 0,\n            s = t[0] * r,\n            a = !0;\n        n.push({\n          left: i,\n          right: s,\n          isDash: a,\n          zeroLength: 0 === t[0]\n        });\n        let o = t[0];\n\n        for (let e = 1; e < t.length; e++) {\n          a = !a;\n          const l = t[e];\n          i = o * r, o += l, s = o * r, n.push({\n            left: i,\n            right: s,\n            isDash: a,\n            zeroLength: 0 === l\n          });\n        }\n\n        return n;\n      }\n\n      addRoundDash(t, e, r) {\n        const n = e / 2;\n\n        for (let e = -r; e <= r; e++) {\n          const i = this.width * (this.nextRow + r + e);\n          let s = 0,\n              a = t[s];\n\n          for (let o = 0; o < this.width; o++) {\n            o / a.right > 1 && (a = t[++s]);\n            const l = Math.abs(o - a.left),\n                  u = Math.abs(o - a.right),\n                  c = Math.min(l, u);\n            let h;\n            const p = e / r * (n + 1);\n\n            if (a.isDash) {\n              const t = n - Math.abs(p);\n              h = Math.sqrt(c * c + t * t);\n            } else h = n - Math.sqrt(c * c + p * p);\n\n            this.image.data[i + o] = Math.max(0, Math.min(255, h + 128));\n          }\n        }\n      }\n\n      addRegularDash(t, e) {\n        for (let e = t.length - 1; e >= 0; --e) {\n          const r = t[e],\n                n = t[e + 1];\n          r.zeroLength ? t.splice(e, 1) : n && n.isDash === r.isDash && (n.left = r.left, t.splice(e, 1));\n        }\n\n        const r = t[0],\n              n = t[t.length - 1];\n        r.isDash === n.isDash && (r.left = n.left - this.width, n.right = r.right + this.width);\n        const i = this.width * this.nextRow;\n        let s = 0,\n            a = t[s];\n\n        for (let r = 0; r < this.width; r++) {\n          r / a.right > 1 && (a = t[++s]);\n          const n = Math.abs(r - a.left),\n                o = Math.abs(r - a.right),\n                l = Math.min(n, o);\n          this.image.data[i + r] = Math.max(0, Math.min(255, (a.isDash ? l : -l) + e + 128));\n        }\n      }\n\n      addDash(t, e) {\n        const r = this.getKey(t, e);\n        if (this.positions[r]) return this.positions[r];\n        const n = \"round\" === e,\n              i = n ? 7 : 0,\n              s = 2 * i + 1;\n        if (this.nextRow + s > this.height) return C(\"LineAtlas out of space\"), null;\n        0 === t.length && t.push(1);\n        let a = 0;\n\n        for (let e = 0; e < t.length; e++) t[e] < 0 && (C(\"Negative value is found in line dasharray, replacing values with 0\"), t[e] = 0), a += t[e];\n\n        if (0 !== a) {\n          const r = this.width / a,\n                s = this.getDashRanges(t, this.width, r);\n          n ? this.addRoundDash(s, r, i) : this.addRegularDash(s, \"square\" === e ? .5 * r : 0);\n        }\n\n        const o = this.nextRow + i;\n        this.nextRow += s;\n        const l = {\n          tl: [o, i],\n          br: [a, 0]\n        };\n        return this.positions[r] = l, l;\n      }\n\n    }\n\n    ai(pp);\n\n    class fp {\n      constructor(t) {\n        this._callback = t, this._triggered = !1, \"undefined\" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {\n          this._triggered = !1, this._callback();\n        });\n      }\n\n      trigger() {\n        this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(() => {\n          this._triggered = !1, this._callback();\n        }, 0));\n      }\n\n      remove() {\n        this._channel = void 0, this._callback = () => {};\n      }\n\n    }\n\n    const dp = a.performance;\n\n    function yp(t) {\n      const e = t ? t.url.toString() : void 0;\n      return dp.getEntriesByName(e);\n    }\n\n    class mp {\n      constructor() {\n        this.tasks = {}, this.taskQueue = [], I([\"process\"], this), this.invoker = new fp(this.process), this.nextId = 0;\n      }\n\n      add(t, e) {\n        const r = this.nextId++,\n              n = function ({\n          type: t,\n          isSymbolTile: e,\n          zoom: r\n        }) {\n          return r = r || 0, \"message\" === t ? 0 : \"maybePrepare\" !== t || e ? \"parseTile\" !== t || e ? \"parseTile\" === t && e ? 300 - r : \"maybePrepare\" === t && e ? 400 - r : 500 : 200 - r : 100 - r;\n        }(e);\n\n        if (0 === n) {\n          V();\n\n          try {\n            t();\n          } finally {}\n\n          return {\n            cancel: () => {}\n          };\n        }\n\n        return this.tasks[r] = {\n          fn: t,\n          metadata: e,\n          priority: n,\n          id: r\n        }, this.taskQueue.push(r), this.invoker.trigger(), {\n          cancel: () => {\n            delete this.tasks[r];\n          }\n        };\n      }\n\n      process() {\n        V();\n\n        try {\n          if (this.taskQueue = this.taskQueue.filter(t => !!this.tasks[t]), !this.taskQueue.length) return;\n          const t = this.pick();\n          if (null === t) return;\n          const e = this.tasks[t];\n          if (delete this.tasks[t], this.taskQueue.length && this.invoker.trigger(), !e) return;\n          e.fn();\n        } finally {}\n      }\n\n      pick() {\n        let t = null,\n            e = 1 / 0;\n\n        for (let r = 0; r < this.taskQueue.length; r++) {\n          const n = this.tasks[this.taskQueue[r]];\n          n.priority < e && (e = n.priority, t = r);\n        }\n\n        if (null === t) return null;\n        const r = this.taskQueue[t];\n        return this.taskQueue.splice(t, 1), r;\n      }\n\n      remove() {\n        this.invoker.remove();\n      }\n\n    }\n\n    const gp = ks([{\n      type: \"Float32\",\n      name: \"a_globe_pos\",\n      components: 3\n    }, {\n      type: \"Float32\",\n      name: \"a_merc_pos\",\n      components: 2\n    }, {\n      type: \"Float32\",\n      name: \"a_uv\",\n      components: 2\n    }]),\n          xp = ks([{\n      type: \"Float32\",\n      name: \"a_pos\",\n      components: 3\n    }, {\n      type: \"Float32\",\n      name: \"a_uv\",\n      components: 2\n    }]),\n          {\n      members: vp\n    } = gp,\n          bp = ks([{\n      name: \"a_pos_3\",\n      components: 3,\n      type: \"Int16\"\n    }]);\n\n    var _p = ks([{\n      name: \"a_pos\",\n      type: \"Int16\",\n      components: 2\n    }]);\n\n    const wp = Ya / Math.PI / 2,\n          Ap = -wp,\n          kp = wp,\n          Sp = [new vl([Ap, Ap, Ap], [kp, kp, kp]), new vl([Ap, Ap, Ap], [0, 0, kp]), new vl([0, Ap, Ap], [kp, 0, kp]), new vl([Ap, 0, Ap], [0, kp, kp]), new vl([0, 0, Ap], [kp, kp, kp])];\n\n    class Ip {\n      constructor(t, e, r) {\n        this.a = hl([], t, r), this.b = hl([], e, r), this.center = r;\n        const n = sl([], this.a),\n              i = sl([], this.b);\n        this.angle = Math.acos(al(n, i));\n      }\n\n    }\n\n    function Mp(t, e) {\n      if (0 === t.angle) return null;\n      let r;\n      return r = 0 === t.a[e] ? 1 / t.angle * .5 * Math.PI : 1 / t.angle * Math.atan(t.b[e] / t.a[e] / Math.sin(t.angle) - 1 / Math.tan(t.angle)), r < 0 || r > 1 ? null : function (t, e, r, n) {\n        const i = Math.sin(r);\n        return t * (Math.sin((1 - n) * r) / i) + e * (Math.sin(n * r) / i);\n      }(t.a[e], t.b[e], t.angle, y(r, 0, 1)) + t.center[e];\n    }\n\n    function Tp(t) {\n      if (t.z <= 1) return Sp[t.z + 2 * t.y + t.x];\n      const [e, r] = Bp(t),\n            n = [Cp(e[0], e[1]), Cp(e[0], r[1]), Cp(r[0], e[1]), Cp(r[0], r[1])],\n            i = [kp, kp, kp],\n            s = [Ap, Ap, Ap];\n\n      for (const t of n) i[0] = Math.min(i[0], t[0]), i[1] = Math.min(i[1], t[1]), i[2] = Math.min(i[2], t[2]), s[0] = Math.max(s[0], t[0]), s[1] = Math.max(s[1], t[1]), s[2] = Math.max(s[2], t[2]);\n\n      return new vl(i, s);\n    }\n\n    function zp(t, e, r) {\n      const n = e / t.worldSize,\n            i = (t, e) => {\n        nl(t, t, n), nl(e, e, n);\n      },\n            s = Number.MAX_VALUE,\n            a = [-s, -s, -s],\n            o = [s, s, s],\n            l = Lp(t);\n\n      if (r.z <= 1) {\n        const t = Tp(r).getCorners();\n\n        for (let e = 0; e < t.length; e++) ll(t[e], t[e], l), el(o, o, t[e]), rl(a, a, t[e]);\n\n        return i(o, a), new vl(o, a);\n      }\n\n      const [c, h] = Bp(r),\n            p = new Ha();\n      p.setSouthWest([c[1], h[0]]), p.setNorthEast([h[1], c[0]]);\n      const f = [Cp(p.getSouth(), p.getWest()), Cp(p.getSouth(), p.getEast()), Cp(p.getNorth(), p.getEast()), Cp(p.getNorth(), p.getWest())];\n\n      for (let t = 0; t < f.length; t++) ll(f[t], f[t], l), el(o, o, f[t]), rl(a, a, f[t]);\n\n      if (p.contains(t.center)) return a[2] = 0, i(o, a), new vl(o, a);\n      const d = [l[12], l[13], l[14]],\n            m = t.center.lng,\n            g = y(t.center.lat, -85.051129, oo),\n            x = [eo(m), ro(g)],\n            v = p.getCenter().lng,\n            b = y(p.getCenter().lat, -85.051129, oo),\n            _ = [eo(v), ro(b)];\n      let w = new Array(3),\n          A = 0;\n      const k = x[0] - _[0],\n            S = x[1] - _[1];\n      if (Math.abs(k) > Math.abs(S)) A = k >= 0 ? 1 : 3, w = d;else {\n        A = S >= 0 ? 0 : 2;\n        const t = [l[4], l[5], l[6]];\n        let e;\n        e = S >= 0 ? -Math.sin(u(p.getSouth())) * wp : -Math.sin(u(p.getNorth())) * wp, w = il(w, d, t, e);\n      }\n      const I = f[A],\n            M = f[(A + 1) % 4],\n            T = new Ip(I, M, w),\n            z = [Mp(T, 0) || I[0], Mp(T, 1) || I[1], Mp(T, 2) || I[2]];\n      return o[2] = Math.min(I[2], M[2]), el(o, o, z), rl(a, a, z), i(o, a), new vl(o, a);\n    }\n\n    function Bp(t) {\n      const e = 1 << t.z,\n            r = t.x / e,\n            n = (t.x + 1) / e,\n            i = (t.y + 1) / e;\n      return [[so(t.y / e), io(r)], [so(i), io(n)]];\n    }\n\n    function Ep(t, e, r, n = wp) {\n      return r = u(r), [t * Math.sin(r) * n, -e * n, t * Math.cos(r) * n];\n    }\n\n    function Cp(t, e, r) {\n      return Ep(Math.cos(u(t)), Math.sin(u(t)), e, r);\n    }\n\n    function Dp(t, e, r) {\n      const n = Math.pow(2, r.z),\n            i = (t / Ya + r.x) / n;\n      return Cp(so((e / Ya + r.y) / n), io(i));\n    }\n\n    function Pp(t) {\n      return 16383 / Math.max(...hl([], t.max, t.min));\n    }\n\n    function Vp(t) {\n      const e = jo(new Float64Array(16)),\n            r = Pp(t);\n      var n, i;\n      return No(e, e, [r, r, r]), qo(e, e, ((n = [])[0] = -(i = t.min)[0], n[1] = -i[1], n[2] = -i[2], n)), e;\n    }\n\n    function Fp(t, e, r, n, i) {\n      const s = function (t) {\n        const e = Ya / (2 * Math.PI);\n        return t / (2 * Math.PI) / e;\n      }(r),\n            a = [t, e, -r / (2 * Math.PI)],\n            o = jo(new Float64Array(16));\n\n      return qo(o, o, a), No(o, o, [s, s, s]), Go(o, o, u(-i)), Zo(o, o, u(-n)), o;\n    }\n\n    function Lp(t) {\n      const {\n        x: e,\n        y: r\n      } = t.point,\n            {\n        lng: n,\n        lat: i\n      } = t._center;\n      return Fp(e, r, t.worldSize, n, i);\n    }\n\n    const Rp = u(85),\n          Up = Math.cos(Rp),\n          $p = Math.sin(Rp);\n\n    function jp(t, e, r) {\n      var n = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r);\n      return [t * n - 2 * Math.PI * 6378137 / 2, e * n - 2 * Math.PI * 6378137 / 2];\n    }\n\n    class Op {\n      constructor(t, e, r) {\n        this.z = t, this.x = e, this.y = r, this.key = Gp(0, t, t, e, r);\n      }\n\n      equals(t) {\n        return this.z === t.z && this.x === t.x && this.y === t.y;\n      }\n\n      url(t, e) {\n        const r = function (t, e, r) {\n          var n = jp(256 * t, 256 * (e = Math.pow(2, r) - e - 1), r),\n              i = jp(256 * (t + 1), 256 * (e + 1), r);\n          return n[0] + \",\" + n[1] + \",\" + i[0] + \",\" + i[1];\n        }(this.x, this.y, this.z),\n              n = function (t, e, r) {\n          let n,\n              i = \"\";\n\n          for (let s = t; s > 0; s--) n = 1 << s - 1, i += (e & n ? 1 : 0) + (r & n ? 2 : 0);\n\n          return i;\n        }(this.z, this.x, this.y);\n\n        return t[(this.x + this.y) % t.length].replace(\"{prefix}\", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(\"{z}\", String(this.z)).replace(\"{x}\", String(this.x)).replace(\"{y}\", String(\"tms\" === e ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(\"{quadkey}\", n).replace(\"{bbox-epsg-3857}\", r);\n      }\n\n      toString() {\n        return `${this.z}/${this.x}/${this.y}`;\n      }\n\n    }\n\n    class qp {\n      constructor(t, e) {\n        this.wrap = t, this.canonical = e, this.key = Gp(t, e.z, e.z, e.x, e.y);\n      }\n\n    }\n\n    class Np {\n      constructor(t, e, r, n, i) {\n        this.overscaledZ = t, this.wrap = e, this.canonical = new Op(r, +n, +i), this.key = 0 === e && t === r ? this.canonical.key : Gp(e, t, r, n, i);\n      }\n\n      equals(t) {\n        return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical);\n      }\n\n      scaledTo(t) {\n        const e = this.canonical.z - t;\n        return t > this.canonical.z ? new Np(t, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Np(t, this.wrap, t, this.canonical.x >> e, this.canonical.y >> e);\n      }\n\n      calculateScaledKey(t, e = !0) {\n        if (this.overscaledZ === t && e) return this.key;\n        if (t > this.canonical.z) return Gp(this.wrap * +e, t, this.canonical.z, this.canonical.x, this.canonical.y);\n        {\n          const r = this.canonical.z - t;\n          return Gp(this.wrap * +e, t, t, this.canonical.x >> r, this.canonical.y >> r);\n        }\n      }\n\n      isChildOf(t) {\n        if (t.wrap !== this.wrap) return !1;\n        const e = this.canonical.z - t.canonical.z;\n        return 0 === t.overscaledZ || t.overscaledZ < this.overscaledZ && t.canonical.x === this.canonical.x >> e && t.canonical.y === this.canonical.y >> e;\n      }\n\n      children(t) {\n        if (this.overscaledZ >= t) return [new Np(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];\n        const e = this.canonical.z + 1,\n              r = 2 * this.canonical.x,\n              n = 2 * this.canonical.y;\n        return [new Np(e, this.wrap, e, r, n), new Np(e, this.wrap, e, r + 1, n), new Np(e, this.wrap, e, r, n + 1), new Np(e, this.wrap, e, r + 1, n + 1)];\n      }\n\n      isLessThan(t) {\n        return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y));\n      }\n\n      wrapped() {\n        return new Np(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);\n      }\n\n      unwrapTo(t) {\n        return new Np(this.overscaledZ, t, this.canonical.z, this.canonical.x, this.canonical.y);\n      }\n\n      overscaleFactor() {\n        return Math.pow(2, this.overscaledZ - this.canonical.z);\n      }\n\n      toUnwrapped() {\n        return new qp(this.wrap, this.canonical);\n      }\n\n      toString() {\n        return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;\n      }\n\n    }\n\n    function Gp(t, e, r, n, i) {\n      const s = 1 << Math.min(r, 22);\n      let a = s * (i % s) + n % s;\n      return t && r < 22 && (a += s * s * ((t < 0 ? -2 * t - 1 : 2 * t) % (1 << 2 * (22 - r)))), 16 * (32 * a + r) + (e - r);\n    }\n\n    function Zp(t, e) {\n      if (!e.isReprojectedInTileSpace) return {\n        scale: 1 << t.z,\n        x: t.x,\n        y: t.y,\n        x2: t.x + 1,\n        y2: t.y + 1,\n        projection: e\n      };\n      const r = Math.pow(2, -t.z),\n            n = t.x * r,\n            i = (t.x + 1) * r,\n            s = t.y * r,\n            a = (t.y + 1) * r,\n            o = io(n),\n            l = io(i),\n            u = so(s),\n            c = so(a),\n            h = e.project(o, u),\n            p = e.project(l, u),\n            f = e.project(l, c),\n            d = e.project(o, c);\n      let y = Math.min(h.x, p.x, f.x, d.x),\n          m = Math.min(h.y, p.y, f.y, d.y),\n          g = Math.max(h.x, p.x, f.x, d.x),\n          x = Math.max(h.y, p.y, f.y, d.y);\n      const v = r / 16;\n\n      function b(t, r, n, i, s, a) {\n        const o = (n + s) / 2,\n              l = (i + a) / 2,\n              u = e.project(io(o), so(l)),\n              c = Math.max(0, y - u.x, m - u.y, u.x - g, u.y - x);\n        y = Math.min(y, u.x), g = Math.max(g, u.x), m = Math.min(m, u.y), x = Math.max(x, u.y), c > v && (b(t, u, n, i, o, l), b(u, r, o, l, s, a));\n      }\n\n      b(h, p, n, s, i, s), b(p, f, i, s, i, a), b(f, d, i, a, n, a), b(d, h, n, a, n, s), y -= v, m -= v, g += v, x += v;\n\n      const _ = 1 / Math.max(g - y, x - m);\n\n      return {\n        scale: _,\n        x: y * _,\n        y: m * _,\n        x2: g * _,\n        y2: x * _,\n        projection: e\n      };\n    }\n\n    ai(Op), ai(Np, {\n      omit: [\"projMatrix\"]\n    });\n\n    class Xp {\n      constructor(t) {\n        this._stringToNumber = {}, this._numberToString = [];\n\n        for (let e = 0; e < t.length; e++) {\n          const r = t[e];\n          this._stringToNumber[r] = e, this._numberToString[e] = r;\n        }\n      }\n\n      encode(t) {\n        return this._stringToNumber[t];\n      }\n\n      decode(t) {\n        return this._numberToString[t];\n      }\n\n    }\n\n    const Kp = [\"tile\", \"layer\", \"source\", \"sourceLayer\", \"state\"];\n\n    class Yp {\n      constructor(t, e, r, n, i) {\n        this.type = \"Feature\", this._vectorTileFeature = t, this._z = e, this._x = r, this._y = n, this.properties = t.properties, this.id = i;\n      }\n\n      get geometry() {\n        return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry), this._geometry;\n      }\n\n      set geometry(t) {\n        this._geometry = t;\n      }\n\n      toJSON() {\n        const t = {\n          type: \"Feature\",\n          geometry: this.geometry,\n          properties: this.properties\n        };\n        void 0 !== this.id && (t.id = this.id);\n\n        for (const e of Kp) void 0 !== this[e] && (t[e] = this[e]);\n\n        return t;\n      }\n\n    }\n\n    const Hp = 32,\n          Wp = 33,\n          Jp = new Uint16Array(8184);\n\n    for (let t = 0; t < 2046; t++) {\n      let e = t + 2,\n          r = 0,\n          n = 0,\n          i = 0,\n          s = 0,\n          a = 0,\n          o = 0;\n\n      for (1 & e ? i = s = a = Hp : r = n = o = Hp; (e >>= 1) > 1;) {\n        const t = r + i >> 1,\n              l = n + s >> 1;\n        1 & e ? (i = r, s = n, r = a, n = o) : (r = i, n = s, i = a, s = o), a = t, o = l;\n      }\n\n      const l = 4 * t;\n      Jp[l + 0] = r, Jp[l + 1] = n, Jp[l + 2] = i, Jp[l + 3] = s;\n    }\n\n    const Qp = new Uint16Array(2178),\n          tf = new Uint8Array(1089),\n          ef = new Uint16Array(1089);\n\n    function rf(t) {\n      return 0 === t ? -.03125 : 32 === t ? .03125 : 0;\n    }\n\n    var nf = ks([{\n      name: \"a_pos\",\n      type: \"Int16\",\n      components: 2\n    }, {\n      name: \"a_texture_pos\",\n      type: \"Int16\",\n      components: 2\n    }]);\n    const sf = {\n      type: 2,\n      extent: Ya,\n      loadGeometry: () => [[new i(0, 0), new i(8193, 0), new i(8193, 8193), new i(0, 8193), new i(0, 0)]]\n    };\n\n    class af {\n      constructor(t, e, r, n, i) {\n        this.tileID = t, this.uid = w(), this.uses = 0, this.tileSize = e, this.tileZoom = r, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.isRaster = i, this.expiredRequestCount = 0, this.state = \"loading\", n && n.transform && (this.projection = n.transform.projection);\n      }\n\n      registerFadeDuration(t) {\n        const e = t + this.timeAdded;\n        e < N.now() || this.fadeEndTime && e < this.fadeEndTime || (this.fadeEndTime = e);\n      }\n\n      wasRequested() {\n        return \"errored\" === this.state || \"loaded\" === this.state || \"reloading\" === this.state;\n      }\n\n      get tileTransform() {\n        return this._tileTransform || (this._tileTransform = Zp(this.tileID.canonical, this.projection)), this._tileTransform;\n      }\n\n      loadVectorData(t, e, r) {\n        if (this.unloadVectorData(), this.state = \"loaded\", t) {\n          t.featureIndex && (this.latestFeatureIndex = t.featureIndex, t.rawTileData ? (this.latestRawTileData = t.rawTileData, this.latestFeatureIndex.rawTileData = t.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t.collisionBoxArray, this.buckets = function (t, e) {\n            const r = {};\n            if (!e) return r;\n\n            for (const n of t) {\n              const t = n.layerIds.map(t => e.getLayer(t)).filter(Boolean);\n\n              if (0 !== t.length) {\n                n.layers = t, n.stateDependentLayerIds && (n.stateDependentLayers = n.stateDependentLayerIds.map(e => t.filter(t => t.id === e)[0]));\n\n                for (const e of t) r[e.id] = n;\n              }\n            }\n\n            return r;\n          }(t.buckets, e.style), this.hasSymbolBuckets = !1;\n\n          for (const t in this.buckets) {\n            const e = this.buckets[t];\n\n            if (e instanceof tp) {\n              if (this.hasSymbolBuckets = !0, !r) break;\n              e.justReloaded = !0;\n            }\n          }\n\n          if (this.hasRTLText = !1, this.hasSymbolBuckets) for (const t in this.buckets) {\n            const e = this.buckets[t];\n\n            if (e instanceof tp && e.hasRTLText) {\n              this.hasRTLText = !0, is.isLoading() || is.isLoaded() || \"deferred\" !== rs() || ns();\n              break;\n            }\n          }\n          this.queryPadding = 0;\n\n          for (const t in this.buckets) {\n            const r = this.buckets[t];\n            this.queryPadding = Math.max(this.queryPadding, e.style.getLayer(t).queryRadius(r));\n          }\n\n          t.imageAtlas && (this.imageAtlas = t.imageAtlas), t.glyphAtlasImage && (this.glyphAtlasImage = t.glyphAtlasImage), t.lineAtlas && (this.lineAtlas = t.lineAtlas);\n        } else this.collisionBoxArray = new ea();\n      }\n\n      unloadVectorData() {\n        if (this.hasData()) {\n          for (const t in this.buckets) this.buckets[t].destroy();\n\n          this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.lineAtlasTexture && this.lineAtlasTexture.destroy(), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugIndexBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), this.latestFeatureIndex = null, this.state = \"unloaded\";\n        }\n      }\n\n      getBucket(t) {\n        return this.buckets[t.id];\n      }\n\n      upload(t) {\n        for (const e in this.buckets) {\n          const r = this.buckets[e];\n          r.uploadPending() && r.upload(t);\n        }\n\n        const e = t.gl;\n        this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new hp(t, this.imageAtlas.image, e.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new hp(t, this.glyphAtlasImage, e.ALPHA), this.glyphAtlasImage = null), this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new hp(t, this.lineAtlas.image, e.ALPHA), this.lineAtlas.uploaded = !0);\n      }\n\n      prepare(t) {\n        this.imageAtlas && this.imageAtlas.patchUpdatedImages(t, this.imageAtlasTexture);\n      }\n\n      queryRenderedFeatures(t, e, r, n, i, s, a, o) {\n        return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({\n          tileResult: n,\n          pixelPosMatrix: a,\n          transform: s,\n          params: i,\n          tileTransform: this.tileTransform\n        }, t, e, r) : {};\n      }\n\n      querySourceFeatures(t, e) {\n        const r = this.latestFeatureIndex;\n        if (!r || !r.rawTileData) return;\n        const n = r.loadVTLayers(),\n              i = e ? e.sourceLayer : \"\",\n              s = n._geojsonTileLayer || n[i];\n        if (!s) return;\n        const a = Sn(e && e.filter),\n              {\n          z: o,\n          x: l,\n          y: u\n        } = this.tileID.canonical,\n              c = {\n          z: o,\n          x: l,\n          y: u\n        };\n\n        for (let e = 0; e < s.length; e++) {\n          const n = s.feature(e);\n\n          if (a.needGeometry) {\n            const t = mo(n, !0);\n            if (!a.filter(new ss(this.tileID.overscaledZ), t, this.tileID.canonical)) continue;\n          } else if (!a.filter(new ss(this.tileID.overscaledZ), n)) continue;\n\n          const h = r.getId(n, i),\n                p = new Yp(n, o, l, u, h);\n          p.tile = c, t.push(p);\n        }\n      }\n\n      hasData() {\n        return \"loaded\" === this.state || \"reloading\" === this.state || \"expired\" === this.state;\n      }\n\n      patternsLoaded() {\n        return !!this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;\n      }\n\n      setExpiryData(t) {\n        const e = this.expirationTime;\n\n        if (t.cacheControl) {\n          const e = F(t.cacheControl);\n          e[\"max-age\"] && (this.expirationTime = Date.now() + 1e3 * e[\"max-age\"]);\n        } else t.expires && (this.expirationTime = new Date(t.expires).getTime());\n\n        if (this.expirationTime) {\n          const t = Date.now();\n          let r = !1;\n          if (this.expirationTime > t) r = !1;else if (e) {\n            if (this.expirationTime < e) r = !0;else {\n              const n = this.expirationTime - e;\n              n ? this.expirationTime = t + Math.max(n, 3e4) : r = !0;\n            }\n          } else r = !0;\n          r ? (this.expiredRequestCount++, this.state = \"expired\") : this.expiredRequestCount = 0;\n        }\n      }\n\n      getExpiryTimeout() {\n        if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1);\n      }\n\n      setFeatureState(t, e) {\n        if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || 0 === Object.keys(t).length || !e) return;\n        const r = this.latestFeatureIndex.loadVTLayers(),\n              n = e.style.listImages();\n\n        for (const i in this.buckets) {\n          if (!e.style.hasLayer(i)) continue;\n          const s = this.buckets[i],\n                a = s.layers[0].sourceLayer || \"_geojsonTileLayer\",\n                o = r[a],\n                l = t[a];\n          if (!o || !l || 0 === Object.keys(l).length) continue;\n\n          if (s.update(l, o, n, this.imageAtlas && this.imageAtlas.patternPositions || {}), s instanceof Qu || s instanceof xu) {\n            const t = e.style._getSourceCache(s.layers[0].source);\n\n            e._terrain && e._terrain.enabled && t && s.programConfigurations.needsUpload && e._terrain._clearRenderCacheForTile(t.id, this.tileID);\n          }\n\n          const u = e && e.style && e.style.getLayer(i);\n          u && (this.queryPadding = Math.max(this.queryPadding, u.queryRadius(s)));\n        }\n      }\n\n      holdingForFade() {\n        return void 0 !== this.symbolFadeHoldUntil;\n      }\n\n      symbolFadeFinished() {\n        return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < N.now();\n      }\n\n      clearFadeHold() {\n        this.symbolFadeHoldUntil = void 0;\n      }\n\n      setHoldDuration(t) {\n        this.symbolFadeHoldUntil = N.now() + t;\n      }\n\n      setTexture(t, e) {\n        const r = e.context,\n              n = r.gl;\n        this.texture = e.getTileTexture(t.width), this.texture ? this.texture.update(t, {\n          useMipmap: !0\n        }) : (this.texture = new hp(r, t, n.RGBA, {\n          useMipmap: !0\n        }), this.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE), r.extTextureFilterAnisotropic && n.texParameterf(n.TEXTURE_2D, r.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, r.extTextureFilterAnisotropicMax));\n      }\n\n      setDependencies(t, e) {\n        const r = {};\n\n        for (const t of e) r[t] = !0;\n\n        this.dependencies[t] = r;\n      }\n\n      hasDependency(t, e) {\n        for (const r of t) {\n          const t = this.dependencies[r];\n          if (t) for (const r of e) if (t[r]) return !0;\n        }\n\n        return !1;\n      }\n\n      clearQueryDebugViz() {}\n\n      _makeDebugTileBoundsBuffers(t, e) {\n        if (!e || \"mercator\" === e.name || this._tileDebugBuffer) return;\n        const r = yo(sf, this.tileID.canonical, this.tileTransform)[0],\n              n = new Is(),\n              i = new Ks();\n\n        for (let t = 0; t < r.length; t++) {\n          const {\n            x: e,\n            y: s\n          } = r[t];\n          n.emplaceBack(e, s), i.emplaceBack(t);\n        }\n\n        i.emplaceBack(0), this._tileDebugIndexBuffer = t.createIndexBuffer(i), this._tileDebugBuffer = t.createVertexBuffer(n, _p.members), this._tileDebugSegments = Ka.simpleSegment(0, 0, n.length, i.length);\n      }\n\n      _makeTileBoundsBuffers(t, e) {\n        if (this._tileBoundsBuffer || !e || \"mercator\" === e.name) return;\n        const r = yo(sf, this.tileID.canonical, this.tileTransform)[0];\n        let n, i;\n\n        if (this.isRaster) {\n          const t = function (t, e) {\n            const r = Zp(t, e),\n                  n = Math.pow(2, t.z);\n\n            for (let i = 0; i < Wp; i++) for (let s = 0; s < Wp; s++) {\n              const a = io((t.x + (s + rf(s)) / Hp) / n),\n                    o = so((t.y + (i + rf(i)) / Hp) / n),\n                    l = e.project(a, o),\n                    u = i * Wp + s;\n              Qp[2 * u + 0] = Math.round((l.x * r.scale - r.x) * Ya), Qp[2 * u + 1] = Math.round((l.y * r.scale - r.y) * Ya);\n            }\n\n            tf.fill(0), ef.fill(0);\n\n            for (let t = 2045; t >= 0; t--) {\n              const e = 4 * t,\n                    r = Jp[e + 0],\n                    n = Jp[e + 1],\n                    i = Jp[e + 2],\n                    s = Jp[e + 3],\n                    a = r + i >> 1,\n                    o = n + s >> 1,\n                    l = a + o - n,\n                    u = o + r - a,\n                    c = n * Wp + r,\n                    h = s * Wp + i,\n                    p = o * Wp + a,\n                    f = Math.hypot((Qp[2 * c + 0] + Qp[2 * h + 0]) / 2 - Qp[2 * p + 0], (Qp[2 * c + 1] + Qp[2 * h + 1]) / 2 - Qp[2 * p + 1]) >= 16;\n\n              if (tf[p] = tf[p] || (f ? 1 : 0), t < 1022) {\n                const t = (n + u >> 1) * Wp + (r + l >> 1),\n                      e = (s + u >> 1) * Wp + (i + l >> 1);\n                tf[p] = tf[p] || tf[t] || tf[e];\n              }\n            }\n\n            const i = new Ts(),\n                  s = new $s();\n            let a = 0;\n\n            function o(t, e) {\n              const r = e * Wp + t;\n              return 0 === ef[r] && (i.emplaceBack(Qp[2 * r + 0], Qp[2 * r + 1], t * Ya / Hp, e * Ya / Hp), ef[r] = ++a), ef[r] - 1;\n            }\n\n            function l(t, e, r, n, i, a) {\n              const u = t + r >> 1,\n                    c = e + n >> 1;\n              if (Math.abs(t - i) + Math.abs(e - a) > 1 && tf[c * Wp + u]) l(i, a, t, e, u, c), l(r, n, i, a, u, c);else {\n                const l = o(t, e),\n                      u = o(r, n),\n                      c = o(i, a);\n                s.emplaceBack(l, u, c);\n              }\n            }\n\n            return l(0, 0, Hp, Hp, Hp, 0), l(Hp, Hp, 0, 0, 0, Hp), {\n              vertices: i,\n              indices: s\n            };\n          }(this.tileID.canonical, e);\n\n          n = t.vertices, i = t.indices;\n        } else {\n          n = new Ts(), i = new $s();\n\n          for (const {\n            x: t,\n            y: e\n          } of r) n.emplaceBack(t, e, 0, 0);\n\n          const t = Fl(n.int16, void 0, 4);\n\n          for (let e = 0; e < t.length; e += 3) i.emplaceBack(t[e], t[e + 1], t[e + 2]);\n        }\n\n        this._tileBoundsBuffer = t.createVertexBuffer(n, nf.members), this._tileBoundsIndexBuffer = t.createIndexBuffer(i), this._tileBoundsSegments = Ka.simpleSegment(0, 0, n.length, i.length);\n      }\n\n      _makeGlobeTileDebugBuffers(t, e) {\n        if (this._globeTileDebugBorderBuffer || this._globeTileDebugTextBuffer || !e || \"globe\" !== e.name) return;\n        const r = this.tileID.canonical,\n              n = Vp(Tp(r));\n        this._makeGlobeTileDebugBorderBuffer(t, r, n), this._makeGlobeTileDebugTextBuffer(t, r, n);\n      }\n\n      _makeGlobeTileDebugBorderBuffer(t, e, r) {\n        const n = new Is(),\n              i = new Ks(),\n              s = new Ms(),\n              a = (t, a, o, l, u) => {\n          const c = (o - t) / (u - 1),\n                h = (l - a) / (u - 1),\n                p = n.length;\n\n          for (let o = 0; o < u; o++) {\n            const l = t + o * c,\n                  u = a + o * h;\n            n.emplaceBack(l, u);\n            const f = Dp(l, u, e),\n                  d = ll(f, f, r);\n            s.emplaceBack(d[0], d[1], d[2]), i.emplaceBack(p + o);\n          }\n        },\n              o = Ya;\n\n        a(0, 0, o, 0, 16), a(o, 0, o, o, 16), a(o, o, 0, o, 16), a(0, o, 0, 0, 16), this._tileDebugIndexBuffer = t.createIndexBuffer(i), this._tileDebugBuffer = t.createVertexBuffer(n, _p.members), this._globeTileDebugBorderBuffer = t.createVertexBuffer(s, bp.members), this._tileDebugSegments = Ka.simpleSegment(0, 0, n.length, i.length);\n      }\n\n      _makeGlobeTileDebugTextBuffer(t, e, r) {\n        const n = new Is(),\n              i = new $s(),\n              s = new Ms(),\n              a = 25;\n        i.reserve(32), n.reserve(a), s.reserve(a);\n\n        const o = (t, e) => a * t + e;\n\n        for (let t = 0; t < a; t++) {\n          const i = 2048 * t;\n\n          for (let t = 0; t < a; t++) {\n            const a = 2048 * t;\n            n.emplaceBack(a, i);\n            const o = Dp(a, i, e),\n                  l = ll(o, o, r);\n            s.emplaceBack(l[0], l[1], l[2]);\n          }\n        }\n\n        for (let t = 0; t < 4; t++) for (let e = 0; e < 4; e++) {\n          const r = o(t, e),\n                n = o(t, e + 1),\n                s = o(t + 1, e),\n                a = o(t + 1, e + 1);\n          i.emplaceBack(r, n, s), i.emplaceBack(s, n, a);\n        }\n\n        this._tileDebugTextIndexBuffer = t.createIndexBuffer(i), this._tileDebugTextBuffer = t.createVertexBuffer(n, _p.members), this._globeTileDebugTextBuffer = t.createVertexBuffer(s, bp.members), this._tileDebugTextSegments = Ka.simpleSegment(0, 0, a, 32);\n      }\n\n    }\n\n    class of {\n      constructor() {\n        this.state = {}, this.stateChanges = {}, this.deletedStates = {};\n      }\n\n      updateState(t, e, r) {\n        const n = String(e);\n\n        if (this.stateChanges[t] = this.stateChanges[t] || {}, this.stateChanges[t][n] = this.stateChanges[t][n] || {}, b(this.stateChanges[t][n], r), null === this.deletedStates[t]) {\n          this.deletedStates[t] = {};\n\n          for (const e in this.state[t]) e !== n && (this.deletedStates[t][e] = null);\n        } else if (this.deletedStates[t] && null === this.deletedStates[t][n]) {\n          this.deletedStates[t][n] = {};\n\n          for (const e in this.state[t][n]) r[e] || (this.deletedStates[t][n][e] = null);\n        } else for (const e in r) this.deletedStates[t] && this.deletedStates[t][n] && null === this.deletedStates[t][n][e] && delete this.deletedStates[t][n][e];\n      }\n\n      removeFeatureState(t, e, r) {\n        if (null === this.deletedStates[t]) return;\n        const n = String(e);\n        if (this.deletedStates[t] = this.deletedStates[t] || {}, r && void 0 !== e) null !== this.deletedStates[t][n] && (this.deletedStates[t][n] = this.deletedStates[t][n] || {}, this.deletedStates[t][n][r] = null);else if (void 0 !== e) {\n          if (this.stateChanges[t] && this.stateChanges[t][n]) for (r in this.deletedStates[t][n] = {}, this.stateChanges[t][n]) this.deletedStates[t][n][r] = null;else this.deletedStates[t][n] = null;\n        } else this.deletedStates[t] = null;\n      }\n\n      getState(t, e) {\n        const r = String(e),\n              n = b({}, (this.state[t] || {})[r], (this.stateChanges[t] || {})[r]);\n        if (null === this.deletedStates[t]) return {};\n\n        if (this.deletedStates[t]) {\n          const r = this.deletedStates[t][e];\n          if (null === r) return {};\n\n          for (const t in r) delete n[t];\n        }\n\n        return n;\n      }\n\n      initializeTileState(t, e) {\n        t.setFeatureState(this.state, e);\n      }\n\n      coalesceChanges(t, e) {\n        const r = {};\n\n        for (const t in this.stateChanges) {\n          this.state[t] = this.state[t] || {};\n          const e = {};\n\n          for (const r in this.stateChanges[t]) this.state[t][r] || (this.state[t][r] = {}), b(this.state[t][r], this.stateChanges[t][r]), e[r] = this.state[t][r];\n\n          r[t] = e;\n        }\n\n        for (const t in this.deletedStates) {\n          this.state[t] = this.state[t] || {};\n          const e = {};\n          if (null === this.deletedStates[t]) for (const r in this.state[t]) e[r] = {}, this.state[t][r] = {};else for (const r in this.deletedStates[t]) {\n            if (null === this.deletedStates[t][r]) this.state[t][r] = {};else for (const e of Object.keys(this.deletedStates[t][r])) delete this.state[t][r][e];\n            e[r] = this.state[t][r];\n          }\n          r[t] = r[t] || {}, b(r[t], e);\n        }\n\n        if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(r).length) for (const n in t) t[n].setFeatureState(r, e);\n      }\n\n    }\n\n    class lf {\n      constructor(t) {\n        this.size = t, this.minimums = [], this.maximums = [], this.leaves = [];\n      }\n\n      getElevation(t, e) {\n        const r = this.toIdx(t, e);\n        return {\n          min: this.minimums[r],\n          max: this.maximums[r]\n        };\n      }\n\n      isLeaf(t, e) {\n        return this.leaves[this.toIdx(t, e)];\n      }\n\n      toIdx(t, e) {\n        return e * this.size + t;\n      }\n\n    }\n\n    function uf(t, e, r, n) {\n      let i = 0,\n          s = Number.MAX_VALUE;\n\n      for (let a = 0; a < 3; a++) if (Math.abs(n[a]) < 1e-15) {\n        if (r[a] < t[a] || r[a] > e[a]) return null;\n      } else {\n        const o = 1 / n[a];\n        let l = (t[a] - r[a]) * o,\n            u = (e[a] - r[a]) * o;\n\n        if (l > u) {\n          const t = l;\n          l = u, u = t;\n        }\n\n        if (l > i && (i = l), u < s && (s = u), i > s) return null;\n      }\n\n      return i;\n    }\n\n    function cf(t, e, r, n, i, s, a, o, l, u, c) {\n      const h = n - t,\n            p = i - e,\n            f = s - r,\n            d = a - t,\n            y = o - e,\n            m = l - r,\n            g = c[1] * m - c[2] * y,\n            x = c[2] * d - c[0] * m,\n            v = c[0] * y - c[1] * d,\n            b = h * g + p * x + f * v;\n      if (Math.abs(b) < 1e-15) return null;\n\n      const _ = 1 / b,\n            w = u[0] - t,\n            A = u[1] - e,\n            k = u[2] - r,\n            S = (w * g + A * x + k * v) * _;\n\n      if (S < 0 || S > 1) return null;\n      const I = A * f - k * p,\n            M = k * h - w * f,\n            T = w * p - A * h,\n            z = (c[0] * I + c[1] * M + c[2] * T) * _;\n      return z < 0 || S + z > 1 ? null : (d * I + y * M + m * T) * _;\n    }\n\n    function hf(t, e, r) {\n      return (t - e) / (r - e);\n    }\n\n    function pf(t, e, r, n, i, s, a, o, l) {\n      const u = 1 << r,\n            c = s - n,\n            h = a - i,\n            p = (t + 1) / u * c + n,\n            f = (e + 0) / u * h + i,\n            d = (e + 1) / u * h + i;\n      o[0] = (t + 0) / u * c + n, o[1] = f, l[0] = p, l[1] = d;\n    }\n\n    class ff {\n      constructor(t) {\n        if (this.maximums = [], this.minimums = [], this.leaves = [], this.childOffsets = [], this.nodeCount = 0, this.dem = t, this._siblingOffset = [[0, 0], [1, 0], [0, 1], [1, 1]], !this.dem) return;\n\n        const e = function (t) {\n          const e = Math.ceil(Math.log2(t.dim / 8)),\n                r = [];\n          let n = Math.ceil(Math.pow(2, e));\n\n          const i = 1 / n,\n                s = (t, e, r, n, i) => {\n            const s = n ? 1 : 0,\n                  a = (t + 1) * r - s,\n                  o = e * r,\n                  l = (e + 1) * r - s;\n            i[0] = t * r, i[1] = o, i[2] = a, i[3] = l;\n          };\n\n          let a = new lf(n);\n          const o = [];\n\n          for (let e = 0; e < n * n; e++) {\n            s(e % n, Math.floor(e / n), i, !1, o);\n            const r = yf(o[0], o[1], t),\n                  l = yf(o[2], o[1], t),\n                  u = yf(o[2], o[3], t),\n                  c = yf(o[0], o[3], t);\n            a.minimums.push(Math.min(r, l, u, c)), a.maximums.push(Math.max(r, l, u, c)), a.leaves.push(1);\n          }\n\n          for (r.push(a), n /= 2; n >= 1; n /= 2) {\n            const t = r[r.length - 1];\n            a = new lf(n);\n\n            for (let e = 0; e < n * n; e++) {\n              s(e % n, Math.floor(e / n), 2, !0, o);\n              const r = t.getElevation(o[0], o[1]),\n                    i = t.getElevation(o[2], o[1]),\n                    l = t.getElevation(o[2], o[3]),\n                    u = t.getElevation(o[0], o[3]),\n                    c = t.isLeaf(o[0], o[1]),\n                    h = t.isLeaf(o[2], o[1]),\n                    p = t.isLeaf(o[2], o[3]),\n                    f = t.isLeaf(o[0], o[3]),\n                    d = Math.min(r.min, i.min, l.min, u.min),\n                    y = Math.max(r.max, i.max, l.max, u.max),\n                    m = c && h && p && f;\n              a.maximums.push(y), a.minimums.push(d), a.leaves.push(y - d <= 5 && m ? 1 : 0);\n            }\n\n            r.push(a);\n          }\n\n          return r;\n        }(this.dem),\n              r = e.length - 1,\n              n = e[r];\n\n        this._addNode(n.minimums[0], n.maximums[0], n.leaves[0]), this._construct(e, 0, 0, r, 0);\n      }\n\n      raycastRoot(t, e, r, n, i, s, a = 1) {\n        return uf([t, e, -100], [r, n, this.maximums[0] * a], i, s);\n      }\n\n      raycast(t, e, r, n, i, s, a = 1) {\n        if (!this.nodeCount) return null;\n        const o = this.raycastRoot(t, e, r, n, i, s, a);\n        if (null == o) return null;\n        const l = [],\n              u = [],\n              c = [],\n              h = [],\n              p = [{\n          idx: 0,\n          t: o,\n          nodex: 0,\n          nodey: 0,\n          depth: 0\n        }];\n\n        for (; p.length > 0;) {\n          const {\n            idx: o,\n            t: f,\n            nodex: d,\n            nodey: y,\n            depth: m\n          } = p.pop();\n\n          if (this.leaves[o]) {\n            pf(d, y, m, t, e, r, n, c, h);\n\n            const o = 1 << m,\n                  l = (d + 0) / o,\n                  u = (d + 1) / o,\n                  p = (y + 0) / o,\n                  g = (y + 1) / o,\n                  x = yf(l, p, this.dem) * a,\n                  v = yf(u, p, this.dem) * a,\n                  b = yf(u, g, this.dem) * a,\n                  _ = yf(l, g, this.dem) * a,\n                  w = cf(c[0], c[1], x, h[0], c[1], v, h[0], h[1], b, i, s),\n                  A = cf(h[0], h[1], b, c[0], h[1], _, c[0], c[1], x, i, s),\n                  k = Math.min(null !== w ? w : Number.MAX_VALUE, null !== A ? A : Number.MAX_VALUE);\n\n            if (k !== Number.MAX_VALUE) return k;\n            {\n              const t = il([], i, s, f);\n              if (df(x, v, _, b, hf(t[0], c[0], h[0]), hf(t[1], c[1], h[1])) >= t[2]) return f;\n            }\n            continue;\n          }\n\n          let g = 0;\n\n          for (let p = 0; p < this._siblingOffset.length; p++) {\n            pf((d << 1) + this._siblingOffset[p][0], (y << 1) + this._siblingOffset[p][1], m + 1, t, e, r, n, c, h), c[2] = -100, h[2] = this.maximums[this.childOffsets[o] + p] * a;\n            const f = uf(c, h, i, s);\n\n            if (null != f) {\n              const t = f;\n              l[p] = t;\n              let e = !1;\n\n              for (let r = 0; r < g && !e; r++) t >= l[u[r]] && (u.splice(r, 0, p), e = !0);\n\n              e || (u[g] = p), g++;\n            }\n          }\n\n          for (let t = 0; t < g; t++) {\n            const e = u[t];\n            p.push({\n              idx: this.childOffsets[o] + e,\n              t: l[e],\n              nodex: (d << 1) + this._siblingOffset[e][0],\n              nodey: (y << 1) + this._siblingOffset[e][1],\n              depth: m + 1\n            });\n          }\n        }\n\n        return null;\n      }\n\n      _addNode(t, e, r) {\n        return this.minimums.push(t), this.maximums.push(e), this.leaves.push(r), this.childOffsets.push(0), this.nodeCount++;\n      }\n\n      _construct(t, e, r, n, i) {\n        if (1 === t[n].isLeaf(e, r)) return;\n        this.childOffsets[i] || (this.childOffsets[i] = this.nodeCount);\n        const s = n - 1,\n              a = t[s];\n        let o = 0,\n            l = 0;\n\n        for (let t = 0; t < this._siblingOffset.length; t++) {\n          const n = 2 * e + this._siblingOffset[t][0],\n                i = 2 * r + this._siblingOffset[t][1],\n                s = a.getElevation(n, i),\n                u = a.isLeaf(n, i),\n                c = this._addNode(s.min, s.max, u);\n\n          u && (o |= 1 << t), l || (l = c);\n        }\n\n        for (let n = 0; n < this._siblingOffset.length; n++) o & 1 << n || this._construct(t, 2 * e + this._siblingOffset[n][0], 2 * r + this._siblingOffset[n][1], s, l + n);\n      }\n\n    }\n\n    function df(t, e, r, n, i, s) {\n      return rr(rr(t, r, s), rr(e, n, s), i);\n    }\n\n    function yf(t, e, r) {\n      const n = r.dim,\n            i = y(t * n - .5, 0, n - 1),\n            s = y(e * n - .5, 0, n - 1),\n            a = Math.floor(i),\n            o = Math.floor(s),\n            l = Math.min(a + 1, n - 1),\n            u = Math.min(o + 1, n - 1);\n      return df(r.get(a, o), r.get(l, o), r.get(a, u), r.get(l, u), i - a, s - o);\n    }\n\n    const mf = {\n      mapbox: [6553.6, 25.6, .1, 1e4],\n      terrarium: [256, 1, 1 / 256, 32768]\n    };\n\n    class gf {\n      get tree() {\n        return this._tree || this._buildQuadTree(), this._tree;\n      }\n\n      constructor(t, e, r, n = !1, i = !1) {\n        if (this.uid = t, e.height !== e.width) throw new RangeError(\"DEM tiles must be square\");\n        if (r && \"mapbox\" !== r && \"terrarium\" !== r) return C(`\"${r}\" is not a valid encoding type. Valid types include \"mapbox\" and \"terrarium\".`);\n        this.stride = e.height;\n        const s = this.dim = e.height - 2,\n              a = new Uint32Array(e.data.buffer);\n\n        if (this.pixels = new Uint8Array(e.data.buffer), this.encoding = r || \"mapbox\", this.borderReady = n, !n) {\n          for (let t = 0; t < s; t++) a[this._idx(-1, t)] = a[this._idx(0, t)], a[this._idx(s, t)] = a[this._idx(s - 1, t)], a[this._idx(t, -1)] = a[this._idx(t, 0)], a[this._idx(t, s)] = a[this._idx(t, s - 1)];\n\n          a[this._idx(-1, -1)] = a[this._idx(0, 0)], a[this._idx(s, -1)] = a[this._idx(s - 1, 0)], a[this._idx(-1, s)] = a[this._idx(0, s - 1)], a[this._idx(s, s)] = a[this._idx(s - 1, s - 1)], i && this._buildQuadTree();\n        }\n      }\n\n      _buildQuadTree() {\n        this._tree = new ff(this);\n      }\n\n      get(t, e, r = !1) {\n        r && (t = y(t, -1, this.dim), e = y(e, -1, this.dim));\n\n        const n = 4 * this._idx(t, e);\n\n        return (\"terrarium\" === this.encoding ? this._unpackTerrarium : this._unpackMapbox)(this.pixels[n], this.pixels[n + 1], this.pixels[n + 2]);\n      }\n\n      static getUnpackVector(t) {\n        return mf[t];\n      }\n\n      get unpackVector() {\n        return mf[this.encoding];\n      }\n\n      _idx(t, e) {\n        if (t < -1 || t >= this.dim + 1 || e < -1 || e >= this.dim + 1) throw new RangeError(\"out of range source coordinates for DEM data\");\n        return (e + 1) * this.stride + (t + 1);\n      }\n\n      _unpackMapbox(t, e, r) {\n        return (256 * t * 256 + 256 * e + r) / 10 - 1e4;\n      }\n\n      _unpackTerrarium(t, e, r) {\n        return 256 * t + e + r / 256 - 32768;\n      }\n\n      static pack(t, e) {\n        const r = [0, 0, 0, 0],\n              n = gf.getUnpackVector(e);\n        let i = Math.floor((t + n[3]) / n[2]);\n        return r[2] = i % 256, i = Math.floor(i / 256), r[1] = i % 256, i = Math.floor(i / 256), r[0] = i, r;\n      }\n\n      getPixels() {\n        return new Bl({\n          width: this.stride,\n          height: this.stride\n        }, this.pixels);\n      }\n\n      backfillBorder(t, e, r) {\n        if (this.dim !== t.dim) throw new Error(\"dem dimension mismatch\");\n        let n = e * this.dim,\n            i = e * this.dim + this.dim,\n            s = r * this.dim,\n            a = r * this.dim + this.dim;\n\n        switch (e) {\n          case -1:\n            n = i - 1;\n            break;\n\n          case 1:\n            i = n + 1;\n        }\n\n        switch (r) {\n          case -1:\n            s = a - 1;\n            break;\n\n          case 1:\n            a = s + 1;\n        }\n\n        const o = -e * this.dim,\n              l = -r * this.dim;\n\n        for (let e = s; e < a; e++) for (let r = n; r < i; r++) {\n          const n = 4 * this._idx(r, e),\n                i = 4 * this._idx(r + o, e + l);\n\n          this.pixels[n + 0] = t.pixels[i + 0], this.pixels[n + 1] = t.pixels[i + 1], this.pixels[n + 2] = t.pixels[i + 2], this.pixels[n + 3] = t.pixels[i + 3];\n        }\n      }\n\n      onDeserialize() {\n        this._tree && (this._tree.dem = this);\n      }\n\n    }\n\n    ai(gf), ai(ff, {\n      omit: [\"dem\"]\n    });\n\n    class xf {\n      constructor(t, e) {\n        this.max = t, this.onRemove = e, this.reset();\n      }\n\n      reset() {\n        for (const t in this.data) for (const e of this.data[t]) e.timeout && clearTimeout(e.timeout), this.onRemove(e.value);\n\n        return this.data = {}, this.order = [], this;\n      }\n\n      add(t, e, r) {\n        const n = t.wrapped().key;\n        void 0 === this.data[n] && (this.data[n] = []);\n        const i = {\n          value: e,\n          timeout: void 0\n        };\n\n        if (void 0 !== r && (i.timeout = setTimeout(() => {\n          this.remove(t, i);\n        }, r)), this.data[n].push(i), this.order.push(n), this.order.length > this.max) {\n          const t = this._getAndRemoveByKey(this.order[0]);\n\n          t && this.onRemove(t);\n        }\n\n        return this;\n      }\n\n      has(t) {\n        return t.wrapped().key in this.data;\n      }\n\n      getAndRemove(t) {\n        return this.has(t) ? this._getAndRemoveByKey(t.wrapped().key) : null;\n      }\n\n      _getAndRemoveByKey(t) {\n        const e = this.data[t].shift();\n        return e.timeout && clearTimeout(e.timeout), 0 === this.data[t].length && delete this.data[t], this.order.splice(this.order.indexOf(t), 1), e.value;\n      }\n\n      getByKey(t) {\n        const e = this.data[t];\n        return e ? e[0].value : null;\n      }\n\n      get(t) {\n        return this.has(t) ? this.data[t.wrapped().key][0].value : null;\n      }\n\n      remove(t, e) {\n        if (!this.has(t)) return this;\n        const r = t.wrapped().key,\n              n = void 0 === e ? 0 : this.data[r].indexOf(e),\n              i = this.data[r][n];\n        return this.data[r].splice(n, 1), i.timeout && clearTimeout(i.timeout), 0 === this.data[r].length && delete this.data[r], this.onRemove(i.value), this.order.splice(this.order.indexOf(r), 1), this;\n      }\n\n      setMaxSize(t) {\n        for (this.max = t; this.order.length > this.max;) {\n          const t = this._getAndRemoveByKey(this.order[0]);\n\n          t && this.onRemove(t);\n        }\n\n        return this;\n      }\n\n      filter(t) {\n        const e = [];\n\n        for (const r in this.data) for (const n of this.data[r]) t(n.value) || e.push(n);\n\n        for (const t of e) this.remove(t.value.tileID, t);\n      }\n\n    }\n\n    class vf {\n      constructor(t, e, r) {\n        this.func = t, this.mask = e, this.range = r;\n      }\n\n    }\n\n    vf.ReadOnly = !1, vf.ReadWrite = !0, vf.disabled = new vf(519, vf.ReadOnly, [0, 1]);\n    const bf = 7680;\n\n    class _f {\n      constructor(t, e, r, n, i, s) {\n        this.test = t, this.ref = e, this.mask = r, this.fail = n, this.depthFail = i, this.pass = s;\n      }\n\n    }\n\n    _f.disabled = new _f({\n      func: 519,\n      mask: 0\n    }, 0, 0, bf, bf, bf);\n\n    class wf {\n      constructor(t, e, r) {\n        this.blendFunction = t, this.blendColor = e, this.mask = r;\n      }\n\n    }\n\n    wf.Replace = [1, 0], wf.disabled = new wf(wf.Replace, ce.transparent, [!1, !1, !1, !1]), wf.unblended = new wf(wf.Replace, ce.transparent, [!0, !0, !0, !0]), wf.alphaBlended = new wf([1, 771], ce.transparent, [!0, !0, !0, !0]);\n    const Af = 1029,\n          kf = 2305;\n\n    class Sf {\n      constructor(t, e, r) {\n        this.enable = t, this.mode = e, this.frontFace = r;\n      }\n\n    }\n\n    Sf.disabled = new Sf(!1, Af, kf), Sf.backCCW = new Sf(!0, Af, kf), Sf.backCW = new Sf(!0, Af, 2304), Sf.frontCW = new Sf(!0, 1028, 2304), Sf.frontCCW = new Sf(!0, 1028, kf);\n\n    class If extends Ut {\n      constructor(t, e, r) {\n        super(), this.id = t, this._onlySymbols = r, e.on(\"data\", t => {\n          \"source\" === t.dataType && \"metadata\" === t.sourceDataType && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && \"source\" === t.dataType && \"content\" === t.sourceDataType && (this.reload(), this.transform && this.update(this.transform));\n        }), e.on(\"error\", () => {\n          this._sourceErrored = !0;\n        }), this._source = e, this._tiles = {}, this._cache = new xf(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._minTileCacheSize = e.minTileCacheSize, this._maxTileCacheSize = e.maxTileCacheSize, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new of(), this._isRaster = \"raster\" === this._source.type || \"raster-dem\" === this._source.type || \"custom\" === this._source.type && \"raster\" === this._source._dataType;\n      }\n\n      onAdd(t) {\n        this.map = t, this._minTileCacheSize = void 0 === this._minTileCacheSize && t ? t._minTileCacheSize : this._minTileCacheSize, this._maxTileCacheSize = void 0 === this._maxTileCacheSize && t ? t._maxTileCacheSize : this._maxTileCacheSize;\n      }\n\n      loaded() {\n        if (this._sourceErrored) return !0;\n        if (!this._sourceLoaded) return !1;\n        if (!this._source.loaded()) return !1;\n\n        for (const t in this._tiles) {\n          const e = this._tiles[t];\n          if (\"loaded\" !== e.state && \"errored\" !== e.state) return !1;\n        }\n\n        return !0;\n      }\n\n      getSource() {\n        return this._source;\n      }\n\n      pause() {\n        this._paused = !0;\n      }\n\n      resume() {\n        if (!this._paused) return;\n        const t = this._shouldReloadOnResume;\n        this._paused = !1, this._shouldReloadOnResume = !1, t && this.reload(), this.transform && this.update(this.transform);\n      }\n\n      _loadTile(t, e) {\n        return t.isSymbolTile = this._onlySymbols, this._source.loadTile(t, e);\n      }\n\n      _unloadTile(t) {\n        if (this._source.unloadTile) return this._source.unloadTile(t, () => {});\n      }\n\n      _abortTile(t) {\n        if (this._source.abortTile) return this._source.abortTile(t, () => {});\n      }\n\n      serialize() {\n        return this._source.serialize();\n      }\n\n      prepare(t) {\n        if (this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null), this._source.prepareTile) for (const e in this._tiles) {\n          const r = this._tiles[e];\n          this._source.prepareTile(r) && this.map.painter.terrain && this.map.painter.terrain._clearRenderCacheForTile(this.id, r.tileID), r.upload(t), r.prepare(this.map.style.imageManager);\n        } else for (const e in this._tiles) {\n          const r = this._tiles[e];\n          r.upload(t), r.prepare(this.map.style.imageManager);\n        }\n      }\n\n      getIds() {\n        return v(this._tiles).map(t => t.tileID).sort(Mf).map(t => t.key);\n      }\n\n      getRenderableIds(t) {\n        const e = [];\n\n        for (const r in this._tiles) this._isIdRenderable(+r, t) && e.push(this._tiles[r]);\n\n        return t ? e.sort((t, e) => {\n          const r = t.tileID,\n                n = e.tileID,\n                s = new i(r.canonical.x, r.canonical.y)._rotate(this.transform.angle),\n                a = new i(n.canonical.x, n.canonical.y)._rotate(this.transform.angle);\n\n          return r.overscaledZ - n.overscaledZ || a.y - s.y || a.x - s.x;\n        }).map(t => t.tileID.key) : e.map(t => t.tileID).sort(Mf).map(t => t.key);\n      }\n\n      hasRenderableParent(t) {\n        const e = this.findLoadedParent(t, 0);\n        return !!e && this._isIdRenderable(e.tileID.key);\n      }\n\n      _isIdRenderable(t, e) {\n        return this._tiles[t] && this._tiles[t].hasData() && !this._coveredTiles[t] && (e || !this._tiles[t].holdingForFade());\n      }\n\n      reload() {\n        if (this._paused) this._shouldReloadOnResume = !0;else {\n          this._cache.reset();\n\n          for (const t in this._tiles) \"errored\" !== this._tiles[t].state && this._reloadTile(+t, \"reloading\");\n        }\n      }\n\n      _reloadTile(t, e) {\n        const r = this._tiles[t];\n        r && (\"loading\" !== r.state && (r.state = e), this._loadTile(r, this._tileLoaded.bind(this, r, t, e)));\n      }\n\n      _tileLoaded(t, e, r, n) {\n        if (n) {\n          if (t.state = \"errored\", 404 !== n.status) this._source.fire(new Rt(n, {\n            tile: t\n          }));else if (\"raster-dem\" === this._source.type && this.usedForTerrain && this.map.painter.terrain) {\n            const t = this.map.painter.terrain;\n            this.update(this.transform, t.getScaledDemTileSize(), !0), t.resetTileLookupCache(this.id);\n          } else this.update(this.transform);\n        } else t.timeAdded = N.now(), \"expired\" === r && (t.refreshedUponExpiration = !0), this._setTileReloadTimer(e, t), \"raster-dem\" === this._source.type && t.dem && this._backfillDEM(t), this._state.initializeTileState(t, this.map ? this.map.painter : null), this._source.fire(new Lt(\"data\", {\n          dataType: \"source\",\n          tile: t,\n          coord: t.tileID,\n          sourceCacheId: this.id\n        }));\n      }\n\n      _backfillDEM(t) {\n        const e = this.getRenderableIds();\n\n        for (let n = 0; n < e.length; n++) {\n          const i = e[n];\n\n          if (t.neighboringTiles && t.neighboringTiles[i]) {\n            const e = this.getTileByID(i);\n            r(t, e), r(e, t);\n          }\n        }\n\n        function r(t, e) {\n          if (!t.dem || t.dem.borderReady) return;\n          t.needsHillshadePrepare = !0, t.needsDEMTextureUpload = !0;\n          let r = e.tileID.canonical.x - t.tileID.canonical.x;\n          const n = e.tileID.canonical.y - t.tileID.canonical.y,\n                i = Math.pow(2, t.tileID.canonical.z),\n                s = e.tileID.key;\n          0 === r && 0 === n || Math.abs(n) > 1 || (Math.abs(r) > 1 && (1 === Math.abs(r + i) ? r += i : 1 === Math.abs(r - i) && (r -= i)), e.dem && t.dem && (t.dem.backfillBorder(e.dem, r, n), t.neighboringTiles && t.neighboringTiles[s] && (t.neighboringTiles[s].backfilled = !0)));\n        }\n      }\n\n      getTile(t) {\n        return this.getTileByID(t.key);\n      }\n\n      getTileByID(t) {\n        return this._tiles[t];\n      }\n\n      _retainLoadedChildren(t, e, r, n) {\n        for (const i in this._tiles) {\n          let s = this._tiles[i];\n          if (n[i] || !s.hasData() || s.tileID.overscaledZ <= e || s.tileID.overscaledZ > r) continue;\n          let a = s.tileID;\n\n          for (; s && s.tileID.overscaledZ > e + 1;) {\n            const t = s.tileID.scaledTo(s.tileID.overscaledZ - 1);\n            s = this._tiles[t.key], s && s.hasData() && (a = t);\n          }\n\n          let o = a;\n\n          for (; o.overscaledZ > e;) if (o = o.scaledTo(o.overscaledZ - 1), t[o.key]) {\n            n[a.key] = a;\n            break;\n          }\n        }\n      }\n\n      findLoadedParent(t, e) {\n        if (t.key in this._loadedParentTiles) {\n          const r = this._loadedParentTiles[t.key];\n          return r && r.tileID.overscaledZ >= e ? r : null;\n        }\n\n        for (let r = t.overscaledZ - 1; r >= e; r--) {\n          const e = t.scaledTo(r),\n                n = this._getLoadedTile(e);\n\n          if (n) return n;\n        }\n      }\n\n      _getLoadedTile(t) {\n        const e = this._tiles[t.key];\n        return e && e.hasData() ? e : this._cache.getByKey(this._source.reparseOverscaled ? t.wrapped().key : t.canonical.key);\n      }\n\n      updateCacheSize(t, e) {\n        e = e || this._source.tileSize;\n        const r = Math.ceil(t.width / e) + 1,\n              n = Math.ceil(t.height / e) + 1,\n              i = Math.floor(r * n * 5),\n              s = \"number\" == typeof this._minTileCacheSize ? Math.max(this._minTileCacheSize, i) : i,\n              a = \"number\" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, s) : s;\n\n        this._cache.setMaxSize(a);\n      }\n\n      handleWrapJump(t) {\n        const e = Math.round((t - (void 0 === this._prevLng ? t : this._prevLng)) / 360);\n\n        if (this._prevLng = t, e) {\n          const t = {};\n\n          for (const r in this._tiles) {\n            const n = this._tiles[r];\n            n.tileID = n.tileID.unwrapTo(n.tileID.wrap + e), t[n.tileID.key] = n;\n          }\n\n          this._tiles = t;\n\n          for (const t in this._timers) clearTimeout(this._timers[t]), delete this._timers[t];\n\n          for (const t in this._tiles) this._setTileReloadTimer(+t, this._tiles[t]);\n        }\n      }\n\n      update(t, e, r) {\n        if (this.transform = t, !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage) return;\n        if (this.usedForTerrain && !r) return;\n        let n;\n        this.updateCacheSize(t, e), \"globe\" !== this.transform.projection.name && this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? n = t.getVisibleUnwrappedCoordinates(this._source.tileID).map(t => new Np(t.canonical.z, t.wrap, t.canonical.z, t.canonical.x, t.canonical.y)) : (n = t.coveringTiles({\n          tileSize: e || this._source.tileSize,\n          minzoom: this._source.minzoom,\n          maxzoom: this._source.maxzoom,\n          roundZoom: this._source.roundZoom && !r,\n          reparseOverscaled: this._source.reparseOverscaled,\n          isTerrainDEM: this.usedForTerrain\n        }), this._source.hasTile && (n = n.filter(t => this._source.hasTile(t)))) : n = [];\n\n        const i = this._updateRetainedTiles(n);\n\n        if (Tf(this._source.type) && 0 !== n.length) {\n          const t = {},\n                e = {},\n                r = Object.keys(i);\n\n          for (const n of r) {\n            const r = i[n],\n                  s = this._tiles[n];\n            if (!s || s.fadeEndTime && s.fadeEndTime <= N.now()) continue;\n            const a = this.findLoadedParent(r, Math.max(r.overscaledZ - If.maxOverzooming, this._source.minzoom));\n            a && (this._addTile(a.tileID), t[a.tileID.key] = a.tileID), e[n] = r;\n          }\n\n          const s = n[n.length - 1].overscaledZ;\n\n          for (const t in this._tiles) {\n            const r = this._tiles[t];\n            if (i[t] || !r.hasData()) continue;\n            let n = r.tileID;\n\n            for (; n.overscaledZ > s;) {\n              n = n.scaledTo(n.overscaledZ - 1);\n              const s = this._tiles[n.key];\n\n              if (s && s.hasData() && e[n.key]) {\n                i[t] = r.tileID;\n                break;\n              }\n            }\n          }\n\n          for (const e in t) i[e] || (this._coveredTiles[e] = !0, i[e] = t[e]);\n        }\n\n        for (const t in i) this._tiles[t].clearFadeHold();\n\n        const s = function (t, e) {\n          const r = [];\n\n          for (const n in t) n in e || r.push(n);\n\n          return r;\n        }(this._tiles, i);\n\n        for (const t of s) {\n          const e = this._tiles[t];\n          e.hasSymbolBuckets && !e.holdingForFade() ? e.setHoldDuration(this.map._fadeDuration) : e.hasSymbolBuckets && !e.symbolFadeFinished() || this._removeTile(+t);\n        }\n\n        this._updateLoadedParentTileCache(), this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate();\n      }\n\n      releaseSymbolFadeTiles() {\n        for (const t in this._tiles) this._tiles[t].holdingForFade() && this._removeTile(+t);\n      }\n\n      _updateRetainedTiles(t) {\n        const e = {};\n        if (0 === t.length) return e;\n        const r = {},\n              n = t.reduce((t, e) => Math.min(t, e.overscaledZ), 1 / 0),\n              i = t[0].overscaledZ,\n              s = Math.max(i - If.maxOverzooming, this._source.minzoom),\n              a = Math.max(i + If.maxUnderzooming, this._source.minzoom),\n              o = {};\n\n        for (const r of t) {\n          const t = this._addTile(r);\n\n          e[r.key] = r, t.hasData() || n < this._source.maxzoom && (o[r.key] = r);\n        }\n\n        this._retainLoadedChildren(o, n, a, e);\n\n        for (const n of t) {\n          let t = this._tiles[n.key];\n          if (t.hasData()) continue;\n\n          if (n.canonical.z >= this._source.maxzoom) {\n            const t = n.children(this._source.maxzoom)[0],\n                  r = this.getTile(t);\n\n            if (r && r.hasData()) {\n              e[t.key] = t;\n              continue;\n            }\n          } else {\n            const t = n.children(this._source.maxzoom);\n            if (e[t[0].key] && e[t[1].key] && e[t[2].key] && e[t[3].key]) continue;\n          }\n\n          let i = t.wasRequested();\n\n          for (let a = n.overscaledZ - 1; a >= s; --a) {\n            const s = n.scaledTo(a);\n            if (r[s.key]) break;\n            if (r[s.key] = !0, t = this.getTile(s), !t && i && (t = this._addTile(s)), t && (e[s.key] = s, i = t.wasRequested(), t.hasData())) break;\n          }\n        }\n\n        return e;\n      }\n\n      _updateLoadedParentTileCache() {\n        this._loadedParentTiles = {};\n\n        for (const t in this._tiles) {\n          const e = [];\n          let r,\n              n = this._tiles[t].tileID;\n\n          for (; n.overscaledZ > 0;) {\n            if (n.key in this._loadedParentTiles) {\n              r = this._loadedParentTiles[n.key];\n              break;\n            }\n\n            e.push(n.key);\n            const t = n.scaledTo(n.overscaledZ - 1);\n            if (r = this._getLoadedTile(t), r) break;\n            n = t;\n          }\n\n          for (const t of e) this._loadedParentTiles[t] = r;\n        }\n      }\n\n      _addTile(t) {\n        let e = this._tiles[t.key];\n        if (e) return this._source.prepareTile && this._source.prepareTile(e), e;\n        e = this._cache.getAndRemove(t), e && (this._setTileReloadTimer(t.key, e), e.tileID = t, this._state.initializeTileState(e, this.map ? this.map.painter : null), this._cacheTimers[t.key] && (clearTimeout(this._cacheTimers[t.key]), delete this._cacheTimers[t.key], this._setTileReloadTimer(t.key, e)));\n        const r = Boolean(e);\n\n        if (!r) {\n          const r = this.map ? this.map.painter : null;\n          e = new af(t, this._source.tileSize * t.overscaleFactor(), this.transform.tileZoom, r, this._isRaster), this._source.prepareTile && this._source.prepareTile(e) || this._loadTile(e, this._tileLoaded.bind(this, e, t.key, e.state));\n        }\n\n        return e ? (e.uses++, this._tiles[t.key] = e, r || this._source.fire(new Lt(\"dataloading\", {\n          tile: e,\n          coord: e.tileID,\n          dataType: \"source\"\n        })), e) : null;\n      }\n\n      _setTileReloadTimer(t, e) {\n        t in this._timers && (clearTimeout(this._timers[t]), delete this._timers[t]);\n        const r = e.getExpiryTimeout();\n        r && (this._timers[t] = setTimeout(() => {\n          this._reloadTile(t, \"expired\"), delete this._timers[t];\n        }, r));\n      }\n\n      _removeTile(t) {\n        const e = this._tiles[t];\n        e && (e.uses--, delete this._tiles[t], this._timers[t] && (clearTimeout(this._timers[t]), delete this._timers[t]), e.uses > 0 || (e.hasData() && \"reloading\" !== e.state ? this._cache.add(e.tileID, e, e.getExpiryTimeout()) : (e.aborted = !0, this._abortTile(e), this._unloadTile(e))));\n      }\n\n      clearTiles() {\n        this._shouldReloadOnResume = !1, this._paused = !1;\n\n        for (const t in this._tiles) this._removeTile(+t);\n\n        this._source._clear && this._source._clear(), this._cache.reset(), this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id);\n      }\n\n      tilesIn(t, e, r) {\n        const n = [],\n              i = this.transform;\n        if (!i) return n;\n\n        for (const s in this._tiles) {\n          const a = this._tiles[s];\n          if (r && a.clearQueryDebugViz(), a.holdingForFade()) continue;\n          const o = t.containsTile(a, i, e);\n          o && n.push(o);\n        }\n\n        return n;\n      }\n\n      getVisibleCoordinates(t) {\n        const e = this.getRenderableIds(t).map(t => this._tiles[t].tileID);\n\n        for (const t of e) t.projMatrix = this.transform.calculateProjMatrix(t.toUnwrapped());\n\n        return e;\n      }\n\n      hasTransition() {\n        if (this._source.hasTransition()) return !0;\n        if (Tf(this._source.type)) for (const t in this._tiles) {\n          const e = this._tiles[t];\n          if (void 0 !== e.fadeEndTime && e.fadeEndTime >= N.now()) return !0;\n        }\n        return !1;\n      }\n\n      setFeatureState(t, e, r) {\n        this._state.updateState(t = t || \"_geojsonTileLayer\", e, r);\n      }\n\n      removeFeatureState(t, e, r) {\n        this._state.removeFeatureState(t = t || \"_geojsonTileLayer\", e, r);\n      }\n\n      getFeatureState(t, e) {\n        return this._state.getState(t = t || \"_geojsonTileLayer\", e);\n      }\n\n      setDependencies(t, e, r) {\n        const n = this._tiles[t];\n        n && n.setDependencies(e, r);\n      }\n\n      reloadTilesForDependencies(t, e) {\n        for (const r in this._tiles) this._tiles[r].hasDependency(t, e) && this._reloadTile(+r, \"reloading\");\n\n        this._cache.filter(r => !r.hasDependency(t, e));\n      }\n\n      _preloadTiles(t, e) {\n        const r = new Map(),\n              n = Array.isArray(t) ? t : [t],\n              i = this.map.painter.terrain,\n              s = this.usedForTerrain && i ? i.getScaledDemTileSize() : this._source.tileSize;\n\n        for (const t of n) {\n          const e = t.coveringTiles({\n            tileSize: s,\n            minzoom: this._source.minzoom,\n            maxzoom: this._source.maxzoom,\n            roundZoom: this._source.roundZoom && !this.usedForTerrain,\n            reparseOverscaled: this._source.reparseOverscaled,\n            isTerrainDEM: this.usedForTerrain\n          });\n\n          for (const t of e) r.set(t.key, t);\n\n          this.usedForTerrain && t.updateElevation(!1);\n        }\n\n        x(Array.from(r.values()), (t, e) => {\n          const r = new af(t, this._source.tileSize * t.overscaleFactor(), this.transform.tileZoom, this.map.painter, this._isRaster);\n\n          this._loadTile(r, t => {\n            \"raster-dem\" === this._source.type && r.dem && this._backfillDEM(r), e(t, r);\n          });\n        }, e);\n      }\n\n    }\n\n    function Mf(t, e) {\n      const r = Math.abs(2 * t.wrap) - +(t.wrap < 0),\n            n = Math.abs(2 * e.wrap) - +(e.wrap < 0);\n      return t.overscaledZ - e.overscaledZ || n - r || e.canonical.y - t.canonical.y || e.canonical.x - t.canonical.x;\n    }\n\n    function Tf(t) {\n      return \"raster\" === t || \"image\" === t || \"video\" === t;\n    }\n\n    If.maxOverzooming = 10, If.maxUnderzooming = 3;\n\n    class zf {\n      constructor(t, e, r) {\n        this._demTile = t, this._dem = this._demTile.dem, this._scale = e, this._offset = r;\n      }\n\n      static create(t, e, r) {\n        const n = r || t.findDEMTileFor(e);\n        if (!n || !n.dem) return;\n        const i = n.dem,\n              s = n.tileID,\n              a = 1 << e.canonical.z - s.canonical.z;\n        return new zf(n, n.tileSize / Ya / a, [(e.canonical.x / a - s.canonical.x) * i.dim, (e.canonical.y / a - s.canonical.y) * i.dim]);\n      }\n\n      tileCoordToPixel(t, e) {\n        const r = e * this._scale + this._offset[1],\n              n = Math.floor(t * this._scale + this._offset[0]),\n              s = Math.floor(r);\n        return new i(n, s);\n      }\n\n      getElevationAt(t, e, r, n) {\n        const i = t * this._scale + this._offset[0],\n              s = e * this._scale + this._offset[1],\n              a = Math.floor(i),\n              o = Math.floor(s),\n              l = this._dem;\n        return n = !!n, r ? rr(rr(l.get(a, o, n), l.get(a, o + 1, n), s - o), rr(l.get(a + 1, o, n), l.get(a + 1, o + 1, n), s - o), i - a) : l.get(a, o, n);\n      }\n\n      getElevationAtPixel(t, e, r) {\n        return this._dem.get(t, e, !!r);\n      }\n\n      getMeterToDEM(t) {\n        return (1 << this._demTile.tileID.canonical.z) * no(1, t) * this._dem.stride;\n      }\n\n    }\n\n    class Bf {\n      constructor(t, e) {\n        this.tileID = t, this.x = t.canonical.x, this.y = t.canonical.y, this.z = t.canonical.z, this.grid = new ni(Ya, 16, 0), this.featureIndexArray = new ua(), this.promoteId = e;\n      }\n\n      insert(t, e, r, n, i, s = 0) {\n        const a = this.featureIndexArray.length;\n        this.featureIndexArray.emplaceBack(r, n, i, s);\n        const o = this.grid;\n\n        for (let t = 0; t < e.length; t++) {\n          const r = e[t],\n                n = [1 / 0, 1 / 0, -1 / 0, -1 / 0];\n\n          for (let t = 0; t < r.length; t++) {\n            const e = r[t];\n            n[0] = Math.min(n[0], e.x), n[1] = Math.min(n[1], e.y), n[2] = Math.max(n[2], e.x), n[3] = Math.max(n[3], e.y);\n          }\n\n          n[0] < Ya && n[1] < Ya && n[2] >= 0 && n[3] >= 0 && o.insert(a, n[0], n[1], n[2], n[3]);\n        }\n      }\n\n      loadVTLayers() {\n        if (!this.vtLayers) {\n          this.vtLayers = new Du.VectorTile(new wc(this.rawTileData)).layers, this.sourceLayerCoder = new Xp(this.vtLayers ? Object.keys(this.vtLayers).sort() : [\"_geojsonTileLayer\"]), this.vtFeatures = {};\n\n          for (const t in this.vtLayers) this.vtFeatures[t] = [];\n        }\n\n        return this.vtLayers;\n      }\n\n      query(t, e, r, n) {\n        this.loadVTLayers();\n        const i = t.params || {},\n              s = Sn(i.filter),\n              a = t.tileResult,\n              o = t.transform,\n              l = a.bufferedTilespaceBounds,\n              u = this.grid.query(l.min.x, l.min.y, l.max.x, l.max.y, (t, e, r, n) => Bo(a.bufferedTilespaceGeometry, t, e, r, n));\n        u.sort(Cf);\n        let c = null;\n        o.elevation && u.length > 0 && (c = zf.create(o.elevation, this.tileID));\n        const h = {};\n        let p;\n\n        for (let o = 0; o < u.length; o++) {\n          const l = u[o];\n          if (l === p) continue;\n          p = l;\n          const f = this.featureIndexArray.get(l);\n          let d = null;\n          this.loadMatchingFeature(h, f, s, i.layers, i.availableImages, e, r, n, (e, r, n, i = 0) => (d || (d = yo(e, this.tileID.canonical, t.tileTransform)), r.queryIntersectsFeature(a, e, n, d, this.z, t.transform, t.pixelPosMatrix, c, i)));\n        }\n\n        return h;\n      }\n\n      loadMatchingFeature(t, e, r, n, i, s, a, o, l) {\n        const {\n          featureIndex: u,\n          bucketIndex: c,\n          sourceLayerIndex: h,\n          layoutVertexArrayOffset: p\n        } = e,\n              f = this.bucketLayerIDs[c];\n        if (n && !function (t, e) {\n          for (let r = 0; r < t.length; r++) if (e.indexOf(t[r]) >= 0) return !0;\n\n          return !1;\n        }(n, f)) return;\n        const d = this.sourceLayerCoder.decode(h),\n              y = this.vtLayers[d].feature(u);\n\n        if (r.needGeometry) {\n          const t = mo(y, !0);\n          if (!r.filter(new ss(this.tileID.overscaledZ), t, this.tileID.canonical)) return;\n        } else if (!r.filter(new ss(this.tileID.overscaledZ), y)) return;\n\n        const m = this.getId(y, d);\n\n        for (let e = 0; e < f.length; e++) {\n          const r = f[e];\n          if (n && n.indexOf(r) < 0) continue;\n          const c = s[r];\n          if (!c) continue;\n          let h = {};\n          void 0 !== m && o && (h = o.getState(c.sourceLayer || \"_geojsonTileLayer\", m));\n          const d = b({}, a[r]);\n          d.paint = Ef(d.paint, c.paint, y, h, i), d.layout = Ef(d.layout, c.layout, y, h, i);\n          const g = !l || l(y, c, h, p);\n          if (!g) continue;\n          const x = new Yp(y, this.z, this.x, this.y, m);\n          x.layer = d;\n          let v = t[r];\n          void 0 === v && (v = t[r] = []), v.push({\n            featureIndex: u,\n            feature: x,\n            intersectionZ: g\n          });\n        }\n      }\n\n      lookupSymbolFeatures(t, e, r, n, i, s, a, o) {\n        const l = {};\n        this.loadVTLayers();\n        const u = Sn(i);\n\n        for (const i of t) this.loadMatchingFeature(l, {\n          bucketIndex: r,\n          sourceLayerIndex: n,\n          featureIndex: i,\n          layoutVertexArrayOffset: 0\n        }, u, s, a, o, e);\n\n        return l;\n      }\n\n      loadFeature(t) {\n        const {\n          featureIndex: e,\n          sourceLayerIndex: r\n        } = t;\n        this.loadVTLayers();\n        const n = this.sourceLayerCoder.decode(r),\n              i = this.vtFeatures[n];\n        if (i[e]) return i[e];\n        const s = this.vtLayers[n].feature(e);\n        return i[e] = s, s;\n      }\n\n      hasLayer(t) {\n        for (const e of this.bucketLayerIDs) for (const r of e) if (t === r) return !0;\n\n        return !1;\n      }\n\n      getId(t, e) {\n        let r = t.id;\n        return this.promoteId && (r = t.properties[\"string\" == typeof this.promoteId ? this.promoteId : this.promoteId[e]], \"boolean\" == typeof r && (r = Number(r))), r;\n      }\n\n    }\n\n    function Ef(t, e, r, n, i) {\n      return T(t, (t, s) => {\n        const a = e instanceof fs ? e.get(s) : null;\n        return a && a.evaluate ? a.evaluate(r, n, i) : a;\n      });\n    }\n\n    function Cf(t, e) {\n      return e - t;\n    }\n\n    ai(Bf, {\n      omit: [\"rawTileData\", \"sourceLayerCoder\"]\n    });\n\n    class Df {\n      constructor(t) {\n        const e = {},\n              r = [];\n\n        for (const n in t) {\n          const i = t[n],\n                s = e[n] = {};\n\n          for (const t in i.glyphs) {\n            const e = i.glyphs[+t];\n            if (!e || 0 === e.bitmap.width || 0 === e.bitmap.height) continue;\n            const n = e.metrics.localGlyph ? 2 : 1,\n                  a = {\n              x: 0,\n              y: 0,\n              w: e.bitmap.width + 2 * n,\n              h: e.bitmap.height + 2 * n\n            };\n            r.push(a), s[t] = a;\n          }\n        }\n\n        const {\n          w: n,\n          h: i\n        } = Gc(r),\n              s = new zl({\n          width: n || 1,\n          height: i || 1\n        });\n\n        for (const r in t) {\n          const n = t[r];\n\n          for (const t in n.glyphs) {\n            const i = n.glyphs[+t];\n            if (!i || 0 === i.bitmap.width || 0 === i.bitmap.height) continue;\n            const a = e[r][t],\n                  o = i.metrics.localGlyph ? 2 : 1;\n            zl.copy(i.bitmap, s, {\n              x: 0,\n              y: 0\n            }, {\n              x: a.x + o,\n              y: a.y + o\n            }, i.bitmap);\n          }\n        }\n\n        this.image = s, this.positions = e;\n      }\n\n    }\n\n    ai(Df);\n\n    class Pf {\n      constructor(t) {\n        this.tileID = new Np(t.tileID.overscaledZ, t.tileID.wrap, t.tileID.canonical.z, t.tileID.canonical.x, t.tileID.canonical.y), this.tileZoom = t.tileZoom, this.uid = t.uid, this.zoom = t.zoom, this.canonical = t.tileID.canonical, this.pixelRatio = t.pixelRatio, this.tileSize = t.tileSize, this.source = t.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t.showCollisionBoxes, this.collectResourceTiming = !!t.collectResourceTiming, this.returnDependencies = !!t.returnDependencies, this.promoteId = t.promoteId, this.enableTerrain = !!t.enableTerrain, this.isSymbolTile = t.isSymbolTile, this.tileTransform = Zp(t.tileID.canonical, t.projection), this.projection = t.projection;\n      }\n\n      parse(t, e, r, n, i) {\n        this.status = \"parsing\", this.data = t, this.collisionBoxArray = new ea();\n        const s = new Xp(Object.keys(t.layers).sort()),\n              a = new Bf(this.tileID, this.promoteId);\n        a.bucketLayerIDs = [];\n        const o = {},\n              l = new pp(256, 256),\n              u = {\n          featureIndex: a,\n          iconDependencies: {},\n          patternDependencies: {},\n          glyphDependencies: {},\n          lineAtlas: l,\n          availableImages: r\n        },\n              c = e.familiesBySource[this.source];\n\n        for (const e in c) {\n          const n = t.layers[e];\n          if (!n) continue;\n          let i = !1,\n              l = !1;\n\n          for (const t of c[e]) \"symbol\" === t[0].type ? i = !0 : l = !0;\n\n          if (!0 === this.isSymbolTile && !i) continue;\n          if (!1 === this.isSymbolTile && !l) continue;\n          1 === n.version && C(`Vector tile source \"${this.source}\" layer \"${e}\" does not use vector tile spec v2 and therefore may have some rendering errors.`);\n          const h = s.encode(e),\n                p = [];\n\n          for (let t = 0; t < n.length; t++) {\n            const r = n.feature(t),\n                  i = a.getId(r, e);\n            p.push({\n              feature: r,\n              id: i,\n              index: t,\n              sourceLayerIndex: h\n            });\n          }\n\n          for (const t of c[e]) {\n            const e = t[0];\n            void 0 !== this.isSymbolTile && \"symbol\" === e.type !== this.isSymbolTile || e.minzoom && this.zoom < Math.floor(e.minzoom) || e.maxzoom && this.zoom >= e.maxzoom || \"none\" !== e.visibility && (Vf(t, this.zoom, r), (o[e.id] = e.createBucket({\n              index: a.bucketLayerIDs.length,\n              layers: t,\n              zoom: this.zoom,\n              canonical: this.canonical,\n              pixelRatio: this.pixelRatio,\n              overscaling: this.overscaling,\n              collisionBoxArray: this.collisionBoxArray,\n              sourceLayerIndex: h,\n              sourceID: this.source,\n              enableTerrain: this.enableTerrain,\n              projection: this.projection.name,\n              availableImages: r\n            })).populate(p, u, this.tileID.canonical, this.tileTransform), a.bucketLayerIDs.push(t.map(t => t.id)));\n          }\n        }\n\n        let h, p, f, d;\n        l.trim();\n        const y = {\n          type: \"maybePrepare\",\n          isSymbolTile: this.isSymbolTile,\n          zoom: this.zoom\n        },\n              m = T(u.glyphDependencies, t => Object.keys(t).map(Number));\n        Object.keys(m).length ? n.send(\"getGlyphs\", {\n          uid: this.uid,\n          stacks: m\n        }, (t, e) => {\n          h || (h = t, p = e, b.call(this));\n        }, void 0, !1, y) : p = {};\n        const g = Object.keys(u.iconDependencies);\n        g.length ? n.send(\"getImages\", {\n          icons: g,\n          source: this.source,\n          tileID: this.tileID,\n          type: \"icons\"\n        }, (t, e) => {\n          h || (h = t, f = e, b.call(this));\n        }, void 0, !1, y) : f = {};\n        const x = Object.keys(u.patternDependencies);\n\n        function b() {\n          if (h) return i(h);\n\n          if (p && f && d) {\n            const t = new Df(p),\n                  e = new Xc(f, d);\n\n            for (const n in o) {\n              const i = o[n];\n              i instanceof tp ? (Vf(i.layers, this.zoom, r), Rh(i, p, t.positions, f, e.iconPositions, this.showCollisionBoxes, r, this.tileID.canonical, this.tileZoom, this.projection)) : i.hasPattern && (i instanceof Qu || i instanceof xu || i instanceof $u) && (Vf(i.layers, this.zoom, r), i.addFeatures(u, this.tileID.canonical, e.patternPositions, r, this.tileTransform));\n            }\n\n            this.status = \"done\", i(null, {\n              buckets: v(o).filter(t => !t.isEmpty()),\n              featureIndex: a,\n              collisionBoxArray: this.collisionBoxArray,\n              glyphAtlasImage: t.image,\n              lineAtlas: l,\n              imageAtlas: e,\n              glyphMap: this.returnDependencies ? p : null,\n              iconMap: this.returnDependencies ? f : null,\n              glyphPositions: this.returnDependencies ? t.positions : null\n            });\n          }\n        }\n\n        x.length ? n.send(\"getImages\", {\n          icons: x,\n          source: this.source,\n          tileID: this.tileID,\n          type: \"patterns\"\n        }, (t, e) => {\n          h || (h = t, d = e, b.call(this));\n        }, void 0, !1, y) : d = {}, b.call(this);\n      }\n\n    }\n\n    function Vf(t, e, r) {\n      const n = new ss(e);\n\n      for (const e of t) e.recalculate(n, r);\n    }\n\n    class Ff {\n      constructor(t) {\n        this.entries = {}, this.scheduler = t;\n      }\n\n      request(t, e, r, n) {\n        const i = this.entries[t] = this.entries[t] || {\n          callbacks: []\n        };\n\n        if (i.result) {\n          const [t, r] = i.result;\n          return this.scheduler ? this.scheduler.add(() => {\n            n(t, r);\n          }, e) : n(t, r), () => {};\n        }\n\n        return i.callbacks.push(n), i.cancel || (i.cancel = r((r, n) => {\n          i.result = [r, n];\n\n          for (const t of i.callbacks) this.scheduler ? this.scheduler.add(() => {\n            t(r, n);\n          }, e) : t(r, n);\n\n          setTimeout(() => delete this.entries[t], 3e3);\n        })), () => {\n          i.result || (i.callbacks = i.callbacks.filter(t => t !== n), i.callbacks.length || (i.cancel(), delete this.entries[t]));\n        };\n      }\n\n    }\n\n    function Lf(t, e, r) {\n      const n = JSON.stringify(t.request);\n      return t.data && (this.deduped.entries[n] = {\n        result: [null, t.data]\n      }), this.deduped.request(n, {\n        type: \"parseTile\",\n        isSymbolTile: t.isSymbolTile,\n        zoom: t.tileZoom\n      }, e => {\n        const n = Mt(t.request, (t, n, i, s) => {\n          t ? e(t) : n && e(null, {\n            vectorTile: r ? void 0 : new Du.VectorTile(new wc(n)),\n            rawData: n,\n            cacheControl: i,\n            expires: s\n          });\n        });\n        return () => {\n          n.cancel(), e();\n        };\n      }, e);\n    }\n\n    const Rf = jo(new Float32Array(16));\n\n    class Uf {\n      constructor(t) {\n        this.name = t.name, this.wrap = !1, this.requiresDraping = !1, this.supportsWorldCopies = !1, this.supportsTerrain = !1, this.supportsFog = !1, this.supportsFreeCamera = !1, this.zAxisUnit = \"meters\", this.isReprojectedInTileSpace = !0, this.unsupportedLayers = [\"custom\"], this.center = [0, 0], this.range = [3.5, 7];\n      }\n\n      project(t, e) {\n        return {\n          x: 0,\n          y: 0,\n          z: 0\n        };\n      }\n\n      unproject(t, e) {\n        return new Ja(0, 0);\n      }\n\n      projectTilePoint(t, e, r) {\n        return {\n          x: t,\n          y: e,\n          z: 0\n        };\n      }\n\n      locationPoint(t, e) {\n        return t._coordinatePoint(t.locationCoordinate(e), !1);\n      }\n\n      pixelsPerMeter(t, e) {\n        return no(1, t) * e;\n      }\n\n      farthestPixelDistance(t) {\n        return function (t, e) {\n          const r = t.fovAboveCenter,\n                n = t.elevation ? t.elevation.getMinElevationBelowMSL() * e : 0,\n                i = (t._camera.position[2] * t.worldSize - n) / Math.cos(t._pitch),\n                s = Math.sin(r) * i / Math.sin(Math.max(Math.PI / 2 - t._pitch - r, .01)),\n                a = Math.sin(t._pitch) * s + i;\n          return Math.min(1.01 * a, i * (1 / t._horizonShift));\n        }(t, t.pixelsPerMeter);\n      }\n\n      pointCoordinate(t, e, r, n) {\n        const s = t.horizonLineFromTop(!1),\n              a = new i(e, Math.max(s, r));\n        return t.rayIntersectionCoordinate(t.pointRayIntersection(a, n));\n      }\n\n      createInversionMatrix(t, e) {\n        return Rf;\n      }\n\n      createTileMatrix(t, e, r) {\n        let n, i, s;\n        const a = r.canonical,\n              o = jo(new Float64Array(16));\n\n        if (this.isReprojectedInTileSpace) {\n          const l = Zp(a, this);\n          n = 1, i = l.x + r.wrap * l.scale, s = l.y, No(o, o, [n / l.scale, n / l.scale, t.pixelsPerMeter / e]);\n        } else n = e / t.zoomScale(a.z), i = (a.x + Math.pow(2, a.z) * r.wrap) * n, s = a.y * n;\n\n        return qo(o, o, [i, s, 0]), No(o, o, [n / Ya, n / Ya, 1]), o;\n      }\n\n      upVector(t, e, r) {\n        return [0, 0, 1];\n      }\n\n      upVectorScale(t, e, r) {\n        return {\n          metersToTile: 1,\n          metersToLabelSpace: 1\n        };\n      }\n\n    }\n\n    class $f extends Uf {\n      constructor(t) {\n        super(t), this.wrap = !0, this.supportsWorldCopies = !0, this.supportsTerrain = !0, this.supportsFog = !0, this.supportsFreeCamera = !0, this.isReprojectedInTileSpace = !1, this.unsupportedLayers = [], this.range = null;\n      }\n\n      project(t, e) {\n        return {\n          x: eo(t),\n          y: ro(e),\n          z: 0\n        };\n      }\n\n      unproject(t, e) {\n        const r = io(t),\n              n = so(e);\n        return new Ja(r, n);\n      }\n\n    }\n\n    class jf extends Uf {\n      constructor(t) {\n        super(t), this.range = [4, 7], this.center = t.center || [-96, 37.5];\n        const [e, r] = this.parallels = t.parallels || [29.5, 45.5],\n              n = Math.sin(u(e));\n        this.n = (n + Math.sin(u(r))) / 2, this.c = 1 + n * (2 * this.n - n), this.r0 = Math.sqrt(this.c) / this.n;\n      }\n\n      project(t, e) {\n        const {\n          n: r,\n          c: n,\n          r0: i\n        } = this,\n              s = u(t - this.center[0]),\n              a = u(e),\n              o = Math.sqrt(n - 2 * r * Math.sin(a)) / r;\n        return {\n          x: o * Math.sin(s * r),\n          y: o * Math.cos(s * r) - i,\n          z: 0\n        };\n      }\n\n      unproject(t, e) {\n        const {\n          n: r,\n          c: n,\n          r0: i\n        } = this,\n              s = i + e;\n        let a = Math.atan2(t, Math.abs(s)) * Math.sign(s);\n        s * r < 0 && (a -= Math.PI * Math.sign(t) * Math.sign(s));\n        const o = u(this.center[0]) * r;\n        a = g(a, -Math.PI - o, Math.PI - o);\n        const l = c(a / r) + this.center[0],\n              h = Math.asin(y((n - (t * t + s * s) * r * r) / (2 * r), -1, 1)),\n              p = y(c(h), -85.051129, oo);\n        return new Ja(l, p);\n      }\n\n    }\n\n    const Of = 1.340264,\n          qf = -.081106,\n          Nf = 893e-6,\n          Gf = .003796,\n          Zf = Math.sqrt(3) / 2;\n\n    class Xf extends Uf {\n      project(t, e) {\n        e = e / 180 * Math.PI, t = t / 180 * Math.PI;\n        const r = Math.asin(Zf * Math.sin(e)),\n              n = r * r,\n              i = n * n * n;\n        return {\n          x: .5 * (t * Math.cos(r) / (Zf * (Of + 3 * qf * n + i * (7 * Nf + 9 * Gf * n))) / Math.PI + .5),\n          y: 1 - .5 * (r * (Of + qf * n + i * (Nf + Gf * n)) / Math.PI + 1),\n          z: 0\n        };\n      }\n\n      unproject(t, e) {\n        t = (2 * t - .5) * Math.PI;\n        let r = e = (2 * (1 - e) - 1) * Math.PI,\n            n = r * r,\n            i = n * n * n;\n\n        for (let t, s, a, o = 0; o < 12 && (s = r * (Of + qf * n + i * (Nf + Gf * n)) - e, a = Of + 3 * qf * n + i * (7 * Nf + 9 * Gf * n), t = s / a, r = y(r - t, -Math.PI / 3, Math.PI / 3), n = r * r, i = n * n * n, !(Math.abs(t) < 1e-12)); ++o);\n\n        const s = Zf * t * (Of + 3 * qf * n + i * (7 * Nf + 9 * Gf * n)) / Math.cos(r),\n              a = Math.asin(Math.sin(r) / Zf),\n              o = y(180 * s / Math.PI, -180, 180),\n              l = y(180 * a / Math.PI, -85.051129, oo);\n        return new Ja(o, l);\n      }\n\n    }\n\n    class Kf extends Uf {\n      constructor(t) {\n        super(t), this.wrap = !0, this.supportsWorldCopies = !0;\n      }\n\n      project(t, e) {\n        return {\n          x: .5 + t / 360,\n          y: .5 - e / 360,\n          z: 0\n        };\n      }\n\n      unproject(t, e) {\n        const r = 360 * (t - .5),\n              n = y(360 * (.5 - e), -85.051129, oo);\n        return new Ja(r, n);\n      }\n\n    }\n\n    const Yf = Math.PI / 2;\n\n    function Hf(t) {\n      return Math.tan((Yf + t) / 2);\n    }\n\n    class Wf extends Uf {\n      constructor(t) {\n        super(t), this.center = t.center || [0, 30];\n        const [e, r] = this.parallels = t.parallels || [30, 30],\n              n = u(e),\n              i = u(r),\n              s = Math.cos(n);\n        this.n = n === i ? Math.sin(n) : Math.log(s / Math.cos(i)) / Math.log(Hf(i) / Hf(n)), this.f = s * Math.pow(Hf(n), this.n) / this.n;\n      }\n\n      project(t, e) {\n        e = u(e), t = u(t - this.center[0]);\n        const r = 1e-6,\n              {\n          n: n,\n          f: i\n        } = this;\n        i > 0 ? e < -Yf + r && (e = -Yf + r) : e > Yf - r && (e = Yf - r);\n        const s = i / Math.pow(Hf(e), n),\n              a = s * Math.sin(n * t),\n              o = i - s * Math.cos(n * t);\n        return {\n          x: .5 * (a / Math.PI + .5),\n          y: 1 - .5 * (o / Math.PI + .5),\n          z: 0\n        };\n      }\n\n      unproject(t, e) {\n        t = (2 * t - .5) * Math.PI, e = (2 * (1 - e) - .5) * Math.PI;\n        const {\n          n: r,\n          f: n\n        } = this,\n              i = n - e,\n              s = Math.sign(i),\n              a = Math.sign(r) * Math.sqrt(t * t + i * i);\n        let o = Math.atan2(t, Math.abs(i)) * s;\n        i * r < 0 && (o -= Math.PI * Math.sign(t) * s);\n        const l = y(c(o / r) + this.center[0], -180, 180),\n              u = y(c(2 * Math.atan(Math.pow(n / a, 1 / r)) - Yf), -85.051129, oo);\n        return new Ja(l, u);\n      }\n\n    }\n\n    const Jf = u(oo);\n\n    class Qf extends Uf {\n      project(t, e) {\n        const r = (e = u(e)) * e,\n              n = r * r;\n        return {\n          x: .5 * ((t = u(t)) * (.8707 - .131979 * r + n * (n * (.003971 * r - .001529 * n) - .013791)) / Math.PI + .5),\n          y: 1 - .5 * (e * (1.007226 + r * (.015085 + n * (.028874 * r - .044475 - .005916 * n))) / Math.PI + 1),\n          z: 0\n        };\n      }\n\n      unproject(t, e) {\n        t = (2 * t - .5) * Math.PI;\n        let r = e = (2 * (1 - e) - 1) * Math.PI,\n            n = 25,\n            i = 0,\n            s = r * r;\n\n        do {\n          s = r * r;\n          const t = s * s;\n          i = (r * (1.007226 + s * (.015085 + t * (.028874 * s - .044475 - .005916 * t))) - e) / (1.007226 + s * (.045255 + t * (.259866 * s - .311325 - .005916 * 11 * t))), r = y(r - i, -Jf, Jf);\n        } while (Math.abs(i) > 1e-6 && --n > 0);\n\n        s = r * r;\n        const a = y(c(t / (.8707 + s * (s * (s * s * s * (.003971 - .001529 * s) - .013791) - .131979))), -180, 180),\n              o = c(r);\n        return new Ja(a, o);\n      }\n\n    }\n\n    const td = u(oo);\n\n    class ed extends Uf {\n      project(t, e) {\n        e = u(e), t = u(t);\n        const r = Math.cos(e),\n              n = 2 / Math.PI,\n              i = Math.acos(r * Math.cos(t / 2)),\n              s = Math.sin(i) / i,\n              a = .5 * (t * n + 2 * r * Math.sin(t / 2) / s) || 0,\n              o = .5 * (e + Math.sin(e) / s) || 0;\n        return {\n          x: .5 * (a / Math.PI + .5),\n          y: 1 - .5 * (o / Math.PI + 1),\n          z: 0\n        };\n      }\n\n      unproject(t, e) {\n        let r = t = (2 * t - .5) * Math.PI,\n            n = e = (2 * (1 - e) - 1) * Math.PI,\n            i = 25;\n        const s = 1e-6;\n        let a = 0,\n            o = 0;\n\n        do {\n          const i = Math.cos(n),\n                s = Math.sin(n),\n                l = 2 * s * i,\n                u = s * s,\n                c = i * i,\n                h = Math.cos(r / 2),\n                p = Math.sin(r / 2),\n                f = 2 * h * p,\n                d = p * p,\n                m = 1 - c * h * h,\n                g = m ? 1 / m : 0,\n                x = m ? Math.acos(i * h) * Math.sqrt(1 / m) : 0,\n                v = .5 * (2 * x * i * p + 2 * r / Math.PI) - t,\n                b = .5 * (x * s + n) - e,\n                _ = .5 * g * (c * d + x * i * h * u) + 1 / Math.PI,\n                w = g * (f * l / 4 - x * s * p),\n                A = .125 * g * (l * p - x * s * c * f),\n                k = .5 * g * (u * h + x * d * i) + .5,\n                S = w * A - k * _;\n\n          a = (b * w - v * k) / S, o = (v * A - b * _) / S, r = y(r - a, -Math.PI, Math.PI), n = y(n - o, -td, td);\n        } while ((Math.abs(a) > s || Math.abs(o) > s) && --i > 0);\n\n        return new Ja(c(r), c(n));\n      }\n\n    }\n\n    class rd extends Uf {\n      constructor(t) {\n        super(t), this.center = t.center || [0, 0], this.parallels = t.parallels || [0, 0], this.cosPhi = Math.max(.01, Math.cos(u(this.parallels[0]))), this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi)), this.wrap = !0, this.supportsWorldCopies = !0;\n      }\n\n      project(t, e) {\n        const {\n          scale: r,\n          cosPhi: n\n        } = this;\n        return {\n          x: u(t) * n * r + .5,\n          y: -Math.sin(u(e)) / n * r + .5,\n          z: 0\n        };\n      }\n\n      unproject(t, e) {\n        const {\n          scale: r,\n          cosPhi: n\n        } = this,\n              i = -(e - .5) / r,\n              s = y(c((t - .5) / r) / n, -180, 180),\n              a = Math.asin(y(i * n, -1, 1)),\n              o = y(c(a), -85.051129, oo);\n        return new Ja(s, o);\n      }\n\n    }\n\n    t.ARRAY_TYPE = Uo, t.AUTH_ERR_MSG = tt, t.Aabb = vl, t.Actor = class {\n      constructor(t, e, r) {\n        this.target = t, this.parent = e, this.mapId = r, this.callbacks = {}, this.cancelCallbacks = {}, I([\"receive\"], this), this.target.addEventListener(\"message\", this.receive, !1), this.globalScope = V() ? t : a, this.scheduler = new mp();\n      }\n\n      send(t, e, r, n, i = !1, s) {\n        const a = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);\n        r && (r.metadata = s, this.callbacks[a] = r);\n        const o = O(this.globalScope) ? void 0 : [];\n        return this.target.postMessage({\n          id: a,\n          type: t,\n          hasCallback: !!r,\n          targetMapId: n,\n          mustQueue: i,\n          sourceMapId: this.mapId,\n          data: ui(e, o)\n        }, o), {\n          cancel: () => {\n            r && delete this.callbacks[a], this.target.postMessage({\n              id: a,\n              type: \"<cancel>\",\n              targetMapId: n,\n              sourceMapId: this.mapId\n            });\n          }\n        };\n      }\n\n      receive(t) {\n        const e = t.data,\n              r = e.id;\n        if (r && (!e.targetMapId || this.mapId === e.targetMapId)) if (\"<cancel>\" === e.type) {\n          const t = this.cancelCallbacks[r];\n          delete this.cancelCallbacks[r], t && t.cancel();\n        } else if (e.mustQueue || V()) {\n          const t = this.callbacks[r];\n          this.cancelCallbacks[r] = this.scheduler.add(() => this.processTask(r, e), t && t.metadata || {\n            type: \"message\"\n          });\n        } else this.processTask(r, e);\n      }\n\n      processTask(t, e) {\n        if (\"<response>\" === e.type) {\n          const r = this.callbacks[t];\n          delete this.callbacks[t], r && (e.error ? r(ci(e.error)) : r(null, ci(e.data)));\n        } else {\n          const r = O(this.globalScope) ? void 0 : [],\n                n = e.hasCallback ? (e, n) => {\n            delete this.cancelCallbacks[t], this.target.postMessage({\n              id: t,\n              type: \"<response>\",\n              sourceMapId: this.mapId,\n              error: e ? ui(e) : null,\n              data: ui(n, r)\n            }, r);\n          } : t => {},\n                i = ci(e.data);\n          if (this.parent[e.type]) this.parent[e.type](e.sourceMapId, i, n);else if (this.parent.getWorkerSource) {\n            const t = e.type.split(\".\");\n            this.parent.getWorkerSource(e.sourceMapId, t[0], i.source)[t[1]](i, n);\n          } else n(new Error(`Could not find function ${e.type}`));\n        }\n      }\n\n      remove() {\n        this.scheduler.remove(), this.target.removeEventListener(\"message\", this.receive, !1);\n      }\n\n    }, t.CanonicalTileID = Op, t.Color = ce, t.ColorMode = wf, t.CullFaceMode = Sf, t.DEMData = gf, t.DataConstantProperty = ds, t.DedupedRequest = Ff, t.DepthMode = vf, t.EXTENT = Ya, t.Elevation = class {\n      isDataAvailableAtPoint(t) {\n        const e = this._source();\n\n        if (!e || t.y < 0 || t.y > 1) return !1;\n        const r = e.getSource().maxzoom,\n              n = 1 << r,\n              i = Math.floor(t.x),\n              s = Math.floor((t.x - i) * n),\n              a = Math.floor(t.y * n),\n              o = this.findDEMTileFor(new Np(r, i, r, s, a));\n        return !(!o || !o.dem);\n      }\n\n      getAtPointOrZero(t, e = 0) {\n        return this.getAtPoint(t, e) || 0;\n      }\n\n      getAtPoint(t, e, r = !0) {\n        null == e && (e = null);\n\n        const n = this._source();\n\n        if (!n) return e;\n        if (t.y < 0 || t.y > 1) return e;\n        const i = n.getSource().maxzoom,\n              s = 1 << i,\n              a = Math.floor(t.x),\n              o = t.x - a,\n              l = new Np(i, a, i, Math.floor(o * s), Math.floor(t.y * s)),\n              u = this.findDEMTileFor(l);\n        if (!u || !u.dem) return e;\n        const c = u.dem,\n              h = 1 << u.tileID.canonical.z,\n              p = (o * h - u.tileID.canonical.x) * c.dim,\n              f = (t.y * h - u.tileID.canonical.y) * c.dim,\n              d = Math.floor(p),\n              y = Math.floor(f);\n        return (r ? this.exaggeration() : 1) * rr(rr(c.get(d, y), c.get(d, y + 1), f - y), rr(c.get(d + 1, y), c.get(d + 1, y + 1), f - y), p - d);\n      }\n\n      getAtTileOffset(t, e, r) {\n        const n = 1 << t.canonical.z;\n        return this.getAtPointOrZero(new lo(t.wrap + (t.canonical.x + e / Ya) / n, (t.canonical.y + r / Ya) / n));\n      }\n\n      getAtTileOffsetFunc(t, e, r, n) {\n        return i => {\n          const s = this.getAtTileOffset(t, i.x, i.y),\n                a = n.upVector(t.canonical, i.x, i.y);\n          return nl(a, a, s * n.upVectorScale(t.canonical, e, r).metersToTile), a;\n        };\n      }\n\n      getForTilePoints(t, e, r, n) {\n        const i = zf.create(this, t, n);\n        return !!i && (e.forEach(t => {\n          t[2] = this.exaggeration() * i.getElevationAt(t[0], t[1], r);\n        }), !0);\n      }\n\n      getMinMaxForTile(t) {\n        const e = this.findDEMTileFor(t);\n        if (!e || !e.dem) return null;\n        const r = e.dem.tree,\n              n = e.tileID,\n              i = 1 << t.canonical.z - n.canonical.z;\n        let s = t.canonical.x / i - n.canonical.x,\n            a = t.canonical.y / i - n.canonical.y,\n            o = 0;\n\n        for (let e = 0; e < t.canonical.z - n.canonical.z && !r.leaves[o]; e++) {\n          s *= 2, a *= 2;\n          const t = 2 * Math.floor(a) + Math.floor(s);\n          o = r.childOffsets[o] + t, s %= 1, a %= 1;\n        }\n\n        return {\n          min: this.exaggeration() * r.minimums[o],\n          max: this.exaggeration() * r.maximums[o]\n        };\n      }\n\n      getMinElevationBelowMSL() {\n        throw new Error(\"Pure virtual method called.\");\n      }\n\n      raycast(t, e, r) {\n        throw new Error(\"Pure virtual method called.\");\n      }\n\n      pointCoordinate(t) {\n        throw new Error(\"Pure virtual method called.\");\n      }\n\n      _source() {\n        throw new Error(\"Pure virtual method called.\");\n      }\n\n      exaggeration() {\n        throw new Error(\"Pure virtual method called.\");\n      }\n\n      findDEMTileFor(t) {\n        throw new Error(\"Pure virtual method called.\");\n      }\n\n      get visibleDemTiles() {\n        throw new Error(\"Getter must be implemented in subclass.\");\n      }\n\n    }, t.ErrorEvent = Rt, t.EvaluationParameters = ss, t.Event = Lt, t.Evented = Ut, t.FillExtrusionBucket = $u, t.Frustum = xl, t.GLOBE_RADIUS = wp, t.GlobeSharedBuffers = class {\n      constructor(t) {\n        this._createGrid(t), this._createPoles(t), this._createAtmosphere(t);\n      }\n\n      destroy() {\n        this._poleIndexBuffer.destroy(), this._gridBuffer.destroy(), this._gridIndexBuffer.destroy(), this._poleNorthVertexBuffer.destroy(), this._poleSouthVertexBuffer.destroy();\n\n        for (const t of this._poleSegments) t.destroy();\n\n        this._gridSegments.destroy(), this.atmosphereVertexBuffer.destroy(), this.atmosphereIndexBuffer.destroy(), this.atmosphereSegments.destroy(), this._wireframeIndexBuffer && (this._wireframeIndexBuffer.destroy(), this._wireframeSegments.destroy());\n      }\n\n      _createGrid(t) {\n        const e = new Is(),\n              r = new $s(),\n              n = 65;\n\n        for (let t = 0; t < n; t++) for (let r = 0; r < n; r++) e.emplaceBack(r, t);\n\n        for (let t = 0; t < 64; t++) for (let e = 0; e < 64; e++) {\n          const i = t * n + e;\n          r.emplaceBack(i + 1, i, i + n), r.emplaceBack(i + n, i + n + 1, i + 1);\n        }\n\n        this._gridBuffer = t.createVertexBuffer(e, _p.members), this._gridIndexBuffer = t.createIndexBuffer(r, !0), this._gridSegments = Ka.simpleSegment(0, 0, 4225, 8192);\n      }\n\n      _createPoles(t) {\n        const e = new $s();\n\n        for (let t = 0; t <= 64; t++) e.emplaceBack(0, t + 1, t + 2);\n\n        this._poleIndexBuffer = t.createIndexBuffer(e, !0);\n        const r = new Ns(),\n              n = new Ns();\n        this._poleSegments = [];\n\n        for (let t = 0, e = 0; t < 5; t++) {\n          const i = 1 << t,\n                s = 512 * i / Math.PI / 2,\n                a = 360 / i;\n          r.emplaceBack(0, -s, 0, 0, 0, .5, 0), n.emplaceBack(0, -s, 0, 0, 0, .5, 1);\n\n          for (let t = 0; t <= 64; t++) {\n            const e = t / 64,\n                  i = rr(0, a, e),\n                  [o, l, u] = Ep(Up, $p, i, s);\n            r.emplaceBack(o, l, u, 0, 0, e, 0), n.emplaceBack(o, l, u, 0, 0, e, 1);\n          }\n\n          this._poleSegments.push(Ka.simpleSegment(e, 0, 66, 64)), e += 66;\n        }\n\n        this._poleNorthVertexBuffer = t.createVertexBuffer(r, vp, !1), this._poleSouthVertexBuffer = t.createVertexBuffer(n, vp, !1);\n      }\n\n      _createAtmosphere(t) {\n        const e = new Gs();\n        e.emplaceBack(-1, 1, 1, 0, 0), e.emplaceBack(1, 1, 1, 1, 0), e.emplaceBack(1, -1, 1, 1, 1), e.emplaceBack(-1, -1, 1, 0, 1);\n        const r = new $s();\n        r.emplaceBack(0, 1, 2), r.emplaceBack(2, 3, 0), this.atmosphereVertexBuffer = t.createVertexBuffer(e, xp.members), this.atmosphereIndexBuffer = t.createIndexBuffer(r), this.atmosphereSegments = Ka.simpleSegment(0, 0, 4, 2);\n      }\n\n      getGridBuffers() {\n        return [this._gridBuffer, this._gridIndexBuffer, this._gridSegments];\n      }\n\n      getPoleBuffers(t) {\n        return [this._poleNorthVertexBuffer, this._poleSouthVertexBuffer, this._poleIndexBuffer, this._poleSegments[t]];\n      }\n\n      getWirefameBuffers(t) {\n        if (!this._wireframeSegments) {\n          const e = new Xs(),\n                r = 64,\n                n = r + 1;\n\n          for (let t = 0; t < r; t++) for (let i = 0; i < r; i++) {\n            const r = t * n + i;\n            e.emplaceBack(r, r + 1), e.emplaceBack(r, r + n), e.emplaceBack(r, r + n + 1);\n          }\n\n          this._wireframeIndexBuffer = t.createIndexBuffer(e), this._wireframeSegments = Ka.simpleSegment(0, 0, r * r, e.length);\n        }\n\n        return [this._gridBuffer, this._wireframeIndexBuffer, this._wireframeSegments];\n      }\n\n    }, t.GlyphManager = Ah, t.ImagePosition = Zc, t.LineAtlas = pp, t.LngLat = Ja, t.LngLatBounds = Ha, t.LocalGlyphMode = wh, t.MAX_MERCATOR_LATITUDE = oo, t.MercatorCoordinate = lo, t.ONE_EM = cc, t.OverscaledTileID = Np, t.Properties = vs, t.RGBAImage = Bl, t.Ray = class {\n      constructor(t, e) {\n        this.pos = t, this.dir = e;\n      }\n\n      intersectsPlane(t, e, r) {\n        const n = al(e, this.dir);\n        if (Math.abs(n) < 1e-6) return !1;\n        const i = ((t[0] - this.pos[0]) * e[0] + (t[1] - this.pos[1]) * e[1] + (t[2] - this.pos[2]) * e[2]) / n;\n        return r[0] = this.pos[0] + this.dir[0] * i, r[1] = this.pos[1] + this.dir[1] * i, r[2] = this.pos[2] + this.dir[2] * i, !0;\n      }\n\n      closestPointOnSphere(t, e, r) {\n        if (function (t, e) {\n          var r = t[0],\n              n = t[1],\n              i = t[2],\n              s = e[0],\n              a = e[1],\n              o = e[2];\n          return Math.abs(r - s) <= Ro * Math.max(1, Math.abs(r), Math.abs(s)) && Math.abs(n - a) <= Ro * Math.max(1, Math.abs(n), Math.abs(a)) && Math.abs(i - o) <= Ro * Math.max(1, Math.abs(i), Math.abs(o));\n        }(this.pos, t) || 0 === e) return r[0] = r[1] = r[2] = 0, !1;\n        const [n, i, s] = this.dir,\n              a = this.pos[0] - t[0],\n              o = this.pos[1] - t[1],\n              l = this.pos[2] - t[2],\n              u = n * n + i * i + s * s,\n              c = 2 * (a * n + o * i + l * s),\n              h = c * c - 4 * u * (a * a + o * o + l * l - e * e);\n\n        if (h < 0) {\n          const t = Math.max(-c / 2, 0),\n                u = a + n * t,\n                h = o + i * t,\n                p = l + s * t,\n                f = Math.hypot(u, h, p);\n          return r[0] = u * e / f, r[1] = h * e / f, r[2] = p * e / f, !1;\n        }\n\n        {\n          const t = (-c - Math.sqrt(h)) / (2 * u);\n\n          if (t < 0) {\n            const t = Math.hypot(a, o, l);\n            return r[0] = a * e / t, r[1] = o * e / t, r[2] = l * e / t, !1;\n          }\n\n          return r[0] = a + n * t, r[1] = o + i * t, r[2] = l + s * t, !0;\n        }\n      }\n\n    }, t.RequestManager = class {\n      constructor(t, e, r) {\n        this._transformRequestFn = t, this._customAccessToken = e, this._silenceAuthErrors = !!r, this._createSkuToken();\n      }\n\n      _createSkuToken() {\n        const t = function () {\n          let t = \"\";\n\n          for (let e = 0; e < 10; e++) t += \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"[Math.floor(62 * Math.random())];\n\n          return {\n            token: [\"1\", Q, t].join(\"\"),\n            tokenExpiresAt: Date.now() + 432e5\n          };\n        }();\n\n        this._skuToken = t.token, this._skuTokenExpiresAt = t.tokenExpiresAt;\n      }\n\n      _isSkuTokenExpired() {\n        return Date.now() > this._skuTokenExpiresAt;\n      }\n\n      transformRequest(t, e) {\n        return this._transformRequestFn && this._transformRequestFn(t, e) || {\n          url: t\n        };\n      }\n\n      normalizeStyleURL(t, e) {\n        if (!et(t)) return t;\n        const r = it(t);\n        return r.path = `/styles/v1${r.path}`, this._makeAPIURL(r, this._customAccessToken || e);\n      }\n\n      normalizeGlyphsURL(t, e) {\n        if (!et(t)) return t;\n        const r = it(t);\n        return r.path = `/fonts/v1${r.path}`, this._makeAPIURL(r, this._customAccessToken || e);\n      }\n\n      normalizeSourceURL(t, e) {\n        if (!et(t)) return t;\n        const r = it(t);\n        return r.path = `/v4/${r.authority}.json`, r.params.push(\"secure\"), this._makeAPIURL(r, this._customAccessToken || e);\n      }\n\n      normalizeSpriteURL(t, e, r, n) {\n        const i = it(t);\n        return et(t) ? (i.path = `/styles/v1${i.path}/sprite${e}${r}`, this._makeAPIURL(i, this._customAccessToken || n)) : (i.path += `${e}${r}`, st(i));\n      }\n\n      normalizeTileURL(t, e, r) {\n        if (this._isSkuTokenExpired() && this._createSkuToken(), t && !et(t)) return t;\n        const n = it(t);\n        n.path = n.path.replace(/(\\.(png|jpg)\\d*)(?=$)/, `${e || r && \"raster\" !== n.authority && 512 === r ? \"@2x\" : \"\"}${X.supported ? \".webp\" : \"$1\"}`), \"raster\" === n.authority ? n.path = `/${Z.RASTER_URL_PREFIX}${n.path}` : (n.path = n.path.replace(/^.+\\/v4\\//, \"/\"), n.path = `/${Z.TILE_URL_VERSION}${n.path}`);\n\n        const i = this._customAccessToken || function (t) {\n          for (const e of t) {\n            const t = e.match(/^access_token=(.*)$/);\n            if (t) return t[1];\n          }\n\n          return null;\n        }(n.params) || Z.ACCESS_TOKEN;\n\n        return Z.REQUIRE_ACCESS_TOKEN && i && this._skuToken && n.params.push(`sku=${this._skuToken}`), this._makeAPIURL(n, i);\n      }\n\n      canonicalizeTileURL(t, e) {\n        const r = it(t);\n        if (!r.path.match(/^(\\/v4\\/|\\/raster\\/v1\\/)/) || !r.path.match(/\\.[\\w]+$/)) return t;\n        let n = \"mapbox://\";\n        r.path.match(/^\\/raster\\/v1\\//) ? n += `raster/${r.path.replace(`/${Z.RASTER_URL_PREFIX}/`, \"\")}` : n += `tiles/${r.path.replace(`/${Z.TILE_URL_VERSION}/`, \"\")}`;\n        let i = r.params;\n        return e && (i = i.filter(t => !t.match(/^access_token=/))), i.length && (n += `?${i.join(\"&\")}`), n;\n      }\n\n      canonicalizeTileset(t, e) {\n        const r = !!e && et(e),\n              n = [];\n\n        for (const e of t.tiles || []) rt(e) ? n.push(this.canonicalizeTileURL(e, r)) : n.push(e);\n\n        return n;\n      }\n\n      _makeAPIURL(t, e) {\n        const r = \"See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes\",\n              n = it(Z.API_URL);\n\n        if (t.protocol = n.protocol, t.authority = n.authority, \"http\" === t.protocol) {\n          const e = t.params.indexOf(\"secure\");\n          e >= 0 && t.params.splice(e, 1);\n        }\n\n        if (\"/\" !== n.path && (t.path = `${n.path}${t.path}`), !Z.REQUIRE_ACCESS_TOKEN) return st(t);\n\n        if (e = e || Z.ACCESS_TOKEN, !this._silenceAuthErrors) {\n          if (!e) throw new Error(`An API access token is required to use Mapbox GL. ${r}`);\n          if (\"s\" === e[0]) throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${r}`);\n        }\n\n        return t.params = t.params.filter(t => -1 === t.indexOf(\"access_token\")), t.params.push(`access_token=${e || \"\"}`), st(t);\n      }\n\n    }, t.ResourceType = At, t.SegmentVector = Ka, t.SourceCache = If, t.StencilMode = _f, t.StructArrayLayout1ui2 = Ks, t.StructArrayLayout2f1f2i16 = Rs, t.StructArrayLayout2i4 = Is, t.StructArrayLayout2ui4 = Xs, t.StructArrayLayout3f12 = Bs, t.StructArrayLayout3ui6 = $s, t.StructArrayLayout4i8 = Ts, t.Texture = hp, t.Tile = af, t.Transitionable = ls, t.Uniform1f = Sa, t.Uniform1i = class extends ka {\n      constructor(t, e) {\n        super(t, e), this.current = 0;\n      }\n\n      set(t) {\n        this.current !== t && (this.current = t, this.gl.uniform1i(this.location, t));\n      }\n\n    }, t.Uniform2f = class extends ka {\n      constructor(t, e) {\n        super(t, e), this.current = [0, 0];\n      }\n\n      set(t) {\n        t[0] === this.current[0] && t[1] === this.current[1] || (this.current = t, this.gl.uniform2f(this.location, t[0], t[1]));\n      }\n\n    }, t.Uniform3f = class extends ka {\n      constructor(t, e) {\n        super(t, e), this.current = [0, 0, 0];\n      }\n\n      set(t) {\n        t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] || (this.current = t, this.gl.uniform3f(this.location, t[0], t[1], t[2]));\n      }\n\n    }, t.Uniform4f = Ia, t.UniformColor = Ma, t.UniformMatrix2f = class extends ka {\n      constructor(t, e) {\n        super(t, e), this.current = Ba;\n      }\n\n      set(t) {\n        for (let e = 0; e < 4; e++) if (t[e] !== this.current[e]) {\n          this.current = t, this.gl.uniformMatrix2fv(this.location, !1, t);\n          break;\n        }\n      }\n\n    }, t.UniformMatrix3f = class extends ka {\n      constructor(t, e) {\n        super(t, e), this.current = za;\n      }\n\n      set(t) {\n        for (let e = 0; e < 9; e++) if (t[e] !== this.current[e]) {\n          this.current = t, this.gl.uniformMatrix3fv(this.location, !1, t);\n          break;\n        }\n      }\n\n    }, t.UniformMatrix4f = class extends ka {\n      constructor(t, e) {\n        super(t, e), this.current = Ta;\n      }\n\n      set(t) {\n        if (t[12] !== this.current[12] || t[0] !== this.current[0]) return this.current = t, void this.gl.uniformMatrix4fv(this.location, !1, t);\n\n        for (let e = 1; e < 16; e++) if (t[e] !== this.current[e]) {\n          this.current = t, this.gl.uniformMatrix4fv(this.location, !1, t);\n          break;\n        }\n      }\n\n    }, t.UnwrappedTileID = qp, t.ValidationError = mn, t.VectorTileWorkerSource = class extends Ut {\n      constructor(t, e, r, n, i) {\n        super(), this.actor = t, this.layerIndex = e, this.availableImages = r, this.loadVectorData = i || Lf, this.loading = {}, this.loaded = {}, this.deduped = new Ff(t.scheduler), this.isSpriteLoaded = n, this.scheduler = t.scheduler;\n      }\n\n      loadTile(t, e) {\n        const r = t.uid,\n              n = t && t.request,\n              i = n && n.collectResourceTiming,\n              s = this.loading[r] = new Pf(t);\n        s.abort = this.loadVectorData(t, (a, o) => {\n          const l = !this.loading[r];\n          if (delete this.loading[r], l || a || !o) return s.status = \"done\", l || (this.loaded[r] = s), e(a);\n          const u = o.rawData,\n                c = {};\n          o.expires && (c.expires = o.expires), o.cacheControl && (c.cacheControl = o.cacheControl), s.vectorTile = o.vectorTile || new Du.VectorTile(new wc(u));\n\n          const h = () => {\n            s.parse(s.vectorTile, this.layerIndex, this.availableImages, this.actor, (t, r) => {\n              if (t || !r) return e(t);\n              const s = {};\n\n              if (i) {\n                const t = yp(n);\n                t.length > 0 && (s.resourceTiming = JSON.parse(JSON.stringify(t)));\n              }\n\n              e(null, b({\n                rawTileData: u.slice(0)\n              }, r, c, s));\n            });\n          };\n\n          this.isSpriteLoaded ? h() : this.once(\"isSpriteLoaded\", () => {\n            this.scheduler ? this.scheduler.add(h, {\n              type: \"parseTile\",\n              isSymbolTile: t.isSymbolTile,\n              zoom: t.tileZoom\n            }) : h();\n          }), this.loaded = this.loaded || {}, this.loaded[r] = s;\n        });\n      }\n\n      reloadTile(t, e) {\n        const r = this.loaded,\n              n = t.uid,\n              i = this;\n\n        if (r && r[n]) {\n          const s = r[n];\n          s.showCollisionBoxes = t.showCollisionBoxes, s.enableTerrain = !!t.enableTerrain, s.projection = t.projection, s.tileTransform = Zp(t.tileID.canonical, t.projection);\n\n          const a = (t, r) => {\n            const n = s.reloadCallback;\n            n && (delete s.reloadCallback, s.parse(s.vectorTile, i.layerIndex, this.availableImages, i.actor, n)), e(t, r);\n          };\n\n          \"parsing\" === s.status ? s.reloadCallback = a : \"done\" === s.status && (s.vectorTile ? s.parse(s.vectorTile, this.layerIndex, this.availableImages, this.actor, a) : a());\n        }\n      }\n\n      abortTile(t, e) {\n        const r = t.uid,\n              n = this.loading[r];\n        n && (n.abort && n.abort(), delete this.loading[r]), e();\n      }\n\n      removeTile(t, e) {\n        const r = this.loaded,\n              n = t.uid;\n        r && r[n] && delete r[n], e();\n      }\n\n    }, t.WritingMode = Kc, t.ZoomHistory = hi, t.add = Jo, t.addDynamicAttributes = Hh, t.adjoint = function (t, e) {\n      var r = e[0],\n          n = e[1],\n          i = e[2],\n          s = e[3],\n          a = e[4],\n          o = e[5],\n          l = e[6],\n          u = e[7],\n          c = e[8];\n      return t[0] = a * c - o * u, t[1] = i * u - n * c, t[2] = n * o - i * a, t[3] = o * l - s * c, t[4] = r * c - i * l, t[5] = i * s - r * o, t[6] = s * u - a * l, t[7] = n * l - r * u, t[8] = r * a - n * s, t;\n    }, t.asyncAll = x, t.bezier = f, t.bindAll = I, t.boundsAttributes = nf, t.bufferConvexPolygon = function (t, e) {\n      const r = [];\n\n      for (let n = 0; n < t.length; n++) {\n        const i = g(n - 1, -1, t.length - 1),\n              s = g(n + 1, -1, t.length - 1),\n              a = t[n],\n              o = t[s],\n              l = t[i].sub(a).unit(),\n              u = o.sub(a).unit(),\n              c = u.angleWithSep(l.x, l.y),\n              h = l.add(u).unit().mult(-1 * e / Math.sin(c / 2));\n        r.push(a.add(h));\n      }\n\n      return r;\n    }, t.cacheEntryPossiblyAdded = function (t) {\n      wt++, wt > vt && (t.getActor().send(\"enforceCacheSizeLimit\", xt), wt = 0);\n    }, t.calculateGlobeLabelMatrix = function (t, e) {\n      const {\n        lng: r,\n        lat: n\n      } = t._center,\n            i = Fp(0, 0, t.worldSize / t._projectionScaler, r, n);\n      return Oo(i, i, function (t) {\n        const e = jo(new Float64Array(16)),\n              r = 1 / Pp(t);\n        return qo(e, e, t.min), No(e, e, [r, r, r]), e;\n      }(Tp(e)));\n    }, t.calculateGlobeMatrix = Lp, t.calculateGlobeMercatorMatrix = function (t) {\n      const e = t.worldSize,\n            r = t.point,\n            n = no(1, t.center.lat) * e,\n            i = t.pixelsPerMeter,\n            s = e / (n / t.pixelsPerMeter),\n            a = jo(new Float64Array(16));\n      return qo(a, a, [r.x, r.y, 0]), No(a, a, [s, s, i]), Float32Array.from(a);\n    }, t.circumferenceAtLatitude = to, t.clamp = y, t.clearTileCache = function (t) {\n      const e = a.caches.delete(yt);\n      t && e.catch(t).then(() => t());\n    }, t.clipLine = xh, t.clone = function (t) {\n      var e = new Uo(16);\n      return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e;\n    }, t.clone$1 = B, t.collisionCircleLayout = uc, t.config = Z, t.conjugate = function (t, e) {\n      return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = e[3], t;\n    }, t.create = function () {\n      var t = new Uo(16);\n      return Uo != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0), t[0] = 1, t[5] = 1, t[10] = 1, t[15] = 1, t;\n    }, t.create$1 = $o, t.createExpression = cn, t.createLayout = ks, t.createStyleLayer = function (t) {\n      return \"custom\" === t.type ? new op(t) : new cp[t.type](t);\n    }, t.cross = ol, t.degToRad = u, t.div = function (t, e, r) {\n      return t[0] = e[0] / r[0], t[1] = e[1] / r[1], t[2] = e[2] / r[2], t;\n    }, t.dot = al, t.earthRadius = Wa, t.ease = d, t.easeCubicInOut = p, t.emitValidationErrors = ri, t.endsWith = M, t.enforceCacheSizeLimit = function (t) {\n      bt(), mt && mt.then(e => {\n        e.keys().then(r => {\n          for (let n = 0; n < r.length - t; n++) e.delete(r[n]);\n        });\n      });\n    }, t.evaluateSizeForFeature = fc, t.evaluateSizeForZoom = dc, t.evaluateVariableOffset = Lh, t.evented = es, t.exactEquals = function (t, e) {\n      return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3];\n    }, t.exactEquals$1 = function (t, e) {\n      return t[0] === e[0] && t[1] === e[1] && t[2] === e[2];\n    }, t.exported = N, t.exported$1 = X, t.extend = b, t.extend$1 = jt, t.filterObject = z, t.fromMat4 = function (t, e) {\n      return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[4], t[4] = e[5], t[5] = e[6], t[6] = e[8], t[7] = e[9], t[8] = e[10], t;\n    }, t.fromQuat = function (t, e) {\n      var r = e[0],\n          n = e[1],\n          i = e[2],\n          s = e[3],\n          a = r + r,\n          o = n + n,\n          l = i + i,\n          u = r * a,\n          c = n * a,\n          h = n * o,\n          p = i * a,\n          f = i * o,\n          d = i * l,\n          y = s * a,\n          m = s * o,\n          g = s * l;\n      return t[0] = 1 - h - d, t[1] = c + g, t[2] = p - m, t[3] = 0, t[4] = c - g, t[5] = 1 - u - d, t[6] = f + y, t[7] = 0, t[8] = p + m, t[9] = f - y, t[10] = 1 - u - h, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;\n    }, t.fromRotation = function (t, e) {\n      var r = Math.sin(e),\n          n = Math.cos(e);\n      return t[0] = n, t[1] = r, t[2] = 0, t[3] = -r, t[4] = n, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;\n    }, t.fromScaling = function (t, e) {\n      return t[0] = e[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = e[1], t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = e[2], t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;\n    }, t.furthestTileCorner = function (t) {\n      const e = Math.round((t + 45 + 360) % 360 / 90) % 4;\n      return h[e];\n    }, t.getAABBPointSquareDist = function (t, e, r) {\n      let n = 0;\n\n      for (let i = 0; i < 2; ++i) {\n        const s = r ? r[i] : 0;\n        t[i] > s && (n += (t[i] - s) * (t[i] - s)), e[i] < s && (n += (s - e[i]) * (s - e[i]));\n      }\n\n      return n;\n    }, t.getAnchorAlignment = ah, t.getAnchorJustification = Uh, t.getBounds = function (t) {\n      let e = 1 / 0,\n          r = 1 / 0,\n          n = -1 / 0,\n          s = -1 / 0;\n\n      for (const i of t) e = Math.min(e, i.x), r = Math.min(r, i.y), n = Math.max(n, i.x), s = Math.max(s, i.y);\n\n      return {\n        min: new i(e, r),\n        max: new i(n, s)\n      };\n    }, t.getColumn = function (t, e) {\n      return [t[4 * e], t[4 * e + 1], t[4 * e + 2], t[4 * e + 3]];\n    }, t.getGridMatrix = function (t, e) {\n      const [r, n] = e,\n            i = .015625;\n      return [0, (n[1] - r[1]) * i, 1 << t.z, (n[0] - r[0]) * i, 0, t.y, r[0], r[1], i];\n    }, t.getImage = Pt, t.getJSON = function (t, e) {\n      return It(b(t, {\n        type: \"json\"\n      }), e);\n    }, t.getMapSessionAPI = ft, t.getPerformanceMeasurement = yp, t.getProjection = function (t) {\n      const e = t.parallels,\n            r = !!e && Math.abs(e[0] + e[1]) < .01;\n\n      switch (t.name) {\n        case \"mercator\":\n          return new $f(t);\n\n        case \"equirectangular\":\n          return new Kf(t);\n\n        case \"naturalEarth\":\n          return new Qf(t);\n\n        case \"equalEarth\":\n          return new Xf(t);\n\n        case \"winkelTripel\":\n          return new ed(t);\n\n        case \"albers\":\n          return r ? new rd(t) : new jf(t);\n\n        case \"lambertConformalConic\":\n          return r ? new rd(t) : new Wf(t);\n      }\n\n      throw new Error(`Invalid projection name: ${t.name}`);\n    }, t.getRTLTextPluginStatus = rs, t.getReferrer = St, t.getTilePoint = function (t, {\n      x: e,\n      y: r\n    }, n = 0) {\n      return new i(((e - n) * t.scale - t.x) * Ya, (r * t.scale - t.y) * Ya);\n    }, t.getTileVec3 = function (t, e, r = 0) {\n      return Wo(((e.x - r) * t.scale - t.x) * Ya, (e.y * t.scale - t.y) * Ya, ao(e.z, e.y));\n    }, t.getVideo = function (t, e) {\n      const r = a.document.createElement(\"video\");\n      r.muted = !0, r.onloadstart = function () {\n        e(null, r);\n      };\n\n      for (let e = 0; e < t.length; e++) {\n        const n = a.document.createElement(\"source\");\n        Bt(t[e]) || (r.crossOrigin = \"Anonymous\"), n.src = t[e], r.appendChild(n);\n      }\n\n      return {\n        cancel: () => {}\n      };\n    }, t.globeECEFOrigin = function (t, e) {\n      const r = [0, 0, 0];\n      return ll(r, r, Vp(Tp(e.canonical))), ll(r, r, t), r;\n    }, t.globePixelsToTileUnits = function (t, e) {\n      return Ya / (512 * Math.pow(2, t)) * Pp(Tp(e));\n    }, t.globePoleMatrixForTile = function (t, e, r) {\n      const n = jo(new Float64Array(16)),\n            i = 1 << t,\n            s = 360 * (e / i - .5),\n            a = r.point,\n            o = r.worldSize / (r.tileSize * i);\n      return qo(n, n, [a.x, a.y, -r.worldSize / Math.PI / 2]), No(n, n, [o, o, o]), Go(n, n, u(-r._center.lat)), Zo(n, n, u(-r._center.lng + s)), Float32Array.from(n);\n    }, t.globeTileLatLngCorners = Bp, t.globeToMercatorTransition = function (t) {\n      return m(5, 6, t);\n    }, t.identity = jo, t.identity$1 = ml, t.invert = function (t, e) {\n      var r = e[0],\n          n = e[1],\n          i = e[2],\n          s = e[3],\n          a = e[4],\n          o = e[5],\n          l = e[6],\n          u = e[7],\n          c = e[8],\n          h = e[9],\n          p = e[10],\n          f = e[11],\n          d = e[12],\n          y = e[13],\n          m = e[14],\n          g = e[15],\n          x = r * o - n * a,\n          v = r * l - i * a,\n          b = r * u - s * a,\n          _ = n * l - i * o,\n          w = n * u - s * o,\n          A = i * u - s * l,\n          k = c * y - h * d,\n          S = c * m - p * d,\n          I = c * g - f * d,\n          M = h * m - p * y,\n          T = h * g - f * y,\n          z = p * g - f * m,\n          B = x * z - v * T + b * M + _ * I - w * S + A * k;\n\n      return B ? (t[0] = (o * z - l * T + u * M) * (B = 1 / B), t[1] = (i * T - n * z - s * M) * B, t[2] = (y * A - m * w + g * _) * B, t[3] = (p * w - h * A - f * _) * B, t[4] = (l * I - a * z - u * S) * B, t[5] = (r * z - i * I + s * S) * B, t[6] = (m * b - d * A - g * v) * B, t[7] = (c * A - p * b + f * v) * B, t[8] = (a * T - o * I + u * k) * B, t[9] = (n * I - r * T - s * k) * B, t[10] = (d * w - y * b + g * x) * B, t[11] = (h * b - c * w - f * x) * B, t[12] = (o * S - a * M - l * k) * B, t[13] = (r * M - n * S + i * k) * B, t[14] = (y * v - d * _ - m * x) * B, t[15] = (c * _ - h * v + p * x) * B, t) : null;\n    }, t.isMapAuthenticated = function (t) {\n      return dt.has(t);\n    }, t.isMapboxURL = et, t.isSafariWithAntialiasingBug = function (t) {\n      const e = t.navigator ? t.navigator.userAgent : null;\n      return !!O(t) && e && (e.match(\"Version/15.4\") || e.match(\"Version/15.5\") || e.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/));\n    }, t.latFromMercatorY = so, t.len = fl, t.length = Ho, t.length$1 = function (t) {\n      return Math.hypot(t[0], t[1], t[2], t[3]);\n    }, t.loadVectorTile = Lf, t.makeRequest = It, t.mercatorXfromLng = eo, t.mercatorYfromLat = ro, t.mercatorZfromAltitude = no, t.mul = Xo, t.mul$1 = pl, t.multiply = function (t, e, r) {\n      var n = e[0],\n          i = e[1],\n          s = e[2],\n          a = e[3],\n          o = e[4],\n          l = e[5],\n          u = e[6],\n          c = e[7],\n          h = e[8],\n          p = r[0],\n          f = r[1],\n          d = r[2],\n          y = r[3],\n          m = r[4],\n          g = r[5],\n          x = r[6],\n          v = r[7],\n          b = r[8];\n      return t[0] = p * n + f * a + d * u, t[1] = p * i + f * o + d * c, t[2] = p * s + f * l + d * h, t[3] = y * n + m * a + g * u, t[4] = y * i + m * o + g * c, t[5] = y * s + m * l + g * h, t[6] = x * n + v * a + b * u, t[7] = x * i + v * o + b * c, t[8] = x * s + v * l + b * h, t;\n    }, t.multiply$1 = Oo, t.multiply$2 = tl, t.nextPowerOfTwo = k, t.normalize = sl, t.normalize$1 = function (t, e) {\n      var r = e[0],\n          n = e[1],\n          i = e[2],\n          s = e[3],\n          a = r * r + n * n + i * i + s * s;\n      return a > 0 && (a = 1 / Math.sqrt(a)), t[0] = r * a, t[1] = n * a, t[2] = i * a, t[3] = s * a, t;\n    }, t.number = rr, t.ortho = function (t, e, r, n, i, s, a) {\n      var o = 1 / (e - r),\n          l = 1 / (n - i),\n          u = 1 / (s - a);\n      return t[0] = -2 * o, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * l, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 2 * u, t[11] = 0, t[12] = (e + r) * o, t[13] = (i + n) * l, t[14] = (a + s) * u, t[15] = 1, t;\n    }, t.pbf = wc, t.perspective = function (t, e, r, n, i) {\n      var s,\n          a = 1 / Math.tan(e / 2);\n      return t[0] = a / r, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = a, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, null != i && i !== 1 / 0 ? (t[10] = (i + n) * (s = 1 / (n - i)), t[14] = 2 * i * n * s) : (t[10] = -1, t[14] = -2 * n), t;\n    }, t.pick = function (t, e) {\n      const r = {};\n\n      for (let n = 0; n < e.length; n++) {\n        const i = e[n];\n        i in t && (r[i] = t[i]);\n      }\n\n      return r;\n    }, t.plugin = is, t.pointGeometry = i, t.polygonIntersectsBox = Bo, t.polygonIntersectsPolygon = bo, t.polygonizeBounds = function (t, e, r = 0, n = !0) {\n      const s = new i(r, r),\n            a = t.sub(s),\n            o = e.add(s),\n            l = [a, new i(o.x, a.y), o, new i(a.x, o.y)];\n      return n && l.push(a), l;\n    }, t.posAttributes = _p, t.postMapLoadEvent = ht, t.postTurnstileEvent = ut, t.potpack = Gc, t.prevPowerOfTwo = function (t) {\n      return t <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(t) / Math.LN2));\n    }, t.radToDeg = c, t.refProperties = [\"type\", \"source\", \"source-layer\", \"minzoom\", \"maxzoom\", \"filter\", \"layout\"], t.registerForPluginStateChange = function (t) {\n      return t({\n        pluginStatus: Wi,\n        pluginURL: Ji\n      }), es.on(\"pluginStateChange\", t), t;\n    }, t.removeAuthState = function (t) {\n      dt.delete(t);\n    }, t.renderColorRamp = Cl, t.rotateX = Go, t.rotateX$1 = gl, t.rotateY = Zo, t.rotateZ = function (t, e, r) {\n      var n = Math.sin(r),\n          i = Math.cos(r),\n          s = e[0],\n          a = e[1],\n          o = e[2],\n          l = e[3],\n          u = e[4],\n          c = e[5],\n          h = e[6],\n          p = e[7];\n      return e !== t && (t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = s * i + u * n, t[1] = a * i + c * n, t[2] = o * i + h * n, t[3] = l * i + p * n, t[4] = u * i - s * n, t[5] = c * i - a * n, t[6] = h * i - o * n, t[7] = p * i - l * n, t;\n    }, t.rotateZ$1 = function (t, e, r) {\n      r *= .5;\n      var n = e[0],\n          i = e[1],\n          s = e[2],\n          a = e[3],\n          o = Math.sin(r),\n          l = Math.cos(r);\n      return t[0] = n * l + i * o, t[1] = i * l - n * o, t[2] = s * l + a * o, t[3] = a * l - s * o, t;\n    }, t.scale = No, t.scale$1 = function (t, e, r) {\n      return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t[3] = e[3] * r, t;\n    }, t.scale$2 = nl, t.scaleAndAdd = il, t.setCacheLimits = function (t, e) {\n      xt = t, vt = e;\n    }, t.setColumn = function (t, e, r) {\n      t[4 * e + 0] = r[0], t[4 * e + 1] = r[1], t[4 * e + 2] = r[2], t[4 * e + 3] = r[3];\n    }, t.setRTLTextPlugin = function (t, e, r = !1) {\n      if (Wi === Xi || Wi === Ki || Wi === Yi) throw new Error(\"setRTLTextPlugin cannot be called multiple times.\");\n      Ji = N.resolveURL(t), Wi = Xi, Hi = e, ts(), r || ns();\n    }, t.smoothstep = m, t.spec = $t, t.storeAuthState = function (t, e) {\n      e ? dt.add(t) : dt.delete(t);\n    }, t.sub = hl, t.subtract = Qo, t.symbolSize = yc, t.tileAABB = function (t, e, r, n, i, s, a, o, l) {\n      if (\"globe\" === l.name) return zp(t, e, new Op(r, n, i));\n      const u = Zp({\n        z: r,\n        x: n,\n        y: i\n      }, l);\n      return new vl([(s + u.x / u.scale) * e, e * (u.y / u.scale), a], [(s + u.x2 / u.scale) * e, e * (u.y2 / u.scale), o]);\n    }, t.tileTransform = Zp, t.transformMat3 = function (t, e, r) {\n      var n = e[0],\n          i = e[1],\n          s = e[2];\n      return t[0] = n * r[0] + i * r[3] + s * r[6], t[1] = n * r[1] + i * r[4] + s * r[7], t[2] = n * r[2] + i * r[5] + s * r[8], t;\n    }, t.transformMat4 = ll, t.transformMat4$1 = dl, t.transformQuat = ul, t.translate = qo, t.transpose = function (t, e) {\n      if (t === e) {\n        var r = e[1],\n            n = e[2],\n            i = e[5];\n        t[1] = e[3], t[2] = e[6], t[3] = r, t[5] = e[7], t[6] = n, t[7] = i;\n      } else t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8];\n\n      return t;\n    }, t.triggerPluginCompletionEvent = Qi, t.uniqueId = w, t.validateCustomStyleLayer = function (t) {\n      const e = [],\n            r = t.id;\n      return void 0 === r && e.push({\n        message: `layers.${r}: missing required property \"id\"`\n      }), void 0 === t.render && e.push({\n        message: `layers.${r}: missing required method \"render\"`\n      }), t.renderingMode && \"2d\" !== t.renderingMode && \"3d\" !== t.renderingMode && e.push({\n        message: `layers.${r}: property \"renderingMode\" must be either \"2d\" or \"3d\"`\n      }), e;\n    }, t.validateFilter = t => ei(Ln(t)), t.validateFog = t => ei(Kn(t)), t.validateLayer = t => ei(On(t)), t.validateLight = t => ei(Zn(t)), t.validateSource = t => ei(Gn(t)), t.validateStyle = Jn, t.validateTerrain = t => ei(Xn(t)), t.values = v, t.vectorTile = Du, t.version = e, t.warnOnce = C, t.window = a, t.wrap = g;\n  });\n  define([\"./shared\"], function (e) {\n    \"use strict\";\n\n    function t(e) {\n      if (\"number\" == typeof e || \"boolean\" == typeof e || \"string\" == typeof e || null == e) return JSON.stringify(e);\n\n      if (Array.isArray(e)) {\n        let r = \"[\";\n\n        for (const o of e) r += `${t(o)},`;\n\n        return `${r}]`;\n      }\n\n      let r = \"{\";\n\n      for (const o of Object.keys(e).sort()) r += `${o}:${t(e[o])},`;\n\n      return `${r}}`;\n    }\n\n    function r(r) {\n      let o = \"\";\n\n      for (const n of e.refProperties) o += `/${t(r[n])}`;\n\n      return o;\n    }\n\n    class o {\n      constructor(e) {\n        this.keyCache = {}, e && this.replace(e);\n      }\n\n      replace(e) {\n        this._layerConfigs = {}, this._layers = {}, this.update(e, []);\n      }\n\n      update(t, o) {\n        for (const r of t) this._layerConfigs[r.id] = r, (this._layers[r.id] = e.createStyleLayer(r)).compileFilter(), this.keyCache[r.id] && delete this.keyCache[r.id];\n\n        for (const e of o) delete this.keyCache[e], delete this._layerConfigs[e], delete this._layers[e];\n\n        this.familiesBySource = {};\n\n        const n = function (e, t) {\n          const o = {};\n\n          for (let n = 0; n < e.length; n++) {\n            const i = t && t[e[n].id] || r(e[n]);\n            t && (t[e[n].id] = i);\n            let s = o[i];\n            s || (s = o[i] = []), s.push(e[n]);\n          }\n\n          const n = [];\n\n          for (const e in o) n.push(o[e]);\n\n          return n;\n        }(e.values(this._layerConfigs), this.keyCache);\n\n        for (const e of n) {\n          const t = e.map(e => this._layers[e.id]),\n                r = t[0];\n          if (\"none\" === r.visibility) continue;\n          const o = r.source || \"\";\n          let n = this.familiesBySource[o];\n          n || (n = this.familiesBySource[o] = {});\n          const i = r.sourceLayer || \"_geojsonTileLayer\";\n          let s = n[i];\n          s || (s = n[i] = []), s.push(t);\n        }\n      }\n\n    }\n\n    class n {\n      loadTile(t, r) {\n        const {\n          uid: o,\n          encoding: n,\n          rawImageData: i,\n          padding: s,\n          buildQuadTree: a\n        } = t,\n              l = e.window.ImageBitmap && i instanceof e.window.ImageBitmap ? this.getImageData(i, s) : i;\n        r(null, new e.DEMData(o, l, n, s < 1, a));\n      }\n\n      getImageData(e, t) {\n        this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(e.width, e.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext(\"2d\")), this.offscreenCanvas.width = e.width, this.offscreenCanvas.height = e.height, this.offscreenCanvasContext.drawImage(e, 0, 0, e.width, e.height);\n        const r = this.offscreenCanvasContext.getImageData(-t, -t, e.width + 2 * t, e.height + 2 * t);\n        return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), r;\n      }\n\n    }\n\n    var i = function e(t, r) {\n      var o,\n          n = t && t.type;\n      if (\"FeatureCollection\" === n) for (o = 0; o < t.features.length; o++) e(t.features[o], r);else if (\"GeometryCollection\" === n) for (o = 0; o < t.geometries.length; o++) e(t.geometries[o], r);else if (\"Feature\" === n) e(t.geometry, r);else if (\"Polygon\" === n) s(t.coordinates, r);else if (\"MultiPolygon\" === n) for (o = 0; o < t.coordinates.length; o++) s(t.coordinates[o], r);\n      return t;\n    };\n\n    function s(e, t) {\n      if (0 !== e.length) {\n        a(e[0], t);\n\n        for (var r = 1; r < e.length; r++) a(e[r], !t);\n      }\n    }\n\n    function a(e, t) {\n      for (var r = 0, o = 0, n = 0, i = e.length, s = i - 1; n < i; s = n++) {\n        var a = (e[n][0] - e[s][0]) * (e[s][1] + e[n][1]),\n            l = r + a;\n        o += Math.abs(r) >= Math.abs(a) ? r - l + a : a - l + r, r = l;\n      }\n\n      r + o >= 0 != !!t && e.reverse();\n    }\n\n    const l = e.vectorTile.VectorTileFeature.prototype.toGeoJSON;\n\n    class u {\n      constructor(t) {\n        this._feature = t, this.extent = e.EXTENT, this.type = t.type, this.properties = t.tags, \"id\" in t && !isNaN(t.id) && (this.id = parseInt(t.id, 10));\n      }\n\n      loadGeometry() {\n        if (1 === this._feature.type) {\n          const t = [];\n\n          for (const r of this._feature.geometry) t.push([new e.pointGeometry(r[0], r[1])]);\n\n          return t;\n        }\n\n        {\n          const t = [];\n\n          for (const r of this._feature.geometry) {\n            const o = [];\n\n            for (const t of r) o.push(new e.pointGeometry(t[0], t[1]));\n\n            t.push(o);\n          }\n\n          return t;\n        }\n      }\n\n      toGeoJSON(e, t, r) {\n        return l.call(this, e, t, r);\n      }\n\n    }\n\n    class h {\n      constructor(t) {\n        this.layers = {\n          _geojsonTileLayer: this\n        }, this.name = \"_geojsonTileLayer\", this.extent = e.EXTENT, this.length = t.length, this._features = t;\n      }\n\n      feature(e) {\n        return new u(this._features[e]);\n      }\n\n    }\n\n    var c = e.vectorTile.VectorTileFeature,\n        f = p;\n\n    function p(e, t) {\n      this.options = t || {}, this.features = e, this.length = e.length;\n    }\n\n    function g(e, t) {\n      this.id = \"number\" == typeof e.id ? e.id : void 0, this.type = e.type, this.rawGeometry = 1 === e.type ? [e.geometry] : e.geometry, this.properties = e.tags, this.extent = t || 4096;\n    }\n\n    p.prototype.feature = function (e) {\n      return new g(this.features[e], this.options.extent);\n    }, g.prototype.loadGeometry = function () {\n      var t = this.rawGeometry;\n      this.geometry = [];\n\n      for (var r = 0; r < t.length; r++) {\n        for (var o = t[r], n = [], i = 0; i < o.length; i++) n.push(new e.pointGeometry(o[i][0], o[i][1]));\n\n        this.geometry.push(n);\n      }\n\n      return this.geometry;\n    }, g.prototype.bbox = function () {\n      this.geometry || this.loadGeometry();\n\n      for (var e = this.geometry, t = 1 / 0, r = -1 / 0, o = 1 / 0, n = -1 / 0, i = 0; i < e.length; i++) for (var s = e[i], a = 0; a < s.length; a++) {\n        var l = s[a];\n        t = Math.min(t, l.x), r = Math.max(r, l.x), o = Math.min(o, l.y), n = Math.max(n, l.y);\n      }\n\n      return [t, o, r, n];\n    }, g.prototype.toGeoJSON = c.prototype.toGeoJSON;\n    var d = y,\n        m = f;\n\n    function y(t) {\n      var r = new e.pbf();\n      return function (e, t) {\n        for (var r in e.layers) t.writeMessage(3, v, e.layers[r]);\n      }(t, r), r.finish();\n    }\n\n    function v(e, t) {\n      var r;\n      t.writeVarintField(15, e.version || 1), t.writeStringField(1, e.name || \"\"), t.writeVarintField(5, e.extent || 4096);\n      var o = {\n        keys: [],\n        values: [],\n        keycache: {},\n        valuecache: {}\n      };\n\n      for (r = 0; r < e.length; r++) o.feature = e.feature(r), t.writeMessage(2, x, o);\n\n      var n = o.keys;\n\n      for (r = 0; r < n.length; r++) t.writeStringField(3, n[r]);\n\n      var i = o.values;\n\n      for (r = 0; r < i.length; r++) t.writeMessage(4, b, i[r]);\n    }\n\n    function x(e, t) {\n      var r = e.feature;\n      void 0 !== r.id && t.writeVarintField(1, r.id), t.writeMessage(2, w, e), t.writeVarintField(3, r.type), t.writeMessage(4, P, r);\n    }\n\n    function w(e, t) {\n      var r = e.feature,\n          o = e.keys,\n          n = e.values,\n          i = e.keycache,\n          s = e.valuecache;\n\n      for (var a in r.properties) {\n        var l = r.properties[a],\n            u = i[a];\n\n        if (null !== l) {\n          void 0 === u && (o.push(a), i[a] = u = o.length - 1), t.writeVarint(u);\n          var h = typeof l;\n          \"string\" !== h && \"boolean\" !== h && \"number\" !== h && (l = JSON.stringify(l));\n          var c = h + \":\" + l,\n              f = s[c];\n          void 0 === f && (n.push(l), s[c] = f = n.length - 1), t.writeVarint(f);\n        }\n      }\n    }\n\n    function S(e, t) {\n      return (t << 3) + (7 & e);\n    }\n\n    function M(e) {\n      return e << 1 ^ e >> 31;\n    }\n\n    function P(e, t) {\n      for (var r = e.loadGeometry(), o = e.type, n = 0, i = 0, s = r.length, a = 0; a < s; a++) {\n        var l = r[a],\n            u = 1;\n        1 === o && (u = l.length), t.writeVarint(S(1, u));\n\n        for (var h = 3 === o ? l.length - 1 : l.length, c = 0; c < h; c++) {\n          1 === c && 1 !== o && t.writeVarint(S(2, h - 1));\n          var f = l[c].x - n,\n              p = l[c].y - i;\n          t.writeVarint(M(f)), t.writeVarint(M(p)), n += f, i += p;\n        }\n\n        3 === o && t.writeVarint(S(7, 1));\n      }\n    }\n\n    function b(e, t) {\n      var r = typeof e;\n      \"string\" === r ? t.writeStringField(1, e) : \"boolean\" === r ? t.writeBooleanField(7, e) : \"number\" === r && (e % 1 != 0 ? t.writeDoubleField(3, e) : e < 0 ? t.writeSVarintField(6, e) : t.writeVarintField(5, e));\n    }\n\n    function T(e, t, r, o, n, i) {\n      if (n - o <= r) return;\n      const s = o + n >> 1;\n      k(e, t, s, o, n, i % 2), T(e, t, r, o, s - 1, i + 1), T(e, t, r, s + 1, n, i + 1);\n    }\n\n    function k(e, t, r, o, n, i) {\n      for (; n > o;) {\n        if (n - o > 600) {\n          const s = n - o + 1,\n                a = r - o + 1,\n                l = Math.log(s),\n                u = .5 * Math.exp(2 * l / 3),\n                h = .5 * Math.sqrt(l * u * (s - u) / s) * (a - s / 2 < 0 ? -1 : 1);\n          k(e, t, r, Math.max(o, Math.floor(r - a * u / s + h)), Math.min(n, Math.floor(r + (s - a) * u / s + h)), i);\n        }\n\n        const s = t[2 * r + i];\n        let a = o,\n            l = n;\n\n        for (I(e, t, o, r), t[2 * n + i] > s && I(e, t, o, n); a < l;) {\n          for (I(e, t, a, l), a++, l--; t[2 * a + i] < s;) a++;\n\n          for (; t[2 * l + i] > s;) l--;\n        }\n\n        t[2 * o + i] === s ? I(e, t, o, l) : (l++, I(e, t, l, n)), l <= r && (o = l + 1), r <= l && (n = l - 1);\n      }\n    }\n\n    function I(e, t, r, o) {\n      _(e, r, o), _(t, 2 * r, 2 * o), _(t, 2 * r + 1, 2 * o + 1);\n    }\n\n    function _(e, t, r) {\n      const o = e[t];\n      e[t] = e[r], e[r] = o;\n    }\n\n    function L(e, t, r, o) {\n      const n = e - r,\n            i = t - o;\n      return n * n + i * i;\n    }\n\n    d.fromVectorTileJs = y, d.fromGeojsonVt = function (e, t) {\n      t = t || {};\n      var r = {};\n\n      for (var o in e) r[o] = new f(e[o].features, t), r[o].name = o, r[o].version = t.version, r[o].extent = t.extent;\n\n      return y({\n        layers: r\n      });\n    }, d.GeoJSONWrapper = m;\n\n    const C = e => e[0],\n          O = e => e[1];\n\n    class z {\n      constructor(e, t = C, r = O, o = 64, n = Float64Array) {\n        this.nodeSize = o, this.points = e;\n        const i = e.length < 65536 ? Uint16Array : Uint32Array,\n              s = this.ids = new i(e.length),\n              a = this.coords = new n(2 * e.length);\n\n        for (let o = 0; o < e.length; o++) s[o] = o, a[2 * o] = t(e[o]), a[2 * o + 1] = r(e[o]);\n\n        T(s, a, o, 0, s.length - 1, 0);\n      }\n\n      range(e, t, r, o) {\n        return function (e, t, r, o, n, i, s) {\n          const a = [0, e.length - 1, 0],\n                l = [];\n          let u, h;\n\n          for (; a.length;) {\n            const c = a.pop(),\n                  f = a.pop(),\n                  p = a.pop();\n\n            if (f - p <= s) {\n              for (let s = p; s <= f; s++) u = t[2 * s], h = t[2 * s + 1], u >= r && u <= n && h >= o && h <= i && l.push(e[s]);\n\n              continue;\n            }\n\n            const g = Math.floor((p + f) / 2);\n            u = t[2 * g], h = t[2 * g + 1], u >= r && u <= n && h >= o && h <= i && l.push(e[g]);\n            const d = (c + 1) % 2;\n            (0 === c ? r <= u : o <= h) && (a.push(p), a.push(g - 1), a.push(d)), (0 === c ? n >= u : i >= h) && (a.push(g + 1), a.push(f), a.push(d));\n          }\n\n          return l;\n        }(this.ids, this.coords, e, t, r, o, this.nodeSize);\n      }\n\n      within(e, t, r) {\n        return function (e, t, r, o, n, i) {\n          const s = [0, e.length - 1, 0],\n                a = [],\n                l = n * n;\n\n          for (; s.length;) {\n            const u = s.pop(),\n                  h = s.pop(),\n                  c = s.pop();\n\n            if (h - c <= i) {\n              for (let n = c; n <= h; n++) L(t[2 * n], t[2 * n + 1], r, o) <= l && a.push(e[n]);\n\n              continue;\n            }\n\n            const f = Math.floor((c + h) / 2),\n                  p = t[2 * f],\n                  g = t[2 * f + 1];\n            L(p, g, r, o) <= l && a.push(e[f]);\n            const d = (u + 1) % 2;\n            (0 === u ? r - n <= p : o - n <= g) && (s.push(c), s.push(f - 1), s.push(d)), (0 === u ? r + n >= p : o + n >= g) && (s.push(f + 1), s.push(h), s.push(d));\n          }\n\n          return a;\n        }(this.ids, this.coords, e, t, r, this.nodeSize);\n      }\n\n    }\n\n    const E = {\n      minZoom: 0,\n      maxZoom: 16,\n      minPoints: 2,\n      radius: 40,\n      extent: 512,\n      nodeSize: 64,\n      log: !1,\n      generateId: !1,\n      reduce: null,\n      map: e => e\n    },\n          F = Math.fround || (N = new Float32Array(1), e => (N[0] = +e, N[0]));\n    var N;\n\n    class j {\n      constructor(e) {\n        this.options = A(Object.create(E), e), this.trees = new Array(this.options.maxZoom + 1);\n      }\n\n      load(e) {\n        const {\n          log: t,\n          minZoom: r,\n          maxZoom: o,\n          nodeSize: n\n        } = this.options;\n        t && console.time(\"total time\");\n        const i = `prepare ${e.length} points`;\n        t && console.time(i), this.points = e;\n        let s = [];\n\n        for (let t = 0; t < e.length; t++) e[t].geometry && s.push(G(e[t], t));\n\n        this.trees[o + 1] = new z(s, D, $, n, Float32Array), t && console.timeEnd(i);\n\n        for (let e = o; e >= r; e--) {\n          const r = +Date.now();\n          s = this._cluster(s, e), this.trees[e] = new z(s, D, $, n, Float32Array), t && console.log(\"z%d: %d clusters in %dms\", e, s.length, +Date.now() - r);\n        }\n\n        return t && console.timeEnd(\"total time\"), this;\n      }\n\n      getClusters(e, t) {\n        let r = ((e[0] + 180) % 360 + 360) % 360 - 180;\n        const o = Math.max(-90, Math.min(90, e[1]));\n        let n = 180 === e[2] ? 180 : ((e[2] + 180) % 360 + 360) % 360 - 180;\n        const i = Math.max(-90, Math.min(90, e[3]));\n        if (e[2] - e[0] >= 360) r = -180, n = 180;else if (r > n) {\n          const e = this.getClusters([r, o, 180, i], t),\n                s = this.getClusters([-180, o, n, i], t);\n          return e.concat(s);\n        }\n\n        const s = this.trees[this._limitZoom(t)],\n              a = s.range(Y(r), X(i), Y(n), X(o)),\n              l = [];\n\n        for (const e of a) {\n          const t = s.points[e];\n          l.push(t.numPoints ? J(t) : this.points[t.index]);\n        }\n\n        return l;\n      }\n\n      getChildren(e) {\n        const t = this._getOriginId(e),\n              r = this._getOriginZoom(e),\n              o = \"No cluster with the specified id.\",\n              n = this.trees[r];\n\n        if (!n) throw new Error(o);\n        const i = n.points[t];\n        if (!i) throw new Error(o);\n        const s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)),\n              a = n.within(i.x, i.y, s),\n              l = [];\n\n        for (const t of a) {\n          const r = n.points[t];\n          r.parentId === e && l.push(r.numPoints ? J(r) : this.points[r.index]);\n        }\n\n        if (0 === l.length) throw new Error(o);\n        return l;\n      }\n\n      getLeaves(e, t, r) {\n        const o = [];\n        return this._appendLeaves(o, e, t = t || 10, r = r || 0, 0), o;\n      }\n\n      getTile(e, t, r) {\n        const o = this.trees[this._limitZoom(e)],\n              n = Math.pow(2, e),\n              {\n          extent: i,\n          radius: s\n        } = this.options,\n              a = s / i,\n              l = (r - a) / n,\n              u = (r + 1 + a) / n,\n              h = {\n          features: []\n        };\n\n        return this._addTileFeatures(o.range((t - a) / n, l, (t + 1 + a) / n, u), o.points, t, r, n, h), 0 === t && this._addTileFeatures(o.range(1 - a / n, l, 1, u), o.points, n, r, n, h), t === n - 1 && this._addTileFeatures(o.range(0, l, a / n, u), o.points, -1, r, n, h), h.features.length ? h : null;\n      }\n\n      getClusterExpansionZoom(e) {\n        let t = this._getOriginZoom(e) - 1;\n\n        for (; t <= this.options.maxZoom;) {\n          const r = this.getChildren(e);\n          if (t++, 1 !== r.length) break;\n          e = r[0].properties.cluster_id;\n        }\n\n        return t;\n      }\n\n      _appendLeaves(e, t, r, o, n) {\n        const i = this.getChildren(t);\n\n        for (const t of i) {\n          const i = t.properties;\n          if (i && i.cluster ? n + i.point_count <= o ? n += i.point_count : n = this._appendLeaves(e, i.cluster_id, r, o, n) : n < o ? n++ : e.push(t), e.length === r) break;\n        }\n\n        return n;\n      }\n\n      _addTileFeatures(e, t, r, o, n, i) {\n        for (const s of e) {\n          const e = t[s],\n                a = e.numPoints;\n          let l, u, h;\n          if (a) l = W(e), u = e.x, h = e.y;else {\n            const t = this.points[e.index];\n            l = t.properties, u = Y(t.geometry.coordinates[0]), h = X(t.geometry.coordinates[1]);\n          }\n          const c = {\n            type: 1,\n            geometry: [[Math.round(this.options.extent * (u * n - r)), Math.round(this.options.extent * (h * n - o))]],\n            tags: l\n          };\n          let f;\n          a ? f = e.id : this.options.generateId ? f = e.index : this.points[e.index].id && (f = this.points[e.index].id), void 0 !== f && (c.id = f), i.features.push(c);\n        }\n      }\n\n      _limitZoom(e) {\n        return Math.max(this.options.minZoom, Math.min(+e, this.options.maxZoom + 1));\n      }\n\n      _cluster(e, t) {\n        const r = [],\n              {\n          radius: o,\n          extent: n,\n          reduce: i,\n          minPoints: s\n        } = this.options,\n              a = o / (n * Math.pow(2, t));\n\n        for (let o = 0; o < e.length; o++) {\n          const n = e[o];\n          if (n.zoom <= t) continue;\n          n.zoom = t;\n          const l = this.trees[t + 1],\n                u = l.within(n.x, n.y, a),\n                h = n.numPoints || 1;\n          let c = h;\n\n          for (const e of u) {\n            const r = l.points[e];\n            r.zoom > t && (c += r.numPoints || 1);\n          }\n\n          if (c > h && c >= s) {\n            let e = n.x * h,\n                s = n.y * h,\n                a = i && h > 1 ? this._map(n, !0) : null;\n            const f = (o << 5) + (t + 1) + this.points.length;\n\n            for (const r of u) {\n              const o = l.points[r];\n              if (o.zoom <= t) continue;\n              o.zoom = t;\n              const u = o.numPoints || 1;\n              e += o.x * u, s += o.y * u, o.parentId = f, i && (a || (a = this._map(n, !0)), i(a, this._map(o)));\n            }\n\n            n.parentId = f, r.push(Z(e / c, s / c, f, c, a));\n          } else if (r.push(n), c > 1) for (const e of u) {\n            const o = l.points[e];\n            o.zoom <= t || (o.zoom = t, r.push(o));\n          }\n        }\n\n        return r;\n      }\n\n      _getOriginId(e) {\n        return e - this.points.length >> 5;\n      }\n\n      _getOriginZoom(e) {\n        return (e - this.points.length) % 32;\n      }\n\n      _map(e, t) {\n        if (e.numPoints) return t ? A({}, e.properties) : e.properties;\n        const r = this.points[e.index].properties,\n              o = this.options.map(r);\n        return t && o === r ? A({}, o) : o;\n      }\n\n    }\n\n    function Z(e, t, r, o, n) {\n      return {\n        x: F(e),\n        y: F(t),\n        zoom: 1 / 0,\n        id: r,\n        parentId: -1,\n        numPoints: o,\n        properties: n\n      };\n    }\n\n    function G(e, t) {\n      const [r, o] = e.geometry.coordinates;\n      return {\n        x: F(Y(r)),\n        y: F(X(o)),\n        zoom: 1 / 0,\n        index: t,\n        parentId: -1\n      };\n    }\n\n    function J(e) {\n      return {\n        type: \"Feature\",\n        id: e.id,\n        properties: W(e),\n        geometry: {\n          type: \"Point\",\n          coordinates: [(t = e.x, 360 * (t - .5)), V(e.y)]\n        }\n      };\n      var t;\n    }\n\n    function W(e) {\n      const t = e.numPoints,\n            r = t >= 1e4 ? `${Math.round(t / 1e3)}k` : t >= 1e3 ? Math.round(t / 100) / 10 + \"k\" : t;\n      return A(A({}, e.properties), {\n        cluster: !0,\n        cluster_id: e.id,\n        point_count: t,\n        point_count_abbreviated: r\n      });\n    }\n\n    function Y(e) {\n      return e / 360 + .5;\n    }\n\n    function X(e) {\n      const t = Math.sin(e * Math.PI / 180),\n            r = .5 - .25 * Math.log((1 + t) / (1 - t)) / Math.PI;\n      return r < 0 ? 0 : r > 1 ? 1 : r;\n    }\n\n    function V(e) {\n      const t = (180 - 360 * e) * Math.PI / 180;\n      return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;\n    }\n\n    function A(e, t) {\n      for (const r in t) e[r] = t[r];\n\n      return e;\n    }\n\n    function D(e) {\n      return e.x;\n    }\n\n    function $(e) {\n      return e.y;\n    }\n\n    function B(e, t, r, o) {\n      for (var n, i = o, s = r - t >> 1, a = r - t, l = e[t], u = e[t + 1], h = e[r], c = e[r + 1], f = t + 3; f < r; f += 3) {\n        var p = R(e[f], e[f + 1], l, u, h, c);\n        if (p > i) n = f, i = p;else if (p === i) {\n          var g = Math.abs(f - s);\n          g < a && (n = f, a = g);\n        }\n      }\n\n      i > o && (n - t > 3 && B(e, t, n, o), e[n + 2] = i, r - n > 3 && B(e, n, r, o));\n    }\n\n    function R(e, t, r, o, n, i) {\n      var s = n - r,\n          a = i - o;\n\n      if (0 !== s || 0 !== a) {\n        var l = ((e - r) * s + (t - o) * a) / (s * s + a * a);\n        l > 1 ? (r = n, o = i) : l > 0 && (r += s * l, o += a * l);\n      }\n\n      return (s = e - r) * s + (a = t - o) * a;\n    }\n\n    function q(e, t, r, o) {\n      var n = {\n        id: void 0 === e ? null : e,\n        type: t,\n        geometry: r,\n        tags: o,\n        minX: 1 / 0,\n        minY: 1 / 0,\n        maxX: -1 / 0,\n        maxY: -1 / 0\n      };\n      return function (e) {\n        var t = e.geometry,\n            r = e.type;\n        if (\"Point\" === r || \"MultiPoint\" === r || \"LineString\" === r) U(e, t);else if (\"Polygon\" === r || \"MultiLineString\" === r) for (var o = 0; o < t.length; o++) U(e, t[o]);else if (\"MultiPolygon\" === r) for (o = 0; o < t.length; o++) for (var n = 0; n < t[o].length; n++) U(e, t[o][n]);\n      }(n), n;\n    }\n\n    function U(e, t) {\n      for (var r = 0; r < t.length; r += 3) e.minX = Math.min(e.minX, t[r]), e.minY = Math.min(e.minY, t[r + 1]), e.maxX = Math.max(e.maxX, t[r]), e.maxY = Math.max(e.maxY, t[r + 1]);\n    }\n\n    function Q(e, t, r, o) {\n      if (t.geometry) {\n        var n = t.geometry.coordinates,\n            i = t.geometry.type,\n            s = Math.pow(r.tolerance / ((1 << r.maxZoom) * r.extent), 2),\n            a = [],\n            l = t.id;\n        if (r.promoteId ? l = t.properties[r.promoteId] : r.generateId && (l = o || 0), \"Point\" === i) H(n, a);else if (\"MultiPoint\" === i) for (var u = 0; u < n.length; u++) H(n[u], a);else if (\"LineString\" === i) K(n, a, s, !1);else if (\"MultiLineString\" === i) {\n          if (r.lineMetrics) {\n            for (u = 0; u < n.length; u++) K(n[u], a = [], s, !1), e.push(q(l, \"LineString\", a, t.properties));\n\n            return;\n          }\n\n          ee(n, a, s, !1);\n        } else if (\"Polygon\" === i) ee(n, a, s, !0);else {\n          if (\"MultiPolygon\" !== i) {\n            if (\"GeometryCollection\" === i) {\n              for (u = 0; u < t.geometry.geometries.length; u++) Q(e, {\n                id: l,\n                geometry: t.geometry.geometries[u],\n                properties: t.properties\n              }, r, o);\n\n              return;\n            }\n\n            throw new Error(\"Input data is not a valid GeoJSON object.\");\n          }\n\n          for (u = 0; u < n.length; u++) {\n            var h = [];\n            ee(n[u], h, s, !0), a.push(h);\n          }\n        }\n        e.push(q(l, i, a, t.properties));\n      }\n    }\n\n    function H(e, t) {\n      t.push(te(e[0])), t.push(re(e[1])), t.push(0);\n    }\n\n    function K(e, t, r, o) {\n      for (var n, i, s = 0, a = 0; a < e.length; a++) {\n        var l = te(e[a][0]),\n            u = re(e[a][1]);\n        t.push(l), t.push(u), t.push(0), a > 0 && (s += o ? (n * u - l * i) / 2 : Math.sqrt(Math.pow(l - n, 2) + Math.pow(u - i, 2))), n = l, i = u;\n      }\n\n      var h = t.length - 3;\n      t[2] = 1, B(t, 0, h, r), t[h + 2] = 1, t.size = Math.abs(s), t.start = 0, t.end = t.size;\n    }\n\n    function ee(e, t, r, o) {\n      for (var n = 0; n < e.length; n++) {\n        var i = [];\n        K(e[n], i, r, o), t.push(i);\n      }\n    }\n\n    function te(e) {\n      return e / 360 + .5;\n    }\n\n    function re(e) {\n      var t = Math.sin(e * Math.PI / 180),\n          r = .5 - .25 * Math.log((1 + t) / (1 - t)) / Math.PI;\n      return r < 0 ? 0 : r > 1 ? 1 : r;\n    }\n\n    function oe(e, t, r, o, n, i, s, a) {\n      if (o /= t, i >= (r /= t) && s < o) return e;\n      if (s < r || i >= o) return null;\n\n      for (var l = [], u = 0; u < e.length; u++) {\n        var h = e[u],\n            c = h.geometry,\n            f = h.type,\n            p = 0 === n ? h.minX : h.minY,\n            g = 0 === n ? h.maxX : h.maxY;\n        if (p >= r && g < o) l.push(h);else if (!(g < r || p >= o)) {\n          var d = [];\n          if (\"Point\" === f || \"MultiPoint\" === f) ne(c, d, r, o, n);else if (\"LineString\" === f) ie(c, d, r, o, n, !1, a.lineMetrics);else if (\"MultiLineString\" === f) ae(c, d, r, o, n, !1);else if (\"Polygon\" === f) ae(c, d, r, o, n, !0);else if (\"MultiPolygon\" === f) for (var m = 0; m < c.length; m++) {\n            var y = [];\n            ae(c[m], y, r, o, n, !0), y.length && d.push(y);\n          }\n\n          if (d.length) {\n            if (a.lineMetrics && \"LineString\" === f) {\n              for (m = 0; m < d.length; m++) l.push(q(h.id, f, d[m], h.tags));\n\n              continue;\n            }\n\n            \"LineString\" !== f && \"MultiLineString\" !== f || (1 === d.length ? (f = \"LineString\", d = d[0]) : f = \"MultiLineString\"), \"Point\" !== f && \"MultiPoint\" !== f || (f = 3 === d.length ? \"Point\" : \"MultiPoint\"), l.push(q(h.id, f, d, h.tags));\n          }\n        }\n      }\n\n      return l.length ? l : null;\n    }\n\n    function ne(e, t, r, o, n) {\n      for (var i = 0; i < e.length; i += 3) {\n        var s = e[i + n];\n        s >= r && s <= o && (t.push(e[i]), t.push(e[i + 1]), t.push(e[i + 2]));\n      }\n    }\n\n    function ie(e, t, r, o, n, i, s) {\n      for (var a, l, u = se(e), h = 0 === n ? ue : he, c = e.start, f = 0; f < e.length - 3; f += 3) {\n        var p = e[f],\n            g = e[f + 1],\n            d = e[f + 2],\n            m = e[f + 3],\n            y = e[f + 4],\n            v = 0 === n ? p : g,\n            x = 0 === n ? m : y,\n            w = !1;\n        s && (a = Math.sqrt(Math.pow(p - m, 2) + Math.pow(g - y, 2))), v < r ? x > r && (l = h(u, p, g, m, y, r), s && (u.start = c + a * l)) : v > o ? x < o && (l = h(u, p, g, m, y, o), s && (u.start = c + a * l)) : le(u, p, g, d), x < r && v >= r && (l = h(u, p, g, m, y, r), w = !0), x > o && v <= o && (l = h(u, p, g, m, y, o), w = !0), !i && w && (s && (u.end = c + a * l), t.push(u), u = se(e)), s && (c += a);\n      }\n\n      var S = e.length - 3;\n      p = e[S], g = e[S + 1], d = e[S + 2], (v = 0 === n ? p : g) >= r && v <= o && le(u, p, g, d), S = u.length - 3, i && S >= 3 && (u[S] !== u[0] || u[S + 1] !== u[1]) && le(u, u[0], u[1], u[2]), u.length && t.push(u);\n    }\n\n    function se(e) {\n      var t = [];\n      return t.size = e.size, t.start = e.start, t.end = e.end, t;\n    }\n\n    function ae(e, t, r, o, n, i) {\n      for (var s = 0; s < e.length; s++) ie(e[s], t, r, o, n, i, !1);\n    }\n\n    function le(e, t, r, o) {\n      e.push(t), e.push(r), e.push(o);\n    }\n\n    function ue(e, t, r, o, n, i) {\n      var s = (i - t) / (o - t);\n      return e.push(i), e.push(r + (n - r) * s), e.push(1), s;\n    }\n\n    function he(e, t, r, o, n, i) {\n      var s = (i - r) / (n - r);\n      return e.push(t + (o - t) * s), e.push(i), e.push(1), s;\n    }\n\n    function ce(e, t) {\n      for (var r = [], o = 0; o < e.length; o++) {\n        var n,\n            i = e[o],\n            s = i.type;\n        if (\"Point\" === s || \"MultiPoint\" === s || \"LineString\" === s) n = fe(i.geometry, t);else if (\"MultiLineString\" === s || \"Polygon\" === s) {\n          n = [];\n\n          for (var a = 0; a < i.geometry.length; a++) n.push(fe(i.geometry[a], t));\n        } else if (\"MultiPolygon\" === s) for (n = [], a = 0; a < i.geometry.length; a++) {\n          for (var l = [], u = 0; u < i.geometry[a].length; u++) l.push(fe(i.geometry[a][u], t));\n\n          n.push(l);\n        }\n        r.push(q(i.id, s, n, i.tags));\n      }\n\n      return r;\n    }\n\n    function fe(e, t) {\n      var r = [];\n      r.size = e.size, void 0 !== e.start && (r.start = e.start, r.end = e.end);\n\n      for (var o = 0; o < e.length; o += 3) r.push(e[o] + t, e[o + 1], e[o + 2]);\n\n      return r;\n    }\n\n    function pe(e, t) {\n      if (e.transformed) return e;\n      var r,\n          o,\n          n,\n          i = 1 << e.z,\n          s = e.x,\n          a = e.y;\n\n      for (r = 0; r < e.features.length; r++) {\n        var l = e.features[r],\n            u = l.geometry,\n            h = l.type;\n        if (l.geometry = [], 1 === h) for (o = 0; o < u.length; o += 2) l.geometry.push(ge(u[o], u[o + 1], t, i, s, a));else for (o = 0; o < u.length; o++) {\n          var c = [];\n\n          for (n = 0; n < u[o].length; n += 2) c.push(ge(u[o][n], u[o][n + 1], t, i, s, a));\n\n          l.geometry.push(c);\n        }\n      }\n\n      return e.transformed = !0, e;\n    }\n\n    function ge(e, t, r, o, n, i) {\n      return [Math.round(r * (e * o - n)), Math.round(r * (t * o - i))];\n    }\n\n    function de(e, t, r, o, n) {\n      for (var i = t === n.maxZoom ? 0 : n.tolerance / ((1 << t) * n.extent), s = {\n        features: [],\n        numPoints: 0,\n        numSimplified: 0,\n        numFeatures: 0,\n        source: null,\n        x: r,\n        y: o,\n        z: t,\n        transformed: !1,\n        minX: 2,\n        minY: 1,\n        maxX: -1,\n        maxY: 0\n      }, a = 0; a < e.length; a++) {\n        s.numFeatures++, me(s, e[a], i, n);\n        var l = e[a].minX,\n            u = e[a].minY,\n            h = e[a].maxX,\n            c = e[a].maxY;\n        l < s.minX && (s.minX = l), u < s.minY && (s.minY = u), h > s.maxX && (s.maxX = h), c > s.maxY && (s.maxY = c);\n      }\n\n      return s;\n    }\n\n    function me(e, t, r, o) {\n      var n = t.geometry,\n          i = t.type,\n          s = [];\n      if (\"Point\" === i || \"MultiPoint\" === i) for (var a = 0; a < n.length; a += 3) s.push(n[a]), s.push(n[a + 1]), e.numPoints++, e.numSimplified++;else if (\"LineString\" === i) ye(s, n, e, r, !1, !1);else if (\"MultiLineString\" === i || \"Polygon\" === i) for (a = 0; a < n.length; a++) ye(s, n[a], e, r, \"Polygon\" === i, 0 === a);else if (\"MultiPolygon\" === i) for (var l = 0; l < n.length; l++) {\n        var u = n[l];\n\n        for (a = 0; a < u.length; a++) ye(s, u[a], e, r, !0, 0 === a);\n      }\n\n      if (s.length) {\n        var h = t.tags || null;\n\n        if (\"LineString\" === i && o.lineMetrics) {\n          for (var c in h = {}, t.tags) h[c] = t.tags[c];\n\n          h.mapbox_clip_start = n.start / n.size, h.mapbox_clip_end = n.end / n.size;\n        }\n\n        var f = {\n          geometry: s,\n          type: \"Polygon\" === i || \"MultiPolygon\" === i ? 3 : \"LineString\" === i || \"MultiLineString\" === i ? 2 : 1,\n          tags: h\n        };\n        null !== t.id && (f.id = t.id), e.features.push(f);\n      }\n    }\n\n    function ye(e, t, r, o, n, i) {\n      var s = o * o;\n      if (o > 0 && t.size < (n ? s : o)) r.numPoints += t.length / 3;else {\n        for (var a = [], l = 0; l < t.length; l += 3) (0 === o || t[l + 2] > s) && (r.numSimplified++, a.push(t[l]), a.push(t[l + 1])), r.numPoints++;\n\n        n && function (e, t) {\n          for (var r = 0, o = 0, n = e.length, i = n - 2; o < n; i = o, o += 2) r += (e[o] - e[i]) * (e[o + 1] + e[i + 1]);\n\n          if (r > 0 === t) for (o = 0, n = e.length; o < n / 2; o += 2) {\n            var s = e[o],\n                a = e[o + 1];\n            e[o] = e[n - 2 - o], e[o + 1] = e[n - 1 - o], e[n - 2 - o] = s, e[n - 1 - o] = a;\n          }\n        }(a, i), e.push(a);\n      }\n    }\n\n    function ve(e, t) {\n      var r = (t = this.options = function (e, t) {\n        for (var r in t) e[r] = t[r];\n\n        return e;\n      }(Object.create(this.options), t)).debug;\n\n      if (r && console.time(\"preprocess data\"), t.maxZoom < 0 || t.maxZoom > 24) throw new Error(\"maxZoom should be in the 0-24 range\");\n      if (t.promoteId && t.generateId) throw new Error(\"promoteId and generateId cannot be used together.\");\n\n      var o = function (e, t) {\n        var r = [];\n        if (\"FeatureCollection\" === e.type) for (var o = 0; o < e.features.length; o++) Q(r, e.features[o], t, o);else Q(r, \"Feature\" === e.type ? e : {\n          geometry: e\n        }, t);\n        return r;\n      }(e, t);\n\n      this.tiles = {}, this.tileCoords = [], r && (console.timeEnd(\"preprocess data\"), console.log(\"index: maxZoom: %d, maxPoints: %d\", t.indexMaxZoom, t.indexMaxPoints), console.time(\"generate tiles\"), this.stats = {}, this.total = 0), (o = function (e, t) {\n        var r = t.buffer / t.extent,\n            o = e,\n            n = oe(e, 1, -1 - r, r, 0, -1, 2, t),\n            i = oe(e, 1, 1 - r, 2 + r, 0, -1, 2, t);\n        return (n || i) && (o = oe(e, 1, -r, 1 + r, 0, -1, 2, t) || [], n && (o = ce(n, 1).concat(o)), i && (o = o.concat(ce(i, -1)))), o;\n      }(o, t)).length && this.splitTile(o, 0, 0, 0), r && (o.length && console.log(\"features: %d, points: %d\", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd(\"generate tiles\"), console.log(\"tiles generated:\", this.total, JSON.stringify(this.stats)));\n    }\n\n    function xe(e, t, r) {\n      return 32 * ((1 << e) * r + t) + e;\n    }\n\n    function we(e, t) {\n      const r = e.tileID.canonical;\n      if (!this._geoJSONIndex) return t(null, null);\n\n      const o = this._geoJSONIndex.getTile(r.z, r.x, r.y);\n\n      if (!o) return t(null, null);\n      const n = new h(o.features);\n      let i = d(n);\n      0 === i.byteOffset && i.byteLength === i.buffer.byteLength || (i = new Uint8Array(i)), t(null, {\n        vectorTile: n,\n        rawData: i.buffer\n      });\n    }\n\n    ve.prototype.options = {\n      maxZoom: 14,\n      indexMaxZoom: 5,\n      indexMaxPoints: 1e5,\n      tolerance: 3,\n      extent: 4096,\n      buffer: 64,\n      lineMetrics: !1,\n      promoteId: null,\n      generateId: !1,\n      debug: 0\n    }, ve.prototype.splitTile = function (e, t, r, o, n, i, s) {\n      for (var a = [e, t, r, o], l = this.options, u = l.debug; a.length;) {\n        o = a.pop(), r = a.pop(), t = a.pop(), e = a.pop();\n        var h = 1 << t,\n            c = xe(t, r, o),\n            f = this.tiles[c];\n\n        if (!f && (u > 1 && console.time(\"creation\"), f = this.tiles[c] = de(e, t, r, o, l), this.tileCoords.push({\n          z: t,\n          x: r,\n          y: o\n        }), u)) {\n          u > 1 && (console.log(\"tile z%d-%d-%d (features: %d, points: %d, simplified: %d)\", t, r, o, f.numFeatures, f.numPoints, f.numSimplified), console.timeEnd(\"creation\"));\n          var p = \"z\" + t;\n          this.stats[p] = (this.stats[p] || 0) + 1, this.total++;\n        }\n\n        if (f.source = e, n) {\n          if (t === l.maxZoom || t === n) continue;\n          var g = 1 << n - t;\n          if (r !== Math.floor(i / g) || o !== Math.floor(s / g)) continue;\n        } else if (t === l.indexMaxZoom || f.numPoints <= l.indexMaxPoints) continue;\n\n        if (f.source = null, 0 !== e.length) {\n          u > 1 && console.time(\"clipping\");\n          var d,\n              m,\n              y,\n              v,\n              x,\n              w,\n              S = .5 * l.buffer / l.extent,\n              M = .5 - S,\n              P = .5 + S,\n              b = 1 + S;\n          d = m = y = v = null, x = oe(e, h, r - S, r + P, 0, f.minX, f.maxX, l), w = oe(e, h, r + M, r + b, 0, f.minX, f.maxX, l), e = null, x && (d = oe(x, h, o - S, o + P, 1, f.minY, f.maxY, l), m = oe(x, h, o + M, o + b, 1, f.minY, f.maxY, l), x = null), w && (y = oe(w, h, o - S, o + P, 1, f.minY, f.maxY, l), v = oe(w, h, o + M, o + b, 1, f.minY, f.maxY, l), w = null), u > 1 && console.timeEnd(\"clipping\"), a.push(d || [], t + 1, 2 * r, 2 * o), a.push(m || [], t + 1, 2 * r, 2 * o + 1), a.push(y || [], t + 1, 2 * r + 1, 2 * o), a.push(v || [], t + 1, 2 * r + 1, 2 * o + 1);\n        }\n      }\n    }, ve.prototype.getTile = function (e, t, r) {\n      var o = this.options,\n          n = o.extent,\n          i = o.debug;\n      if (e < 0 || e > 24) return null;\n      var s = 1 << e,\n          a = xe(e, t = (t % s + s) % s, r);\n      if (this.tiles[a]) return pe(this.tiles[a], n);\n      i > 1 && console.log(\"drilling down to z%d-%d-%d\", e, t, r);\n\n      for (var l, u = e, h = t, c = r; !l && u > 0;) u--, h = Math.floor(h / 2), c = Math.floor(c / 2), l = this.tiles[xe(u, h, c)];\n\n      return l && l.source ? (i > 1 && console.log(\"found parent tile z%d-%d-%d\", u, h, c), i > 1 && console.time(\"drilling down\"), this.splitTile(l.source, u, h, c, e, t, r), i > 1 && console.timeEnd(\"drilling down\"), this.tiles[a] ? pe(this.tiles[a], n) : null) : null;\n    };\n\n    class Se extends e.VectorTileWorkerSource {\n      constructor(e, t, r, o, n) {\n        super(e, t, r, o, we), n && (this.loadGeoJSON = n);\n      }\n\n      loadData(t, r) {\n        const o = t && t.request,\n              n = o && o.collectResourceTiming;\n        this.loadGeoJSON(t, (s, a) => {\n          if (s || !a) return r(s);\n          if (\"object\" != typeof a) return r(new Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`));\n          {\n            i(a, !0);\n\n            try {\n              if (t.filter) {\n                const r = e.createExpression(t.filter, {\n                  type: \"boolean\",\n                  \"property-type\": \"data-driven\",\n                  overridable: !1,\n                  transition: !1\n                });\n                if (\"error\" === r.result) throw new Error(r.value.map(e => `${e.key}: ${e.message}`).join(\", \"));\n                const o = a.features.filter(e => r.value.evaluate({\n                  zoom: 0\n                }, e));\n                a = {\n                  type: \"FeatureCollection\",\n                  features: o\n                };\n              }\n\n              this._geoJSONIndex = t.cluster ? new j(function ({\n                superclusterOptions: t,\n                clusterProperties: r\n              }) {\n                if (!r || !t) return t;\n                const o = {},\n                      n = {},\n                      i = {\n                  accumulated: null,\n                  zoom: 0\n                },\n                      s = {\n                  properties: null\n                },\n                      a = Object.keys(r);\n\n                for (const t of a) {\n                  const [i, s] = r[t],\n                        a = e.createExpression(s),\n                        l = e.createExpression(\"string\" == typeof i ? [i, [\"accumulated\"], [\"get\", t]] : i);\n                  o[t] = a.value, n[t] = l.value;\n                }\n\n                return t.map = e => {\n                  s.properties = e;\n                  const t = {};\n\n                  for (const e of a) t[e] = o[e].evaluate(i, s);\n\n                  return t;\n                }, t.reduce = (e, t) => {\n                  s.properties = t;\n\n                  for (const t of a) i.accumulated = e[t], e[t] = n[t].evaluate(i, s);\n                }, t;\n              }(t)).load(a.features) : function (e, t) {\n                return new ve(e, t);\n              }(a, t.geojsonVtOptions);\n            } catch (s) {\n              return r(s);\n            }\n\n            this.loaded = {};\n            const l = {};\n\n            if (n) {\n              const r = e.getPerformanceMeasurement(o);\n              r && (l.resourceTiming = {}, l.resourceTiming[t.source] = JSON.parse(JSON.stringify(r)));\n            }\n\n            r(null, l);\n          }\n        });\n      }\n\n      reloadTile(e, t) {\n        const r = this.loaded;\n        return r && r[e.uid] ? super.reloadTile(e, t) : this.loadTile(e, t);\n      }\n\n      loadGeoJSON(t, r) {\n        if (t.request) e.getJSON(t.request, r);else {\n          if (\"string\" != typeof t.data) return r(new Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`));\n\n          try {\n            return r(null, JSON.parse(t.data));\n          } catch (e) {\n            return r(new Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`));\n          }\n        }\n      }\n\n      getClusterExpansionZoom(e, t) {\n        try {\n          t(null, this._geoJSONIndex.getClusterExpansionZoom(e.clusterId));\n        } catch (e) {\n          t(e);\n        }\n      }\n\n      getClusterChildren(e, t) {\n        try {\n          t(null, this._geoJSONIndex.getChildren(e.clusterId));\n        } catch (e) {\n          t(e);\n        }\n      }\n\n      getClusterLeaves(e, t) {\n        try {\n          t(null, this._geoJSONIndex.getLeaves(e.clusterId, e.limit, e.offset));\n        } catch (e) {\n          t(e);\n        }\n      }\n\n    }\n\n    class Me {\n      constructor(t) {\n        this.self = t, this.actor = new e.Actor(t, this), this.layerIndexes = {}, this.availableImages = {}, this.isSpriteLoaded = {}, this.projections = {}, this.defaultProjection = e.getProjection({\n          name: \"mercator\"\n        }), this.workerSourceTypes = {\n          vector: e.VectorTileWorkerSource,\n          geojson: Se\n        }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (e, t) => {\n          if (this.workerSourceTypes[e]) throw new Error(`Worker source with name \"${e}\" already registered.`);\n          this.workerSourceTypes[e] = t;\n        }, this.self.registerRTLTextPlugin = t => {\n          if (e.plugin.isParsed()) throw new Error(\"RTL text plugin already registered.\");\n          e.plugin.applyArabicShaping = t.applyArabicShaping, e.plugin.processBidirectionalText = t.processBidirectionalText, e.plugin.processStyledBidirectionalText = t.processStyledBidirectionalText;\n        };\n      }\n\n      clearCaches(e, t, r) {\n        delete this.layerIndexes[e], delete this.availableImages[e], delete this.workerSources[e], delete this.demWorkerSources[e], r();\n      }\n\n      checkIfReady(e, t, r) {\n        r();\n      }\n\n      setReferrer(e, t) {\n        this.referrer = t;\n      }\n\n      spriteLoaded(t, r) {\n        this.isSpriteLoaded[t] = r;\n\n        for (const o in this.workerSources[t]) {\n          const n = this.workerSources[t][o];\n\n          for (const t in n) n[t] instanceof e.VectorTileWorkerSource && (n[t].isSpriteLoaded = r, n[t].fire(new e.Event(\"isSpriteLoaded\")));\n        }\n      }\n\n      setImages(e, t, r) {\n        this.availableImages[e] = t;\n\n        for (const r in this.workerSources[e]) {\n          const o = this.workerSources[e][r];\n\n          for (const e in o) o[e].availableImages = t;\n        }\n\n        r();\n      }\n\n      enableTerrain(e, t, r) {\n        this.terrain = t, r();\n      }\n\n      setProjection(t, r) {\n        this.projections[t] = e.getProjection(r);\n      }\n\n      setLayers(e, t, r) {\n        this.getLayerIndex(e).replace(t), r();\n      }\n\n      updateLayers(e, t, r) {\n        this.getLayerIndex(e).update(t.layers, t.removedIds), r();\n      }\n\n      loadTile(t, r, o) {\n        const n = this.enableTerrain ? e.extend({\n          enableTerrain: this.terrain\n        }, r) : r;\n        n.projection = this.projections[t] || this.defaultProjection, this.getWorkerSource(t, r.type, r.source).loadTile(n, o);\n      }\n\n      loadDEMTile(t, r, o) {\n        const n = this.enableTerrain ? e.extend({\n          buildQuadTree: this.terrain\n        }, r) : r;\n        this.getDEMWorkerSource(t, r.source).loadTile(n, o);\n      }\n\n      reloadTile(t, r, o) {\n        const n = this.enableTerrain ? e.extend({\n          enableTerrain: this.terrain\n        }, r) : r;\n        n.projection = this.projections[t] || this.defaultProjection, this.getWorkerSource(t, r.type, r.source).reloadTile(n, o);\n      }\n\n      abortTile(e, t, r) {\n        this.getWorkerSource(e, t.type, t.source).abortTile(t, r);\n      }\n\n      removeTile(e, t, r) {\n        this.getWorkerSource(e, t.type, t.source).removeTile(t, r);\n      }\n\n      removeSource(e, t, r) {\n        if (!this.workerSources[e] || !this.workerSources[e][t.type] || !this.workerSources[e][t.type][t.source]) return;\n        const o = this.workerSources[e][t.type][t.source];\n        delete this.workerSources[e][t.type][t.source], void 0 !== o.removeSource ? o.removeSource(t, r) : r();\n      }\n\n      loadWorkerSource(e, t, r) {\n        try {\n          this.self.importScripts(t.url), r();\n        } catch (e) {\n          r(e.toString());\n        }\n      }\n\n      syncRTLPluginState(t, r, o) {\n        try {\n          e.plugin.setState(r);\n          const t = e.plugin.getPluginURL();\n\n          if (e.plugin.isLoaded() && !e.plugin.isParsed() && null != t) {\n            this.self.importScripts(t);\n            const r = e.plugin.isParsed();\n            o(r ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${t}`), r);\n          }\n        } catch (e) {\n          o(e.toString());\n        }\n      }\n\n      getAvailableImages(e) {\n        let t = this.availableImages[e];\n        return t || (t = []), t;\n      }\n\n      getLayerIndex(e) {\n        let t = this.layerIndexes[e];\n        return t || (t = this.layerIndexes[e] = new o()), t;\n      }\n\n      getWorkerSource(e, t, r) {\n        return this.workerSources[e] || (this.workerSources[e] = {}), this.workerSources[e][t] || (this.workerSources[e][t] = {}), this.workerSources[e][t][r] || (this.workerSources[e][t][r] = new this.workerSourceTypes[t]({\n          send: (t, r, o, n, i, s) => {\n            this.actor.send(t, r, o, e, i, s);\n          },\n          scheduler: this.actor.scheduler\n        }, this.getLayerIndex(e), this.getAvailableImages(e), this.isSpriteLoaded[e])), this.workerSources[e][t][r];\n      }\n\n      getDEMWorkerSource(e, t) {\n        return this.demWorkerSources[e] || (this.demWorkerSources[e] = {}), this.demWorkerSources[e][t] || (this.demWorkerSources[e][t] = new n()), this.demWorkerSources[e][t];\n      }\n\n      enforceCacheSizeLimit(t, r) {\n        e.enforceCacheSizeLimit(r);\n      }\n\n      getWorkerPerformanceMetrics(e, t, r) {\n        r(void 0, void 0);\n      }\n\n    }\n\n    return \"undefined\" != typeof WorkerGlobalScope && \"undefined\" != typeof self && self instanceof WorkerGlobalScope && (self.worker = new Me(self)), Me;\n  });\n  define([\"./shared\"], function (e) {\n    \"use strict\";\n\n    var t = i;\n\n    function i(e) {\n      return !function (e) {\n        return \"undefined\" == typeof window || \"undefined\" == typeof document ? \"not a browser\" : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray ? Function.prototype && Function.prototype.bind ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions ? \"JSON\" in window && \"parse\" in JSON && \"stringify\" in JSON ? function () {\n          if (!(\"Worker\" in window && \"Blob\" in window && \"URL\" in window)) return !1;\n          var e,\n              t,\n              i = new Blob([\"\"], {\n            type: \"text/javascript\"\n          }),\n              o = URL.createObjectURL(i);\n\n          try {\n            t = new Worker(o), e = !0;\n          } catch (t) {\n            e = !1;\n          }\n\n          return t && t.terminate(), URL.revokeObjectURL(o), e;\n        }() ? \"Uint8ClampedArray\" in window ? ArrayBuffer.isView ? function () {\n          var e = document.createElement(\"canvas\");\n          e.width = e.height = 1;\n          var t = e.getContext(\"2d\");\n          if (!t) return !1;\n          var i = t.getImageData(0, 0, 1, 1);\n          return i && i.width === e.width;\n        }() ? (void 0 === o[t = e && e.failIfMajorPerformanceCaveat] && (o[t] = function (e) {\n          var t,\n              o = function (e) {\n            var t = document.createElement(\"canvas\"),\n                o = Object.create(i.webGLContextAttributes);\n            return o.failIfMajorPerformanceCaveat = e, t.getContext(\"webgl\", o) || t.getContext(\"experimental-webgl\", o);\n          }(e);\n\n          if (!o) return !1;\n\n          try {\n            t = o.createShader(o.VERTEX_SHADER);\n          } catch (e) {\n            return !1;\n          }\n\n          return !(!t || o.isContextLost()) && (o.shaderSource(t, \"void main() {}\"), o.compileShader(t), !0 === o.getShaderParameter(t, o.COMPILE_STATUS));\n        }(t)), o[t] ? document.documentMode ? \"insufficient ECMAScript 6 support\" : void 0 : \"insufficient WebGL support\") : \"insufficient Canvas/getImageData support\" : \"insufficient ArrayBuffer support\" : \"insufficient Uint8ClampedArray support\" : \"insufficient worker support\" : \"insufficient JSON support\" : \"insufficient Object support\" : \"insufficient Function support\" : \"insufficent Array support\";\n        var t;\n      }(e);\n    }\n\n    var o = {};\n\n    function r(e, t) {\n      if (Array.isArray(e)) {\n        if (!Array.isArray(t) || e.length !== t.length) return !1;\n\n        for (let i = 0; i < e.length; i++) if (!r(e[i], t[i])) return !1;\n\n        return !0;\n      }\n\n      if (\"object\" == typeof e && null !== e && null !== t) {\n        if (\"object\" != typeof t) return !1;\n        if (Object.keys(e).length !== Object.keys(t).length) return !1;\n\n        for (const i in e) if (!r(e[i], t[i])) return !1;\n\n        return !0;\n      }\n\n      return e === t;\n    }\n\n    function n(t, i, o) {\n      const r = e.window.document.createElement(t);\n      return void 0 !== i && (r.className = i), o && o.appendChild(r), r;\n    }\n\n    function a(t, i, o) {\n      const r = e.window.document.createElementNS(\"http://www.w3.org/2000/svg\", t);\n\n      for (const e of Object.keys(i)) r.setAttributeNS(null, e, i[e]);\n\n      return o && o.appendChild(r), r;\n    }\n\n    i.webGLContextAttributes = {\n      antialias: !1,\n      alpha: !0,\n      stencil: !0,\n      depth: !0\n    };\n    const s = e.window.document && e.window.document.documentElement.style,\n          l = s && void 0 !== s.userSelect ? \"userSelect\" : \"WebkitUserSelect\";\n    let c;\n\n    function h() {\n      s && l && (c = s[l], s[l] = \"none\");\n    }\n\n    function _() {\n      s && l && (s[l] = c);\n    }\n\n    function u(t) {\n      t.preventDefault(), t.stopPropagation(), e.window.removeEventListener(\"click\", u, !0);\n    }\n\n    function d() {\n      e.window.addEventListener(\"click\", u, !0), e.window.setTimeout(() => {\n        e.window.removeEventListener(\"click\", u, !0);\n      }, 0);\n    }\n\n    function p(e, t) {\n      const i = e.getBoundingClientRect();\n      return g(e, i, t);\n    }\n\n    function m(e, t) {\n      const i = e.getBoundingClientRect(),\n            o = [];\n\n      for (let r = 0; r < t.length; r++) o.push(g(e, i, t[r]));\n\n      return o;\n    }\n\n    function f(t) {\n      return void 0 !== e.window.InstallTrigger && 2 === t.button && t.ctrlKey && e.window.navigator.platform.toUpperCase().indexOf(\"MAC\") >= 0 ? 0 : t.button;\n    }\n\n    function g(t, i, o) {\n      const r = t.offsetWidth === i.width ? 1 : t.offsetWidth / i.width;\n      return new e.pointGeometry((o.clientX - i.left) * r, (o.clientY - i.top) * r);\n    }\n\n    function v(e, t) {\n      var i = t[0],\n          o = t[1],\n          r = t[2],\n          n = t[3],\n          a = i * n - r * o;\n      return a ? (e[0] = n * (a = 1 / a), e[1] = -o * a, e[2] = -r * a, e[3] = i * a, e) : null;\n    }\n\n    function x(e) {\n      const {\n        userImage: t\n      } = e;\n      return !!(t && t.render && t.render()) && (e.data.replace(new Uint8Array(t.data.buffer)), !0);\n    }\n\n    class y extends e.Evented {\n      constructor() {\n        super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new e.RGBAImage({\n          width: 1,\n          height: 1\n        }), this.dirty = !0;\n      }\n\n      isLoaded() {\n        return this.loaded;\n      }\n\n      setLoaded(e) {\n        if (this.loaded !== e && (this.loaded = e, e)) {\n          for (const {\n            ids: e,\n            callback: t\n          } of this.requestors) this._notify(e, t);\n\n          this.requestors = [];\n        }\n      }\n\n      hasImage(e) {\n        return !!this.getImage(e);\n      }\n\n      getImage(e) {\n        return this.images[e];\n      }\n\n      addImage(e, t) {\n        this._validate(e, t) && (this.images[e] = t);\n      }\n\n      _validate(t, i) {\n        let o = !0;\n        return this._validateStretch(i.stretchX, i.data && i.data.width) || (this.fire(new e.ErrorEvent(new Error(`Image \"${t}\" has invalid \"stretchX\" value`))), o = !1), this._validateStretch(i.stretchY, i.data && i.data.height) || (this.fire(new e.ErrorEvent(new Error(`Image \"${t}\" has invalid \"stretchY\" value`))), o = !1), this._validateContent(i.content, i) || (this.fire(new e.ErrorEvent(new Error(`Image \"${t}\" has invalid \"content\" value`))), o = !1), o;\n      }\n\n      _validateStretch(e, t) {\n        if (!e) return !0;\n        let i = 0;\n\n        for (const o of e) {\n          if (o[0] < i || o[1] < o[0] || t < o[1]) return !1;\n          i = o[1];\n        }\n\n        return !0;\n      }\n\n      _validateContent(e, t) {\n        return !(e && (4 !== e.length || e[0] < 0 || t.data.width < e[0] || e[1] < 0 || t.data.height < e[1] || e[2] < 0 || t.data.width < e[2] || e[3] < 0 || t.data.height < e[3] || e[2] < e[0] || e[3] < e[1]));\n      }\n\n      updateImage(e, t) {\n        t.version = this.images[e].version + 1, this.images[e] = t, this.updatedImages[e] = !0;\n      }\n\n      removeImage(e) {\n        const t = this.images[e];\n        delete this.images[e], delete this.patterns[e], t.userImage && t.userImage.onRemove && t.userImage.onRemove();\n      }\n\n      listImages() {\n        return Object.keys(this.images);\n      }\n\n      getImages(e, t) {\n        let i = !0;\n        if (!this.isLoaded()) for (const t of e) this.images[t] || (i = !1);\n        this.isLoaded() || i ? this._notify(e, t) : this.requestors.push({\n          ids: e,\n          callback: t\n        });\n      }\n\n      _notify(t, i) {\n        const o = {};\n\n        for (const i of t) {\n          this.images[i] || this.fire(new e.Event(\"styleimagemissing\", {\n            id: i\n          }));\n          const t = this.images[i];\n          t ? o[i] = {\n            data: t.data.clone(),\n            pixelRatio: t.pixelRatio,\n            sdf: t.sdf,\n            version: t.version,\n            stretchX: t.stretchX,\n            stretchY: t.stretchY,\n            content: t.content,\n            hasRenderCallback: Boolean(t.userImage && t.userImage.render)\n          } : e.warnOnce(`Image \"${i}\" could not be loaded. Please make sure you have added the image with map.addImage() or a \"sprite\" property in your style. You can provide missing images by listening for the \"styleimagemissing\" map event.`);\n        }\n\n        i(null, o);\n      }\n\n      getPixelSize() {\n        const {\n          width: e,\n          height: t\n        } = this.atlasImage;\n        return {\n          width: e,\n          height: t\n        };\n      }\n\n      getPattern(t) {\n        const i = this.patterns[t],\n              o = this.getImage(t);\n        if (!o) return null;\n        if (i && i.position.version === o.version) return i.position;\n        if (i) i.position.version = o.version;else {\n          const i = {\n            w: o.data.width + 2,\n            h: o.data.height + 2,\n            x: 0,\n            y: 0\n          },\n                r = new e.ImagePosition(i, o);\n          this.patterns[t] = {\n            bin: i,\n            position: r\n          };\n        }\n        return this._updatePatternAtlas(), this.patterns[t].position;\n      }\n\n      bind(t) {\n        const i = t.gl;\n        this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new e.Texture(t, this.atlasImage, i.RGBA), this.atlasTexture.bind(i.LINEAR, i.CLAMP_TO_EDGE);\n      }\n\n      _updatePatternAtlas() {\n        const t = [];\n\n        for (const e in this.patterns) t.push(this.patterns[e].bin);\n\n        const {\n          w: i,\n          h: o\n        } = e.potpack(t),\n              r = this.atlasImage;\n        r.resize({\n          width: i || 1,\n          height: o || 1\n        });\n\n        for (const t in this.patterns) {\n          const {\n            bin: i\n          } = this.patterns[t],\n                o = i.x + 1,\n                n = i.y + 1,\n                a = this.images[t].data,\n                s = a.width,\n                l = a.height;\n          e.RGBAImage.copy(a, r, {\n            x: 0,\n            y: 0\n          }, {\n            x: o,\n            y: n\n          }, {\n            width: s,\n            height: l\n          }), e.RGBAImage.copy(a, r, {\n            x: 0,\n            y: l - 1\n          }, {\n            x: o,\n            y: n - 1\n          }, {\n            width: s,\n            height: 1\n          }), e.RGBAImage.copy(a, r, {\n            x: 0,\n            y: 0\n          }, {\n            x: o,\n            y: n + l\n          }, {\n            width: s,\n            height: 1\n          }), e.RGBAImage.copy(a, r, {\n            x: s - 1,\n            y: 0\n          }, {\n            x: o - 1,\n            y: n\n          }, {\n            width: 1,\n            height: l\n          }), e.RGBAImage.copy(a, r, {\n            x: 0,\n            y: 0\n          }, {\n            x: o + s,\n            y: n\n          }, {\n            width: 1,\n            height: l\n          });\n        }\n\n        this.dirty = !0;\n      }\n\n      beginFrame() {\n        this.callbackDispatchedThisFrame = {};\n      }\n\n      dispatchRenderCallbacks(e) {\n        for (const t of e) {\n          if (this.callbackDispatchedThisFrame[t]) continue;\n          this.callbackDispatchedThisFrame[t] = !0;\n          const e = this.images[t];\n          x(e) && this.updateImage(t, e);\n        }\n      }\n\n    }\n\n    const b = new e.Properties({\n      anchor: new e.DataConstantProperty(e.spec.light.anchor),\n      position: new class {\n        constructor() {\n          this.specification = e.spec.light.position;\n        }\n\n        possiblyEvaluate(t, i) {\n          return function ([t, i, o]) {\n            const r = e.degToRad(i + 90),\n                  n = e.degToRad(o);\n            return {\n              x: t * Math.cos(r) * Math.sin(n),\n              y: t * Math.sin(r) * Math.sin(n),\n              z: t * Math.cos(n),\n              azimuthal: i,\n              polar: o\n            };\n          }(t.expression.evaluate(i));\n        }\n\n        interpolate(t, i, o) {\n          return {\n            x: e.number(t.x, i.x, o),\n            y: e.number(t.y, i.y, o),\n            z: e.number(t.z, i.z, o),\n            azimuthal: e.number(t.azimuthal, i.azimuthal, o),\n            polar: e.number(t.polar, i.polar, o)\n          };\n        }\n\n      }(),\n      color: new e.DataConstantProperty(e.spec.light.color),\n      intensity: new e.DataConstantProperty(e.spec.light.intensity)\n    }),\n          w = \"-transition\";\n\n    class T extends e.Evented {\n      constructor(t) {\n        super(), this._transitionable = new e.Transitionable(b), this.setLight(t), this._transitioning = this._transitionable.untransitioned();\n      }\n\n      getLight() {\n        return this._transitionable.serialize();\n      }\n\n      setLight(t, i = {}) {\n        if (!this._validate(e.validateLight, t, i)) for (const i in t) {\n          const o = t[i];\n          e.endsWith(i, w) ? this._transitionable.setTransition(i.slice(0, -w.length), o) : this._transitionable.setValue(i, o);\n        }\n      }\n\n      updateTransitions(e) {\n        this._transitioning = this._transitionable.transitioned(e, this._transitioning);\n      }\n\n      hasTransition() {\n        return this._transitioning.hasTransition();\n      }\n\n      recalculate(e) {\n        this.properties = this._transitioning.possiblyEvaluate(e);\n      }\n\n      _validate(t, i, o) {\n        return (!o || !1 !== o.validate) && e.emitValidationErrors(this, t.call(e.validateStyle, e.extend({\n          value: i,\n          style: {\n            glyphs: !0,\n            sprite: !0\n          },\n          styleSpec: e.spec\n        })));\n      }\n\n    }\n\n    const E = new e.Properties({\n      source: new e.DataConstantProperty(e.spec.terrain.source),\n      exaggeration: new e.DataConstantProperty(e.spec.terrain.exaggeration)\n    }),\n          C = \"-transition\";\n\n    class I extends e.Evented {\n      constructor(t, i) {\n        super(), this._transitionable = new e.Transitionable(E), this.set(t), this._transitioning = this._transitionable.untransitioned(), this.drapeRenderMode = i;\n      }\n\n      get() {\n        return this._transitionable.serialize();\n      }\n\n      set(t) {\n        for (const i in t) {\n          const o = t[i];\n          e.endsWith(i, C) ? this._transitionable.setTransition(i.slice(0, -C.length), o) : this._transitionable.setValue(i, o);\n        }\n      }\n\n      updateTransitions(e) {\n        this._transitioning = this._transitionable.transitioned(e, this._transitioning);\n      }\n\n      hasTransition() {\n        return this._transitioning.hasTransition();\n      }\n\n      recalculate(e) {\n        this.properties = this._transitioning.possiblyEvaluate(e);\n      }\n\n    }\n\n    function M(t, i, o, r) {\n      const n = e.smoothstep(45, 65, o),\n            [a, s] = S(t, r),\n            l = e.length(i);\n      let c = 1 - Math.min(1, Math.exp((l - a) / (s - a) * -6));\n      return c *= c * c, c = Math.min(1, 1.00747 * c), c * n * t.alpha;\n    }\n\n    function S(e, t) {\n      const i = .5 / Math.tan(.5 * t);\n      return [e.range[0] + i, e.range[1] + i];\n    }\n\n    const z = new e.Properties({\n      range: new e.DataConstantProperty(e.spec.fog.range),\n      color: new e.DataConstantProperty(e.spec.fog.color),\n      \"horizon-blend\": new e.DataConstantProperty(e.spec.fog[\"horizon-blend\"])\n    }),\n          D = \"-transition\";\n\n    class P extends e.Evented {\n      constructor(t, i) {\n        super(), this._transitionable = new e.Transitionable(z), this.set(t), this._transitioning = this._transitionable.untransitioned(), this._transform = i;\n      }\n\n      get state() {\n        return {\n          range: this.properties.get(\"range\"),\n          horizonBlend: this.properties.get(\"horizon-blend\"),\n          alpha: this.properties.get(\"color\").a\n        };\n      }\n\n      get() {\n        return this._transitionable.serialize();\n      }\n\n      set(t, i = {}) {\n        if (!this._validate(e.validateFog, t, i)) for (const i in t) {\n          const o = t[i];\n          e.endsWith(i, D) ? this._transitionable.setTransition(i.slice(0, -D.length), o) : this._transitionable.setValue(i, o);\n        }\n      }\n\n      getOpacity(t) {\n        if (!this._transform.projection.supportsFog) return 0;\n        const i = this.properties && this.properties.get(\"color\") || 1;\n        return e.smoothstep(45, 65, t) * i.a;\n      }\n\n      getOpacityAtLatLng(t, i) {\n        return this._transform.projection.supportsFog ? function (t, i, o) {\n          const r = e.MercatorCoordinate.fromLngLat(i),\n                n = o.elevation ? o.elevation.getAtPointOrZero(r) : 0,\n                a = [r.x, r.y, n];\n          return e.transformMat4(a, a, o.mercatorFogMatrix), M(t, a, o.pitch, o._fov);\n        }(this.state, t, i) : 0;\n      }\n\n      getFovAdjustedRange(e) {\n        return this._transform.projection.supportsFog ? S(this.state, e) : [0, 1];\n      }\n\n      updateTransitions(e) {\n        this._transitioning = this._transitionable.transitioned(e, this._transitioning);\n      }\n\n      hasTransition() {\n        return this._transitioning.hasTransition();\n      }\n\n      recalculate(e) {\n        this.properties = this._transitioning.possiblyEvaluate(e);\n      }\n\n      _validate(t, i, o) {\n        return (!o || !1 !== o.validate) && e.emitValidationErrors(this, t.call(e.validateStyle, e.extend({\n          value: i,\n          style: {\n            glyphs: !0,\n            sprite: !0\n          },\n          styleSpec: e.spec\n        })));\n      }\n\n    }\n\n    class A {\n      constructor(t, i) {\n        this.workerPool = t, this.actors = [], this.currentActor = 0, this.id = e.uniqueId();\n        const o = this.workerPool.acquire(this.id);\n\n        for (let e = 0; e < o.length; e++) {\n          const t = new A.Actor(o[e], i, this.id);\n          t.name = `Worker ${e}`, this.actors.push(t);\n        }\n\n        this.ready = !1, this.broadcast(\"checkIfReady\", null, () => {\n          this.ready = !0;\n        });\n      }\n\n      broadcast(t, i, o) {\n        e.asyncAll(this.actors, (e, o) => {\n          e.send(t, i, o);\n        }, o = o || function () {});\n      }\n\n      getActor() {\n        return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];\n      }\n\n      remove() {\n        this.actors.forEach(e => {\n          e.remove();\n        }), this.actors = [], this.workerPool.release(this.id);\n      }\n\n    }\n\n    function L(t, i, o) {\n      return i * (e.EXTENT / (t.tileSize * Math.pow(2, o - t.tileID.overscaledZ)));\n    }\n\n    A.Actor = e.Actor;\n\n    class R {\n      constructor(e, t, i, o) {\n        this.screenBounds = e, this.cameraPoint = t, this._screenRaycastCache = {}, this._cameraRaycastCache = {}, this.isAboveHorizon = i, this.screenGeometry = this.bufferedScreenGeometry(0), this.screenGeometryMercator = this.screenGeometry.map(e => o.pointCoordinate3D(e)), this.cameraGeometry = this.bufferedCameraGeometry(0);\n      }\n\n      static createFromScreenPoints(t, i) {\n        let o, r;\n\n        if (t instanceof e.pointGeometry || \"number\" == typeof t[0]) {\n          const n = e.pointGeometry.convert(t);\n          o = [e.pointGeometry.convert(t)], r = i.isPointAboveHorizon(n);\n        } else {\n          const n = e.pointGeometry.convert(t[0]),\n                a = e.pointGeometry.convert(t[1]);\n          o = [n, a], r = e.polygonizeBounds(n, a).every(e => i.isPointAboveHorizon(e));\n        }\n\n        return new R(o, i.getCameraPoint(), r, i);\n      }\n\n      isPointQuery() {\n        return 1 === this.screenBounds.length;\n      }\n\n      bufferedScreenGeometry(t) {\n        return e.polygonizeBounds(this.screenBounds[0], 1 === this.screenBounds.length ? this.screenBounds[0] : this.screenBounds[1], t);\n      }\n\n      bufferedCameraGeometry(t) {\n        const i = this.screenBounds[0],\n              o = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e.pointGeometry(1, 1)) : this.screenBounds[1],\n              r = e.polygonizeBounds(i, o, 0, !1);\n        return this.cameraPoint.y > o.y && (this.cameraPoint.x > i.x && this.cameraPoint.x < o.x ? r.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= o.x ? r[2] = this.cameraPoint : this.cameraPoint.x <= i.x && (r[3] = this.cameraPoint)), e.bufferConvexPolygon(r, t);\n      }\n\n      containsTile(t, i, o) {\n        const r = t.queryPadding + 1,\n              n = t.tileID.wrap,\n              a = o ? this._bufferedCameraMercator(r, i).map(i => e.getTilePoint(t.tileTransform, i, n)) : this._bufferedScreenMercator(r, i).map(i => e.getTilePoint(t.tileTransform, i, n)),\n              s = this.screenGeometryMercator.map(i => e.getTileVec3(t.tileTransform, i, n)),\n              l = s.map(t => new e.pointGeometry(t[0], t[1])),\n              c = i.getFreeCameraOptions().position || new e.MercatorCoordinate(0, 0, 0),\n              h = e.getTileVec3(t.tileTransform, c, n),\n              _ = s.map(t => {\n          const i = e.sub(t, t, h);\n          return e.normalize(i, i), new e.Ray(h, i);\n        }),\n              u = L(t, 1, i.zoom);\n\n        if (e.polygonIntersectsBox(a, 0, 0, e.EXTENT, e.EXTENT)) return {\n          queryGeometry: this,\n          tilespaceGeometry: l,\n          tilespaceRays: _,\n          bufferedTilespaceGeometry: a,\n          bufferedTilespaceBounds: (d = e.getBounds(a), d.min.x = e.clamp(d.min.x, 0, e.EXTENT), d.min.y = e.clamp(d.min.y, 0, e.EXTENT), d.max.x = e.clamp(d.max.x, 0, e.EXTENT), d.max.y = e.clamp(d.max.y, 0, e.EXTENT), d),\n          tile: t,\n          tileID: t.tileID,\n          pixelToTileUnitsFactor: u\n        };\n        var d;\n      }\n\n      _bufferedScreenMercator(e, t) {\n        const i = k(e);\n        if (this._screenRaycastCache[i]) return this._screenRaycastCache[i];\n        {\n          const o = this.bufferedScreenGeometry(e).map(e => t.pointCoordinate3D(e));\n          return this._screenRaycastCache[i] = o, o;\n        }\n      }\n\n      _bufferedCameraMercator(e, t) {\n        const i = k(e);\n        if (this._cameraRaycastCache[i]) return this._cameraRaycastCache[i];\n        {\n          const o = this.bufferedCameraGeometry(e).map(e => t.pointCoordinate3D(e));\n          return this._cameraRaycastCache[i] = o, o;\n        }\n      }\n\n    }\n\n    function k(e) {\n      return 100 * e | 0;\n    }\n\n    function O(t, i, o) {\n      const r = function (r, n) {\n        if (r) return o(r);\n\n        if (n) {\n          const r = e.pick(e.extend(n, t), [\"tiles\", \"minzoom\", \"maxzoom\", \"attribution\", \"mapbox_logo\", \"bounds\", \"scheme\", \"tileSize\", \"encoding\"]);\n          n.vector_layers && (r.vectorLayers = n.vector_layers, r.vectorLayerIds = r.vectorLayers.map(e => e.id)), r.tiles = i.canonicalizeTileset(r, t.url), o(null, r);\n        }\n      };\n\n      return t.url ? e.getJSON(i.transformRequest(i.normalizeSourceURL(t.url), e.ResourceType.Source), r) : e.exported.frame(() => r(null, t));\n    }\n\n    class B {\n      constructor(t, i, o) {\n        this.bounds = e.LngLatBounds.convert(this.validateBounds(t)), this.minzoom = i || 0, this.maxzoom = o || 24;\n      }\n\n      validateBounds(e) {\n        return Array.isArray(e) && 4 === e.length ? [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])] : [-180, -90, 180, 90];\n      }\n\n      contains(t) {\n        const i = Math.pow(2, t.z),\n              o = Math.floor(e.mercatorXfromLng(this.bounds.getWest()) * i),\n              r = Math.floor(e.mercatorYfromLat(this.bounds.getNorth()) * i),\n              n = Math.ceil(e.mercatorXfromLng(this.bounds.getEast()) * i),\n              a = Math.ceil(e.mercatorYfromLat(this.bounds.getSouth()) * i);\n        return t.x >= o && t.x < n && t.y >= r && t.y < a;\n      }\n\n    }\n\n    class F {\n      constructor(e, t, i) {\n        this.context = e;\n        const o = e.gl;\n        this.buffer = o.createBuffer(), this.dynamicDraw = Boolean(i), this.context.unbindVAO(), e.bindElementBuffer.set(this.buffer), o.bufferData(o.ELEMENT_ARRAY_BUFFER, t.arrayBuffer, this.dynamicDraw ? o.DYNAMIC_DRAW : o.STATIC_DRAW), this.dynamicDraw || t.destroy();\n      }\n\n      bind() {\n        this.context.bindElementBuffer.set(this.buffer);\n      }\n\n      updateData(e) {\n        const t = this.context.gl;\n        this.context.unbindVAO(), this.bind(), t.bufferSubData(t.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer);\n      }\n\n      destroy() {\n        this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);\n      }\n\n    }\n\n    const U = {\n      Int8: \"BYTE\",\n      Uint8: \"UNSIGNED_BYTE\",\n      Int16: \"SHORT\",\n      Uint16: \"UNSIGNED_SHORT\",\n      Int32: \"INT\",\n      Uint32: \"UNSIGNED_INT\",\n      Float32: \"FLOAT\"\n    };\n\n    class N {\n      constructor(e, t, i, o) {\n        this.length = t.length, this.attributes = i, this.itemSize = t.bytesPerElement, this.dynamicDraw = o, this.context = e;\n        const r = e.gl;\n        this.buffer = r.createBuffer(), e.bindVertexBuffer.set(this.buffer), r.bufferData(r.ARRAY_BUFFER, t.arrayBuffer, this.dynamicDraw ? r.DYNAMIC_DRAW : r.STATIC_DRAW), this.dynamicDraw || t.destroy();\n      }\n\n      bind() {\n        this.context.bindVertexBuffer.set(this.buffer);\n      }\n\n      updateData(e) {\n        const t = this.context.gl;\n        this.bind(), t.bufferSubData(t.ARRAY_BUFFER, 0, e.arrayBuffer);\n      }\n\n      enableAttributes(e, t) {\n        for (let i = 0; i < this.attributes.length; i++) {\n          const o = t.attributes[this.attributes[i].name];\n          void 0 !== o && e.enableVertexAttribArray(o);\n        }\n      }\n\n      setVertexAttribPointers(e, t, i) {\n        for (let o = 0; o < this.attributes.length; o++) {\n          const r = this.attributes[o],\n                n = t.attributes[r.name];\n          void 0 !== n && e.vertexAttribPointer(n, r.components, e[U[r.type]], !1, this.itemSize, r.offset + this.itemSize * (i || 0));\n        }\n      }\n\n      destroy() {\n        this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);\n      }\n\n    }\n\n    class G {\n      constructor(e) {\n        this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;\n      }\n\n      get() {\n        return this.current;\n      }\n\n      set(e) {}\n\n      getDefault() {\n        return this.default;\n      }\n\n      setDefault() {\n        this.set(this.default);\n      }\n\n    }\n\n    class j extends G {\n      getDefault() {\n        return e.Color.transparent;\n      }\n\n      set(e) {\n        const t = this.current;\n        (e.r !== t.r || e.g !== t.g || e.b !== t.b || e.a !== t.a || this.dirty) && (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);\n      }\n\n    }\n\n    class Z extends G {\n      getDefault() {\n        return 1;\n      }\n\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.clearDepth(e), this.current = e, this.dirty = !1);\n      }\n\n    }\n\n    class V extends G {\n      getDefault() {\n        return 0;\n      }\n\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.clearStencil(e), this.current = e, this.dirty = !1);\n      }\n\n    }\n\n    class W extends G {\n      getDefault() {\n        return [!0, !0, !0, !0];\n      }\n\n      set(e) {\n        const t = this.current;\n        (e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || e[3] !== t[3] || this.dirty) && (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);\n      }\n\n    }\n\n    class q extends G {\n      getDefault() {\n        return !0;\n      }\n\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.depthMask(e), this.current = e, this.dirty = !1);\n      }\n\n    }\n\n    class X extends G {\n      getDefault() {\n        return 255;\n      }\n\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.stencilMask(e), this.current = e, this.dirty = !1);\n      }\n\n    }\n\n    class $ extends G {\n      getDefault() {\n        return {\n          func: this.gl.ALWAYS,\n          ref: 0,\n          mask: 255\n        };\n      }\n\n      set(e) {\n        const t = this.current;\n        (e.func !== t.func || e.ref !== t.ref || e.mask !== t.mask || this.dirty) && (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = !1);\n      }\n\n    }\n\n    class H extends G {\n      getDefault() {\n        const e = this.gl;\n        return [e.KEEP, e.KEEP, e.KEEP];\n      }\n\n      set(e) {\n        const t = this.current;\n        (e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || this.dirty) && (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = !1);\n      }\n\n    }\n\n    class K extends G {\n      getDefault() {\n        return !1;\n      }\n\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        e ? t.enable(t.STENCIL_TEST) : t.disable(t.STENCIL_TEST), this.current = e, this.dirty = !1;\n      }\n\n    }\n\n    class Y extends G {\n      getDefault() {\n        return [0, 1];\n      }\n\n      set(e) {\n        const t = this.current;\n        (e[0] !== t[0] || e[1] !== t[1] || this.dirty) && (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = !1);\n      }\n\n    }\n\n    class J extends G {\n      getDefault() {\n        return !1;\n      }\n\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        e ? t.enable(t.DEPTH_TEST) : t.disable(t.DEPTH_TEST), this.current = e, this.dirty = !1;\n      }\n\n    }\n\n    class Q extends G {\n      getDefault() {\n        return this.gl.LESS;\n      }\n\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.depthFunc(e), this.current = e, this.dirty = !1);\n      }\n\n    }\n\n    class ee extends G {\n      getDefault() {\n        return !1;\n      }\n\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        e ? t.enable(t.BLEND) : t.disable(t.BLEND), this.current = e, this.dirty = !1;\n      }\n\n    }\n\n    class te extends G {\n      getDefault() {\n        const e = this.gl;\n        return [e.ONE, e.ZERO];\n      }\n\n      set(e) {\n        const t = this.current;\n        (e[0] !== t[0] || e[1] !== t[1] || this.dirty) && (this.gl.blendFunc(e[0], e[1]), this.current = e, this.dirty = !1);\n      }\n\n    }\n\n    class ie extends G {\n      getDefault() {\n        return e.Color.transparent;\n      }\n\n      set(e) {\n        const t = this.current;\n        (e.r !== t.r || e.g !== t.g || e.b !== t.b || e.a !== t.a || this.dirty) && (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);\n      }\n\n    }\n\n    class oe extends G {\n      getDefault() {\n        return this.gl.FUNC_ADD;\n      }\n\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.blendEquation(e), this.current = e, this.dirty = !1);\n      }\n\n    }\n\n    class re extends G {\n      getDefault() {\n        return !1;\n      }\n\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        e ? t.enable(t.CULL_FACE) : t.disable(t.CULL_FACE), this.current = e, this.dirty = !1;\n      }\n\n    }\n\n    class ne extends G {\n      getDefault() {\n        return this.gl.BACK;\n      }\n\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.cullFace(e), this.current = e, this.dirty = !1);\n      }\n\n    }\n\n    class ae extends G {\n      getDefault() {\n        return this.gl.CCW;\n      }\n\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.frontFace(e), this.current = e, this.dirty = !1);\n      }\n\n    }\n\n    class se extends G {\n      getDefault() {\n        return null;\n      }\n\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.useProgram(e), this.current = e, this.dirty = !1);\n      }\n\n    }\n\n    class le extends G {\n      getDefault() {\n        return this.gl.TEXTURE0;\n      }\n\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.activeTexture(e), this.current = e, this.dirty = !1);\n      }\n\n    }\n\n    class ce extends G {\n      getDefault() {\n        const e = this.gl;\n        return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight];\n      }\n\n      set(e) {\n        const t = this.current;\n        (e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || e[3] !== t[3] || this.dirty) && (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);\n      }\n\n    }\n\n    class he extends G {\n      getDefault() {\n        return null;\n      }\n\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        t.bindFramebuffer(t.FRAMEBUFFER, e), this.current = e, this.dirty = !1;\n      }\n\n    }\n\n    class _e extends G {\n      getDefault() {\n        return null;\n      }\n\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        t.bindRenderbuffer(t.RENDERBUFFER, e), this.current = e, this.dirty = !1;\n      }\n\n    }\n\n    class ue extends G {\n      getDefault() {\n        return null;\n      }\n\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        t.bindTexture(t.TEXTURE_2D, e), this.current = e, this.dirty = !1;\n      }\n\n    }\n\n    class de extends G {\n      getDefault() {\n        return null;\n      }\n\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        t.bindBuffer(t.ARRAY_BUFFER, e), this.current = e, this.dirty = !1;\n      }\n\n    }\n\n    class pe extends G {\n      getDefault() {\n        return null;\n      }\n\n      set(e) {\n        const t = this.gl;\n        t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = !1;\n      }\n\n    }\n\n    class me extends G {\n      constructor(e) {\n        super(e), this.vao = e.extVertexArrayObject;\n      }\n\n      getDefault() {\n        return null;\n      }\n\n      set(e) {\n        this.vao && (e !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(e), this.current = e, this.dirty = !1);\n      }\n\n    }\n\n    class fe extends G {\n      getDefault() {\n        return 4;\n      }\n\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        t.pixelStorei(t.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = !1;\n      }\n\n    }\n\n    class ge extends G {\n      getDefault() {\n        return !1;\n      }\n\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = !1;\n      }\n\n    }\n\n    class ve extends G {\n      getDefault() {\n        return !1;\n      }\n\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = !1;\n      }\n\n    }\n\n    class xe extends G {\n      constructor(e, t) {\n        super(e), this.context = e, this.parent = t;\n      }\n\n      getDefault() {\n        return null;\n      }\n\n    }\n\n    class ye extends xe {\n      setDirty() {\n        this.dirty = !0;\n      }\n\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        this.context.bindFramebuffer.set(this.parent);\n        const t = this.gl;\n        t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1;\n      }\n\n    }\n\n    class be extends xe {\n      attachment() {\n        return this.gl.DEPTH_ATTACHMENT;\n      }\n\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        this.context.bindFramebuffer.set(this.parent);\n        const t = this.gl;\n        t.framebufferRenderbuffer(t.FRAMEBUFFER, this.attachment(), t.RENDERBUFFER, e), this.current = e, this.dirty = !1;\n      }\n\n    }\n\n    class we extends be {\n      attachment() {\n        return this.gl.DEPTH_STENCIL_ATTACHMENT;\n      }\n\n    }\n\n    class Te {\n      constructor(e, t, i, o) {\n        this.context = e, this.width = t, this.height = i;\n        const r = this.framebuffer = e.gl.createFramebuffer();\n        this.colorAttachment = new ye(e, r), o && (this.depthAttachment = new be(e, r));\n      }\n\n      destroy() {\n        const e = this.context.gl,\n              t = this.colorAttachment.get();\n\n        if (t && e.deleteTexture(t), this.depthAttachment) {\n          const t = this.depthAttachment.get();\n          t && e.deleteRenderbuffer(t);\n        }\n\n        e.deleteFramebuffer(this.framebuffer);\n      }\n\n    }\n\n    class Ee {\n      constructor(e) {\n        this.gl = e, this.extVertexArrayObject = this.gl.getExtension(\"OES_vertex_array_object\"), this.clearColor = new j(this), this.clearDepth = new Z(this), this.clearStencil = new V(this), this.colorMask = new W(this), this.depthMask = new q(this), this.stencilMask = new X(this), this.stencilFunc = new $(this), this.stencilOp = new H(this), this.stencilTest = new K(this), this.depthRange = new Y(this), this.depthTest = new J(this), this.depthFunc = new Q(this), this.blend = new ee(this), this.blendFunc = new te(this), this.blendColor = new ie(this), this.blendEquation = new oe(this), this.cullFace = new re(this), this.cullFaceSide = new ne(this), this.frontFace = new ae(this), this.program = new se(this), this.activeTexture = new le(this), this.viewport = new ce(this), this.bindFramebuffer = new he(this), this.bindRenderbuffer = new _e(this), this.bindTexture = new ue(this), this.bindVertexBuffer = new de(this), this.bindElementBuffer = new pe(this), this.bindVertexArrayOES = this.extVertexArrayObject && new me(this), this.pixelStoreUnpack = new fe(this), this.pixelStoreUnpackPremultiplyAlpha = new ge(this), this.pixelStoreUnpackFlipY = new ve(this), this.extTextureFilterAnisotropic = e.getExtension(\"EXT_texture_filter_anisotropic\") || e.getExtension(\"MOZ_EXT_texture_filter_anisotropic\") || e.getExtension(\"WEBKIT_EXT_texture_filter_anisotropic\"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.extTextureFilterAnisotropicForceOff = !1, this.extTextureHalfFloat = e.getExtension(\"OES_texture_half_float\"), this.extTextureHalfFloat && (e.getExtension(\"OES_texture_half_float_linear\"), this.extRenderToTextureHalfFloat = e.getExtension(\"EXT_color_buffer_half_float\")), this.extTimerQuery = e.getExtension(\"EXT_disjoint_timer_query\"), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE);\n      }\n\n      setDefault() {\n        this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();\n      }\n\n      setDirty() {\n        this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = !0), this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;\n      }\n\n      createIndexBuffer(e, t) {\n        return new F(this, e, t);\n      }\n\n      createVertexBuffer(e, t, i) {\n        return new N(this, e, t, i);\n      }\n\n      createRenderbuffer(e, t, i) {\n        const o = this.gl,\n              r = o.createRenderbuffer();\n        return this.bindRenderbuffer.set(r), o.renderbufferStorage(o.RENDERBUFFER, e, t, i), this.bindRenderbuffer.set(null), r;\n      }\n\n      createFramebuffer(e, t, i) {\n        return new Te(this, e, t, i);\n      }\n\n      clear({\n        color: e,\n        depth: t,\n        stencil: i\n      }) {\n        const o = this.gl;\n        let r = 0;\n        e && (r |= o.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([!0, !0, !0, !0])), void 0 !== t && (r |= o.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t), this.depthMask.set(!0)), void 0 !== i && (r |= o.STENCIL_BUFFER_BIT, this.clearStencil.set(i), this.stencilMask.set(255)), o.clear(r);\n      }\n\n      setCullFace(e) {\n        !1 === e.enable ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace));\n      }\n\n      setDepthMode(e) {\n        e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(!0), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range)) : this.depthTest.set(!1);\n      }\n\n      setStencilMode(e) {\n        e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e.mask), this.stencilOp.set([e.fail, e.depthFail, e.pass]), this.stencilFunc.set({\n          func: e.test.func,\n          ref: e.ref,\n          mask: e.test.mask\n        })) : this.stencilTest.set(!1);\n      }\n\n      setColorMode(t) {\n        r(t.blendFunction, e.ColorMode.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(t.blendFunction), this.blendColor.set(t.blendColor)), this.colorMask.set(t.mask);\n      }\n\n      unbindVAO() {\n        this.extVertexArrayObject && this.bindVertexArrayOES.set(null);\n      }\n\n    }\n\n    class Ce extends e.Evented {\n      constructor(t, i, o, r) {\n        super(), this.id = t, this.dispatcher = o, this.setEventedParent(r), this.type = \"raster\", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = \"xyz\", this.tileSize = 512, this._loaded = !1, this._options = e.extend({\n          type: \"raster\"\n        }, i), e.extend(this, e.pick(i, [\"url\", \"scheme\", \"tileSize\"]));\n      }\n\n      load() {\n        this._loaded = !1, this.fire(new e.Event(\"dataloading\", {\n          dataType: \"source\"\n        })), this._tileJSONRequest = O(this._options, this.map._requestManager, (t, i) => {\n          this._tileJSONRequest = null, this._loaded = !0, t ? this.fire(new e.ErrorEvent(t)) : i && (e.extend(this, i), i.bounds && (this.tileBounds = new B(i.bounds, this.minzoom, this.maxzoom)), e.postTurnstileEvent(i.tiles), this.fire(new e.Event(\"data\", {\n            dataType: \"source\",\n            sourceDataType: \"metadata\"\n          })), this.fire(new e.Event(\"data\", {\n            dataType: \"source\",\n            sourceDataType: \"content\"\n          })));\n        });\n      }\n\n      loaded() {\n        return this._loaded;\n      }\n\n      onAdd(e) {\n        this.map = e, this.load();\n      }\n\n      onRemove() {\n        this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);\n      }\n\n      serialize() {\n        return e.extend({}, this._options);\n      }\n\n      hasTile(e) {\n        return !this.tileBounds || this.tileBounds.contains(e.canonical);\n      }\n\n      loadTile(t, i) {\n        const o = e.exported.devicePixelRatio >= 2,\n              r = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme), o, this.tileSize);\n\n        t.request = e.getImage(this.map._requestManager.transformRequest(r, e.ResourceType.Tile), (o, r, n, a) => (delete t.request, t.aborted ? (t.state = \"unloaded\", i(null)) : o ? (t.state = \"errored\", i(o)) : r ? (this.map._refreshExpiredTiles && t.setExpiryData({\n          cacheControl: n,\n          expires: a\n        }), t.setTexture(r, this.map.painter), t.state = \"loaded\", e.cacheEntryPossiblyAdded(this.dispatcher), void i(null)) : i(null)));\n      }\n\n      static loadTileData(e, t, i) {\n        e.setTexture(t, i);\n      }\n\n      static unloadTileData(e, t) {\n        e.texture && t.saveTileTexture(e.texture);\n      }\n\n      abortTile(e, t) {\n        e.request && (e.request.cancel(), delete e.request), t();\n      }\n\n      unloadTile(e, t) {\n        e.texture && this.map.painter.saveTileTexture(e.texture), t();\n      }\n\n      hasTransition() {\n        return !1;\n      }\n\n    }\n\n    let Ie;\n\n    function Me(t, i, o, r, n, a, s, l) {\n      const c = [t, o, n, i, r, a, 1, 1, 1],\n            h = [s, l, 1],\n            _ = e.adjoint([], c),\n            [u, d, p] = e.transformMat3(h, h, e.transpose(_, _));\n\n      return e.multiply(c, [u, 0, 0, 0, d, 0, 0, 0, p], c);\n    }\n\n    class Se extends e.Evented {\n      constructor(e, t, i, o) {\n        super(), this.id = e, this.dispatcher = i, this.coordinates = t.coordinates, this.type = \"image\", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(o), this.options = t;\n      }\n\n      load(t) {\n        this._loaded = !1, this.fire(new e.Event(\"dataloading\", {\n          dataType: \"source\"\n        })), this.url = this.options.url, e.getImage(this.map._requestManager.transformRequest(this.url, e.ResourceType.Image), (i, o) => {\n          if (this._loaded = !0, i) this.fire(new e.ErrorEvent(i));else if (o) {\n            const {\n              HTMLImageElement: i\n            } = e.window;\n            this.image = o instanceof i ? e.exported.getImageData(o) : o, this.width = this.image.width, this.height = this.image.height, t && (this.coordinates = t), this._finishLoading();\n          }\n        });\n      }\n\n      loaded() {\n        return this._loaded;\n      }\n\n      updateImage(e) {\n        return this.image && e.url ? (this.options.url = e.url, this.load(e.coordinates), this) : this;\n      }\n\n      _finishLoading() {\n        this.map && (this.setCoordinates(this.coordinates), this.fire(new e.Event(\"data\", {\n          dataType: \"source\",\n          sourceDataType: \"metadata\"\n        })));\n      }\n\n      onAdd(e) {\n        this.map = e, this.load();\n      }\n\n      onRemove() {\n        this.texture && this.texture.destroy();\n      }\n\n      setCoordinates(t) {\n        this.coordinates = t, this._boundsArray = void 0;\n        const i = t.map(e.MercatorCoordinate.fromLngLat);\n        return this.tileID = function (t) {\n          let i = 1 / 0,\n              o = 1 / 0,\n              r = -1 / 0,\n              n = -1 / 0;\n\n          for (const e of t) i = Math.min(i, e.x), o = Math.min(o, e.y), r = Math.max(r, e.x), n = Math.max(n, e.y);\n\n          const a = Math.max(r - i, n - o),\n                s = Math.max(0, Math.floor(-Math.log(a) / Math.LN2)),\n                l = Math.pow(2, s);\n          return new e.CanonicalTileID(s, Math.floor((i + r) / 2 * l), Math.floor((o + n) / 2 * l));\n        }(i), this.minzoom = this.maxzoom = this.tileID.z, this.fire(new e.Event(\"data\", {\n          dataType: \"source\",\n          sourceDataType: \"content\"\n        })), this;\n      }\n\n      _clear() {\n        this._boundsArray = void 0;\n      }\n\n      _prepareData(t) {\n        for (const e in this.tiles) {\n          const t = this.tiles[e];\n          \"loaded\" !== t.state && (t.state = \"loaded\", t.texture = this.texture);\n        }\n\n        if (this._boundsArray) return;\n        const i = e.tileTransform(this.tileID, this.map.transform.projection),\n              [o, r, n, a] = this.coordinates.map(t => {\n          const o = i.projection.project(t[0], t[1]);\n          return e.getTilePoint(i, o)._round();\n        });\n\n        this.perspectiveTransform = function (t, i, o, r, n, a, s, l, c, h) {\n          const _ = Me(0, 0, t, 0, 0, i, t, i),\n                u = Me(o, r, n, a, s, l, c, h);\n\n          return e.multiply(u, e.adjoint(_, _), u), [u[6] / u[8] * t / e.EXTENT, u[7] / u[8] * i / e.EXTENT];\n        }(this.width, this.height, o.x, o.y, r.x, r.y, a.x, a.y, n.x, n.y);\n\n        const s = this._boundsArray = new e.StructArrayLayout4i8();\n        s.emplaceBack(o.x, o.y, 0, 0), s.emplaceBack(r.x, r.y, e.EXTENT, 0), s.emplaceBack(a.x, a.y, 0, e.EXTENT), s.emplaceBack(n.x, n.y, e.EXTENT, e.EXTENT), this.boundsBuffer && this.boundsBuffer.destroy(), this.boundsBuffer = t.createVertexBuffer(s, e.boundsAttributes.members), this.boundsSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);\n      }\n\n      prepare() {\n        if (0 === Object.keys(this.tiles).length || !this.image) return;\n        const t = this.map.painter.context,\n              i = t.gl;\n        this.texture ? this.texture.update(this.image) : (this.texture = new e.Texture(t, this.image, i.RGBA), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE)), this._prepareData(t);\n      }\n\n      loadTile(e, t) {\n        this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e, e.buckets = {}, t(null)) : (e.state = \"errored\", t(null));\n      }\n\n      serialize() {\n        return {\n          type: \"image\",\n          url: this.options.url,\n          coordinates: this.coordinates\n        };\n      }\n\n      hasTransition() {\n        return !1;\n      }\n\n    }\n\n    const ze = {\n      vector: class extends e.Evented {\n        constructor(t, i, o, r) {\n          if (super(), this.id = t, this.dispatcher = o, this.type = \"vector\", this.minzoom = 0, this.maxzoom = 22, this.scheme = \"xyz\", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, e.extend(this, e.pick(i, [\"url\", \"scheme\", \"tileSize\", \"promoteId\"])), this._options = e.extend({\n            type: \"vector\"\n          }, i), this._collectResourceTiming = i.collectResourceTiming, 512 !== this.tileSize) throw new Error(\"vector tile sources must have a tileSize of 512\");\n          this.setEventedParent(r), this._tileWorkers = {}, this._deduped = new e.DedupedRequest();\n        }\n\n        load() {\n          this._loaded = !1, this.fire(new e.Event(\"dataloading\", {\n            dataType: \"source\"\n          })), this._tileJSONRequest = O(this._options, this.map._requestManager, (t, i) => {\n            this._tileJSONRequest = null, this._loaded = !0, t ? this.fire(new e.ErrorEvent(t)) : i && (e.extend(this, i), i.bounds && (this.tileBounds = new B(i.bounds, this.minzoom, this.maxzoom)), e.postTurnstileEvent(i.tiles, this.map._requestManager._customAccessToken), this.fire(new e.Event(\"data\", {\n              dataType: \"source\",\n              sourceDataType: \"metadata\"\n            })), this.fire(new e.Event(\"data\", {\n              dataType: \"source\",\n              sourceDataType: \"content\"\n            })));\n          });\n        }\n\n        loaded() {\n          return this._loaded;\n        }\n\n        hasTile(e) {\n          return !this.tileBounds || this.tileBounds.contains(e.canonical);\n        }\n\n        onAdd(e) {\n          this.map = e, this.load();\n        }\n\n        setSourceProperty(e) {\n          this._tileJSONRequest && this._tileJSONRequest.cancel(), e();\n\n          const t = this.map.style._getSourceCaches(this.id);\n\n          for (const e of t) e.clearTiles();\n\n          this.load();\n        }\n\n        setTiles(e) {\n          return this.setSourceProperty(() => {\n            this._options.tiles = e;\n          }), this;\n        }\n\n        setUrl(e) {\n          return this.setSourceProperty(() => {\n            this.url = e, this._options.url = e;\n          }), this;\n        }\n\n        onRemove() {\n          this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);\n        }\n\n        serialize() {\n          return e.extend({}, this._options);\n        }\n\n        loadTile(t, i) {\n          const o = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme)),\n                r = {\n            request: this.map._requestManager.transformRequest(o, e.ResourceType.Tile),\n            data: void 0,\n            uid: t.uid,\n            tileID: t.tileID,\n            tileZoom: t.tileZoom,\n            zoom: t.tileID.overscaledZ,\n            tileSize: this.tileSize * t.tileID.overscaleFactor(),\n            type: this.type,\n            source: this.id,\n            pixelRatio: e.exported.devicePixelRatio,\n            showCollisionBoxes: this.map.showCollisionBoxes,\n            promoteId: this.promoteId,\n            isSymbolTile: t.isSymbolTile\n          };\n\n          if (r.request.collectResourceTiming = this._collectResourceTiming, t.actor && \"expired\" !== t.state) \"loading\" === t.state ? t.reloadCallback = i : t.request = t.actor.send(\"reloadTile\", r, n.bind(this));else if (t.actor = this._tileWorkers[o] = this._tileWorkers[o] || this.dispatcher.getActor(), this.dispatcher.ready) t.request = t.actor.send(\"loadTile\", r, n.bind(this), void 0, !0);else {\n            const i = e.loadVectorTile.call({\n              deduped: this._deduped\n            }, r, (e, i) => {\n              e || !i ? n.call(this, e) : (r.data = {\n                cacheControl: i.cacheControl,\n                expires: i.expires,\n                rawData: i.rawData.slice(0)\n              }, t.actor && t.actor.send(\"loadTile\", r, n.bind(this), void 0, !0));\n            }, !0);\n            t.request = {\n              cancel: i\n            };\n          }\n\n          function n(o, r) {\n            return delete t.request, t.aborted ? i(null) : o && 404 !== o.status ? i(o) : (r && r.resourceTiming && (t.resourceTiming = r.resourceTiming), this.map._refreshExpiredTiles && r && t.setExpiryData(r), t.loadVectorData(r, this.map.painter), e.cacheEntryPossiblyAdded(this.dispatcher), i(null), void (t.reloadCallback && (this.loadTile(t, t.reloadCallback), t.reloadCallback = null)));\n          }\n        }\n\n        abortTile(e) {\n          e.request && (e.request.cancel(), delete e.request), e.actor && e.actor.send(\"abortTile\", {\n            uid: e.uid,\n            type: this.type,\n            source: this.id\n          });\n        }\n\n        unloadTile(e) {\n          e.unloadVectorData(), e.actor && e.actor.send(\"removeTile\", {\n            uid: e.uid,\n            type: this.type,\n            source: this.id\n          });\n        }\n\n        hasTransition() {\n          return !1;\n        }\n\n        afterUpdate() {\n          this._tileWorkers = {};\n        }\n\n      },\n      raster: Ce,\n      \"raster-dem\": class extends Ce {\n        constructor(t, i, o, r) {\n          super(t, i, o, r), this.type = \"raster-dem\", this.maxzoom = 22, this._options = e.extend({\n            type: \"raster-dem\"\n          }, i), this.encoding = i.encoding || \"mapbox\";\n        }\n\n        loadTile(t, i) {\n          const o = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize);\n\n          function r(e, o) {\n            e && (t.state = \"errored\", i(e)), o && (t.dem = o, t.dem.onDeserialize(), t.needsHillshadePrepare = !0, t.needsDEMTextureUpload = !0, t.state = \"loaded\", i(null));\n          }\n\n          t.request = e.getImage(this.map._requestManager.transformRequest(o, e.ResourceType.Tile), function (o, n, a, s) {\n            if (delete t.request, t.aborted) t.state = \"unloaded\", i(null);else if (o) t.state = \"errored\", i(o);else if (n) {\n              this.map._refreshExpiredTiles && t.setExpiryData({\n                cacheControl: a,\n                expires: s\n              });\n              const i = e.window.ImageBitmap && n instanceof e.window.ImageBitmap && (null == Ie && (Ie = e.window.OffscreenCanvas && new e.window.OffscreenCanvas(1, 1).getContext(\"2d\") && \"function\" == typeof e.window.createImageBitmap), Ie),\n                    o = 1 - (n.width - e.prevPowerOfTwo(n.width)) / 2;\n              o < 1 || t.neighboringTiles || (t.neighboringTiles = this._getNeighboringTiles(t.tileID));\n              const l = i ? n : e.exported.getImageData(n, o),\n                    c = {\n                uid: t.uid,\n                coord: t.tileID,\n                source: this.id,\n                rawImageData: l,\n                encoding: this.encoding,\n                padding: o\n              };\n              t.actor && \"expired\" !== t.state || (t.actor = this.dispatcher.getActor(), t.actor.send(\"loadDEMTile\", c, r.bind(this), void 0, !0));\n            }\n          }.bind(this));\n        }\n\n        _getNeighboringTiles(t) {\n          const i = t.canonical,\n                o = Math.pow(2, i.z),\n                r = (i.x - 1 + o) % o,\n                n = 0 === i.x ? t.wrap - 1 : t.wrap,\n                a = (i.x + 1 + o) % o,\n                s = i.x + 1 === o ? t.wrap + 1 : t.wrap,\n                l = {};\n          return l[new e.OverscaledTileID(t.overscaledZ, n, i.z, r, i.y).key] = {\n            backfilled: !1\n          }, l[new e.OverscaledTileID(t.overscaledZ, s, i.z, a, i.y).key] = {\n            backfilled: !1\n          }, i.y > 0 && (l[new e.OverscaledTileID(t.overscaledZ, n, i.z, r, i.y - 1).key] = {\n            backfilled: !1\n          }, l[new e.OverscaledTileID(t.overscaledZ, t.wrap, i.z, i.x, i.y - 1).key] = {\n            backfilled: !1\n          }, l[new e.OverscaledTileID(t.overscaledZ, s, i.z, a, i.y - 1).key] = {\n            backfilled: !1\n          }), i.y + 1 < o && (l[new e.OverscaledTileID(t.overscaledZ, n, i.z, r, i.y + 1).key] = {\n            backfilled: !1\n          }, l[new e.OverscaledTileID(t.overscaledZ, t.wrap, i.z, i.x, i.y + 1).key] = {\n            backfilled: !1\n          }, l[new e.OverscaledTileID(t.overscaledZ, s, i.z, a, i.y + 1).key] = {\n            backfilled: !1\n          }), l;\n        }\n\n        unloadTile(e) {\n          e.demTexture && this.map.painter.saveTileTexture(e.demTexture), e.fbo && (e.fbo.destroy(), delete e.fbo), e.dem && delete e.dem, delete e.neighboringTiles, e.state = \"unloaded\";\n        }\n\n      },\n      geojson: class extends e.Evented {\n        constructor(t, i, o, r) {\n          super(), this.id = t, this.type = \"geojson\", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._loaded = !1, this.actor = o.getActor(), this.setEventedParent(r), this._data = i.data, this._options = e.extend({}, i), this._collectResourceTiming = i.collectResourceTiming, void 0 !== i.maxzoom && (this.maxzoom = i.maxzoom), i.type && (this.type = i.type), i.attribution && (this.attribution = i.attribution), this.promoteId = i.promoteId;\n          const n = e.EXTENT / this.tileSize;\n          this.workerOptions = e.extend({\n            source: this.id,\n            cluster: i.cluster || !1,\n            geojsonVtOptions: {\n              buffer: (void 0 !== i.buffer ? i.buffer : 128) * n,\n              tolerance: (void 0 !== i.tolerance ? i.tolerance : .375) * n,\n              extent: e.EXTENT,\n              maxZoom: this.maxzoom,\n              lineMetrics: i.lineMetrics || !1,\n              generateId: i.generateId || !1\n            },\n            superclusterOptions: {\n              maxZoom: void 0 !== i.clusterMaxZoom ? i.clusterMaxZoom : this.maxzoom - 1,\n              minPoints: Math.max(2, i.clusterMinPoints || 2),\n              extent: e.EXTENT,\n              radius: (void 0 !== i.clusterRadius ? i.clusterRadius : 50) * n,\n              log: !1,\n              generateId: i.generateId || !1\n            },\n            clusterProperties: i.clusterProperties,\n            filter: i.filter\n          }, i.workerOptions);\n        }\n\n        onAdd(e) {\n          this.map = e, this.setData(this._data);\n        }\n\n        setData(e) {\n          return this._data = e, this._updateWorkerData(), this;\n        }\n\n        getClusterExpansionZoom(e, t) {\n          return this.actor.send(\"geojson.getClusterExpansionZoom\", {\n            clusterId: e,\n            source: this.id\n          }, t), this;\n        }\n\n        getClusterChildren(e, t) {\n          return this.actor.send(\"geojson.getClusterChildren\", {\n            clusterId: e,\n            source: this.id\n          }, t), this;\n        }\n\n        getClusterLeaves(e, t, i, o) {\n          return this.actor.send(\"geojson.getClusterLeaves\", {\n            source: this.id,\n            clusterId: e,\n            limit: t,\n            offset: i\n          }, o), this;\n        }\n\n        _updateWorkerData() {\n          if (this._pendingLoad) return void (this._coalesce = !0);\n          this.fire(new e.Event(\"dataloading\", {\n            dataType: \"source\"\n          })), this._loaded = !1;\n          const t = e.extend({}, this.workerOptions),\n                i = this._data;\n          \"string\" == typeof i ? (t.request = this.map._requestManager.transformRequest(e.exported.resolveURL(i), e.ResourceType.Source), t.request.collectResourceTiming = this._collectResourceTiming) : t.data = JSON.stringify(i), this._pendingLoad = this.actor.send(`${this.type}.loadData`, t, (t, i) => {\n            if (this._loaded = !0, this._pendingLoad = null, t) this.fire(new e.ErrorEvent(t));else {\n              const t = {\n                dataType: \"source\",\n                sourceDataType: this._metadataFired ? \"content\" : \"metadata\"\n              };\n              this._collectResourceTiming && i && i.resourceTiming && i.resourceTiming[this.id] && (t.resourceTiming = i.resourceTiming[this.id]), this.fire(new e.Event(\"data\", t)), this._metadataFired = !0;\n            }\n            this._coalesce && (this._updateWorkerData(), this._coalesce = !1);\n          });\n        }\n\n        loaded() {\n          return this._loaded;\n        }\n\n        loadTile(t, i) {\n          const o = t.actor ? \"reloadTile\" : \"loadTile\";\n          t.actor = this.actor, t.request = this.actor.send(o, {\n            type: this.type,\n            uid: t.uid,\n            tileID: t.tileID,\n            tileZoom: t.tileZoom,\n            zoom: t.tileID.overscaledZ,\n            maxZoom: this.maxzoom,\n            tileSize: this.tileSize,\n            source: this.id,\n            pixelRatio: e.exported.devicePixelRatio,\n            showCollisionBoxes: this.map.showCollisionBoxes,\n            promoteId: this.promoteId\n          }, (e, r) => (delete t.request, t.unloadVectorData(), t.aborted ? i(null) : e ? i(e) : (t.loadVectorData(r, this.map.painter, \"reloadTile\" === o), i(null))), void 0, \"loadTile\" === o);\n        }\n\n        abortTile(e) {\n          e.request && (e.request.cancel(), delete e.request), e.aborted = !0;\n        }\n\n        unloadTile(e) {\n          e.unloadVectorData(), this.actor.send(\"removeTile\", {\n            uid: e.uid,\n            type: this.type,\n            source: this.id\n          });\n        }\n\n        onRemove() {\n          this._pendingLoad && this._pendingLoad.cancel();\n        }\n\n        serialize() {\n          return e.extend({}, this._options, {\n            type: this.type,\n            data: this._data\n          });\n        }\n\n        hasTransition() {\n          return !1;\n        }\n\n      },\n      video: class extends Se {\n        constructor(e, t, i, o) {\n          super(e, t, i, o), this.roundZoom = !0, this.type = \"video\", this.options = t;\n        }\n\n        load() {\n          this._loaded = !1;\n          const t = this.options;\n          this.urls = [];\n\n          for (const i of t.urls) this.urls.push(this.map._requestManager.transformRequest(i, e.ResourceType.Source).url);\n\n          e.getVideo(this.urls, (t, i) => {\n            this._loaded = !0, t ? this.fire(new e.ErrorEvent(t)) : i && (this.video = i, this.video.loop = !0, this.video.setAttribute(\"playsinline\", \"\"), this.video.addEventListener(\"playing\", () => {\n              this.map.triggerRepaint();\n            }), this.map && this.video.play(), this._finishLoading());\n          });\n        }\n\n        pause() {\n          this.video && this.video.pause();\n        }\n\n        play() {\n          this.video && this.video.play();\n        }\n\n        seek(t) {\n          if (this.video) {\n            const i = this.video.seekable;\n            t < i.start(0) || t > i.end(0) ? this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i.start(0)} and ${i.end(0)}-second mark.`))) : this.video.currentTime = t;\n          }\n        }\n\n        getVideo() {\n          return this.video;\n        }\n\n        onAdd(e) {\n          this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));\n        }\n\n        prepare() {\n          if (0 === Object.keys(this.tiles).length || this.video.readyState < 2) return;\n          const t = this.map.painter.context,\n                i = t.gl;\n          this.texture ? this.video.paused || (this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE), i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, i.RGBA, i.UNSIGNED_BYTE, this.video)) : (this.texture = new e.Texture(t, this.video, i.RGBA), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE), this.width = this.video.videoWidth, this.height = this.video.videoHeight), this._prepareData(t);\n        }\n\n        serialize() {\n          return {\n            type: \"video\",\n            urls: this.urls,\n            coordinates: this.coordinates\n          };\n        }\n\n        hasTransition() {\n          return this.video && !this.video.paused;\n        }\n\n      },\n      image: Se,\n      canvas: class extends Se {\n        constructor(t, i, o, r) {\n          super(t, i, o, r), i.coordinates ? Array.isArray(i.coordinates) && 4 === i.coordinates.length && !i.coordinates.some(e => !Array.isArray(e) || 2 !== e.length || e.some(e => \"number\" != typeof e)) || this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t}`, null, '\"coordinates\" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t}`, null, 'missing required property \"coordinates\"'))), i.animate && \"boolean\" != typeof i.animate && this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t}`, null, 'optional \"animate\" property must be a boolean value'))), i.canvas ? \"string\" == typeof i.canvas || i.canvas instanceof e.window.HTMLCanvasElement || this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t}`, null, '\"canvas\" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t}`, null, 'missing required property \"canvas\"'))), this.options = i, this.animate = void 0 === i.animate || i.animate;\n        }\n\n        load() {\n          this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof e.window.HTMLCanvasElement ? this.options.canvas : e.window.document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new e.ErrorEvent(new Error(\"Canvas dimensions cannot be less than or equal to zero.\"))) : (this.play = function () {\n            this._playing = !0, this.map.triggerRepaint();\n          }, this.pause = function () {\n            this._playing && (this.prepare(), this._playing = !1);\n          }, this._finishLoading());\n        }\n\n        getCanvas() {\n          return this.canvas;\n        }\n\n        onAdd(e) {\n          this.map = e, this.load(), this.canvas && this.animate && this.play();\n        }\n\n        onRemove() {\n          this.pause();\n        }\n\n        prepare() {\n          let t = !1;\n          if (this.canvas.width !== this.width && (this.width = this.canvas.width, t = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, t = !0), this._hasInvalidDimensions()) return;\n          if (0 === Object.keys(this.tiles).length) return;\n          const i = this.map.painter.context;\n          this.texture ? (t || this._playing) && this.texture.update(this.canvas, {\n            premultiply: !0\n          }) : this.texture = new e.Texture(i, this.canvas, i.gl.RGBA, {\n            premultiply: !0\n          }), this._prepareData(i);\n        }\n\n        serialize() {\n          return {\n            type: \"canvas\",\n            coordinates: this.coordinates\n          };\n        }\n\n        hasTransition() {\n          return this._playing;\n        }\n\n        _hasInvalidDimensions() {\n          for (const e of [this.canvas.width, this.canvas.height]) if (isNaN(e) || e <= 0) return !0;\n\n          return !1;\n        }\n\n      },\n      custom: class extends e.Evented {\n        constructor(t, i, o, r) {\n          super(), this.id = t, this.type = \"custom\", this._dataType = \"raster\", this._dispatcher = o, this._implementation = i, this.setEventedParent(r), this.scheme = \"xyz\", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this._loaded = !1, this.roundZoom = !0, this._implementation || this.fire(new e.ErrorEvent(new Error(`Missing implementation for ${this.id} custom source`))), this._implementation.loadTile || this.fire(new e.ErrorEvent(new Error(`Missing loadTile implementation for ${this.id} custom source`))), this._implementation.bounds && (this.tileBounds = new B(this._implementation.bounds, this.minzoom, this.maxzoom)), i.update = this._update.bind(this), i.coveringTiles = this._coveringTiles.bind(this), e.extend(this, e.pick(i, [\"dataType\", \"scheme\", \"minzoom\", \"maxzoom\", \"tileSize\", \"attribution\", \"minTileCacheSize\", \"maxTileCacheSize\"]));\n        }\n\n        serialize() {\n          return e.pick(this, [\"type\", \"scheme\", \"minzoom\", \"maxzoom\", \"tileSize\", \"attribution\"]);\n        }\n\n        load() {\n          this._loaded = !0, this.fire(new e.Event(\"data\", {\n            dataType: \"source\",\n            sourceDataType: \"metadata\"\n          })), this.fire(new e.Event(\"data\", {\n            dataType: \"source\",\n            sourceDataType: \"content\"\n          }));\n        }\n\n        loaded() {\n          return this._loaded;\n        }\n\n        onAdd(t) {\n          this._map = t, this._loaded = !1, this.fire(new e.Event(\"dataloading\", {\n            dataType: \"source\"\n          })), this._implementation.onAdd && this._implementation.onAdd(t), this.load();\n        }\n\n        onRemove(e) {\n          this._implementation.onRemove && this._implementation.onRemove(e);\n        }\n\n        hasTile(e) {\n          if (this._implementation.hasTile) {\n            const {\n              x: t,\n              y: i,\n              z: o\n            } = e.canonical;\n            return this._implementation.hasTile({\n              x: t,\n              y: i,\n              z: o\n            });\n          }\n\n          return !this.tileBounds || this.tileBounds.contains(e.canonical);\n        }\n\n        loadTile(t, i) {\n          const {\n            x: o,\n            y: r,\n            z: n\n          } = t.tileID.canonical,\n                a = new e.window.AbortController(),\n                s = this._implementation.loadTile({\n            x: o,\n            y: r,\n            z: n\n          }, {\n            signal: a.signal\n          });\n\n          if (!s) return this.loadTileData(t, {\n            width: this.tileSize,\n            height: this.tileSize,\n            data: null\n          }), t.state = \"loaded\", i(null);\n          s.cancel = () => a.abort(), t.request = s.then(function (o) {\n            return delete t.request, t.aborted ? (t.state = \"unloaded\", i(null)) : o ? function (t) {\n              return t instanceof e.window.ImageData || t instanceof e.window.ImageBitmap || t instanceof e.window.HTMLCanvasElement;\n            }(o) ? (this.loadTileData(t, o), t.state = \"loaded\", void i(null)) : (t.state = \"errored\", i(new Error(`Can't infer data type for ${this.id}, only raster data supported at the moment`))) : (this.loadTileData(t, {\n              width: this.tileSize,\n              height: this.tileSize,\n              data: null\n            }), t.state = \"loaded\", i(null));\n          }.bind(this)).catch(e => {\n            20 !== e.code && (t.state = \"errored\", i(e));\n          });\n        }\n\n        loadTileData(e, t) {\n          Ce.loadTileData(e, t, this._map.painter);\n        }\n\n        unloadTileData(e) {\n          Ce.unloadTileData(e, this._map.painter);\n        }\n\n        prepareTile(e) {\n          if (!this._implementation.prepareTile) return null;\n\n          const {\n            x: t,\n            y: i,\n            z: o\n          } = e.tileID.canonical,\n                r = this._implementation.prepareTile({\n            x: t,\n            y: i,\n            z: o\n          });\n\n          return r ? (this.loadTileData(e, r), e.state = \"loaded\", r) : null;\n        }\n\n        unloadTile(e, t) {\n          if (this.unloadTileData(e), this._implementation.unloadTile) {\n            const {\n              x: t,\n              y: i,\n              z: o\n            } = e.tileID.canonical;\n\n            this._implementation.unloadTile({\n              x: t,\n              y: i,\n              z: o\n            });\n          }\n\n          t();\n        }\n\n        abortTile(e, t) {\n          e.request && e.request.cancel && (e.request.cancel(), delete e.request), t();\n        }\n\n        hasTransition() {\n          return !1;\n        }\n\n        _coveringTiles() {\n          return this._map.transform.coveringTiles({\n            tileSize: this.tileSize,\n            minzoom: this.minzoom,\n            maxzoom: this.maxzoom\n          }).map(e => ({\n            x: e.canonical.x,\n            y: e.canonical.y,\n            z: e.canonical.z\n          }));\n        }\n\n        _update() {\n          this.fire(new e.Event(\"data\", {\n            dataType: \"source\",\n            sourceDataType: \"content\"\n          }));\n        }\n\n      }\n    },\n          De = function (t, i, o, r) {\n      const n = new ze[i.type](t, i, o, r);\n      if (n.id !== t) throw new Error(`Expected Source id to be ${t} instead of ${n.id}`);\n      return e.bindAll([\"load\", \"abort\", \"unload\", \"serialize\", \"prepare\"], n), n;\n    };\n\n    function Pe(t, i) {\n      const o = e.identity([]);\n      return e.scale(o, o, [.5 * t.width, .5 * -t.height, 1]), e.translate(o, o, [1, -1, 0]), e.multiply$1(o, o, t.calculateProjMatrix(i.toUnwrapped())), Float32Array.from(o);\n    }\n\n    function Ae(e, t, i, o, r, n, a, s = !1) {\n      const l = e.tilesIn(o, a, s);\n      l.sort(Re);\n      const c = [];\n\n      for (const o of l) c.push({\n        wrappedTileID: o.tile.tileID.wrapped().key,\n        queryResults: o.tile.queryRenderedFeatures(t, i, e._state, o, r, n, Pe(e.transform, o.tile.tileID), s)\n      });\n\n      const h = function (e) {\n        const t = {},\n              i = {};\n\n        for (const o of e) {\n          const e = o.queryResults,\n                r = o.wrappedTileID,\n                n = i[r] = i[r] || {};\n\n          for (const i in e) {\n            const o = e[i],\n                  r = n[i] = n[i] || {},\n                  a = t[i] = t[i] || [];\n\n            for (const e of o) r[e.featureIndex] || (r[e.featureIndex] = !0, a.push(e));\n          }\n        }\n\n        return t;\n      }(c);\n\n      for (const t in h) h[t].forEach(t => {\n        const i = t.feature,\n              o = i.layer;\n        o && \"background\" !== o.type && \"sky\" !== o.type && (i.source = o.source, o[\"source-layer\"] && (i.sourceLayer = o[\"source-layer\"]), i.state = void 0 !== i.id ? e.getFeatureState(o[\"source-layer\"], i.id) : {});\n      });\n\n      return h;\n    }\n\n    function Le(e, t) {\n      const i = e.getRenderableIds().map(t => e.getTileByID(t)),\n            o = [],\n            r = {};\n\n      for (let e = 0; e < i.length; e++) {\n        const n = i[e],\n              a = n.tileID.canonical.key;\n        r[a] || (r[a] = !0, n.querySourceFeatures(o, t));\n      }\n\n      return o;\n    }\n\n    function Re(e, t) {\n      const i = e.tileID,\n            o = t.tileID;\n      return i.overscaledZ - o.overscaledZ || i.canonical.y - o.canonical.y || i.wrap - o.wrap || i.canonical.x - o.canonical.x;\n    }\n\n    function ke() {\n      return null != ln.workerClass ? new ln.workerClass() : new e.window.Worker(ln.workerUrl);\n    }\n\n    const Oe = \"mapboxgl_preloaded_worker_pool\";\n\n    class Be {\n      constructor() {\n        this.active = {};\n      }\n\n      acquire(e) {\n        if (!this.workers) for (this.workers = []; this.workers.length < Be.workerCount;) this.workers.push(new ke());\n        return this.active[e] = !0, this.workers.slice();\n      }\n\n      release(e) {\n        delete this.active[e], 0 === this.numActive() && (this.workers.forEach(e => {\n          e.terminate();\n        }), this.workers = null);\n      }\n\n      isPreloaded() {\n        return !!this.active[Oe];\n      }\n\n      numActive() {\n        return Object.keys(this.active).length;\n      }\n\n    }\n\n    let Fe;\n\n    function Ue() {\n      return Fe || (Fe = new Be()), Fe;\n    }\n\n    function Ne(t, i) {\n      const o = {};\n\n      for (const e in t) \"ref\" !== e && (o[e] = t[e]);\n\n      return e.refProperties.forEach(e => {\n        e in i && (o[e] = i[e]);\n      }), o;\n    }\n\n    function Ge(e) {\n      e = e.slice();\n      const t = Object.create(null);\n\n      for (let i = 0; i < e.length; i++) t[e[i].id] = e[i];\n\n      for (let i = 0; i < e.length; i++) \"ref\" in e[i] && (e[i] = Ne(e[i], t[e[i].ref]));\n\n      return e;\n    }\n\n    Be.workerCount = 2;\n    const je = {\n      setStyle: \"setStyle\",\n      addLayer: \"addLayer\",\n      removeLayer: \"removeLayer\",\n      setPaintProperty: \"setPaintProperty\",\n      setLayoutProperty: \"setLayoutProperty\",\n      setFilter: \"setFilter\",\n      addSource: \"addSource\",\n      removeSource: \"removeSource\",\n      setGeoJSONSourceData: \"setGeoJSONSourceData\",\n      setLayerZoomRange: \"setLayerZoomRange\",\n      setLayerProperty: \"setLayerProperty\",\n      setCenter: \"setCenter\",\n      setZoom: \"setZoom\",\n      setBearing: \"setBearing\",\n      setPitch: \"setPitch\",\n      setSprite: \"setSprite\",\n      setGlyphs: \"setGlyphs\",\n      setTransition: \"setTransition\",\n      setLight: \"setLight\",\n      setTerrain: \"setTerrain\",\n      setFog: \"setFog\",\n      setProjection: \"setProjection\"\n    };\n\n    function Ze(e, t, i) {\n      i.push({\n        command: je.addSource,\n        args: [e, t[e]]\n      });\n    }\n\n    function Ve(e, t, i) {\n      t.push({\n        command: je.removeSource,\n        args: [e]\n      }), i[e] = !0;\n    }\n\n    function We(e, t, i, o) {\n      Ve(e, i, o), Ze(e, t, i);\n    }\n\n    function qe(e, t, i) {\n      let o;\n\n      for (o in e[i]) if (e[i].hasOwnProperty(o) && \"data\" !== o && !r(e[i][o], t[i][o])) return !1;\n\n      for (o in t[i]) if (t[i].hasOwnProperty(o) && \"data\" !== o && !r(e[i][o], t[i][o])) return !1;\n\n      return !0;\n    }\n\n    function Xe(e, t, i, o, n, a) {\n      let s;\n\n      for (s in t = t || {}, e = e || {}) e.hasOwnProperty(s) && (r(e[s], t[s]) || i.push({\n        command: a,\n        args: [o, s, t[s], n]\n      }));\n\n      for (s in t) t.hasOwnProperty(s) && !e.hasOwnProperty(s) && (r(e[s], t[s]) || i.push({\n        command: a,\n        args: [o, s, t[s], n]\n      }));\n    }\n\n    function $e(e) {\n      return e.id;\n    }\n\n    function He(e, t) {\n      return e[t.id] = t, e;\n    }\n\n    class Ke {\n      constructor(e, t) {\n        this.reset(e, t);\n      }\n\n      reset(e, t) {\n        this.points = e || [], this._distances = [0];\n\n        for (let e = 1; e < this.points.length; e++) this._distances[e] = this._distances[e - 1] + this.points[e].dist(this.points[e - 1]);\n\n        this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding;\n      }\n\n      lerp(t) {\n        if (1 === this.points.length) return this.points[0];\n        t = e.clamp(t, 0, 1);\n        let i = 1,\n            o = this._distances[i];\n        const r = t * this.paddedLength + this.padding;\n\n        for (; o < r && i < this._distances.length;) o = this._distances[++i];\n\n        const n = i - 1,\n              a = this._distances[n],\n              s = o - a,\n              l = s > 0 ? (r - a) / s : 0;\n        return this.points[n].mult(1 - l).add(this.points[i].mult(l));\n      }\n\n    }\n\n    class Ye {\n      constructor(e, t, i) {\n        const o = this.boxCells = [],\n              r = this.circleCells = [];\n        this.xCellCount = Math.ceil(e / i), this.yCellCount = Math.ceil(t / i);\n\n        for (let e = 0; e < this.xCellCount * this.yCellCount; e++) o.push([]), r.push([]);\n\n        this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = t, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / t, this.boxUid = 0, this.circleUid = 0;\n      }\n\n      keysLength() {\n        return this.boxKeys.length + this.circleKeys.length;\n      }\n\n      insert(e, t, i, o, r) {\n        this._forEachCell(t, i, o, r, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(t), this.bboxes.push(i), this.bboxes.push(o), this.bboxes.push(r);\n      }\n\n      insertCircle(e, t, i, o) {\n        this._forEachCell(t - o, i - o, t + o, i + o, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(t), this.circles.push(i), this.circles.push(o);\n      }\n\n      _insertBoxCell(e, t, i, o, r, n) {\n        this.boxCells[r].push(n);\n      }\n\n      _insertCircleCell(e, t, i, o, r, n) {\n        this.circleCells[r].push(n);\n      }\n\n      _query(e, t, i, o, r, n) {\n        if (i < 0 || e > this.width || o < 0 || t > this.height) return !r && [];\n        const a = [];\n\n        if (e <= 0 && t <= 0 && this.width <= i && this.height <= o) {\n          if (r) return !0;\n\n          for (let e = 0; e < this.boxKeys.length; e++) a.push({\n            key: this.boxKeys[e],\n            x1: this.bboxes[4 * e],\n            y1: this.bboxes[4 * e + 1],\n            x2: this.bboxes[4 * e + 2],\n            y2: this.bboxes[4 * e + 3]\n          });\n\n          for (let e = 0; e < this.circleKeys.length; e++) {\n            const t = this.circles[3 * e],\n                  i = this.circles[3 * e + 1],\n                  o = this.circles[3 * e + 2];\n            a.push({\n              key: this.circleKeys[e],\n              x1: t - o,\n              y1: i - o,\n              x2: t + o,\n              y2: i + o\n            });\n          }\n\n          return n ? a.filter(n) : a;\n        }\n\n        return this._forEachCell(e, t, i, o, this._queryCell, a, {\n          hitTest: r,\n          seenUids: {\n            box: {},\n            circle: {}\n          }\n        }, n), r ? a.length > 0 : a;\n      }\n\n      _queryCircle(e, t, i, o, r) {\n        const n = e - i,\n              a = e + i,\n              s = t - i,\n              l = t + i;\n        if (a < 0 || n > this.width || l < 0 || s > this.height) return !o && [];\n        const c = [];\n        return this._forEachCell(n, s, a, l, this._queryCellCircle, c, {\n          hitTest: o,\n          circle: {\n            x: e,\n            y: t,\n            radius: i\n          },\n          seenUids: {\n            box: {},\n            circle: {}\n          }\n        }, r), o ? c.length > 0 : c;\n      }\n\n      query(e, t, i, o, r) {\n        return this._query(e, t, i, o, !1, r);\n      }\n\n      hitTest(e, t, i, o, r) {\n        return this._query(e, t, i, o, !0, r);\n      }\n\n      hitTestCircle(e, t, i, o) {\n        return this._queryCircle(e, t, i, !0, o);\n      }\n\n      _queryCell(e, t, i, o, r, n, a, s) {\n        const l = a.seenUids,\n              c = this.boxCells[r];\n\n        if (null !== c) {\n          const r = this.bboxes;\n\n          for (const h of c) if (!l.box[h]) {\n            l.box[h] = !0;\n            const c = 4 * h;\n\n            if (e <= r[c + 2] && t <= r[c + 3] && i >= r[c + 0] && o >= r[c + 1] && (!s || s(this.boxKeys[h]))) {\n              if (a.hitTest) return n.push(!0), !0;\n              n.push({\n                key: this.boxKeys[h],\n                x1: r[c],\n                y1: r[c + 1],\n                x2: r[c + 2],\n                y2: r[c + 3]\n              });\n            }\n          }\n        }\n\n        const h = this.circleCells[r];\n\n        if (null !== h) {\n          const r = this.circles;\n\n          for (const c of h) if (!l.circle[c]) {\n            l.circle[c] = !0;\n            const h = 3 * c;\n\n            if (this._circleAndRectCollide(r[h], r[h + 1], r[h + 2], e, t, i, o) && (!s || s(this.circleKeys[c]))) {\n              if (a.hitTest) return n.push(!0), !0;\n              {\n                const e = r[h],\n                      t = r[h + 1],\n                      i = r[h + 2];\n                n.push({\n                  key: this.circleKeys[c],\n                  x1: e - i,\n                  y1: t - i,\n                  x2: e + i,\n                  y2: t + i\n                });\n              }\n            }\n          }\n        }\n      }\n\n      _queryCellCircle(e, t, i, o, r, n, a, s) {\n        const l = a.circle,\n              c = a.seenUids,\n              h = this.boxCells[r];\n\n        if (null !== h) {\n          const e = this.bboxes;\n\n          for (const t of h) if (!c.box[t]) {\n            c.box[t] = !0;\n            const i = 4 * t;\n            if (this._circleAndRectCollide(l.x, l.y, l.radius, e[i + 0], e[i + 1], e[i + 2], e[i + 3]) && (!s || s(this.boxKeys[t]))) return n.push(!0), !0;\n          }\n        }\n\n        const _ = this.circleCells[r];\n\n        if (null !== _) {\n          const e = this.circles;\n\n          for (const t of _) if (!c.circle[t]) {\n            c.circle[t] = !0;\n            const i = 3 * t;\n            if (this._circlesCollide(e[i], e[i + 1], e[i + 2], l.x, l.y, l.radius) && (!s || s(this.circleKeys[t]))) return n.push(!0), !0;\n          }\n        }\n      }\n\n      _forEachCell(e, t, i, o, r, n, a, s) {\n        const l = this._convertToXCellCoord(e),\n              c = this._convertToYCellCoord(t),\n              h = this._convertToXCellCoord(i),\n              _ = this._convertToYCellCoord(o);\n\n        for (let u = l; u <= h; u++) for (let l = c; l <= _; l++) if (r.call(this, e, t, i, o, this.xCellCount * l + u, n, a, s)) return;\n      }\n\n      _convertToXCellCoord(e) {\n        return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)));\n      }\n\n      _convertToYCellCoord(e) {\n        return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)));\n      }\n\n      _circlesCollide(e, t, i, o, r, n) {\n        const a = o - e,\n              s = r - t,\n              l = i + n;\n        return l * l > a * a + s * s;\n      }\n\n      _circleAndRectCollide(e, t, i, o, r, n, a) {\n        const s = (n - o) / 2,\n              l = Math.abs(e - (o + s));\n        if (l > s + i) return !1;\n        const c = (a - r) / 2,\n              h = Math.abs(t - (r + c));\n        if (h > c + i) return !1;\n        if (l <= s || h <= c) return !0;\n\n        const _ = l - s,\n              u = h - c;\n\n        return _ * _ + u * u <= i * i;\n      }\n\n    }\n\n    const Je = Math.tan(85 * Math.PI / 180);\n\n    function Qe(t, i, o, r, n, a) {\n      const s = e.create();\n\n      if (o) {\n        if (\"globe\" === n.projection.name) e.multiply$1(s, s, e.calculateGlobeLabelMatrix(n, i));else {\n          const e = v([], a);\n          s[0] = e[0], s[1] = e[1], s[4] = e[2], s[5] = e[3];\n        }\n        r || e.rotateZ(s, s, n.angle);\n      } else e.multiply$1(s, n.labelPlaneMatrix, t);\n\n      return s;\n    }\n\n    function et(t, i, o, r, n, a) {\n      if (o) {\n        if (\"globe\" === n.projection.name) {\n          const s = Qe(t, i, o, r, n, a);\n          return e.invert(s, s), e.multiply$1(s, t, s), s;\n        }\n\n        {\n          const i = e.clone(t),\n                o = e.identity([]);\n          return o[0] = a[0], o[1] = a[1], o[4] = a[2], o[5] = a[3], e.multiply$1(i, i, o), r || e.rotateZ(i, i, -n.angle), i;\n        }\n      }\n\n      return n.glCoordMatrix;\n    }\n\n    function tt(t, i, o = 0) {\n      const r = [t.x, t.y, o, 1];\n      o ? e.transformMat4$1(r, r, i) : pt(r, r, i);\n      const n = r[3];\n      return {\n        point: new e.pointGeometry(r[0] / n, r[1] / n),\n        signedDistanceFromCamera: n\n      };\n    }\n\n    function it(t, i) {\n      const o = [t[0], t[1], t[2], 1];\n      e.transformMat4$1(o, o, i);\n      const r = o[3];\n      return {\n        point: new e.pointGeometry(o[0] / r, o[1] / r),\n        signedDistanceFromCamera: r\n      };\n    }\n\n    function ot(e, t) {\n      return Math.min(.5 + e / t * .5, 1.5);\n    }\n\n    function rt(e, t) {\n      const i = e[0] / e[3],\n            o = e[1] / e[3];\n      return i >= -t[0] && i <= t[0] && o >= -t[1] && o <= t[1];\n    }\n\n    function nt(t, i, o, r, n, a, s, l, c, h) {\n      const _ = o.transform,\n            u = r ? t.textSizeData : t.iconSizeData,\n            d = e.evaluateSizeForZoom(u, o.transform.zoom),\n            p = [256 / o.width * 2 + 1, 256 / o.height * 2 + 1],\n            m = r ? t.text.dynamicLayoutVertexArray : t.icon.dynamicLayoutVertexArray;\n      m.clear();\n      const f = t.lineVertexArray,\n            g = r ? t.text.placedSymbolArray : t.icon.placedSymbolArray,\n            v = o.transform.width / o.transform.height;\n      let x = !1;\n\n      for (let r = 0; r < g.length; r++) {\n        const y = g.get(r);\n\n        if (y.writingMode !== e.WritingMode.vertical || x || 0 !== r && g.get(r - 1).writingMode === e.WritingMode.horizontal || (x = !0), (y.hidden || y.writingMode === e.WritingMode.vertical) && !x) {\n          dt(y.numGlyphs, m);\n          continue;\n        }\n\n        x = !1;\n\n        const b = new e.pointGeometry(y.tileAnchorX, y.tileAnchorY),\n              w = c ? c(b) : [0, 0, 0],\n              T = _.projection.projectTilePoint(b.x, b.y, h.canonical),\n              E = [T.x + w[0], T.y + w[1], T.z + w[2]],\n              C = [...E, 1];\n\n        if (e.transformMat4$1(C, C, i), !rt(C, p)) {\n          dt(y.numGlyphs, m);\n          continue;\n        }\n\n        const I = ot(o.transform.cameraToCenterDistance, C[3]),\n              M = e.evaluateSizeForFeature(u, d, y),\n              S = s ? M / I : M * I,\n              z = tt(new e.pointGeometry(E[0], E[1]), n, E[2]);\n\n        if (z.signedDistanceFromCamera <= 0) {\n          dt(y.numGlyphs, m);\n          continue;\n        }\n\n        let D = {};\n        const P = s ? null : c,\n              A = lt(y, S, !1, l, i, n, a, t.glyphOffsetArray, f, m, z.point, b, D, v, P, _.projection, h);\n        x = A.useVertical, P && A.needsFlipping && (D = {}), (A.notEnoughRoom || x || A.needsFlipping && lt(y, S, !0, l, i, n, a, t.glyphOffsetArray, f, m, z.point, b, D, v, P, _.projection, h).notEnoughRoom) && dt(y.numGlyphs, m);\n      }\n\n      r ? t.text.dynamicLayoutVertexBuffer.updateData(m) : t.icon.dynamicLayoutVertexBuffer.updateData(m);\n    }\n\n    function at(e, t, i, o, r, n, a, s, l, c, h, _, u, d, p) {\n      const m = s.glyphStartIndex + s.numGlyphs,\n            f = s.lineStartIndex,\n            g = s.lineStartIndex + s.lineLength,\n            v = t.getoffsetX(s.glyphStartIndex),\n            x = t.getoffsetX(m - 1),\n            y = _t(e * v, i, o, r, n, a, s.segment, f, g, l, c, h, _, u, !0, d, p);\n\n      if (!y) return null;\n\n      const b = _t(e * x, i, o, r, n, a, s.segment, f, g, l, c, h, _, u, !0, d, p);\n\n      return b ? {\n        first: y,\n        last: b\n      } : null;\n    }\n\n    function st(t, i, o, r) {\n      return t.writingMode === e.WritingMode.horizontal && Math.abs(o.y - i.y) > Math.abs(o.x - i.x) * r ? {\n        useVertical: !0\n      } : t.writingMode === e.WritingMode.vertical ? i.y < o.y ? {\n        needsFlipping: !0\n      } : null : 0 !== t.flipState && function (e, t, i) {\n        const o = (t.x - e.x) * i;\n        return 0 === o || Math.abs((t.y - e.y) / o) > Je;\n      }(i, o, r) ? 1 === t.flipState ? {\n        needsFlipping: !0\n      } : null : i.x > o.x ? {\n        needsFlipping: !0\n      } : null;\n    }\n\n    function lt(t, i, o, r, n, a, s, l, c, h, _, u, d, p, m, f, g) {\n      const v = i / 24,\n            x = t.lineOffsetX * v,\n            y = t.lineOffsetY * v;\n      let b;\n\n      if (t.numGlyphs > 1) {\n        const e = t.glyphStartIndex + t.numGlyphs,\n              i = t.lineStartIndex,\n              n = t.lineStartIndex + t.lineLength,\n              h = at(v, l, x, y, o, _, u, t, c, a, d, m, !1, f, g);\n        if (!h) return {\n          notEnoughRoom: !0\n        };\n        const w = tt(h.first.point, s).point,\n              T = tt(h.last.point, s).point;\n\n        if (r && !o) {\n          const e = st(t, w, T, p);\n          if (t.flipState = e && e.needsFlipping ? 1 : 2, e) return e;\n        }\n\n        b = [h.first];\n\n        for (let r = t.glyphStartIndex + 1; r < e - 1; r++) b.push(_t(v * l.getoffsetX(r), x, y, o, _, u, t.segment, i, n, c, a, d, m, !1, !1, f, g));\n\n        b.push(h.last);\n      } else {\n        if (r && !o) {\n          const i = tt(u, n).point,\n                o = t.lineStartIndex + t.segment + 1,\n                r = new e.pointGeometry(c.getx(o), c.gety(o)),\n                a = tt(r, n),\n                s = st(t, i, a.signedDistanceFromCamera > 0 ? a.point : ht(u, r, i, 1, n, void 0, f, g.canonical), p);\n          if (t.flipState = s && s.needsFlipping ? 1 : 2, s) return s;\n        }\n\n        const i = _t(v * l.getoffsetX(t.glyphStartIndex), x, y, o, _, u, t.segment, t.lineStartIndex, t.lineStartIndex + t.lineLength, c, a, d, m, !1, !1, f, g);\n\n        if (!i) return {\n          notEnoughRoom: !0\n        };\n        b = [i];\n      }\n\n      for (const t of b) e.addDynamicAttributes(h, t.point, t.angle);\n\n      return {};\n    }\n\n    function ct(t, i, o, r, n) {\n      const a = r.projectTilePoint(t.x, t.y, i);\n      if (!n) return tt(a, o, a.z);\n      const s = n(t);\n      return tt(new e.pointGeometry(a.x + s[0], a.y + s[1]), o, a.z + s[2]);\n    }\n\n    function ht(e, t, i, o, r, n, a, s) {\n      const l = ct(e.add(e.sub(t)._unit()), s, r, a, n).point,\n            c = i.sub(l);\n      return i.add(c._mult(o / c.mag()));\n    }\n\n    function _t(t, i, o, r, n, a, s, l, c, h, _, u, d, p, m, f, g) {\n      const v = r ? t - i : t + i;\n      let x = v > 0 ? 1 : -1,\n          y = 0;\n      r && (x *= -1, y = Math.PI), x < 0 && (y += Math.PI);\n      let b = x > 0 ? l + s : l + s + 1,\n          w = n,\n          T = n,\n          E = 0,\n          C = 0;\n      const I = Math.abs(v),\n            M = [],\n            S = [];\n      let z = a;\n\n      const D = () => {\n        const t = b - x;\n        return 0 === E ? a : new e.pointGeometry(h.getx(t), h.gety(t));\n      },\n            P = () => ht(D(), z, T, I - E + 1, _, d, f, g.canonical);\n\n      for (; E + C <= I;) {\n        if (b += x, b < l || b >= c) return null;\n\n        if (T = w, M.push(w), p && S.push(z || D()), w = u[b], void 0 === w) {\n          z = new e.pointGeometry(h.getx(b), h.gety(b));\n          const t = ct(z, g.canonical, _, f, d);\n          w = t.signedDistanceFromCamera > 0 ? u[b] = t.point : P();\n        } else z = null;\n\n        E += C, C = T.dist(w);\n      }\n\n      m && d && (z = z || new e.pointGeometry(h.getx(b), h.gety(b)), u[b] = w = void 0 === u[b] ? w : P(), C = T.dist(w));\n\n      const A = (I - E) / C,\n            L = w.sub(T),\n            R = L.mult(A)._add(T);\n\n      o && R._add(L._unit()._perp()._mult(o * x));\n      const k = y + Math.atan2(w.y - T.y, w.x - T.x);\n      return M.push(R), p && (z = z || new e.pointGeometry(h.getx(b), h.gety(b)), S.push(function (t, i, o) {\n        const r = 1 - o;\n        return new e.pointGeometry(t.x * r + i.x * o, t.y * r + i.y * o);\n      }(S.length > 0 ? S[S.length - 1] : z, z, A))), {\n        point: R,\n        angle: k,\n        path: M,\n        tilePath: S\n      };\n    }\n\n    const ut = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);\n\n    function dt(e, t) {\n      for (let i = 0; i < e; i++) {\n        const e = t.length;\n        t.resize(e + 4), t.float32.set(ut, 3 * e);\n      }\n    }\n\n    function pt(e, t, i) {\n      const o = t[0],\n            r = t[1];\n      return e[0] = i[0] * o + i[4] * r + i[12], e[1] = i[1] * o + i[5] * r + i[13], e[3] = i[3] * o + i[7] * r + i[15], e;\n    }\n\n    const mt = 100;\n\n    class ft {\n      constructor(e, t, i = new Ye(e.width + 200, e.height + 200, 25), o = new Ye(e.width + 200, e.height + 200, 25)) {\n        this.transform = e, this.grid = i, this.ignoredGrid = o, this.pitchfactor = Math.cos(e._pitch) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + mt, this.screenBottomBoundary = e.height + mt, this.gridRightBoundary = e.width + 200, this.gridBottomBoundary = e.height + 200, this.fogState = t;\n      }\n\n      placeCollisionBox(e, t, i, o, r, n, a) {\n        let s = t.projectedAnchorX,\n            l = t.projectedAnchorY,\n            c = t.projectedAnchorZ;\n        const h = t.elevation,\n              _ = t.tileID;\n\n        if (h && _) {\n          const e = this.transform.projection.upVector(_.canonical, t.tileAnchorX, t.tileAnchorY),\n                i = this.transform.projection.upVectorScale(_.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile;\n          s += e[0] * h * i, l += e[1] * h * i, c += e[2] * h * i;\n        }\n\n        const u = this.projectAndGetPerspectiveRatio(n, [s, l, c], t.tileID, \"globe\" === this.transform.projection.name || !!h || this.transform.pitch > 0),\n              d = r * u.perspectiveRatio,\n              p = (t.x1 * e + i.x - t.padding) * d + u.point.x,\n              m = (t.y1 * e + i.y - t.padding) * d + u.point.y,\n              f = (t.x2 * e + i.x + t.padding) * d + u.point.x,\n              g = (t.y2 * e + i.y + t.padding) * d + u.point.y,\n              v = u.perspectiveRatio <= .55 || u.occluded;\n        return !this.isInsideGrid(p, m, f, g) || !o && this.grid.hitTest(p, m, f, g, a) || v ? {\n          box: [],\n          offscreen: !1,\n          occluded: u.occluded\n        } : {\n          box: [p, m, f, g],\n          offscreen: this.isOffscreen(p, m, f, g),\n          occluded: !1\n        };\n      }\n\n      placeCollisionCircles(t, i, o, r, n, a, s, l, c, h, _, u, d, p) {\n        const m = [],\n              f = this.transform.elevation,\n              g = f ? f.getAtTileOffsetFunc(p, this.transform.center.lat, this.transform.worldSize, this.transform.projection) : e => [0, 0, 0],\n              v = new e.pointGeometry(i.tileAnchorX, i.tileAnchorY),\n              x = this.transform.projection.projectTilePoint(i.tileAnchorX, i.tileAnchorY, p.canonical),\n              y = g(v),\n              b = [x.x + y[0], x.y + y[1], x.z + y[2]],\n              w = this.projectAndGetPerspectiveRatio(a, [b[0], b[1], b[2]], p, \"globe\" === this.transform.projection.name || !!f || this.transform.pitch > 0),\n              {\n          perspectiveRatio: T\n        } = w,\n              E = (h ? n / T : n * T) / e.ONE_EM,\n              C = tt(new e.pointGeometry(b[0], b[1]), s, b[2]).point,\n              I = w.signedDistanceFromCamera > 0 ? at(E, r, i.lineOffsetX * E, i.lineOffsetY * E, !1, C, v, i, o, s, {}, f && !h ? g : null, h && !!f, this.transform.projection, p) : null;\n        let M = !1,\n            S = !1,\n            z = !0;\n\n        if (I && !w.occluded) {\n          const i = .5 * u * T + d,\n                o = new e.pointGeometry(-100, -100),\n                r = new e.pointGeometry(this.screenRightBoundary, this.screenBottomBoundary),\n                n = new Ke(),\n                a = I.first,\n                s = I.last;\n          let h = [];\n\n          for (let e = a.path.length - 1; e >= 1; e--) h.push(a.path[e]);\n\n          for (let e = 1; e < s.path.length; e++) h.push(s.path[e]);\n\n          const p = 2.5 * i;\n\n          if (l) {\n            const e = h.map(f ? (e, t) => {\n              const i = g(t < a.path.length - 1 ? a.tilePath[a.path.length - 1 - t] : s.tilePath[t - a.path.length + 2]);\n              return tt(e, l, i[2]);\n            } : e => tt(e, l));\n            h = e.some(e => e.signedDistanceFromCamera <= 0) ? [] : e.map(e => e.point);\n          }\n\n          let v = [];\n\n          if (h.length > 0) {\n            const t = h[0].clone(),\n                  i = h[0].clone();\n\n            for (let e = 1; e < h.length; e++) t.x = Math.min(t.x, h[e].x), t.y = Math.min(t.y, h[e].y), i.x = Math.max(i.x, h[e].x), i.y = Math.max(i.y, h[e].y);\n\n            v = t.x >= o.x && i.x <= r.x && t.y >= o.y && i.y <= r.y ? [h] : i.x < o.x || t.x > r.x || i.y < o.y || t.y > r.y ? [] : e.clipLine([h], o.x, o.y, r.x, r.y);\n          }\n\n          for (const e of v) {\n            n.reset(e, .25 * i);\n            let o = 0;\n            o = n.length <= .5 * i ? 1 : Math.ceil(n.paddedLength / p) + 1;\n\n            for (let e = 0; e < o; e++) {\n              const r = e / Math.max(o - 1, 1),\n                    a = n.lerp(r),\n                    s = a.x + mt,\n                    l = a.y + mt;\n              m.push(s, l, i, 0);\n              const h = s - i,\n                    u = l - i,\n                    d = s + i,\n                    p = l + i;\n              if (z = z && this.isOffscreen(h, u, d, p), S = S || this.isInsideGrid(h, u, d, p), !t && this.grid.hitTestCircle(s, l, i, _) && (M = !0, !c)) return {\n                circles: [],\n                offscreen: !1,\n                collisionDetected: M,\n                occluded: !1\n              };\n            }\n          }\n        }\n\n        return {\n          circles: !c && M || !S ? [] : m,\n          offscreen: z,\n          collisionDetected: M,\n          occluded: w.occluded\n        };\n      }\n\n      queryRenderedSymbols(t) {\n        if (0 === t.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()) return {};\n        const i = [];\n        let o = 1 / 0,\n            r = 1 / 0,\n            n = -1 / 0,\n            a = -1 / 0;\n\n        for (const s of t) {\n          const t = new e.pointGeometry(s.x + mt, s.y + mt);\n          o = Math.min(o, t.x), r = Math.min(r, t.y), n = Math.max(n, t.x), a = Math.max(a, t.y), i.push(t);\n        }\n\n        const s = this.grid.query(o, r, n, a).concat(this.ignoredGrid.query(o, r, n, a)),\n              l = {},\n              c = {};\n\n        for (const t of s) {\n          const o = t.key;\n          if (void 0 === l[o.bucketInstanceId] && (l[o.bucketInstanceId] = {}), l[o.bucketInstanceId][o.featureIndex]) continue;\n          const r = [new e.pointGeometry(t.x1, t.y1), new e.pointGeometry(t.x2, t.y1), new e.pointGeometry(t.x2, t.y2), new e.pointGeometry(t.x1, t.y2)];\n          e.polygonIntersectsPolygon(i, r) && (l[o.bucketInstanceId][o.featureIndex] = !0, void 0 === c[o.bucketInstanceId] && (c[o.bucketInstanceId] = []), c[o.bucketInstanceId].push(o.featureIndex));\n        }\n\n        return c;\n      }\n\n      insertCollisionBox(e, t, i, o, r) {\n        (t ? this.ignoredGrid : this.grid).insert({\n          bucketInstanceId: i,\n          featureIndex: o,\n          collisionGroupID: r\n        }, e[0], e[1], e[2], e[3]);\n      }\n\n      insertCollisionCircles(e, t, i, o, r) {\n        const n = t ? this.ignoredGrid : this.grid,\n              a = {\n          bucketInstanceId: i,\n          featureIndex: o,\n          collisionGroupID: r\n        };\n\n        for (let t = 0; t < e.length; t += 4) n.insertCircle(a, e[t], e[t + 1], e[t + 2]);\n      }\n\n      projectAndGetPerspectiveRatio(t, i, o, r) {\n        const n = [i[0], i[1], i[2], 1];\n        let a = !1;\n        return i[2] || this.transform.pitch > 0 ? (e.transformMat4$1(n, n, t), this.fogState && o && (a = function (t, i, o, r, n, a) {\n          const s = a.calculateFogTileMatrix(n),\n                l = [i, o, r];\n          return e.transformMat4(l, l, s), M(t, l, a.pitch, a._fov);\n        }(this.fogState, i[0], i[1], i[2], o.toUnwrapped(), this.transform) > .9)) : pt(n, n, t), {\n          point: new e.pointGeometry((n[0] / n[3] + 1) / 2 * this.transform.width + mt, (-n[1] / n[3] + 1) / 2 * this.transform.height + mt),\n          perspectiveRatio: Math.min(.5 + this.transform.cameraToCenterDistance / n[3] * .5, 1.5),\n          signedDistanceFromCamera: n[3],\n          occluded: r && n[2] > n[3] || a\n        };\n      }\n\n      isOffscreen(e, t, i, o) {\n        return i < mt || e >= this.screenRightBoundary || o < mt || t > this.screenBottomBoundary;\n      }\n\n      isInsideGrid(e, t, i, o) {\n        return i >= 0 && e < this.gridRightBoundary && o >= 0 && t < this.gridBottomBoundary;\n      }\n\n      getViewportMatrix() {\n        const t = e.identity([]);\n        return e.translate(t, t, [-100, -100, 0]), t;\n      }\n\n    }\n\n    class gt {\n      constructor(e, t, i, o) {\n        this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? t : -t))) : o && i ? 1 : 0, this.placed = i;\n      }\n\n      isHidden() {\n        return 0 === this.opacity && !this.placed;\n      }\n\n    }\n\n    class vt {\n      constructor(e, t, i, o, r, n = !1) {\n        this.text = new gt(e ? e.text : null, t, i, r), this.icon = new gt(e ? e.icon : null, t, o, r), this.clipped = n;\n      }\n\n      isHidden() {\n        return this.text.isHidden() && this.icon.isHidden();\n      }\n\n    }\n\n    class xt {\n      constructor(e, t, i, o = !1) {\n        this.text = e, this.icon = t, this.skipFade = i, this.clipped = o;\n      }\n\n    }\n\n    class yt {\n      constructor() {\n        this.invProjMatrix = e.create(), this.viewportMatrix = e.create(), this.circles = [];\n      }\n\n    }\n\n    class bt {\n      constructor(e, t, i, o, r) {\n        this.bucketInstanceId = e, this.featureIndex = t, this.sourceLayerIndex = i, this.bucketIndex = o, this.tileID = r;\n      }\n\n    }\n\n    class wt {\n      constructor(e) {\n        this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {};\n      }\n\n      get(e) {\n        if (this.crossSourceCollisions) return {\n          ID: 0,\n          predicate: null\n        };\n\n        if (!this.collisionGroups[e]) {\n          const t = ++this.maxGroupID;\n          this.collisionGroups[e] = {\n            ID: t,\n            predicate: e => e.collisionGroupID === t\n          };\n        }\n\n        return this.collisionGroups[e];\n      }\n\n    }\n\n    function Tt(t, i, o, r, n) {\n      const {\n        horizontalAlign: a,\n        verticalAlign: s\n      } = e.getAnchorAlignment(t),\n            l = -(a - .5) * i,\n            c = -(s - .5) * o,\n            h = e.evaluateVariableOffset(t, r);\n      return new e.pointGeometry(l + h[0] * n, c + h[1] * n);\n    }\n\n    function Et(t, i, o, r, n) {\n      const a = new e.pointGeometry(t, i);\n      return o && a._rotate(r ? n : -n), a;\n    }\n\n    class Ct {\n      constructor(e, t, i, o, r) {\n        this.transform = e.clone(), this.collisionIndex = new ft(this.transform, r), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = t, this.retainedQueryData = {}, this.collisionGroups = new wt(i), this.collisionCircleArrays = {}, this.prevPlacement = o, o && (o.prevPlacement = void 0), this.placedOrientations = {};\n      }\n\n      getBucketParts(t, i, o, r) {\n        const n = o.getBucket(i),\n              a = o.latestFeatureIndex;\n        if (!n || !a || i.id !== n.layerIds[0]) return;\n\n        const s = n.layers[0].layout,\n              l = o.collisionBoxArray,\n              c = Math.pow(2, this.transform.zoom - o.tileID.overscaledZ),\n              h = o.tileSize / e.EXTENT,\n              _ = o.tileID.toUnwrapped(),\n              u = this.transform.calculateProjMatrix(_),\n              d = \"map\" === s.get(\"text-pitch-alignment\"),\n              p = \"map\" === s.get(\"text-rotation-alignment\");\n\n        i.compileFilter();\n        const m = i.dynamicFilter(),\n              f = i.dynamicFilterNeedsFeature(),\n              g = this.transform.calculatePixelsToTileUnitsMatrix(o),\n              v = Qe(u, o.tileID.canonical, d, p, this.transform, g);\n        let x = null;\n\n        if (d) {\n          const t = et(u, o.tileID.canonical, d, p, this.transform, g);\n          x = e.multiply$1([], this.transform.labelPlaneMatrix, t);\n        }\n\n        let y = null;\n        m && o.latestFeatureIndex && (y = {\n          unwrappedTileID: _,\n          dynamicFilter: m,\n          dynamicFilterNeedsFeature: f,\n          featureIndex: o.latestFeatureIndex\n        }), this.retainedQueryData[n.bucketInstanceId] = new bt(n.bucketInstanceId, a, n.sourceLayerIndex, n.index, o.tileID);\n        const b = {\n          bucket: n,\n          layout: s,\n          posMatrix: u,\n          textLabelPlaneMatrix: v,\n          labelToScreenMatrix: x,\n          clippingData: y,\n          scale: c,\n          textPixelRatio: h,\n          holdingForFade: o.holdingForFade(),\n          collisionBoxArray: l,\n          partiallyEvaluatedTextSize: e.evaluateSizeForZoom(n.textSizeData, this.transform.zoom),\n          partiallyEvaluatedIconSize: e.evaluateSizeForZoom(n.iconSizeData, this.transform.zoom),\n          collisionGroup: this.collisionGroups.get(n.sourceID)\n        };\n        if (r) for (const e of n.sortKeyRanges) {\n          const {\n            sortKey: i,\n            symbolInstanceStart: o,\n            symbolInstanceEnd: r\n          } = e;\n          t.push({\n            sortKey: i,\n            symbolInstanceStart: o,\n            symbolInstanceEnd: r,\n            parameters: b\n          });\n        } else t.push({\n          symbolInstanceStart: 0,\n          symbolInstanceEnd: n.symbolInstances.length,\n          parameters: b\n        });\n      }\n\n      attemptAnchorPlacement(e, t, i, o, r, n, a, s, l, c, h, _, u, d, p, m, f, g) {\n        const v = [_.textOffset0, _.textOffset1],\n              x = Tt(e, i, o, v, r),\n              y = this.collisionIndex.placeCollisionBox(r, t, Et(x.x, x.y, n, a, this.transform.angle), h, s, l, c.predicate);\n\n        if ((!m || 0 !== this.collisionIndex.placeCollisionBox(d.getSymbolInstanceIconSize(g, this.transform.zoom, u), m, Et(x.x, x.y, n, a, this.transform.angle), h, s, l, c.predicate).box.length) && y.box.length > 0) {\n          let t;\n          return this.prevPlacement && this.prevPlacement.variableOffsets[_.crossTileID] && this.prevPlacement.placements[_.crossTileID] && this.prevPlacement.placements[_.crossTileID].text && (t = this.prevPlacement.variableOffsets[_.crossTileID].anchor), this.variableOffsets[_.crossTileID] = {\n            textOffset: v,\n            width: i,\n            height: o,\n            anchor: e,\n            textScale: r,\n            prevAnchor: t\n          }, this.markUsedJustification(d, e, _, p), d.allowVerticalPlacement && (this.markUsedOrientation(d, p, _), this.placedOrientations[_.crossTileID] = p), {\n            shift: x,\n            placedGlyphBoxes: y\n          };\n        }\n      }\n\n      placeLayerBucketPart(t, i, o, r) {\n        const {\n          bucket: n,\n          layout: a,\n          posMatrix: s,\n          textLabelPlaneMatrix: l,\n          labelToScreenMatrix: c,\n          clippingData: h,\n          textPixelRatio: _,\n          holdingForFade: u,\n          collisionBoxArray: d,\n          partiallyEvaluatedTextSize: p,\n          partiallyEvaluatedIconSize: m,\n          collisionGroup: f\n        } = t.parameters,\n              g = a.get(\"text-optional\"),\n              v = a.get(\"icon-optional\"),\n              x = a.get(\"text-allow-overlap\"),\n              y = a.get(\"icon-allow-overlap\"),\n              b = \"map\" === a.get(\"text-rotation-alignment\"),\n              w = \"map\" === a.get(\"text-pitch-alignment\"),\n              T = \"none\" !== a.get(\"icon-text-fit\"),\n              E = \"viewport-y\" === a.get(\"symbol-z-order\");\n        let C = x && (y || !n.hasIconData() || v),\n            I = y && (x || !n.hasTextData() || g);\n        !n.collisionArrays && d && n.deserializeCollisionBoxes(d), o && r && n.updateCollisionDebugBuffers(this.transform.zoom, d);\n\n        const M = (t, r, d) => {\n          if (h) {\n            const o = {\n              zoom: this.transform.zoom,\n              pitch: this.transform.pitch\n            };\n            let r = null;\n\n            if (h.dynamicFilterNeedsFeature) {\n              const e = this.retainedQueryData[n.bucketInstanceId];\n              r = h.featureIndex.loadFeature({\n                featureIndex: t.featureIndex,\n                bucketIndex: e.bucketIndex,\n                sourceLayerIndex: e.sourceLayerIndex,\n                layoutVertexArrayOffset: 0\n              });\n            }\n\n            if (!(0, h.dynamicFilter)(o, r, this.retainedQueryData[n.bucketInstanceId].tileID.canonical, new e.pointGeometry(t.tileAnchorX, t.tileAnchorY), this.transform.calculateDistanceTileData(h.unwrappedTileID))) return this.placements[t.crossTileID] = new xt(!1, !1, !1, !0), void (i[t.crossTileID] = !0);\n          }\n\n          if (i[t.crossTileID]) return;\n          if (u) return void (this.placements[t.crossTileID] = new xt(!1, !1, !1));\n          let E = !1,\n              M = !1,\n              S = !0,\n              z = !1,\n              D = !1,\n              P = null,\n              A = {\n            box: null,\n            offscreen: null,\n            occluded: null\n          },\n              L = {\n            box: null,\n            offscreen: null,\n            occluded: null\n          },\n              R = null,\n              k = null,\n              O = null,\n              B = 0,\n              F = 0,\n              U = 0;\n          d.textFeatureIndex ? B = d.textFeatureIndex : t.useRuntimeCollisionCircles && (B = t.featureIndex), d.verticalTextFeatureIndex && (F = d.verticalTextFeatureIndex);\n\n          const N = e => {\n            e.tileID = this.retainedQueryData[n.bucketInstanceId].tileID, (this.transform.elevation || e.elevation) && (e.elevation = this.transform.elevation ? this.transform.elevation.getAtTileOffset(this.retainedQueryData[n.bucketInstanceId].tileID, e.tileAnchorX, e.tileAnchorY) : 0);\n          },\n                G = d.textBox;\n\n          if (G) {\n            N(G);\n\n            const i = i => {\n              let o = e.WritingMode.horizontal;\n\n              if (n.allowVerticalPlacement && !i && this.prevPlacement) {\n                const e = this.prevPlacement.placedOrientations[t.crossTileID];\n                e && (this.placedOrientations[t.crossTileID] = e, o = e, this.markUsedOrientation(n, o, t));\n              }\n\n              return o;\n            },\n                  o = (i, o) => {\n              if (n.allowVerticalPlacement && t.numVerticalGlyphVertices > 0 && d.verticalTextBox) {\n                for (const t of n.writingModes) if (t === e.WritingMode.vertical ? (A = o(), L = A) : A = i(), A && A.box && A.box.length) break;\n              } else A = i();\n            };\n\n            if (a.get(\"text-variable-anchor\")) {\n              let l = a.get(\"text-variable-anchor\");\n\n              if (this.prevPlacement && this.prevPlacement.variableOffsets[t.crossTileID]) {\n                const e = this.prevPlacement.variableOffsets[t.crossTileID];\n                l.indexOf(e.anchor) > 0 && (l = l.filter(t => t !== e.anchor), l.unshift(e.anchor));\n              }\n\n              const c = (e, i, o) => {\n                const a = n.getSymbolInstanceTextSize(p, t, this.transform.zoom, r),\n                      c = (e.x2 - e.x1) * a + 2 * e.padding,\n                      h = (e.y2 - e.y1) * a + 2 * e.padding,\n                      u = T && !y ? i : null;\n                u && N(u);\n                let d = {\n                  box: [],\n                  offscreen: !1,\n                  occluded: !1\n                };\n                const g = x ? 2 * l.length : l.length;\n\n                for (let i = 0; i < g; ++i) {\n                  const g = this.attemptAnchorPlacement(l[i % l.length], e, c, h, a, b, w, _, s, f, i >= l.length, t, r, n, o, u, p, m);\n\n                  if (g && (d = g.placedGlyphBoxes, d && d.box && d.box.length)) {\n                    E = !0, P = g.shift;\n                    break;\n                  }\n                }\n\n                return d;\n              };\n\n              o(() => c(G, d.iconBox, e.WritingMode.horizontal), () => {\n                const i = d.verticalTextBox;\n                return i && N(i), n.allowVerticalPlacement && !(A && A.box && A.box.length) && t.numVerticalGlyphVertices > 0 && i ? c(i, d.verticalIconBox, e.WritingMode.vertical) : {\n                  box: null,\n                  offscreen: null,\n                  occluded: null\n                };\n              }), A && (E = A.box, S = A.offscreen, z = A.occluded);\n              const h = i(A && A.box);\n\n              if (!E && this.prevPlacement) {\n                const e = this.prevPlacement.variableOffsets[t.crossTileID];\n                e && (this.variableOffsets[t.crossTileID] = e, this.markUsedJustification(n, e.anchor, t, h));\n              }\n            } else {\n              const a = (i, o) => {\n                const a = n.getSymbolInstanceTextSize(p, t, this.transform.zoom, r),\n                      l = this.collisionIndex.placeCollisionBox(a, i, new e.pointGeometry(0, 0), x, _, s, f.predicate);\n                return l && l.box && l.box.length && (this.markUsedOrientation(n, o, t), this.placedOrientations[t.crossTileID] = o), l;\n              };\n\n              o(() => a(G, e.WritingMode.horizontal), () => {\n                const i = d.verticalTextBox;\n                return n.allowVerticalPlacement && t.numVerticalGlyphVertices > 0 && i ? (N(i), a(i, e.WritingMode.vertical)) : {\n                  box: null,\n                  offscreen: null,\n                  occluded: null\n                };\n              }), i(A && A.box && A.box.length);\n            }\n          }\n\n          if (R = A, E = R && R.box && R.box.length > 0, S = R && R.offscreen, z = R && R.occluded, t.useRuntimeCollisionCircles) {\n            const i = n.text.placedSymbolArray.get(t.centerJustifiedTextSymbolIndex >= 0 ? t.centerJustifiedTextSymbolIndex : t.verticalPlacedTextSymbolIndex),\n                  r = e.evaluateSizeForFeature(n.textSizeData, p, i),\n                  h = a.get(\"text-padding\");\n            k = this.collisionIndex.placeCollisionCircles(x, i, n.lineVertexArray, n.glyphOffsetArray, r, s, l, c, o, w, f.predicate, t.collisionCircleDiameter * r / e.ONE_EM, h, this.retainedQueryData[n.bucketInstanceId].tileID), E = x || k.circles.length > 0 && !k.collisionDetected, S = S && k.offscreen, z = k.occluded;\n          }\n\n          if (d.iconFeatureIndex && (U = d.iconFeatureIndex), d.iconBox) {\n            const t = t => {\n              N(t);\n              const i = T && P ? Et(P.x, P.y, b, w, this.transform.angle) : new e.pointGeometry(0, 0),\n                    o = n.getSymbolInstanceIconSize(m, this.transform.zoom, r);\n              return this.collisionIndex.placeCollisionBox(o, t, i, y, _, s, f.predicate);\n            };\n\n            L && L.box && L.box.length && d.verticalIconBox ? (O = t(d.verticalIconBox), M = O.box.length > 0) : (O = t(d.iconBox), M = O.box.length > 0), S = S && O.offscreen, D = O.occluded;\n          }\n\n          const j = g || 0 === t.numHorizontalGlyphVertices && 0 === t.numVerticalGlyphVertices,\n                Z = v || 0 === t.numIconVertices;\n\n          if (j || Z ? Z ? j || (M = M && E) : E = M && E : M = E = M && E, E && R && R.box && this.collisionIndex.insertCollisionBox(R.box, a.get(\"text-ignore-placement\"), n.bucketInstanceId, L && L.box && F ? F : B, f.ID), M && O && this.collisionIndex.insertCollisionBox(O.box, a.get(\"icon-ignore-placement\"), n.bucketInstanceId, U, f.ID), k && (E && this.collisionIndex.insertCollisionCircles(k.circles, a.get(\"text-ignore-placement\"), n.bucketInstanceId, B, f.ID), o)) {\n            const e = n.bucketInstanceId;\n            let t = this.collisionCircleArrays[e];\n            void 0 === t && (t = this.collisionCircleArrays[e] = new yt());\n\n            for (let e = 0; e < k.circles.length; e += 4) t.circles.push(k.circles[e + 0]), t.circles.push(k.circles[e + 1]), t.circles.push(k.circles[e + 2]), t.circles.push(k.collisionDetected ? 1 : 0);\n          }\n\n          const V = \"globe\" !== this.transform.projection.name;\n          C = C && (V || !z), I = I && (V || !D), this.placements[t.crossTileID] = new xt(E || C, M || I, S || n.justReloaded), i[t.crossTileID] = !0;\n        };\n\n        if (E) {\n          const e = n.getSortedSymbolIndexes(this.transform.angle);\n\n          for (let t = e.length - 1; t >= 0; --t) {\n            const i = e[t];\n            M(n.symbolInstances.get(i), i, n.collisionArrays[i]);\n          }\n        } else for (let e = t.symbolInstanceStart; e < t.symbolInstanceEnd; e++) M(n.symbolInstances.get(e), e, n.collisionArrays[e]);\n\n        if (o && n.bucketInstanceId in this.collisionCircleArrays) {\n          const t = this.collisionCircleArrays[n.bucketInstanceId];\n          e.invert(t.invProjMatrix, s), t.viewportMatrix = this.collisionIndex.getViewportMatrix();\n        }\n\n        n.justReloaded = !1;\n      }\n\n      markUsedJustification(t, i, o, r) {\n        let n;\n        n = r === e.WritingMode.vertical ? o.verticalPlacedTextSymbolIndex : {\n          left: o.leftJustifiedTextSymbolIndex,\n          center: o.centerJustifiedTextSymbolIndex,\n          right: o.rightJustifiedTextSymbolIndex\n        }[e.getAnchorJustification(i)];\n        const a = [o.leftJustifiedTextSymbolIndex, o.centerJustifiedTextSymbolIndex, o.rightJustifiedTextSymbolIndex, o.verticalPlacedTextSymbolIndex];\n\n        for (const e of a) e >= 0 && (t.text.placedSymbolArray.get(e).crossTileID = n >= 0 && e !== n ? 0 : o.crossTileID);\n      }\n\n      markUsedOrientation(t, i, o) {\n        const r = i === e.WritingMode.horizontal || i === e.WritingMode.horizontalOnly ? i : 0,\n              n = i === e.WritingMode.vertical ? i : 0,\n              a = [o.leftJustifiedTextSymbolIndex, o.centerJustifiedTextSymbolIndex, o.rightJustifiedTextSymbolIndex];\n\n        for (const e of a) t.text.placedSymbolArray.get(e).placedOrientation = r;\n\n        o.verticalPlacedTextSymbolIndex && (t.text.placedSymbolArray.get(o.verticalPlacedTextSymbolIndex).placedOrientation = n);\n      }\n\n      commit(e) {\n        this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom;\n        const t = this.prevPlacement;\n        let i = !1;\n        this.prevZoomAdjustment = t ? t.zoomAdjustment(this.transform.zoom) : 0;\n        const o = t ? t.symbolFadeChange(e) : 1,\n              r = t ? t.opacities : {},\n              n = t ? t.variableOffsets : {},\n              a = t ? t.placedOrientations : {};\n\n        for (const e in this.placements) {\n          const t = this.placements[e],\n                n = r[e];\n          n ? (this.opacities[e] = new vt(n, o, t.text, t.icon, null, t.clipped), i = i || t.text !== n.text.placed || t.icon !== n.icon.placed) : (this.opacities[e] = new vt(null, o, t.text, t.icon, t.skipFade, t.clipped), i = i || t.text || t.icon);\n        }\n\n        for (const e in r) {\n          const t = r[e];\n\n          if (!this.opacities[e]) {\n            const r = new vt(t, o, !1, !1);\n            r.isHidden() || (this.opacities[e] = r, i = i || t.text.placed || t.icon.placed);\n          }\n        }\n\n        for (const e in n) this.variableOffsets[e] || !this.opacities[e] || this.opacities[e].isHidden() || (this.variableOffsets[e] = n[e]);\n\n        for (const e in a) this.placedOrientations[e] || !this.opacities[e] || this.opacities[e].isHidden() || (this.placedOrientations[e] = a[e]);\n\n        i ? this.lastPlacementChangeTime = e : \"number\" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t ? t.lastPlacementChangeTime : e);\n      }\n\n      updateLayerOpacities(e, t) {\n        const i = {};\n\n        for (const o of t) {\n          const t = o.getBucket(e);\n          t && o.latestFeatureIndex && e.id === t.layerIds[0] && this.updateBucketOpacities(t, i, o.collisionBoxArray);\n        }\n      }\n\n      updateBucketOpacities(t, i, o) {\n        t.hasTextData() && t.text.opacityVertexArray.clear(), t.hasIconData() && t.icon.opacityVertexArray.clear(), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexArray.clear(), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexArray.clear();\n\n        const r = t.layers[0].layout,\n              n = !!t.layers[0].dynamicFilter(),\n              a = new vt(null, 0, !1, !1, !0),\n              s = r.get(\"text-allow-overlap\"),\n              l = r.get(\"icon-allow-overlap\"),\n              c = r.get(\"text-variable-anchor\"),\n              h = \"map\" === r.get(\"text-rotation-alignment\"),\n              _ = \"map\" === r.get(\"text-pitch-alignment\"),\n              u = \"none\" !== r.get(\"icon-text-fit\"),\n              d = new vt(null, 0, s && (l || !t.hasIconData() || r.get(\"icon-optional\")), l && (s || !t.hasTextData() || r.get(\"text-optional\")), !0);\n\n        !t.collisionArrays && o && (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) && t.deserializeCollisionBoxes(o);\n\n        const p = (e, t, i) => {\n          for (let o = 0; o < t / 4; o++) e.opacityVertexArray.emplaceBack(i);\n        };\n\n        let m = 0;\n\n        for (let o = 0; o < t.symbolInstances.length; o++) {\n          const r = t.symbolInstances.get(o),\n                {\n            numHorizontalGlyphVertices: s,\n            numVerticalGlyphVertices: l,\n            crossTileID: f\n          } = r;\n          let g = this.opacities[f];\n          i[f] ? g = a : g || (g = d, this.opacities[f] = g), i[f] = !0;\n          const v = s > 0 || l > 0,\n                x = r.numIconVertices > 0,\n                y = this.placedOrientations[r.crossTileID],\n                b = y === e.WritingMode.vertical,\n                w = y === e.WritingMode.horizontal || y === e.WritingMode.horizontalOnly;\n\n          if (!v && !x || g.isHidden() || m++, v) {\n            const e = Rt(g.text);\n            p(t.text, s, b ? kt : e), p(t.text, l, w ? kt : e);\n            const i = g.text.isHidden();\n            [r.rightJustifiedTextSymbolIndex, r.centerJustifiedTextSymbolIndex, r.leftJustifiedTextSymbolIndex].forEach(e => {\n              e >= 0 && (t.text.placedSymbolArray.get(e).hidden = i || b ? 1 : 0);\n            }), r.verticalPlacedTextSymbolIndex >= 0 && (t.text.placedSymbolArray.get(r.verticalPlacedTextSymbolIndex).hidden = i || w ? 1 : 0);\n            const o = this.variableOffsets[r.crossTileID];\n            o && this.markUsedJustification(t, o.anchor, r, y);\n            const n = this.placedOrientations[r.crossTileID];\n            n && (this.markUsedJustification(t, \"left\", r, n), this.markUsedOrientation(t, n, r));\n          }\n\n          if (x) {\n            const e = Rt(g.icon);\n            r.placedIconSymbolIndex >= 0 && (p(t.icon, r.numIconVertices, b ? kt : e), t.icon.placedSymbolArray.get(r.placedIconSymbolIndex).hidden = g.icon.isHidden()), r.verticalPlacedIconSymbolIndex >= 0 && (p(t.icon, r.numVerticalIconVertices, w ? kt : e), t.icon.placedSymbolArray.get(r.verticalPlacedIconSymbolIndex).hidden = g.icon.isHidden());\n          }\n\n          if (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) {\n            const i = t.collisionArrays[o];\n\n            if (i) {\n              let o = new e.pointGeometry(0, 0),\n                  r = !0;\n\n              if (i.textBox || i.verticalTextBox) {\n                if (c) {\n                  const e = this.variableOffsets[f];\n                  e ? (o = Tt(e.anchor, e.width, e.height, e.textOffset, e.textScale), h && o._rotate(_ ? this.transform.angle : -this.transform.angle)) : r = !1;\n                }\n\n                n && (r = !g.clipped), i.textBox && It(t.textCollisionBox.collisionVertexArray, g.text.placed, !r || b, o.x, o.y), i.verticalTextBox && It(t.textCollisionBox.collisionVertexArray, g.text.placed, !r || w, o.x, o.y);\n              }\n\n              const a = r && Boolean(!w && i.verticalIconBox);\n              i.iconBox && It(t.iconCollisionBox.collisionVertexArray, g.icon.placed, a, u ? o.x : 0, u ? o.y : 0), i.verticalIconBox && It(t.iconCollisionBox.collisionVertexArray, g.icon.placed, !a, u ? o.x : 0, u ? o.y : 0);\n            }\n          }\n        }\n\n        if (t.fullyClipped = 0 === m, t.sortFeatures(this.transform.angle), this.retainedQueryData[t.bucketInstanceId] && (this.retainedQueryData[t.bucketInstanceId].featureSortOrder = t.featureSortOrder), t.hasTextData() && t.text.opacityVertexBuffer && t.text.opacityVertexBuffer.updateData(t.text.opacityVertexArray), t.hasIconData() && t.icon.opacityVertexBuffer && t.icon.opacityVertexBuffer.updateData(t.icon.opacityVertexArray), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexBuffer && t.iconCollisionBox.collisionVertexBuffer.updateData(t.iconCollisionBox.collisionVertexArray), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexBuffer && t.textCollisionBox.collisionVertexBuffer.updateData(t.textCollisionBox.collisionVertexArray), t.bucketInstanceId in this.collisionCircleArrays) {\n          const e = this.collisionCircleArrays[t.bucketInstanceId];\n          t.placementInvProjMatrix = e.invProjMatrix, t.placementViewportMatrix = e.viewportMatrix, t.collisionCircleArray = e.circles, delete this.collisionCircleArrays[t.bucketInstanceId];\n        }\n      }\n\n      symbolFadeChange(e) {\n        return 0 === this.fadeDuration ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;\n      }\n\n      zoomAdjustment(e) {\n        return Math.max(0, (this.transform.zoom - e) / 1.5);\n      }\n\n      hasTransitions(e) {\n        return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration;\n      }\n\n      stillRecent(e, t) {\n        const i = this.zoomAtLastRecencyCheck === t ? 1 - this.zoomAdjustment(t) : 1;\n        return this.zoomAtLastRecencyCheck = t, this.commitTime + this.fadeDuration * i > e;\n      }\n\n      setStale() {\n        this.stale = !0;\n      }\n\n    }\n\n    function It(e, t, i, o, r) {\n      e.emplaceBack(t ? 1 : 0, i ? 1 : 0, o || 0, r || 0), e.emplaceBack(t ? 1 : 0, i ? 1 : 0, o || 0, r || 0), e.emplaceBack(t ? 1 : 0, i ? 1 : 0, o || 0, r || 0), e.emplaceBack(t ? 1 : 0, i ? 1 : 0, o || 0, r || 0);\n    }\n\n    const Mt = Math.pow(2, 25),\n          St = Math.pow(2, 24),\n          zt = Math.pow(2, 17),\n          Dt = Math.pow(2, 16),\n          Pt = Math.pow(2, 9),\n          At = Math.pow(2, 8),\n          Lt = Math.pow(2, 1);\n\n    function Rt(e) {\n      if (0 === e.opacity && !e.placed) return 0;\n      if (1 === e.opacity && e.placed) return 4294967295;\n      const t = e.placed ? 1 : 0,\n            i = Math.floor(127 * e.opacity);\n      return i * Mt + t * St + i * zt + t * Dt + i * Pt + t * At + i * Lt + t;\n    }\n\n    const kt = 0;\n\n    class Ot {\n      constructor(e) {\n        this._sortAcrossTiles = \"viewport-y\" !== e.layout.get(\"symbol-z-order\") && void 0 !== e.layout.get(\"symbol-sort-key\").constantOr(1), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];\n      }\n\n      continuePlacement(e, t, i, o, r) {\n        const n = this._bucketParts;\n\n        for (; this._currentTileIndex < e.length;) if (t.getBucketParts(n, o, e[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, r()) return !0;\n\n        for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, n.sort((e, t) => e.sortKey - t.sortKey)); this._currentPartIndex < n.length;) {\n          const e = n[this._currentPartIndex];\n          if (t.placeLayerBucketPart(e, this._seenCrossTileIDs, i, 0 === e.symbolInstanceStart), this._currentPartIndex++, r()) return !0;\n        }\n\n        return !1;\n      }\n\n    }\n\n    class Bt {\n      constructor(e, t, i, o, r, n, a, s) {\n        this.placement = new Ct(e, r, n, a, s), this._currentPlacementIndex = t.length - 1, this._forceFullPlacement = i, this._showCollisionBoxes = o, this._done = !1;\n      }\n\n      isDone() {\n        return this._done;\n      }\n\n      continuePlacement(t, i, o) {\n        const r = e.exported.now(),\n              n = () => {\n          const t = e.exported.now() - r;\n          return !this._forceFullPlacement && t > 2;\n        };\n\n        for (; this._currentPlacementIndex >= 0;) {\n          const e = i[t[this._currentPlacementIndex]],\n                r = this.placement.collisionIndex.transform.zoom;\n\n          if (\"symbol\" === e.type && (!e.minzoom || e.minzoom <= r) && (!e.maxzoom || e.maxzoom > r)) {\n            if (this._inProgressLayer || (this._inProgressLayer = new Ot(e)), this._inProgressLayer.continuePlacement(o[e.source], this.placement, this._showCollisionBoxes, e, n)) return;\n            delete this._inProgressLayer;\n          }\n\n          this._currentPlacementIndex--;\n        }\n\n        this._done = !0;\n      }\n\n      commit(e) {\n        return this.placement.commit(e), this.placement;\n      }\n\n    }\n\n    const Ft = 512 / e.EXTENT / 2;\n\n    class Ut {\n      constructor(e, t, i) {\n        this.tileID = e, this.indexedSymbolInstances = {}, this.bucketInstanceId = i;\n\n        for (let i = 0; i < t.length; i++) {\n          const o = t.get(i),\n                r = o.key;\n          this.indexedSymbolInstances[r] || (this.indexedSymbolInstances[r] = []), this.indexedSymbolInstances[r].push({\n            crossTileID: o.crossTileID,\n            coord: this.getScaledCoordinates(o, e)\n          });\n        }\n      }\n\n      getScaledCoordinates(t, i) {\n        const o = Ft / Math.pow(2, i.canonical.z - this.tileID.canonical.z);\n        return {\n          x: Math.floor((i.canonical.x * e.EXTENT + t.tileAnchorX) * o),\n          y: Math.floor((i.canonical.y * e.EXTENT + t.tileAnchorY) * o)\n        };\n      }\n\n      findMatches(e, t, i) {\n        const o = this.tileID.canonical.z < t.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - t.canonical.z);\n\n        for (let r = 0; r < e.length; r++) {\n          const n = e.get(r);\n          if (n.crossTileID) continue;\n          const a = this.indexedSymbolInstances[n.key];\n          if (!a) continue;\n          const s = this.getScaledCoordinates(n, t);\n\n          for (const e of a) if (Math.abs(e.coord.x - s.x) <= o && Math.abs(e.coord.y - s.y) <= o && !i[e.crossTileID]) {\n            i[e.crossTileID] = !0, n.crossTileID = e.crossTileID;\n            break;\n          }\n        }\n      }\n\n    }\n\n    class Nt {\n      constructor() {\n        this.maxCrossTileID = 0;\n      }\n\n      generate() {\n        return ++this.maxCrossTileID;\n      }\n\n    }\n\n    class Gt {\n      constructor() {\n        this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;\n      }\n\n      handleWrapJump(e) {\n        const t = Math.round((e - this.lng) / 360);\n        if (0 !== t) for (const e in this.indexes) {\n          const i = this.indexes[e],\n                o = {};\n\n          for (const e in i) {\n            const r = i[e];\n            r.tileID = r.tileID.unwrapTo(r.tileID.wrap + t), o[r.tileID.key] = r;\n          }\n\n          this.indexes[e] = o;\n        }\n        this.lng = e;\n      }\n\n      addBucket(e, t, i) {\n        if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {\n          if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === t.bucketInstanceId) return !1;\n          this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key]);\n        }\n\n        for (let e = 0; e < t.symbolInstances.length; e++) t.symbolInstances.get(e).crossTileID = 0;\n\n        this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = {});\n        const o = this.usedCrossTileIDs[e.overscaledZ];\n\n        for (const i in this.indexes) {\n          const r = this.indexes[i];\n          if (Number(i) > e.overscaledZ) for (const i in r) {\n            const n = r[i];\n            n.tileID.isChildOf(e) && n.findMatches(t.symbolInstances, e, o);\n          } else {\n            const n = r[e.scaledTo(Number(i)).key];\n            n && n.findMatches(t.symbolInstances, e, o);\n          }\n        }\n\n        for (let e = 0; e < t.symbolInstances.length; e++) {\n          const r = t.symbolInstances.get(e);\n          r.crossTileID || (r.crossTileID = i.generate(), o[r.crossTileID] = !0);\n        }\n\n        return void 0 === this.indexes[e.overscaledZ] && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new Ut(e, t.symbolInstances, t.bucketInstanceId), !0;\n      }\n\n      removeBucketCrossTileIDs(e, t) {\n        for (const i in t.indexedSymbolInstances) for (const o of t.indexedSymbolInstances[i]) delete this.usedCrossTileIDs[e][o.crossTileID];\n      }\n\n      removeStaleBuckets(e) {\n        let t = !1;\n\n        for (const i in this.indexes) {\n          const o = this.indexes[i];\n\n          for (const r in o) e[o[r].bucketInstanceId] || (this.removeBucketCrossTileIDs(i, o[r]), delete o[r], t = !0);\n        }\n\n        return t;\n      }\n\n    }\n\n    class jt {\n      constructor() {\n        this.layerIndexes = {}, this.crossTileIDs = new Nt(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};\n      }\n\n      addLayer(e, t, i, o) {\n        let r = this.layerIndexes[e.id];\n        void 0 === r && (r = this.layerIndexes[e.id] = new Gt());\n        let n = !1;\n        const a = {};\n        \"globe\" !== o.name && r.handleWrapJump(i);\n\n        for (const i of t) {\n          const t = i.getBucket(e);\n          t && e.id === t.layerIds[0] && (t.bucketInstanceId || (t.bucketInstanceId = ++this.maxBucketInstanceId), r.addBucket(i.tileID, t, this.crossTileIDs) && (n = !0), a[t.bucketInstanceId] = !0);\n        }\n\n        return r.removeStaleBuckets(a) && (n = !0), n;\n      }\n\n      pruneUnusedLayers(e) {\n        const t = {};\n        e.forEach(e => {\n          t[e] = !0;\n        });\n\n        for (const e in this.layerIndexes) t[e] || delete this.layerIndexes[e];\n      }\n\n    }\n\n    const Zt = (t, i) => e.emitValidationErrors(t, i && i.filter(e => \"source.canvas\" !== e.identifier)),\n          Vt = e.pick(je, [\"addLayer\", \"removeLayer\", \"setPaintProperty\", \"setLayoutProperty\", \"setFilter\", \"addSource\", \"removeSource\", \"setLayerZoomRange\", \"setLight\", \"setTransition\", \"setGeoJSONSourceData\", \"setTerrain\", \"setFog\", \"setProjection\"]),\n          Wt = e.pick(je, [\"setCenter\", \"setZoom\", \"setBearing\", \"setPitch\"]),\n          qt = {\n      version: 8,\n      layers: [],\n      sources: {}\n    },\n          Xt = {\n      fill: !0,\n      line: !0,\n      background: !0,\n      hillshade: !0,\n      raster: !0\n    };\n\n    class $t extends e.Evented {\n      constructor(t, i = {}) {\n        super(), this.map = t, this.dispatcher = new A(Ue(), this), this.imageManager = new y(), this.imageManager.setEventedParent(this), this.glyphManager = new e.GlyphManager(t._requestManager, i.localFontFamily ? e.LocalGlyphMode.all : i.localIdeographFontFamily ? e.LocalGlyphMode.ideographs : e.LocalGlyphMode.none, i.localFontFamily || i.localIdeographFontFamily), this.lineAtlas = new e.LineAtlas(256, 512), this.crossTileSymbolIndex = new jt(), this._layers = {}, this._num3DLayers = 0, this._numSymbolLayers = 0, this._numCircleLayers = 0, this._serializedLayers = {}, this._sourceCaches = {}, this._otherSourceCaches = {}, this._symbolSourceCaches = {}, this.zoomHistory = new e.ZoomHistory(), this._loaded = !1, this._availableImages = [], this._order = [], this._drapedFirstOrder = [], this._markersNeedUpdate = !1, this._resetUpdates(), this.dispatcher.broadcast(\"setReferrer\", e.getReferrer());\n        const o = this;\n        this._rtlTextPluginCallback = $t.registerForPluginStateChange(t => {\n          o.dispatcher.broadcast(\"syncRTLPluginState\", {\n            pluginStatus: t.pluginStatus,\n            pluginURL: t.pluginURL\n          }, (t, i) => {\n            if (e.triggerPluginCompletionEvent(t), i && i.every(e => e)) for (const e in o._sourceCaches) {\n              const t = o._sourceCaches[e],\n                    i = t.getSource().type;\n              \"vector\" !== i && \"geojson\" !== i || t.reload();\n            }\n          });\n        }), this.on(\"data\", e => {\n          if (\"source\" !== e.dataType || \"metadata\" !== e.sourceDataType) return;\n          const t = this.getSource(e.sourceId);\n          if (t && t.vectorLayerIds) for (const e in this._layers) {\n            const i = this._layers[e];\n            i.source === t.id && this._validateLayer(i);\n          }\n        });\n      }\n\n      loadURL(t, i = {}) {\n        this.fire(new e.Event(\"dataloading\", {\n          dataType: \"style\"\n        }));\n        const o = \"boolean\" == typeof i.validate ? i.validate : !e.isMapboxURL(t);\n        t = this.map._requestManager.normalizeStyleURL(t, i.accessToken);\n\n        const r = this.map._requestManager.transformRequest(t, e.ResourceType.Style);\n\n        this._request = e.getJSON(r, (t, i) => {\n          this._request = null, t ? this.fire(new e.ErrorEvent(t)) : i && this._load(i, o);\n        });\n      }\n\n      loadJSON(t, i = {}) {\n        this.fire(new e.Event(\"dataloading\", {\n          dataType: \"style\"\n        })), this._request = e.exported.frame(() => {\n          this._request = null, this._load(t, !1 !== i.validate);\n        });\n      }\n\n      loadEmpty() {\n        this.fire(new e.Event(\"dataloading\", {\n          dataType: \"style\"\n        })), this._load(qt, !1);\n      }\n\n      _updateLayerCount(e, t) {\n        const i = t ? 1 : -1;\n        e.is3D() && (this._num3DLayers += i), \"circle\" === e.type && (this._numCircleLayers += i), \"symbol\" === e.type && (this._numSymbolLayers += i);\n      }\n\n      _load(t, i) {\n        if (i && Zt(this, e.validateStyle(t))) return;\n        this._loaded = !0, this.stylesheet = t, this._updateMapProjection();\n\n        for (const e in t.sources) this.addSource(e, t.sources[e], {\n          validate: !1\n        });\n\n        this._changed = !1, t.sprite ? this._loadSprite(t.sprite) : (this.imageManager.setLoaded(!0), this.dispatcher.broadcast(\"spriteLoaded\", !0)), this.glyphManager.setURL(t.glyphs);\n        const o = Ge(this.stylesheet.layers);\n        this._order = o.map(e => e.id), this._layers = {}, this._serializedLayers = {};\n\n        for (let t of o) t = e.createStyleLayer(t), t.setEventedParent(this, {\n          layer: {\n            id: t.id\n          }\n        }), this._layers[t.id] = t, this._serializedLayers[t.id] = t.serialize(), this._updateLayerCount(t, !0);\n\n        this.dispatcher.broadcast(\"setLayers\", this._serializeLayers(this._order)), this.light = new T(this.stylesheet.light), this.stylesheet.terrain && !this.terrainSetForDrapingOnly() && this._createTerrain(this.stylesheet.terrain, 1), this.stylesheet.fog && this._createFog(this.stylesheet.fog), this._updateDrapeFirstLayers(), this.fire(new e.Event(\"data\", {\n          dataType: \"style\"\n        })), this.fire(new e.Event(\"style.load\"));\n      }\n\n      terrainSetForDrapingOnly() {\n        return !!this.terrain && 0 === this.terrain.drapeRenderMode;\n      }\n\n      setProjection(e) {\n        e ? this.stylesheet.projection = e : delete this.stylesheet.projection, this.map._explicitProjection || this.map._updateProjection();\n      }\n\n      _updateMapProjection() {\n        this.map._explicitProjection ? this.applyProjectionUpdate() : this.map._updateProjection();\n      }\n\n      applyProjectionUpdate() {\n        this._loaded && (this.dispatcher.broadcast(\"setProjection\", this.map.transform.projectionOptions), this.map.transform.projection.requiresDraping ? this.getTerrain() || this.stylesheet.terrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null));\n      }\n\n      _loadSprite(t) {\n        this._spriteRequest = function (t, i, o) {\n          let r, n, a;\n          const s = e.exported.devicePixelRatio > 1 ? \"@2x\" : \"\";\n          let l = e.getJSON(i.transformRequest(i.normalizeSpriteURL(t, s, \".json\"), e.ResourceType.SpriteJSON), (e, t) => {\n            l = null, a || (a = e, r = t, h());\n          }),\n              c = e.getImage(i.transformRequest(i.normalizeSpriteURL(t, s, \".png\"), e.ResourceType.SpriteImage), (e, t) => {\n            c = null, a || (a = e, n = t, h());\n          });\n\n          function h() {\n            if (a) o(a);else if (r && n) {\n              const t = e.exported.getImageData(n),\n                    i = {};\n\n              for (const o in r) {\n                const {\n                  width: n,\n                  height: a,\n                  x: s,\n                  y: l,\n                  sdf: c,\n                  pixelRatio: h,\n                  stretchX: _,\n                  stretchY: u,\n                  content: d\n                } = r[o],\n                      p = new e.RGBAImage({\n                  width: n,\n                  height: a\n                });\n                e.RGBAImage.copy(t, p, {\n                  x: s,\n                  y: l\n                }, {\n                  x: 0,\n                  y: 0\n                }, {\n                  width: n,\n                  height: a\n                }), i[o] = {\n                  data: p,\n                  pixelRatio: h,\n                  sdf: c,\n                  stretchX: _,\n                  stretchY: u,\n                  content: d\n                };\n              }\n\n              o(null, i);\n            }\n          }\n\n          return {\n            cancel() {\n              l && (l.cancel(), l = null), c && (c.cancel(), c = null);\n            }\n\n          };\n        }(t, this.map._requestManager, (t, i) => {\n          if (this._spriteRequest = null, t) this.fire(new e.ErrorEvent(t));else if (i) for (const e in i) this.imageManager.addImage(e, i[e]);\n          this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), this.dispatcher.broadcast(\"setImages\", this._availableImages), this.dispatcher.broadcast(\"spriteLoaded\", !0), this.fire(new e.Event(\"data\", {\n            dataType: \"style\"\n          }));\n        });\n      }\n\n      _validateLayer(t) {\n        const i = this.getSource(t.source);\n        if (!i) return;\n        const o = t.sourceLayer;\n        o && (\"geojson\" === i.type || i.vectorLayerIds && -1 === i.vectorLayerIds.indexOf(o)) && this.fire(new e.ErrorEvent(new Error(`Source layer \"${o}\" does not exist on source \"${i.id}\" as specified by style layer \"${t.id}\"`)));\n      }\n\n      loaded() {\n        if (!this._loaded) return !1;\n        if (Object.keys(this._updatedSources).length) return !1;\n\n        for (const e in this._sourceCaches) if (!this._sourceCaches[e].loaded()) return !1;\n\n        return !!this.imageManager.isLoaded();\n      }\n\n      _serializeLayers(e) {\n        const t = [];\n\n        for (const i of e) {\n          const e = this._layers[i];\n          \"custom\" !== e.type && t.push(e.serialize());\n        }\n\n        return t;\n      }\n\n      hasTransitions() {\n        if (this.light && this.light.hasTransition()) return !0;\n        if (this.fog && this.fog.hasTransition()) return !0;\n\n        for (const e in this._sourceCaches) if (this._sourceCaches[e].hasTransition()) return !0;\n\n        for (const e in this._layers) if (this._layers[e].hasTransition()) return !0;\n\n        return !1;\n      }\n\n      get order() {\n        return this.map._optimizeForTerrain && this.terrain ? this._drapedFirstOrder : this._order;\n      }\n\n      isLayerDraped(e) {\n        return !!this.terrain && Xt[e.type];\n      }\n\n      _checkLoaded() {\n        if (!this._loaded) throw new Error(\"Style is not done loading\");\n      }\n\n      update(t) {\n        if (!this._loaded) return;\n        const i = this._changed;\n\n        if (this._changed) {\n          const e = Object.keys(this._updatedLayers),\n                i = Object.keys(this._removedLayers);\n          (e.length || i.length) && this._updateWorkerLayers(e, i);\n\n          for (const e in this._updatedSources) {\n            const t = this._updatedSources[e];\n            \"reload\" === t ? this._reloadSource(e) : \"clear\" === t && this._clearSource(e);\n          }\n\n          this._updateTilesForChangedImages();\n\n          for (const e in this._updatedPaintProps) this._layers[e].updateTransitions(t);\n\n          this.light.updateTransitions(t), this.fog && this.fog.updateTransitions(t), this._resetUpdates();\n        }\n\n        const o = {};\n\n        for (const e in this._sourceCaches) {\n          const t = this._sourceCaches[e];\n          o[e] = t.used, t.used = !1;\n        }\n\n        for (const e of this._order) {\n          const i = this._layers[e];\n\n          if (i.recalculate(t, this._availableImages), !i.isHidden(t.zoom)) {\n            const e = this._getLayerSourceCache(i);\n\n            e && (e.used = !0);\n          }\n\n          const o = this.map.painter;\n\n          if (o) {\n            const e = i.getProgramIds();\n            if (!e) continue;\n            const r = i.getProgramConfiguration(t.zoom);\n\n            for (const t of e) o.useProgram(t, r);\n          }\n        }\n\n        for (const t in o) {\n          const i = this._sourceCaches[t];\n          o[t] !== i.used && i.getSource().fire(new e.Event(\"data\", {\n            sourceDataType: \"visibility\",\n            dataType: \"source\",\n            sourceId: i.getSource().id\n          }));\n        }\n\n        this.light.recalculate(t), this.terrain && this.terrain.recalculate(t), this.fog && this.fog.recalculate(t), this.z = t.zoom, this._markersNeedUpdate && (this._updateMarkersOpacity(), this._markersNeedUpdate = !1), i && this.fire(new e.Event(\"data\", {\n          dataType: \"style\"\n        }));\n      }\n\n      _updateTilesForChangedImages() {\n        const e = Object.keys(this._changedImages);\n\n        if (e.length) {\n          for (const t in this._sourceCaches) this._sourceCaches[t].reloadTilesForDependencies([\"icons\", \"patterns\"], e);\n\n          this._changedImages = {};\n        }\n      }\n\n      _updateWorkerLayers(e, t) {\n        this.dispatcher.broadcast(\"updateLayers\", {\n          layers: this._serializeLayers(e),\n          removedIds: t\n        });\n      }\n\n      _resetUpdates() {\n        this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {};\n      }\n\n      setState(t) {\n        if (this._checkLoaded(), Zt(this, e.validateStyle(t))) return !1;\n        (t = e.clone$1(t)).layers = Ge(t.layers);\n\n        const i = function (e, t) {\n          if (!e) return [{\n            command: je.setStyle,\n            args: [t]\n          }];\n          let i = [];\n\n          try {\n            if (!r(e.version, t.version)) return [{\n              command: je.setStyle,\n              args: [t]\n            }];\n            r(e.center, t.center) || i.push({\n              command: je.setCenter,\n              args: [t.center]\n            }), r(e.zoom, t.zoom) || i.push({\n              command: je.setZoom,\n              args: [t.zoom]\n            }), r(e.bearing, t.bearing) || i.push({\n              command: je.setBearing,\n              args: [t.bearing]\n            }), r(e.pitch, t.pitch) || i.push({\n              command: je.setPitch,\n              args: [t.pitch]\n            }), r(e.sprite, t.sprite) || i.push({\n              command: je.setSprite,\n              args: [t.sprite]\n            }), r(e.glyphs, t.glyphs) || i.push({\n              command: je.setGlyphs,\n              args: [t.glyphs]\n            }), r(e.transition, t.transition) || i.push({\n              command: je.setTransition,\n              args: [t.transition]\n            }), r(e.light, t.light) || i.push({\n              command: je.setLight,\n              args: [t.light]\n            }), r(e.fog, t.fog) || i.push({\n              command: je.setFog,\n              args: [t.fog]\n            }), r(e.projection, t.projection) || i.push({\n              command: je.setProjection,\n              args: [t.projection]\n            });\n            const o = {},\n                  n = [];\n            !function (e, t, i, o) {\n              let n;\n\n              for (n in t = t || {}, e = e || {}) e.hasOwnProperty(n) && (t.hasOwnProperty(n) || Ve(n, i, o));\n\n              for (n in t) t.hasOwnProperty(n) && (e.hasOwnProperty(n) ? r(e[n], t[n]) || (\"geojson\" === e[n].type && \"geojson\" === t[n].type && qe(e, t, n) ? i.push({\n                command: je.setGeoJSONSourceData,\n                args: [n, t[n].data]\n              }) : We(n, t, i, o)) : Ze(n, t, i));\n            }(e.sources, t.sources, n, o);\n            const a = [];\n            e.layers && e.layers.forEach(e => {\n              e.source && o[e.source] ? i.push({\n                command: je.removeLayer,\n                args: [e.id]\n              }) : a.push(e);\n            });\n            let s = e.terrain;\n            s && o[s.source] && (i.push({\n              command: je.setTerrain,\n              args: [void 0]\n            }), s = void 0), i = i.concat(n), r(s, t.terrain) || i.push({\n              command: je.setTerrain,\n              args: [t.terrain]\n            }), function (e, t, i) {\n              t = t || [];\n              const o = (e = e || []).map($e),\n                    n = t.map($e),\n                    a = e.reduce(He, {}),\n                    s = t.reduce(He, {}),\n                    l = o.slice(),\n                    c = Object.create(null);\n\n              let h, _, u, d, p, m, f;\n\n              for (h = 0, _ = 0; h < o.length; h++) u = o[h], s.hasOwnProperty(u) ? _++ : (i.push({\n                command: je.removeLayer,\n                args: [u]\n              }), l.splice(l.indexOf(u, _), 1));\n\n              for (h = 0, _ = 0; h < n.length; h++) u = n[n.length - 1 - h], l[l.length - 1 - h] !== u && (a.hasOwnProperty(u) ? (i.push({\n                command: je.removeLayer,\n                args: [u]\n              }), l.splice(l.lastIndexOf(u, l.length - _), 1)) : _++, m = l[l.length - h], i.push({\n                command: je.addLayer,\n                args: [s[u], m]\n              }), l.splice(l.length - h, 0, u), c[u] = !0);\n\n              for (h = 0; h < n.length; h++) if (u = n[h], d = a[u], p = s[u], !c[u] && !r(d, p)) if (r(d.source, p.source) && r(d[\"source-layer\"], p[\"source-layer\"]) && r(d.type, p.type)) {\n                for (f in Xe(d.layout, p.layout, i, u, null, je.setLayoutProperty), Xe(d.paint, p.paint, i, u, null, je.setPaintProperty), r(d.filter, p.filter) || i.push({\n                  command: je.setFilter,\n                  args: [u, p.filter]\n                }), r(d.minzoom, p.minzoom) && r(d.maxzoom, p.maxzoom) || i.push({\n                  command: je.setLayerZoomRange,\n                  args: [u, p.minzoom, p.maxzoom]\n                }), d) d.hasOwnProperty(f) && \"layout\" !== f && \"paint\" !== f && \"filter\" !== f && \"metadata\" !== f && \"minzoom\" !== f && \"maxzoom\" !== f && (0 === f.indexOf(\"paint.\") ? Xe(d[f], p[f], i, u, f.slice(6), je.setPaintProperty) : r(d[f], p[f]) || i.push({\n                  command: je.setLayerProperty,\n                  args: [u, f, p[f]]\n                }));\n\n                for (f in p) p.hasOwnProperty(f) && !d.hasOwnProperty(f) && \"layout\" !== f && \"paint\" !== f && \"filter\" !== f && \"metadata\" !== f && \"minzoom\" !== f && \"maxzoom\" !== f && (0 === f.indexOf(\"paint.\") ? Xe(d[f], p[f], i, u, f.slice(6), je.setPaintProperty) : r(d[f], p[f]) || i.push({\n                  command: je.setLayerProperty,\n                  args: [u, f, p[f]]\n                }));\n              } else i.push({\n                command: je.removeLayer,\n                args: [u]\n              }), m = l[l.lastIndexOf(u) + 1], i.push({\n                command: je.addLayer,\n                args: [p, m]\n              });\n            }(a, t.layers, i);\n          } catch (e) {\n            console.warn(\"Unable to compute style diff:\", e), i = [{\n              command: je.setStyle,\n              args: [t]\n            }];\n          }\n\n          return i;\n        }(this.serialize(), t).filter(e => !(e.command in Wt));\n\n        if (0 === i.length) return !1;\n        const o = i.filter(e => !(e.command in Vt));\n        if (o.length > 0) throw new Error(`Unimplemented: ${o.map(e => e.command).join(\", \")}.`);\n        return i.forEach(e => {\n          \"setTransition\" !== e.command && this[e.command].apply(this, e.args);\n        }), this.stylesheet = t, this._updateMapProjection(), !0;\n      }\n\n      addImage(t, i) {\n        return this.getImage(t) ? this.fire(new e.ErrorEvent(new Error(\"An image with this name already exists.\"))) : (this.imageManager.addImage(t, i), this._afterImageUpdated(t), this);\n      }\n\n      updateImage(e, t) {\n        this.imageManager.updateImage(e, t);\n      }\n\n      getImage(e) {\n        return this.imageManager.getImage(e);\n      }\n\n      removeImage(t) {\n        return this.getImage(t) ? (this.imageManager.removeImage(t), this._afterImageUpdated(t), this) : this.fire(new e.ErrorEvent(new Error(\"No image with this name exists.\")));\n      }\n\n      _afterImageUpdated(t) {\n        this._availableImages = this.imageManager.listImages(), this._changedImages[t] = !0, this._changed = !0, this.dispatcher.broadcast(\"setImages\", this._availableImages), this.fire(new e.Event(\"data\", {\n          dataType: \"style\"\n        }));\n      }\n\n      listImages() {\n        return this._checkLoaded(), this._availableImages.slice();\n      }\n\n      addSource(t, i, o = {}) {\n        if (this._checkLoaded(), void 0 !== this.getSource(t)) throw new Error(\"There is already a source with this ID\");\n        if (!i.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i).join(\", \")}.`);\n        if ([\"vector\", \"raster\", \"geojson\", \"video\", \"image\"].indexOf(i.type) >= 0 && this._validate(e.validateSource, `sources.${t}`, i, null, o)) return;\n        this.map && this.map._collectResourceTiming && (i.collectResourceTiming = !0);\n        const r = De(t, i, this.dispatcher, this);\n        r.setEventedParent(this, () => ({\n          isSourceLoaded: this._isSourceCacheLoaded(t),\n          source: r.serialize(),\n          sourceId: t\n        }));\n\n        const n = i => {\n          const o = (i ? \"symbol:\" : \"other:\") + t,\n                n = this._sourceCaches[o] = new e.SourceCache(o, r, i);\n          (i ? this._symbolSourceCaches : this._otherSourceCaches)[t] = n, n.style = this, n.onAdd(this.map);\n        };\n\n        n(!1), \"vector\" !== i.type && \"geojson\" !== i.type || n(!0), r.onAdd && r.onAdd(this.map), this._changed = !0;\n      }\n\n      removeSource(t) {\n        this._checkLoaded();\n\n        const i = this.getSource(t);\n        if (!i) throw new Error(\"There is no source with this ID\");\n\n        for (const i in this._layers) if (this._layers[i].source === t) return this.fire(new e.ErrorEvent(new Error(`Source \"${t}\" cannot be removed while layer \"${i}\" is using it.`)));\n\n        if (this.terrain && this.terrain.get().source === t) return this.fire(new e.ErrorEvent(new Error(`Source \"${t}\" cannot be removed while terrain is using it.`)));\n\n        const o = this._getSourceCaches(t);\n\n        for (const t of o) delete this._sourceCaches[t.id], delete this._updatedSources[t.id], t.fire(new e.Event(\"data\", {\n          sourceDataType: \"metadata\",\n          dataType: \"source\",\n          sourceId: t.getSource().id\n        })), t.setEventedParent(null), t.clearTiles();\n\n        return delete this._otherSourceCaches[t], delete this._symbolSourceCaches[t], i.setEventedParent(null), i.onRemove && i.onRemove(this.map), this._changed = !0, this;\n      }\n\n      setGeoJSONSourceData(e, t) {\n        this._checkLoaded(), this.getSource(e).setData(t), this._changed = !0;\n      }\n\n      getSource(e) {\n        const t = this._getSourceCache(e);\n\n        return t && t.getSource();\n      }\n\n      addLayer(t, i, o = {}) {\n        this._checkLoaded();\n\n        const r = t.id;\n        if (this.getLayer(r)) return void this.fire(new e.ErrorEvent(new Error(`Layer with id \"${r}\" already exists on this map`)));\n        let n;\n\n        if (\"custom\" === t.type) {\n          if (Zt(this, e.validateCustomStyleLayer(t))) return;\n          n = e.createStyleLayer(t);\n        } else {\n          if (\"object\" == typeof t.source && (this.addSource(r, t.source), t = e.clone$1(t), t = e.extend(t, {\n            source: r\n          })), this._validate(e.validateLayer, `layers.${r}`, t, {\n            arrayIndex: -1\n          }, o)) return;\n          n = e.createStyleLayer(t), this._validateLayer(n), n.setEventedParent(this, {\n            layer: {\n              id: r\n            }\n          }), this._serializedLayers[n.id] = n.serialize(), this._updateLayerCount(n, !0);\n        }\n\n        const a = i ? this._order.indexOf(i) : this._order.length;\n        if (i && -1 === a) return void this.fire(new e.ErrorEvent(new Error(`Layer with id \"${i}\" does not exist on this map.`)));\n        this._order.splice(a, 0, r), this._layerOrderChanged = !0, this._layers[r] = n;\n\n        const s = this._getLayerSourceCache(n);\n\n        if (this._removedLayers[r] && n.source && s && \"custom\" !== n.type) {\n          const e = this._removedLayers[r];\n          delete this._removedLayers[r], e.type !== n.type ? this._updatedSources[n.source] = \"clear\" : (this._updatedSources[n.source] = \"reload\", s.pause());\n        }\n\n        this._updateLayer(n), n.onAdd && n.onAdd(this.map), this._updateDrapeFirstLayers();\n      }\n\n      moveLayer(t, i) {\n        if (this._checkLoaded(), this._changed = !0, !this._layers[t]) return void this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot be moved.`)));\n        if (t === i) return;\n\n        const o = this._order.indexOf(t);\n\n        this._order.splice(o, 1);\n\n        const r = i ? this._order.indexOf(i) : this._order.length;\n        i && -1 === r ? this.fire(new e.ErrorEvent(new Error(`Layer with id \"${i}\" does not exist on this map.`))) : (this._order.splice(r, 0, t), this._layerOrderChanged = !0, this._updateDrapeFirstLayers());\n      }\n\n      removeLayer(t) {\n        this._checkLoaded();\n\n        const i = this._layers[t];\n        if (!i) return void this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot be removed.`)));\n        i.setEventedParent(null), this._updateLayerCount(i, !1);\n\n        const o = this._order.indexOf(t);\n\n        this._order.splice(o, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[t] = i, delete this._layers[t], delete this._serializedLayers[t], delete this._updatedLayers[t], delete this._updatedPaintProps[t], i.onRemove && i.onRemove(this.map), this._updateDrapeFirstLayers();\n      }\n\n      getLayer(e) {\n        return this._layers[e];\n      }\n\n      hasLayer(e) {\n        return e in this._layers;\n      }\n\n      hasLayerType(e) {\n        for (const t in this._layers) if (this._layers[t].type === e) return !0;\n\n        return !1;\n      }\n\n      setLayerZoomRange(t, i, o) {\n        this._checkLoaded();\n\n        const r = this.getLayer(t);\n        r ? r.minzoom === i && r.maxzoom === o || (null != i && (r.minzoom = i), null != o && (r.maxzoom = o), this._updateLayer(r)) : this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot have zoom extent.`)));\n      }\n\n      setFilter(t, i, o = {}) {\n        this._checkLoaded();\n\n        const n = this.getLayer(t);\n\n        if (n) {\n          if (!r(n.filter, i)) return null == i ? (n.filter = void 0, void this._updateLayer(n)) : void (this._validate(e.validateFilter, `layers.${n.id}.filter`, i, {\n            layerType: n.type\n          }, o) || (n.filter = e.clone$1(i), this._updateLayer(n)));\n        } else this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot be filtered.`)));\n      }\n\n      getFilter(t) {\n        const i = this.getLayer(t);\n        return i && e.clone$1(i.filter);\n      }\n\n      setLayoutProperty(t, i, o, n = {}) {\n        this._checkLoaded();\n\n        const a = this.getLayer(t);\n        a ? r(a.getLayoutProperty(i), o) || (a.setLayoutProperty(i, o, n), this._updateLayer(a)) : this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot be styled.`)));\n      }\n\n      getLayoutProperty(t, i) {\n        const o = this.getLayer(t);\n        if (o) return o.getLayoutProperty(i);\n        this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style.`)));\n      }\n\n      setPaintProperty(t, i, o, n = {}) {\n        this._checkLoaded();\n\n        const a = this.getLayer(t);\n        a ? r(a.getPaintProperty(i), o) || (a.setPaintProperty(i, o, n) && this._updateLayer(a), this._changed = !0, this._updatedPaintProps[t] = !0) : this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot be styled.`)));\n      }\n\n      getPaintProperty(e, t) {\n        const i = this.getLayer(e);\n        return i && i.getPaintProperty(t);\n      }\n\n      setFeatureState(t, i) {\n        this._checkLoaded();\n\n        const o = t.source,\n              r = t.sourceLayer,\n              n = this.getSource(o);\n        if (!n) return void this.fire(new e.ErrorEvent(new Error(`The source '${o}' does not exist in the map's style.`)));\n        const a = n.type;\n        if (\"geojson\" === a && r) return void this.fire(new e.ErrorEvent(new Error(\"GeoJSON sources cannot have a sourceLayer parameter.\")));\n        if (\"vector\" === a && !r) return void this.fire(new e.ErrorEvent(new Error(\"The sourceLayer parameter must be provided for vector source types.\")));\n        void 0 === t.id && this.fire(new e.ErrorEvent(new Error(\"The feature id parameter must be provided.\")));\n\n        const s = this._getSourceCaches(o);\n\n        for (const e of s) e.setFeatureState(r, t.id, i);\n      }\n\n      removeFeatureState(t, i) {\n        this._checkLoaded();\n\n        const o = t.source,\n              r = this.getSource(o);\n        if (!r) return void this.fire(new e.ErrorEvent(new Error(`The source '${o}' does not exist in the map's style.`)));\n        const n = r.type,\n              a = \"vector\" === n ? t.sourceLayer : void 0;\n        if (\"vector\" === n && !a) return void this.fire(new e.ErrorEvent(new Error(\"The sourceLayer parameter must be provided for vector source types.\")));\n        if (i && \"string\" != typeof t.id && \"number\" != typeof t.id) return void this.fire(new e.ErrorEvent(new Error(\"A feature id is required to remove its specific state property.\")));\n\n        const s = this._getSourceCaches(o);\n\n        for (const e of s) e.removeFeatureState(a, t.id, i);\n      }\n\n      getFeatureState(t) {\n        this._checkLoaded();\n\n        const i = t.source,\n              o = t.sourceLayer,\n              r = this.getSource(i);\n\n        if (r) {\n          if (\"vector\" !== r.type || o) return void 0 === t.id && this.fire(new e.ErrorEvent(new Error(\"The feature id parameter must be provided.\"))), this._getSourceCaches(i)[0].getFeatureState(o, t.id);\n          this.fire(new e.ErrorEvent(new Error(\"The sourceLayer parameter must be provided for vector source types.\")));\n        } else this.fire(new e.ErrorEvent(new Error(`The source '${i}' does not exist in the map's style.`)));\n      }\n\n      getTransition() {\n        return e.extend({\n          duration: 300,\n          delay: 0\n        }, this.stylesheet && this.stylesheet.transition);\n      }\n\n      serialize() {\n        const t = {};\n\n        for (const e in this._sourceCaches) {\n          const i = this._sourceCaches[e].getSource();\n\n          t[i.id] || (t[i.id] = i.serialize());\n        }\n\n        return e.filterObject({\n          version: this.stylesheet.version,\n          name: this.stylesheet.name,\n          metadata: this.stylesheet.metadata,\n          light: this.stylesheet.light,\n          terrain: this.stylesheet.terrain,\n          fog: this.stylesheet.fog,\n          center: this.stylesheet.center,\n          zoom: this.stylesheet.zoom,\n          bearing: this.stylesheet.bearing,\n          pitch: this.stylesheet.pitch,\n          sprite: this.stylesheet.sprite,\n          glyphs: this.stylesheet.glyphs,\n          transition: this.stylesheet.transition,\n          projection: this.stylesheet.projection,\n          sources: t,\n          layers: this._serializeLayers(this._order)\n        }, e => void 0 !== e);\n      }\n\n      _updateLayer(e) {\n        this._updatedLayers[e.id] = !0;\n\n        const t = this._getLayerSourceCache(e);\n\n        e.source && !this._updatedSources[e.source] && t && \"raster\" !== t.getSource().type && (this._updatedSources[e.source] = \"reload\", t.pause()), this._changed = !0, e.invalidateCompiledFilter();\n      }\n\n      _flattenAndSortRenderedFeatures(e) {\n        const t = e => \"fill-extrusion\" === this._layers[e].type,\n              i = {},\n              o = [];\n\n        for (let r = this._order.length - 1; r >= 0; r--) {\n          const n = this._order[r];\n\n          if (t(n)) {\n            i[n] = r;\n\n            for (const t of e) {\n              const e = t[n];\n              if (e) for (const t of e) o.push(t);\n            }\n          }\n        }\n\n        o.sort((e, t) => t.intersectionZ - e.intersectionZ);\n        const r = [];\n\n        for (let n = this._order.length - 1; n >= 0; n--) {\n          const a = this._order[n];\n          if (t(a)) for (let e = o.length - 1; e >= 0; e--) {\n            const t = o[e].feature;\n            if (i[t.layer.id] < n) break;\n            r.push(t), o.pop();\n          } else for (const t of e) {\n            const e = t[a];\n            if (e) for (const t of e) r.push(t.feature);\n          }\n        }\n\n        return r;\n      }\n\n      queryRenderedFeatures(t, i, o) {\n        i && i.filter && this._validate(e.validateFilter, \"queryRenderedFeatures.filter\", i.filter, null, i);\n        const r = {};\n\n        if (i && i.layers) {\n          if (!Array.isArray(i.layers)) return this.fire(new e.ErrorEvent(new Error(\"parameters.layers must be an Array.\"))), [];\n\n          for (const t of i.layers) {\n            const i = this._layers[t];\n            if (!i) return this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot be queried for features.`))), [];\n            r[i.source] = !0;\n          }\n        }\n\n        const n = [];\n        i.availableImages = this._availableImages;\n        const a = i && i.layers ? i.layers.some(e => {\n          const t = this.getLayer(e);\n          return t && t.is3D();\n        }) : this.has3DLayers(),\n              s = R.createFromScreenPoints(t, o);\n\n        for (const e in this._sourceCaches) {\n          const t = this._sourceCaches[e].getSource().id;\n\n          i.layers && !r[t] || n.push(Ae(this._sourceCaches[e], this._layers, this._serializedLayers, s, i, o, a, !!this.map._showQueryGeometry));\n        }\n\n        return this.placement && n.push(function (e, t, i, o, r, n, a) {\n          const s = {},\n                l = n.queryRenderedSymbols(o),\n                c = [];\n\n          for (const e of Object.keys(l).map(Number)) c.push(a[e]);\n\n          c.sort(Re);\n\n          for (const i of c) {\n            const o = i.featureIndex.lookupSymbolFeatures(l[i.bucketInstanceId], t, i.bucketIndex, i.sourceLayerIndex, r.filter, r.layers, r.availableImages, e);\n\n            for (const e in o) {\n              const t = s[e] = s[e] || [],\n                    r = o[e];\n              r.sort((e, t) => {\n                const o = i.featureSortOrder;\n\n                if (o) {\n                  const i = o.indexOf(e.featureIndex);\n                  return o.indexOf(t.featureIndex) - i;\n                }\n\n                return t.featureIndex - e.featureIndex;\n              });\n\n              for (const e of r) t.push(e);\n            }\n          }\n\n          for (const t in s) s[t].forEach(o => {\n            const r = o.feature,\n                  n = i(e[t]).getFeatureState(r.layer[\"source-layer\"], r.id);\n            r.source = r.layer.source, r.layer[\"source-layer\"] && (r.sourceLayer = r.layer[\"source-layer\"]), r.state = n;\n          });\n\n          return s;\n        }(this._layers, this._serializedLayers, this._getLayerSourceCache.bind(this), s.screenGeometry, i, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(n);\n      }\n\n      querySourceFeatures(t, i) {\n        i && i.filter && this._validate(e.validateFilter, \"querySourceFeatures.filter\", i.filter, null, i);\n\n        const o = this._getSourceCaches(t);\n\n        let r = [];\n\n        for (const e of o) r = r.concat(Le(e, i));\n\n        return r;\n      }\n\n      addSourceType(e, t, i) {\n        return $t.getSourceType(e) ? i(new Error(`A source type called \"${e}\" already exists.`)) : ($t.setSourceType(e, t), t.workerSourceURL ? void this.dispatcher.broadcast(\"loadWorkerSource\", {\n          name: e,\n          url: t.workerSourceURL\n        }, i) : i(null, null));\n      }\n\n      getLight() {\n        return this.light.getLight();\n      }\n\n      setLight(t, i = {}) {\n        this._checkLoaded();\n\n        const o = this.light.getLight();\n        let n = !1;\n\n        for (const e in t) if (!r(t[e], o[e])) {\n          n = !0;\n          break;\n        }\n\n        if (!n) return;\n        const a = {\n          now: e.exported.now(),\n          transition: e.extend({\n            duration: 300,\n            delay: 0\n          }, this.stylesheet.transition)\n        };\n        this.light.setLight(t, i), this.light.updateTransitions(a);\n      }\n\n      getTerrain() {\n        return this.terrain && 1 === this.terrain.drapeRenderMode ? this.terrain.get() : null;\n      }\n\n      setTerrainForDraping() {\n        this.setTerrain({\n          source: \"\",\n          exaggeration: 0\n        }, 0);\n      }\n\n      setTerrain(t, i = 1) {\n        if (this._checkLoaded(), !t) return delete this.terrain, delete this.stylesheet.terrain, this.dispatcher.broadcast(\"enableTerrain\", !1), this._force3DLayerUpdate(), void (this._markersNeedUpdate = !0);\n\n        if (1 === i) {\n          if (\"object\" == typeof t.source) {\n            const i = \"terrain-dem-src\";\n            this.addSource(i, t.source), t = e.clone$1(t), t = e.extend(t, {\n              source: i\n            });\n          }\n\n          if (this._validate(e.validateTerrain, \"terrain\", t)) return;\n        }\n\n        if (!this.terrain || this.terrain && i !== this.terrain.drapeRenderMode) this._createTerrain(t, i);else {\n          const i = this.terrain,\n                o = i.get();\n\n          for (const n in t) if (!r(t[n], o[n])) {\n            i.set(t), this.stylesheet.terrain = t;\n            const o = {\n              now: e.exported.now(),\n              transition: e.extend({\n                duration: 0\n              }, this.stylesheet.transition)\n            };\n            i.updateTransitions(o);\n            break;\n          }\n        }\n        this._updateDrapeFirstLayers(), this._markersNeedUpdate = !0;\n      }\n\n      _createFog(t) {\n        const i = this.fog = new P(t, this.map.transform);\n        this.stylesheet.fog = t;\n        const o = {\n          now: e.exported.now(),\n          transition: e.extend({\n            duration: 0\n          }, this.stylesheet.transition)\n        };\n        i.updateTransitions(o);\n      }\n\n      _updateMarkersOpacity() {\n        0 !== this.map._markers.length && this.map._requestDomTask(() => {\n          for (const e of this.map._markers) e._evaluateOpacity();\n        });\n      }\n\n      getFog() {\n        return this.fog ? this.fog.get() : null;\n      }\n\n      setFog(t) {\n        if (this._checkLoaded(), !t) return delete this.fog, delete this.stylesheet.fog, void (this._markersNeedUpdate = !0);\n\n        if (this.fog) {\n          const i = this.fog,\n                o = i.get();\n\n          for (const n in t) if (!r(t[n], o[n])) {\n            i.set(t), this.stylesheet.fog = t;\n            const o = {\n              now: e.exported.now(),\n              transition: e.extend({\n                duration: 0\n              }, this.stylesheet.transition)\n            };\n            i.updateTransitions(o);\n            break;\n          }\n        } else this._createFog(t);\n\n        this._markersNeedUpdate = !0;\n      }\n\n      _updateDrapeFirstLayers() {\n        if (!this.map._optimizeForTerrain || !this.terrain) return;\n\n        const e = this._order.filter(e => this.isLayerDraped(this._layers[e])),\n              t = this._order.filter(e => !this.isLayerDraped(this._layers[e]));\n\n        this._drapedFirstOrder = [], this._drapedFirstOrder.push(...e), this._drapedFirstOrder.push(...t);\n      }\n\n      _createTerrain(t, i) {\n        const o = this.terrain = new I(t, i);\n        this.stylesheet.terrain = t, this.dispatcher.broadcast(\"enableTerrain\", !this.terrainSetForDrapingOnly()), this._force3DLayerUpdate();\n        const r = {\n          now: e.exported.now(),\n          transition: e.extend({\n            duration: 0\n          }, this.stylesheet.transition)\n        };\n        o.updateTransitions(r);\n      }\n\n      _force3DLayerUpdate() {\n        for (const e in this._layers) {\n          const t = this._layers[e];\n          \"fill-extrusion\" === t.type && this._updateLayer(t);\n        }\n      }\n\n      _forceSymbolLayerUpdate() {\n        for (const e in this._layers) {\n          const t = this._layers[e];\n          \"symbol\" === t.type && this._updateLayer(t);\n        }\n      }\n\n      _validate(t, i, o, r, n = {}) {\n        return (!n || !1 !== n.validate) && Zt(this, t.call(e.validateStyle, e.extend({\n          key: i,\n          style: this.serialize(),\n          value: o,\n          styleSpec: e.spec\n        }, r)));\n      }\n\n      _remove() {\n        this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), e.evented.off(\"pluginStateChange\", this._rtlTextPluginCallback);\n\n        for (const e in this._layers) this._layers[e].setEventedParent(null);\n\n        for (const e in this._sourceCaches) this._sourceCaches[e].clearTiles(), this._sourceCaches[e].setEventedParent(null);\n\n        this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove();\n      }\n\n      _clearSource(e) {\n        const t = this._getSourceCaches(e);\n\n        for (const e of t) e.clearTiles();\n      }\n\n      _reloadSource(e) {\n        const t = this._getSourceCaches(e);\n\n        for (const e of t) e.resume(), e.reload();\n      }\n\n      _updateSources(e) {\n        for (const t in this._sourceCaches) this._sourceCaches[t].update(e);\n      }\n\n      _generateCollisionBoxes() {\n        for (const e in this._sourceCaches) {\n          const t = this._sourceCaches[e];\n          t.resume(), t.reload();\n        }\n      }\n\n      _updatePlacement(t, i, o, r, n = !1) {\n        let a = !1,\n            s = !1;\n        const l = {};\n\n        for (const e of this._order) {\n          const i = this._layers[e];\n          if (\"symbol\" !== i.type) continue;\n\n          if (!l[i.source]) {\n            const e = this._getLayerSourceCache(i);\n\n            if (!e) continue;\n            l[i.source] = e.getRenderableIds(!0).map(t => e.getTileByID(t)).sort((e, t) => t.tileID.overscaledZ - e.tileID.overscaledZ || (e.tileID.isLessThan(t.tileID) ? -1 : 1));\n          }\n\n          const o = this.crossTileSymbolIndex.addLayer(i, l[i.source], t.center.lng, t.projection);\n          a = a || o;\n        }\n\n        if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), n = n || this._layerOrderChanged || 0 === o, this._layerOrderChanged && this.fire(new e.Event(\"neworder\")), (n || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(e.exported.now(), t.zoom)) && (this.pauseablePlacement = new Bt(t, this._order, n, i, o, r, this.placement, this.fog && t.projection.supportsFog ? this.fog.state : null), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(e.exported.now()), s = !0), a && this.pauseablePlacement.placement.setStale()), s || a) for (const e of this._order) {\n          const t = this._layers[e];\n          \"symbol\" === t.type && this.placement.updateLayerOpacities(t, l[t.source]);\n        }\n        return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(e.exported.now());\n      }\n\n      _releaseSymbolFadeTiles() {\n        for (const e in this._sourceCaches) this._sourceCaches[e].releaseSymbolFadeTiles();\n      }\n\n      getImages(e, t, i) {\n        this.imageManager.getImages(t.icons, i), this._updateTilesForChangedImages();\n\n        const o = e => {\n          e && e.setDependencies(t.tileID.key, t.type, t.icons);\n        };\n\n        o(this._otherSourceCaches[t.source]), o(this._symbolSourceCaches[t.source]);\n      }\n\n      getGlyphs(e, t, i) {\n        this.glyphManager.getGlyphs(t.stacks, i);\n      }\n\n      getResource(t, i, o) {\n        return e.makeRequest(i, o);\n      }\n\n      _getSourceCache(e) {\n        return this._otherSourceCaches[e];\n      }\n\n      _getLayerSourceCache(e) {\n        return \"symbol\" === e.type ? this._symbolSourceCaches[e.source] : this._otherSourceCaches[e.source];\n      }\n\n      _getSourceCaches(e) {\n        const t = [];\n        return this._otherSourceCaches[e] && t.push(this._otherSourceCaches[e]), this._symbolSourceCaches[e] && t.push(this._symbolSourceCaches[e]), t;\n      }\n\n      _isSourceCacheLoaded(t) {\n        const i = this._getSourceCaches(t);\n\n        return 0 === i.length ? (this.fire(new e.ErrorEvent(new Error(`There is no source with ID '${t}'`))), !1) : i.every(e => e.loaded());\n      }\n\n      has3DLayers() {\n        return this._num3DLayers > 0;\n      }\n\n      hasSymbolLayers() {\n        return this._numSymbolLayers > 0;\n      }\n\n      hasCircleLayers() {\n        return this._numCircleLayers > 0;\n      }\n\n      _clearWorkerCaches() {\n        this.dispatcher.broadcast(\"clearCaches\");\n      }\n\n      destroy() {\n        this._clearWorkerCaches(), this.terrainSetForDrapingOnly() && (delete this.terrain, delete this.stylesheet.terrain);\n      }\n\n    }\n\n    $t.getSourceType = function (e) {\n      return ze[e];\n    }, $t.setSourceType = function (e, t) {\n      ze[e] = t;\n    }, $t.registerForPluginStateChange = e.registerForPluginStateChange;\n    var Ht = \"\\n#define EPSILON 0.0000001\\n#define PI 3.141592653589793\\n#define EXTENT 8192.0\\n#define HALF_PI PI/2.0\\n#define QUARTER_PI PI/4.0\\n#define RAD_TO_DEG 180.0/PI\\n#define DEG_TO_RAD PI/180.0\\n#define GLOBE_RADIUS EXTENT/PI/2.0\\n#ifdef FOG\\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;varying vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}\\n#endif\",\n        Kt = \"attribute highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;varying highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}\";\n    let Yt = {},\n        Jt = {};\n    Yt = ii(\"\", \"\\n#define ELEVATION_SCALE 7.0\\n#define ELEVATION_OFFSET 450.0\\n#ifdef PROJECTION_GLOBE_VIEW\\nuniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(\\nmix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}\\n#else\\nvec3 elevationVector(vec2 pos) { return vec3(0,0,1); }\\n#endif\\n#ifdef TERRAIN\\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;\\n#else\\nuniform sampler2D u_dem;uniform sampler2D u_dem_prev;\\n#endif\\nuniform vec4 u_dem_unpack;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;uniform sampler2D u_depth;uniform vec2 u_depth_size_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float decodeElevation(vec4 v) {return dot(vec4(v.xyz*255.0,-1.0),u_dem_unpack);}float currentElevation(vec2 apos) {\\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem,pos).a;\\n#else\\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem,pos));\\n#ifdef TERRAIN_DEM_NEAREST_FILTER\\nreturn u_exaggeration*tl;\\n#endif\\nfloat tr=decodeElevation(texture2D(u_dem,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\\n#endif\\n}float prevElevation(vec2 apos) {\\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem_prev,pos).a;\\n#else\\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem_prev,pos));float tr=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem_prev,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\\n#endif\\n}\\n#ifdef TERRAIN_VERTEX_MORPHING\\nfloat elevation(vec2 apos) {float nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}\\n#else\\nfloat elevation(vec2 apos) {return currentElevation(apos);}\\n#endif\\nfloat unpack_depth(vec4 rgba_depth)\\n{const vec4 bit_shift=vec4(1.0/(256.0*256.0*256.0),1.0/(256.0*256.0),1.0/256.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}bool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;float depth=unpack_depth(texture2D(u_depth,(coord.xy+1.0)*0.5));return coord.z > depth+0.0005;}float occlusionFade(vec4 frag) {vec3 coord=frag.xyz/frag.w;vec3 df=vec3(5.0*u_depth_size_inv,0.0);vec2 uv=0.5*coord.xy+0.5;vec4 depth=vec4(\\nunpack_depth(texture2D(u_depth,uv-df.xz)),unpack_depth(texture2D(u_depth,uv+df.xz)),unpack_depth(texture2D(u_depth,uv-df.zy)),unpack_depth(texture2D(u_depth,uv+df.zy))\\n);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z-0.001)-depth),0.0,1.0));}vec4 fourSample(vec2 pos,vec2 off) {\\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\\nfloat tl=texture2D(u_dem,pos).a;float tr=texture2D(u_dem,pos+vec2(off.x,0.0)).a;float bl=texture2D(u_dem,pos+vec2(0.0,off.y)).a;float br=texture2D(u_dem,pos+off).a;\\n#else\\nvec4 demtl=vec4(texture2D(u_dem,pos).xyz*255.0,-1.0);float tl=dot(demtl,u_dem_unpack);vec4 demtr=vec4(texture2D(u_dem,pos+vec2(off.x,0.0)).xyz*255.0,-1.0);float tr=dot(demtr,u_dem_unpack);vec4 dembl=vec4(texture2D(u_dem,pos+vec2(0.0,off.y)).xyz*255.0,-1.0);float bl=dot(dembl,u_dem_unpack);vec4 dembr=vec4(texture2D(u_dem,pos+off).xyz*255.0,-1.0);float br=dot(dembr,u_dem_unpack);\\n#endif\\nreturn vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;vec4 bounds=vec4(d,vec2(1.0)-d);h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}\\n#else\\nfloat elevation(vec2 pos) { return 0.0; }bool isOccluded(vec4 frag) { return false; }float occlusionFade(vec4 frag) { return 1.0; }\\n#endif\", !0), Jt = ii(\"#ifdef FOG\\nuniform float u_fog_temporal_offset;float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);return mix(color,u_fog_color.rgb,opacity);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec3 fog_dither(vec3 color) {vec2 dither_seed=gl_FragCoord.xy+u_fog_temporal_offset;return dither(color,dither_seed);}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\\n#endif\", \"#ifdef FOG\\nuniform mat4 u_fog_matrix;vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\\n#endif\", !0);\n    const Qt = ii(\"\\nhighp vec3 hash(highp vec2 p) {highp vec3 p3=fract(p.xyx*vec3(443.8975,397.2973,491.1871));p3+=dot(p3,p3.yxz+19.19);return fract((p3.xxy+p3.yzz)*p3.zyx);}vec3 dither(vec3 color,highp vec2 seed) {vec3 rnd=hash(seed)+hash(seed+0.59374)-0.5;return color+rnd/255.0;}\\n#ifdef TERRAIN\\nhighp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(256.0*256.0*256.0,256.0*256.0,256.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/256.0,1.0/256.0,1.0/256.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}\\n#endif\", \"\\nfloat wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {\\n#ifndef PROJECTED_POS_ON_VIEWPORT\\nfloat tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;\\n#else\\nreturn vec3(0.0);\\n#endif\\n}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}\\n#endif\\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(\\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}const vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);//Normalized device coordinate that is not rendered.\"),\n          ei = Ht;\n    var ti = {\n      background: ii(\"uniform vec4 u_color;uniform float u_opacity;void main() {vec4 out_color=u_color;\\n#ifdef FOG\\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\\n#endif\\ngl_FragColor=out_color*u_opacity;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);\\n#endif\\n}\"),\n      backgroundPattern: ii(\"uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 out_color=mix(color1,color2,u_mix);\\n#ifdef FOG\\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\\n#endif\\ngl_FragColor=out_color*u_opacity;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);\\n#endif\\n}\"),\n      circle: ii(\"varying vec3 v_data;varying float v_visibility;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define mediump float radius\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define highp vec4 stroke_color\\n#pragma mapbox: define mediump float stroke_width\\n#pragma mapbox: define lowp float stroke_opacity\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize mediump float radius\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize highp vec4 stroke_color\\n#pragma mapbox: initialize mediump float stroke_width\\n#pragma mapbox: initialize lowp float stroke_opacity\\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\\n#ifdef FOG\\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\\n#endif\\ngl_FragColor=out_color*(v_visibility*opacity_t);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"#define NUM_VISIBILITY_RINGS 2\\n#define INV_SQRT2 0.70710678\\n#define ELEVATION_BIAS 0.0001\\n#define NUM_SAMPLES_PER_RING 16\\nuniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;\\n#ifdef PROJECTION_GLOBE_VIEW\\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;attribute float a_scale;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\\n#endif\\nvarying vec3 v_data;varying float v_visibility;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define mediump float radius\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define highp vec4 stroke_color\\n#pragma mapbox: define mediump float stroke_width\\n#pragma mapbox: define lowp float stroke_opacity\\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\\n#if defined(TERRAIN)\\nreturn elevation(pos)+ELEVATION_BIAS;\\n#else\\nreturn 0.0;\\n#endif\\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\\n#ifdef PITCH_WITH_MAP\\n#ifdef PROJECTION_GLOBE_VIEW\\nreturn u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );\\n#else\\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\\n#endif\\n#else\\nreturn projected_center+vec4(sample_offset,0,0);\\n#endif\\n}float get_sample_step() {\\n#ifdef PITCH_WITH_MAP\\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\\n#else\\nreturn PI/float(NUM_SAMPLES_PER_RING);\\n#endif\\n}void main(void) {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize mediump float radius\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize highp vec4 stroke_color\\n#pragma mapbox: initialize mediump float stroke_width\\n#pragma mapbox: initialize lowp float stroke_opacity\\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec2 scaled_extrude=extrude*a_scale;vec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=scaled_extrude.x*surface_vectors[0]+scaled_extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);vec4 world_center=vec4(pos,1);\\n#else \\nmat3 surface_vectors=mat3(1.0);float height=circle_elevation(circle_center);vec4 world_center=vec4(circle_center,height,1);\\n#endif\\nvec4 projected_center=u_matrix*world_center;float view_scale=0.0;\\n#ifdef PITCH_WITH_MAP\\n#ifdef SCALE_WITH_MAP\\nview_scale=1.0;\\n#else\\nview_scale=projected_center.w/u_camera_to_center_distance;\\n#endif\\n#else\\n#ifdef SCALE_WITH_MAP\\nview_scale=u_camera_to_center_distance;\\n#else\\nview_scale=projected_center.w;\\n#endif\\n#endif\\n#if defined(SCALE_WITH_MAP) && defined(PROJECTION_GLOBE_VIEW)\\nview_scale*=a_scale;\\n#endif\\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;\\n#ifdef TERRAIN\\nfloat step=get_sample_step();\\n#ifdef PITCH_WITH_MAP\\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);vec4 occlusion_world_center=vec4(circle_center,cantilevered_height,1);vec4 occlusion_projected_center=u_matrix*occlusion_world_center;\\n#else\\nvec4 occlusion_world_center=world_center;vec4 occlusion_projected_center=projected_center;\\n#endif\\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\\n#else\\nvisibility=1.0;\\n#endif\\n#ifdef PROJECTION_GLOBE_VIEW\\nvisibility=1.0;\\n#endif\\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\\n#ifdef FOG\\nv_fog_pos=fog_position(world_center.xyz);\\n#endif\\n}\"),\n      clippingMask: ii(\"void main() {gl_FragColor=vec4(1.0);}\", \"attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}\"),\n      heatmap: ii(\"uniform highp float u_intensity;varying vec2 v_extrude;\\n#pragma mapbox: define highp float weight\\n#define GAUSS_COEF 0.3989422804014327\\nvoid main() {\\n#pragma mapbox: initialize highp float weight\\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\\n#ifdef FOG\\ngl_FragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);\\n#endif\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;\\n#ifdef PROJECTION_GLOBE_VIEW\\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;attribute float a_scale;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\\n#endif\\nvarying vec2 v_extrude;\\n#pragma mapbox: define highp float weight\\n#pragma mapbox: define mediump float radius\\nconst highp float ZERO=1.0/255.0/16.0;\\n#define GAUSS_COEF 0.3989422804014327\\nvoid main(void) {\\n#pragma mapbox: initialize highp float weight\\n#pragma mapbox: initialize mediump float radius\\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);\\n#ifdef PROJECTION_GLOBE_VIEW\\nextrude*=a_scale;vec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\\n#else\\nvec3 pos=vec3(tilePos+extrude,elevation(tilePos));\\n#endif\\ngl_Position=u_matrix*vec4(pos,1);\\n#ifdef FOG\\nv_fog_pos=fog_position(pos);\\n#endif\\n}\"),\n      heatmapTexture: ii(\"uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(0.0);\\n#endif\\n}\", \"attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}\"),\n      collisionBox: ii(\"varying float v_placed;varying float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);gl_FragColor =mix(red,blue,step(0.5,v_placed))*0.5;gl_FragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}\", \"attribute vec3 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;attribute float a_size_scale;attribute vec2 a_padding;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*elevation(a_anchor_pos),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}\"),\n      collisionCircle: ii(\"varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}\", \"attribute vec2 a_pos_2f;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}\"),\n      debug: ii(\"uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}\", \"attribute vec2 a_pos;\\n#ifdef PROJECTION_GLOBE_VIEW\\nattribute vec3 a_pos_3;\\n#endif\\nvarying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;\\n#ifdef PROJECTION_GLOBE_VIEW\\ngl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);\\n#else\\ngl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);\\n#endif\\n}\"),\n      fill: ii(\"#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize lowp float opacity\\nvec4 out_color=color;\\n#ifdef FOG\\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\\n#endif\\ngl_FragColor=out_color*opacity;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"attribute vec2 a_pos;uniform mat4 u_matrix;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize lowp float opacity\\ngl_Position=u_matrix*vec4(a_pos,0,1);\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);\\n#endif\\n}\"),\n      fillOutline: ii(\"varying vec2 v_pos;\\n#pragma mapbox: define highp vec4 outline_color\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 outline_color\\n#pragma mapbox: initialize lowp float opacity\\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\\n#ifdef FOG\\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\\n#endif\\ngl_FragColor=out_color*(alpha*opacity);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\\n#pragma mapbox: define highp vec4 outline_color\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 outline_color\\n#pragma mapbox: initialize lowp float opacity\\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);\\n#endif\\n}\"),\n      fillOutlinePattern: ii(\"uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp vec4 pattern_from\\n#pragma mapbox: define lowp vec4 pattern_to\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump vec4 pattern_from\\n#pragma mapbox: initialize mediump vec4 pattern_to\\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=mix(color1,color2,u_fade);\\n#ifdef FOG\\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\\n#endif\\ngl_FragColor=out_color*(alpha*opacity);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp vec4 pattern_from\\n#pragma mapbox: define lowp vec4 pattern_to\\n#pragma mapbox: define lowp float pixel_ratio_from\\n#pragma mapbox: define lowp float pixel_ratio_to\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump vec4 pattern_from\\n#pragma mapbox: initialize mediump vec4 pattern_to\\n#pragma mapbox: initialize lowp float pixel_ratio_from\\n#pragma mapbox: initialize lowp float pixel_ratio_to\\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);\\n#endif\\n}\"),\n      fillPattern: ii(\"uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp vec4 pattern_from\\n#pragma mapbox: define lowp vec4 pattern_to\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump vec4 pattern_from\\n#pragma mapbox: initialize mediump vec4 pattern_to\\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 out_color=mix(color1,color2,u_fade);\\n#ifdef FOG\\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\\n#endif\\ngl_FragColor=out_color*opacity;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp vec4 pattern_from\\n#pragma mapbox: define lowp vec4 pattern_to\\n#pragma mapbox: define lowp float pixel_ratio_from\\n#pragma mapbox: define lowp float pixel_ratio_to\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump vec4 pattern_from\\n#pragma mapbox: initialize mediump vec4 pattern_to\\n#pragma mapbox: initialize lowp float pixel_ratio_from\\n#pragma mapbox: initialize lowp float pixel_ratio_to\\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);\\n#endif\\n}\"),\n      fillExtrusion: ii(\"varying vec4 v_color;void main() {vec4 color=v_color;\\n#ifdef FOG\\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\\n#endif\\ngl_FragColor=color;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\\n#ifdef PROJECTION_GLOBE_VIEW\\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\\n#endif\\nvarying vec4 v_color;\\n#pragma mapbox: define highp float base\\n#pragma mapbox: define highp float height\\n#pragma mapbox: define highp vec4 color\\nvoid main() {\\n#pragma mapbox: initialize highp float base\\n#pragma mapbox: initialize highp float height\\n#pragma mapbox: initialize highp vec4 color\\nvec3 pos_nx=floor(a_pos_normal_ed.xyz*0.5);mediump vec3 top_up_ny=a_pos_normal_ed.xyz-2.0*pos_nx;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\\n#if defined(HAS_CENTROID) || defined(TERRAIN)\\ncentroid_pos=a_centroid_pos;\\n#endif\\n#ifdef TERRAIN\\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;float ele=elevation(pos_nx.xy);float c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;float h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);vec3 pos=vec3(pos_nx.xy,h);\\n#else\\nvec3 pos=vec3(pos_nx.xy,t > 0.0 ? height : base);\\n#endif\\n#ifdef PROJECTION_GLOBE_VIEW\\nfloat lift=float((t+base) > 0.0)*u_height_lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(pos.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\\n#endif\\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=(\\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.rgb+=clamp(color.rgb*directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_color*=u_opacity;\\n#ifdef FOG\\nv_fog_pos=fog_position(pos);\\n#endif\\n}\"),\n      fillExtrusionPattern: ii(\"uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\\n#pragma mapbox: define lowp float base\\n#pragma mapbox: define lowp float height\\n#pragma mapbox: define lowp vec4 pattern_from\\n#pragma mapbox: define lowp vec4 pattern_to\\n#pragma mapbox: define lowp float pixel_ratio_from\\n#pragma mapbox: define lowp float pixel_ratio_to\\nvoid main() {\\n#pragma mapbox: initialize lowp float base\\n#pragma mapbox: initialize lowp float height\\n#pragma mapbox: initialize mediump vec4 pattern_from\\n#pragma mapbox: initialize mediump vec4 pattern_to\\n#pragma mapbox: initialize lowp float pixel_ratio_from\\n#pragma mapbox: initialize lowp float pixel_ratio_to\\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 out_color=mix(color1,color2,u_fade);out_color=out_color*v_lighting;\\n#ifdef FOG\\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\\n#endif\\ngl_FragColor=out_color;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\\n#ifdef PROJECTION_GLOBE_VIEW\\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\\n#endif\\nvarying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\\n#pragma mapbox: define lowp float base\\n#pragma mapbox: define lowp float height\\n#pragma mapbox: define lowp vec4 pattern_from\\n#pragma mapbox: define lowp vec4 pattern_to\\n#pragma mapbox: define lowp float pixel_ratio_from\\n#pragma mapbox: define lowp float pixel_ratio_to\\nvoid main() {\\n#pragma mapbox: initialize lowp float base\\n#pragma mapbox: initialize lowp float height\\n#pragma mapbox: initialize mediump vec4 pattern_from\\n#pragma mapbox: initialize mediump vec4 pattern_to\\n#pragma mapbox: initialize lowp float pixel_ratio_from\\n#pragma mapbox: initialize lowp float pixel_ratio_to\\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 pos_nx=floor(a_pos_normal_ed.xyz*0.5);mediump vec3 top_up_ny=a_pos_normal_ed.xyz-2.0*pos_nx;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);\\n#if defined(HAS_CENTROID) || defined(TERRAIN)\\ncentroid_pos=a_centroid_pos;\\n#endif\\n#ifdef TERRAIN\\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;float ele=elevation(pos_nx.xy);float c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;float h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);vec3 p=vec3(pos_nx.xy,h);\\n#else\\nvec3 p=vec3(pos_nx.xy,z);\\n#endif\\n#ifdef PROJECTION_GLOBE_VIEW\\nfloat lift=float((t+base) > 0.0)*u_height_lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\\n#endif\\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0\\n? pos_nx.xy\\n: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=(\\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;\\n#ifdef FOG\\nv_fog_pos=fog_position(p);\\n#endif\\n}\"),\n      hillshadePrepare: ii(\"#ifdef GL_ES\\nprecision highp float;\\n#endif\\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord) {\\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\\nreturn texture2D(u_image,coord).a/4.0;\\n#else\\nvec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;\\n#endif\\n}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos);float f=getElevation(v_pos+vec2(epsilon.x,0));float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float h=getElevation(v_pos+vec2(0,epsilon.y));float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\\n(c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c)\\n)/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(\\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}\"),\n      hillshade: ii(\"uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\\n#ifdef FOG\\ngl_FragColor=fog_dither(fog_apply_premultiplied(gl_FragColor,v_fog_pos));\\n#endif\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);\\n#endif\\n}\"),\n      line: ii(\"uniform lowp float u_device_pixel_ratio;uniform float u_alpha_discard_threshold;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;\\n#ifdef RENDER_LINE_DASH\\nuniform sampler2D u_dash_image;uniform float u_mix;uniform vec3 u_scale;varying vec2 v_tex_a;varying vec2 v_tex_b;\\n#endif\\n#ifdef RENDER_LINE_GRADIENT\\nuniform sampler2D u_gradient_image;varying highp vec2 v_uv;\\n#endif\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define lowp float floorwidth\\n#pragma mapbox: define lowp vec4 dash_from\\n#pragma mapbox: define lowp vec4 dash_to\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize lowp float floorwidth\\n#pragma mapbox: initialize lowp vec4 dash_from\\n#pragma mapbox: initialize lowp vec4 dash_to\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\\n#ifdef RENDER_LINE_DASH\\nfloat sdfdist_a=texture2D(u_dash_image,v_tex_a).a;float sdfdist_b=texture2D(u_dash_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfwidth=min(dash_from.z*u_scale.y,dash_to.z*u_scale.z);float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/sdfwidth;alpha*=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);\\n#endif\\n#ifdef RENDER_LINE_GRADIENT\\nvec4 out_color=texture2D(u_gradient_image,v_uv);\\n#else\\nvec4 out_color=color;\\n#endif\\n#ifdef FOG\\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\\n#endif\\n#ifdef RENDER_LINE_ALPHA_DISCARD\\nif (alpha < u_alpha_discard_threshold) {discard;}\\n#endif\\ngl_FragColor=out_color*(alpha*opacity);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"\\n#define EXTRUDE_SCALE 0.015873016\\nattribute vec2 a_pos_normal;attribute vec4 a_data;\\n#ifdef RENDER_LINE_GRADIENT\\nattribute vec3 a_packed;\\n#else\\nattribute float a_linesofar;\\n#endif\\nuniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;\\n#ifdef RENDER_LINE_DASH\\nuniform vec2 u_texsize;uniform mediump vec3 u_scale;varying vec2 v_tex_a;varying vec2 v_tex_b;\\n#endif\\n#ifdef RENDER_LINE_GRADIENT\\nuniform float u_image_height;varying highp vec2 v_uv;\\n#endif\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define lowp float floorwidth\\n#pragma mapbox: define lowp vec4 dash_from\\n#pragma mapbox: define lowp vec4 dash_to\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define mediump float gapwidth\\n#pragma mapbox: define lowp float offset\\n#pragma mapbox: define mediump float width\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize lowp float floorwidth\\n#pragma mapbox: initialize lowp vec4 dash_from\\n#pragma mapbox: initialize lowp vec4 dash_to\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump float gapwidth\\n#pragma mapbox: initialize lowp float offset\\n#pragma mapbox: initialize mediump float width\\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\\n#ifndef RENDER_TO_TEXTURE\\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\\n#else\\nv_gamma_scale=1.0;\\n#endif\\n#ifdef RENDER_LINE_GRADIENT\\nfloat a_uv_x=a_packed[0];float a_split_index=a_packed[1];float a_linesofar=a_packed[2];highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);\\n#endif\\n#ifdef RENDER_LINE_DASH\\nfloat tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;float scaleA=dash_from.z==0.0 ? 0.0 : tileZoomRatio/(dash_from.z*fromScale);float scaleB=dash_to.z==0.0 ? 0.0 : tileZoomRatio/(dash_to.z*toScale);float heightA=dash_from.y;float heightB=dash_to.y;v_tex_a=vec2(a_linesofar*scaleA/floorwidth,(-normal.y*heightA+dash_from.x+0.5)/u_texsize.y);v_tex_b=vec2(a_linesofar*scaleB/floorwidth,(-normal.y*heightB+dash_to.x+0.5)/u_texsize.y);\\n#endif\\nv_width2=vec2(outset,inset);\\n#ifdef FOG\\nv_fog_pos=fog_position(pos);\\n#endif\\n}\"),\n      linePattern: ii(\"uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\\n#pragma mapbox: define lowp vec4 pattern_from\\n#pragma mapbox: define lowp vec4 pattern_to\\n#pragma mapbox: define lowp float pixel_ratio_from\\n#pragma mapbox: define lowp float pixel_ratio_to\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize mediump vec4 pattern_from\\n#pragma mapbox: initialize mediump vec4 pattern_to\\n#pragma mapbox: initialize lowp float pixel_ratio_from\\n#pragma mapbox: initialize lowp float pixel_ratio_to\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);\\n#ifdef FOG\\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\\n#endif\\ngl_FragColor=color*(alpha*opacity);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"\\n#define scale 0.015873016\\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_linesofar;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp float offset\\n#pragma mapbox: define mediump float gapwidth\\n#pragma mapbox: define mediump float width\\n#pragma mapbox: define lowp float floorwidth\\n#pragma mapbox: define lowp vec4 pattern_from\\n#pragma mapbox: define lowp vec4 pattern_to\\n#pragma mapbox: define lowp float pixel_ratio_from\\n#pragma mapbox: define lowp float pixel_ratio_to\\nvoid main() {\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize lowp float offset\\n#pragma mapbox: initialize mediump float gapwidth\\n#pragma mapbox: initialize mediump float width\\n#pragma mapbox: initialize lowp float floorwidth\\n#pragma mapbox: initialize mediump vec4 pattern_from\\n#pragma mapbox: initialize mediump vec4 pattern_to\\n#pragma mapbox: initialize lowp float pixel_ratio_from\\n#pragma mapbox: initialize lowp float pixel_ratio_to\\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\\n#ifndef RENDER_TO_TEXTURE\\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\\n#else\\nv_gamma_scale=1.0;\\n#endif\\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;\\n#ifdef FOG\\nv_fog_pos=fog_position(pos);\\n#endif\\n}\"),\n      raster: ii(\"uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(\\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\\n#ifdef FOG\\nout_color=fog_dither(fog_apply(out_color,v_fog_pos));\\n#endif\\ngl_FragColor=vec4(out_color*color.a,color.a);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {float w=1.0+dot(a_texture_pos,u_perspective_transform);gl_Position=u_matrix*vec4(a_pos*w,0,w);v_pos0=a_texture_pos/8192.0;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);\\n#endif\\n}\"),\n      symbolIcon: ii(\"uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_z_tile_anchor;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;\\n#ifdef PROJECTION_GLOBE_VIEW\\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\\n#endif\\nvarying vec2 v_tex;varying float v_fade_opacity;\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}float anchor_z=a_z_tile_anchor.x;vec2 tile_anchor=a_z_tile_anchor.yz;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec3 mercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);vec3 world_pos=mix_globe_mercator(vec3(a_pos,anchor_z)+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;float globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\\n#else\\nvec3 world_pos=vec3(a_pos,anchor_z)+h;float globe_occlusion_fade=1.0;\\n#endif\\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\\ncamera_to_anchor_distance/u_camera_to_center_distance :\\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjected_point=u_matrix*vec4(a_pos+vec2(1,0),anchor_z,1);vec2 a=projected_point.xy/projected_point.w;vec2 b=offsetProjected_point.xy/offsetProjected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec3 proj_pos=mix_globe_mercator(vec3(a_projected_pos.xy,anchor_z),mercator_pos,u_zoom_transition);\\n#else\\nvec3 proj_pos=vec3(a_projected_pos.xy,anchor_z);\\n#endif\\n#ifdef PROJECTED_POS_ON_VIEWPORT\\nvec4 projected_pos=u_label_plane_matrix*vec4(proj_pos.xy,0.0,1.0);\\n#else\\nvec4 projected_pos=u_label_plane_matrix*vec4(proj_pos.xyz+h,1.0);\\n#endif\\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);\\n#ifdef PITCH_WITH_MAP_TERRAIN\\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\\n#endif\\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;gl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));float projection_transition_fade=1.0;\\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\\n#endif\\nv_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change))*projection_transition_fade;}\"),\n      symbolSDF: ii(\"#define SDF_PX 8.0\\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\\n#pragma mapbox: define highp vec4 fill_color\\n#pragma mapbox: define highp vec4 halo_color\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp float halo_width\\n#pragma mapbox: define lowp float halo_blur\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 fill_color\\n#pragma mapbox: initialize highp vec4 halo_color\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize lowp float halo_width\\n#pragma mapbox: initialize lowp float halo_blur\\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_z_tile_anchor;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;\\n#ifdef PROJECTION_GLOBE_VIEW\\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\\n#endif\\nvarying vec2 v_data0;varying vec3 v_data1;\\n#pragma mapbox: define highp vec4 fill_color\\n#pragma mapbox: define highp vec4 halo_color\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp float halo_width\\n#pragma mapbox: define lowp float halo_blur\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 fill_color\\n#pragma mapbox: initialize highp vec4 halo_color\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize lowp float halo_width\\n#pragma mapbox: initialize lowp float halo_blur\\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}float anchor_z=a_z_tile_anchor.x;vec2 tile_anchor=a_z_tile_anchor.yz;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec3 mercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);vec3 world_pos=mix_globe_mercator(vec3(a_pos,anchor_z)+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;float globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\\n#else\\nvec3 world_pos=vec3(a_pos,anchor_z)+h;float globe_occlusion_fade=1.0;\\n#endif\\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\\ncamera_to_anchor_distance/u_camera_to_center_distance :\\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point=u_matrix*vec4(a_pos+vec2(1,0),anchor_z,1);vec2 a=projected_point.xy/projected_point.w;vec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec3 proj_pos=mix_globe_mercator(vec3(a_projected_pos.xy,anchor_z),mercator_pos,u_zoom_transition);\\n#else\\nvec3 proj_pos=vec3(a_projected_pos.xy,anchor_z);\\n#endif\\n#ifdef PROJECTED_POS_ON_VIEWPORT\\nvec4 projected_pos=u_label_plane_matrix*vec4(proj_pos.xy,0.0,1.0);\\n#else\\nvec4 projected_pos=u_label_plane_matrix*vec4(proj_pos.xyz+h,1.0);\\n#endif\\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset);\\n#ifdef PITCH_WITH_MAP_TERRAIN\\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\\n#endif\\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;gl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));float gamma_scale=gl_Position.w;float projection_transition_fade=1.0;\\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\\n#endif\\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade);}\"),\n      symbolTextAndIcon: ii(\"#define SDF_PX 8.0\\n#define SDF 1.0\\n#define ICON 0.0\\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\\n#pragma mapbox: define highp vec4 fill_color\\n#pragma mapbox: define highp vec4 halo_color\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp float halo_width\\n#pragma mapbox: define lowp float halo_blur\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 fill_color\\n#pragma mapbox: initialize highp vec4 halo_color\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize lowp float halo_width\\n#pragma mapbox: initialize lowp float halo_blur\\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_z_tile_anchor;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;\\n#ifdef PROJECTION_GLOBE_VIEW\\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\\n#endif\\nvarying vec4 v_data0;varying vec4 v_data1;\\n#pragma mapbox: define highp vec4 fill_color\\n#pragma mapbox: define highp vec4 halo_color\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp float halo_width\\n#pragma mapbox: define lowp float halo_blur\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 fill_color\\n#pragma mapbox: initialize highp vec4 halo_color\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize lowp float halo_width\\n#pragma mapbox: initialize lowp float halo_blur\\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}float anchor_z=a_z_tile_anchor.x;vec2 tile_anchor=a_z_tile_anchor.yz;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec3 mercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);vec3 world_pos=mix_globe_mercator(vec3(a_pos,anchor_z)+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;float globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\\n#else\\nvec3 world_pos=vec3(a_pos,anchor_z)+h;float globe_occlusion_fade=1.0;\\n#endif\\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\\ncamera_to_anchor_distance/u_camera_to_center_distance :\\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offset_projected_point=u_matrix*vec4(a_pos+vec2(1,0),anchor_z,1);vec2 a=projected_point.xy/projected_point.w;vec2 b=offset_projected_point.xy/offset_projected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec3 proj_pos=mix_globe_mercator(vec3(a_projected_pos.xy,anchor_z),mercator_pos,u_zoom_transition);\\n#else\\nvec3 proj_pos=vec3(a_projected_pos.xy,anchor_z);\\n#endif\\n#ifdef PROJECTED_POS_ON_VIEWPORT\\nvec4 projected_pos=u_label_plane_matrix*vec4(proj_pos.xy,0.0,1.0);\\n#else\\nvec4 projected_pos=u_label_plane_matrix*vec4(proj_pos.xyz+h,1.0);\\n#endif\\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*font_scale);\\n#ifdef PITCH_WITH_MAP_TERRAIN\\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\\n#endif\\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;gl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float projection_transition_fade=1.0;\\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\\n#endif\\nv_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade,is_sdf);}\"),\n      terrainRaster: ii(\"uniform sampler2D u_image0;varying vec2 v_pos0;\\n#ifdef FOG\\nvarying float v_fog_opacity;\\n#endif\\nvoid main() {vec4 color=texture2D(u_image0,v_pos0);\\n#ifdef FOG\\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\\n#endif\\ngl_FragColor=color;\\n#ifdef TERRAIN_WIREFRAME\\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\\n#endif\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"uniform mat4 u_matrix;uniform float u_skirt_height;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;\\n#ifdef FOG\\nvarying float v_fog_opacity;\\n#endif\\nconst float skirtOffset=24575.0;const float wireframeOffset=0.00015;void main() {v_pos0=a_texture_pos/8192.0;float skirt=float(a_pos.x >=skirtOffset);float elevation=elevation(a_texture_pos)-skirt*u_skirt_height;\\n#ifdef TERRAIN_WIREFRAME\\nelevation+=u_skirt_height*u_skirt_height*wireframeOffset;\\n#endif\\nvec2 decodedPos=a_pos-vec2(skirt*skirtOffset,0.0);gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\\n#ifdef FOG\\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\\n#endif\\n}\"),\n      terrainDepth: ii(\"#ifdef GL_ES\\nprecision highp float;\\n#endif\\nvarying float v_depth;void main() {gl_FragColor=pack_depth(v_depth);}\", \"uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying float v_depth;void main() {float elevation=elevation(a_texture_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}\"),\n      skybox: ii(\"\\nvarying lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=textureCube(u_cubemap,uv).rgb;\\n#ifdef FOG\\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\\n#endif\\nsky_color.rgb=dither(sky_color.rgb,gl_FragCoord.xy+u_temporal_offset);sky_color+=0.1*sun_disk(v_uv,u_sun_direction);gl_FragColor=vec4(sky_color*u_opacity,u_opacity);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", Kt),\n      skyboxGradient: ii(\"varying highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture2D(u_color_ramp,vec2(progress,0.5));\\n#ifdef FOG\\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\\n#endif\\ncolor*=u_opacity;color.rgb=dither(color.rgb,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=color;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", Kt),\n      skyboxCapture: ii(\"\\nvarying highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;\\n#ifdef GL_ES\\nprecision highp float;\\n#endif\\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\\n#define MIE_G                   0.76\\n#define DENSITY_HEIGHT_SCALE_R  8000.0\\n#define DENSITY_HEIGHT_SCALE_M  1200.0\\n#define PLANET_RADIUS           6360e3\\n#define ATMOSPHERE_RADIUS       6420e3\\n#define SAMPLE_STEPS            10\\n#define DENSITY_STEPS           4\\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;gl_FragColor=vec4(color,1.0);}\", \"attribute highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;varying highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}\"),\n      globeRaster: ii(\"uniform sampler2D u_image0;varying vec2 v_pos0;void main() {gl_FragColor=texture2D(u_image0,v_pos0);\\n#ifdef TERRAIN_WIREFRAME\\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\\n#endif\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"uniform mat4 u_proj_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;\\n#ifdef GLOBE_POLES\\nattribute vec3 a_globe_pos;attribute vec2 a_merc_pos;attribute vec2 a_uv;\\n#else\\nattribute vec2 a_pos;\\n#endif\\nvarying vec2 v_pos0;const float wireframeOffset=1e3;float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(QUARTER_PI+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}void main() {\\n#ifdef GLOBE_POLES\\nvec3 globe_pos=a_globe_pos;vec2 merc_pos=a_merc_pos;vec2 uv=a_uv;\\n#else\\nfloat tiles=u_grid_matrix[0][2];float idy=u_grid_matrix[1][2];float S=u_grid_matrix[2][2];vec3 latLng=u_grid_matrix*vec3(a_pos,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=a_pos[0]*S;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);\\n#endif\\nv_pos0=uv;uv=uv*EXTENT;vec4 up_vector=vec4(elevationVector(uv),1.0);float height=elevation(uv);\\n#ifdef TERRAIN_WIREFRAME\\nheight+=wireframeOffset;\\n#endif\\nvec4 globe=u_globe_matrix*vec4(globe_pos+up_vector.xyz*height,1.0);vec4 mercator=vec4(0.0);if (u_zoom_transition > 0.0) {mercator=vec4(merc_pos,height,1.0);mercator.xy-=u_merc_center;mercator.x=wrap(mercator.x,-0.5,0.5);mercator=u_merc_matrix*mercator;}vec3 position=mix(globe.xyz,mercator.xyz,u_zoom_transition);gl_Position=u_proj_matrix*vec4(position,1.0);}\"),\n      globeAtmosphere: ii(\"uniform float u_opacity;uniform highp float u_fadeout_range;uniform vec3 u_start_color;uniform vec3 u_end_color;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;varying highp vec3 v_ray_dir;void main() {highp vec3 dir=normalize(v_ray_dir);highp vec3 closest_point=abs(dot(u_globe_pos,dir))*dir;float norm_dist_from_center=length(closest_point-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 1.0)\\ndiscard;float t=clamp(1.0-sqrt(norm_dist_from_center-1.0)/u_fadeout_range,0.0,1.0);vec3 color=mix(u_start_color,u_end_color,1.0-t);gl_FragColor=vec4(color*t*u_opacity,u_opacity);}\", \"attribute vec3 a_pos;attribute vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;varying highp vec3 v_ray_dir;void main() {v_ray_dir=mix(mix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);gl_Position=vec4(a_pos,1.0);}\")\n    };\n\n    function ii(e, t, i) {\n      const o = /#pragma mapbox: ([\\w]+) ([\\w]+) ([\\w]+) ([\\w]+)/g,\n            r = /uniform (highp |mediump |lowp )?([\\w]+) ([\\w]+)([\\s]*)([\\w]*)/g,\n            n = t.match(/attribute (highp |mediump |lowp )?([\\w]+) ([\\w]+)/g),\n            a = e.match(r),\n            s = t.match(r),\n            l = Ht.match(r);\n      let c = s ? s.concat(a) : a;\n      i || (Yt.staticUniforms && (c = Yt.staticUniforms.concat(c)), Jt.staticUniforms && (c = Jt.staticUniforms.concat(c))), c && (c = c.concat(l));\n      const h = {};\n      return {\n        fragmentSource: e = e.replace(o, (e, t, i, o, r) => (h[r] = !0, \"define\" === t ? `\\n#ifndef HAS_UNIFORM_u_${r}\\nvarying ${i} ${o} ${r};\\n#else\\nuniform ${i} ${o} u_${r};\\n#endif\\n` : `\\n#ifdef HAS_UNIFORM_u_${r}\\n    ${i} ${o} ${r} = u_${r};\\n#endif\\n`)),\n        vertexSource: t = t.replace(o, (e, t, i, o, r) => {\n          const n = \"float\" === o ? \"vec2\" : \"vec4\",\n                a = r.match(/color/) ? \"color\" : n;\n          return h[r] ? \"define\" === t ? `\\n#ifndef HAS_UNIFORM_u_${r}\\nuniform lowp float u_${r}_t;\\nattribute ${i} ${n} a_${r};\\nvarying ${i} ${o} ${r};\\n#else\\nuniform ${i} ${o} u_${r};\\n#endif\\n` : \"vec4\" === a ? `\\n#ifndef HAS_UNIFORM_u_${r}\\n    ${r} = a_${r};\\n#else\\n    ${i} ${o} ${r} = u_${r};\\n#endif\\n` : `\\n#ifndef HAS_UNIFORM_u_${r}\\n    ${r} = unpack_mix_${a}(a_${r}, u_${r}_t);\\n#else\\n    ${i} ${o} ${r} = u_${r};\\n#endif\\n` : \"define\" === t ? `\\n#ifndef HAS_UNIFORM_u_${r}\\nuniform lowp float u_${r}_t;\\nattribute ${i} ${n} a_${r};\\n#else\\nuniform ${i} ${o} u_${r};\\n#endif\\n` : \"vec4\" === a ? `\\n#ifndef HAS_UNIFORM_u_${r}\\n    ${i} ${o} ${r} = a_${r};\\n#else\\n    ${i} ${o} ${r} = u_${r};\\n#endif\\n` : `\\n#ifndef HAS_UNIFORM_u_${r}\\n    ${i} ${o} ${r} = unpack_mix_${a}(a_${r}, u_${r}_t);\\n#else\\n    ${i} ${o} ${r} = u_${r};\\n#endif\\n`;\n        }),\n        staticAttributes: n,\n        staticUniforms: c\n      };\n    }\n\n    class oi {\n      constructor() {\n        this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;\n      }\n\n      bind(e, t, i, o, r, n, a, s) {\n        this.context = e;\n        let l = this.boundPaintVertexBuffers.length !== o.length;\n\n        for (let e = 0; !l && e < o.length; e++) this.boundPaintVertexBuffers[e] !== o[e] && (l = !0);\n\n        e.extVertexArrayObject && this.vao && this.boundProgram === t && this.boundLayoutVertexBuffer === i && !l && this.boundIndexBuffer === r && this.boundVertexOffset === n && this.boundDynamicVertexBuffer === a && this.boundDynamicVertexBuffer2 === s ? (e.bindVertexArrayOES.set(this.vao), a && a.bind(), r && r.dynamicDraw && r.bind(), s && s.bind()) : this.freshBind(t, i, o, r, n, a, s);\n      }\n\n      freshBind(e, t, i, o, r, n, a) {\n        let s;\n        const l = e.numAttributes,\n              c = this.context,\n              h = c.gl;\n        if (c.extVertexArrayObject) this.vao && this.destroy(), this.vao = c.extVertexArrayObject.createVertexArrayOES(), c.bindVertexArrayOES.set(this.vao), s = 0, this.boundProgram = e, this.boundLayoutVertexBuffer = t, this.boundPaintVertexBuffers = i, this.boundIndexBuffer = o, this.boundVertexOffset = r, this.boundDynamicVertexBuffer = n, this.boundDynamicVertexBuffer2 = a;else {\n          s = c.currentNumAttributes || 0;\n\n          for (let e = l; e < s; e++) h.disableVertexAttribArray(e);\n        }\n        t.enableAttributes(h, e);\n\n        for (const t of i) t.enableAttributes(h, e);\n\n        n && n.enableAttributes(h, e), a && a.enableAttributes(h, e), t.bind(), t.setVertexAttribPointers(h, e, r);\n\n        for (const t of i) t.bind(), t.setVertexAttribPointers(h, e, r);\n\n        n && (n.bind(), n.setVertexAttribPointers(h, e, r)), o && o.bind(), a && (a.bind(), a.setVertexAttribPointers(h, e, r)), c.currentNumAttributes = l;\n      }\n\n      destroy() {\n        this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao), this.vao = null);\n      }\n\n    }\n\n    function ri(t, i) {\n      const o = Math.pow(2, i.canonical.z),\n            r = i.canonical.y;\n      return [new e.MercatorCoordinate(0, r / o).toLngLat().lat, new e.MercatorCoordinate(0, (r + 1) / o).toLngLat().lat];\n    }\n\n    function ni(t, i, o, r, n, a, s) {\n      const l = t.context,\n            c = l.gl,\n            h = o.fbo;\n      if (!h) return;\n      t.prepareDrawTile();\n\n      const _ = t.useProgram(\"hillshade\");\n\n      l.activeTexture.set(c.TEXTURE0), c.bindTexture(c.TEXTURE_2D, h.colorAttachment.get());\n\n      const u = ((e, t, i, o) => {\n        const r = i.paint.get(\"hillshade-shadow-color\"),\n              n = i.paint.get(\"hillshade-highlight-color\"),\n              a = i.paint.get(\"hillshade-accent-color\");\n        let s = i.paint.get(\"hillshade-illumination-direction\") * (Math.PI / 180);\n        \"viewport\" === i.paint.get(\"hillshade-illumination-anchor\") && (s -= e.transform.angle);\n        const l = !e.options.moving;\n        return {\n          u_matrix: o || e.transform.calculateProjMatrix(t.tileID.toUnwrapped(), l),\n          u_image: 0,\n          u_latrange: ri(0, t.tileID),\n          u_light: [i.paint.get(\"hillshade-exaggeration\"), s],\n          u_shadow: r,\n          u_highlight: n,\n          u_accent: a\n        };\n      })(t, o, r, t.terrain ? i.projMatrix : null);\n\n      t.prepareDrawProgram(l, _, i.toUnwrapped());\n      const {\n        tileBoundsBuffer: d,\n        tileBoundsIndexBuffer: p,\n        tileBoundsSegments: m\n      } = t.getTileBoundsBuffers(o);\n\n      _.draw(l, c.TRIANGLES, n, a, s, e.CullFaceMode.disabled, u, r.id, d, p, m);\n    }\n\n    function ai(t, i, o) {\n      if (!i.needsDEMTextureUpload) return;\n      const r = t.context,\n            n = r.gl;\n      r.pixelStoreUnpackPremultiplyAlpha.set(!1), i.demTexture = i.demTexture || t.getTileTexture(o.stride);\n      const a = o.getPixels();\n      i.demTexture ? i.demTexture.update(a, {\n        premultiply: !1\n      }) : i.demTexture = new e.Texture(r, a, n.RGBA, {\n        premultiply: !1\n      }), i.needsDEMTextureUpload = !1;\n    }\n\n    function si(t, i, o, r, n, a) {\n      const s = t.context,\n            l = s.gl;\n      if (!i.dem) return;\n      const c = i.dem;\n      if (s.activeTexture.set(l.TEXTURE1), ai(t, i, c), !i.demTexture) return;\n      i.demTexture.bind(l.NEAREST, l.CLAMP_TO_EDGE);\n      const h = c.dim;\n      s.activeTexture.set(l.TEXTURE0);\n      let _ = i.fbo;\n\n      if (!_) {\n        const t = new e.Texture(s, {\n          width: h,\n          height: h,\n          data: null\n        }, l.RGBA);\n        t.bind(l.LINEAR, l.CLAMP_TO_EDGE), _ = i.fbo = s.createFramebuffer(h, h, !0), _.colorAttachment.set(t.texture);\n      }\n\n      s.bindFramebuffer.set(_.framebuffer), s.viewport.set([0, 0, h, h]);\n      const {\n        tileBoundsBuffer: u,\n        tileBoundsIndexBuffer: d,\n        tileBoundsSegments: p\n      } = t.getMercatorTileBoundsBuffers();\n      t.useProgram(\"hillshadePrepare\").draw(s, l.TRIANGLES, r, n, a, e.CullFaceMode.disabled, ((t, i) => {\n        const o = i.stride,\n              r = e.create();\n        return e.ortho(r, 0, e.EXTENT, -e.EXTENT, 0, 0, 1), e.translate(r, r, [0, -e.EXTENT, 0]), {\n          u_matrix: r,\n          u_image: 1,\n          u_dimension: [o, o],\n          u_zoom: t.overscaledZ,\n          u_unpack: i.unpackVector\n        };\n      })(i.tileID, c), o.id, u, d, p), i.needsHillshadePrepare = !1;\n    }\n\n    const li = (t, i) => ({\n      u_matrix: new e.UniformMatrix4f(t, i.u_matrix),\n      u_image0: new e.Uniform1i(t, i.u_image0),\n      u_skirt_height: new e.Uniform1f(t, i.u_skirt_height)\n    }),\n          ci = (e, t) => ({\n      u_matrix: e,\n      u_image0: 0,\n      u_skirt_height: t\n    }),\n          hi = (e, t, i, o, r, n) => ({\n      u_proj_matrix: Float32Array.from(e),\n      u_globe_matrix: t,\n      u_merc_matrix: i,\n      u_zoom_transition: o,\n      u_merc_center: r,\n      u_image0: 0,\n      u_grid_matrix: n ? Float32Array.from(n) : new Float32Array(9)\n    });\n\n    function _i(e, t) {\n      return null != e && null != t && !(!e.hasData() || !t.hasData()) && null != e.demTexture && null != t.demTexture && e.tileID.key !== t.tileID.key;\n    }\n\n    const ui = new class {\n      constructor() {\n        this.operations = {};\n      }\n\n      newMorphing(e, t, i, o, r) {\n        if (e in this.operations) {\n          const t = this.operations[e];\n          t.to.tileID.key !== i.tileID.key && (t.queued = i);\n        } else this.operations[e] = {\n          startTime: o,\n          phase: 0,\n          duration: r,\n          from: t,\n          to: i,\n          queued: null\n        };\n      }\n\n      getMorphValuesForProxy(e) {\n        if (!(e in this.operations)) return null;\n        const t = this.operations[e];\n        return {\n          from: t.from,\n          to: t.to,\n          phase: t.phase\n        };\n      }\n\n      update(e) {\n        for (const t in this.operations) {\n          const i = this.operations[t];\n\n          for (i.phase = (e - i.startTime) / i.duration; i.phase >= 1 || !this._validOp(i);) if (!this._nextOp(i, e)) {\n            delete this.operations[t];\n            break;\n          }\n        }\n      }\n\n      _nextOp(e, t) {\n        return !!e.queued && (e.from = e.to, e.to = e.queued, e.queued = null, e.phase = 0, e.startTime = t, !0);\n      }\n\n      _validOp(e) {\n        return e.from.hasData() && e.to.hasData();\n      }\n\n    }(),\n          di = {\n      0: null,\n      1: \"TERRAIN_VERTEX_MORPHING\",\n      2: \"TERRAIN_WIREFRAME\"\n    };\n\n    function pi(e, t) {\n      const i = 1 << e.z;\n      return !t && (0 === e.x || e.x === i - 1) || 0 === e.y || e.y === i - 1;\n    }\n\n    const mi = e => ({\n      u_matrix: e\n    });\n\n    function fi(t, i, o, r, n) {\n      if (n > 0) {\n        const a = e.exported.now(),\n              s = (a - t.timeAdded) / n,\n              l = i ? (a - i.timeAdded) / n : -1,\n              c = o.getSource(),\n              h = r.coveringZoomLevel({\n          tileSize: c.tileSize,\n          roundZoom: c.roundZoom\n        }),\n              _ = !i || Math.abs(i.tileID.overscaledZ - h) > Math.abs(t.tileID.overscaledZ - h),\n              u = _ && t.refreshedUponExpiration ? 1 : e.clamp(_ ? s : 1 - l, 0, 1);\n\n        return t.refreshedUponExpiration && s >= 1 && (t.refreshedUponExpiration = !1), i ? {\n          opacity: 1,\n          mix: 1 - u\n        } : {\n          opacity: u,\n          mix: 0\n        };\n      }\n\n      return {\n        opacity: 1,\n        mix: 0\n      };\n    }\n\n    const gi = 2 * e.mercatorZfromAltitude(1, 0) * e.GLOBE_RADIUS * Math.PI;\n\n    class vi extends e.SourceCache {\n      constructor(e) {\n        const t = {\n          type: \"raster-dem\",\n          maxzoom: e.transform.maxZoom\n        },\n              i = new A(Ue(), null),\n              o = De(\"mock-dem\", t, i, e.style);\n        super(\"mock-dem\", o, !1), o.setEventedParent(this), this._sourceLoaded = !0;\n      }\n\n      _loadTile(e, t) {\n        e.state = \"loaded\", t(null);\n      }\n\n    }\n\n    class xi extends e.SourceCache {\n      constructor(e) {\n        const t = De(\"proxy\", {\n          type: \"geojson\",\n          maxzoom: e.transform.maxZoom\n        }, new A(Ue(), null), e.style);\n        super(\"proxy\", t, !1), t.setEventedParent(this), this.map = this.getSource().map = e, this.used = this._sourceLoaded = !0, this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};\n      }\n\n      update(t, i, o) {\n        if (t.freezeTileCoverage) return;\n        this.transform = t;\n        const r = t.coveringTiles({\n          tileSize: this._source.tileSize,\n          minzoom: this._source.minzoom,\n          maxzoom: this._source.maxzoom,\n          roundZoom: this._source.roundZoom,\n          reparseOverscaled: this._source.reparseOverscaled\n        }).reduce((i, o) => {\n          if (i[o.key] = \"\", !this._tiles[o.key]) {\n            const i = new e.Tile(o, this._source.tileSize * o.overscaleFactor(), t.tileZoom);\n            i.state = \"loaded\", this._tiles[o.key] = i;\n          }\n\n          return i;\n        }, {});\n\n        for (const e in this._tiles) e in r || (this.freeFBO(e), this._tiles[e].unloadVectorData(), delete this._tiles[e]);\n      }\n\n      freeFBO(e) {\n        const t = this.proxyCachedFBO[e];\n\n        if (void 0 !== t) {\n          const i = Object.values(t);\n          this.renderCachePool.push(...i), delete this.proxyCachedFBO[e];\n        }\n      }\n\n      deallocRenderCache() {\n        this.renderCache.forEach(e => e.fb.destroy()), this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};\n      }\n\n    }\n\n    class yi extends e.OverscaledTileID {\n      constructor(e, t, i) {\n        super(e.overscaledZ, e.wrap, e.canonical.z, e.canonical.x, e.canonical.y), this.proxyTileKey = t, this.projMatrix = i;\n      }\n\n    }\n\n    class bi extends e.Elevation {\n      constructor(t, i) {\n        super(), this.painter = t, this.terrainTileForTile = {}, this.prevTerrainTileForTile = {};\n\n        const [o, r, n] = function (t) {\n          const i = new e.StructArrayLayout4i8(),\n                o = new e.StructArrayLayout3ui6(),\n                r = 131;\n          i.reserve(17161), o.reserve(33800);\n          const n = e.EXTENT / 128,\n                a = e.EXTENT + n / 2,\n                s = a + n;\n\n          for (let t = -n; t < s; t += n) for (let o = -n; o < s; o += n) {\n            const r = o < 0 || o > a || t < 0 || t > a ? 24575 : 0,\n                  n = e.clamp(Math.round(o), 0, e.EXTENT),\n                  s = e.clamp(Math.round(t), 0, e.EXTENT);\n            i.emplaceBack(n + r, s, n, s);\n          }\n\n          const l = (e, t) => {\n            const i = t * r + e;\n            o.emplaceBack(i + 1, i, i + r), o.emplaceBack(i + r, i + r + 1, i + 1);\n          };\n\n          for (let e = 1; e < 129; e++) for (let t = 1; t < 129; t++) l(t, e);\n\n          return [0, 129].forEach(e => {\n            for (let t = 0; t < 130; t++) l(t, e), l(e, t);\n          }), [i, o, 32768];\n        }(),\n              a = t.context;\n\n        this.gridBuffer = a.createVertexBuffer(o, e.boundsAttributes.members), this.gridIndexBuffer = a.createIndexBuffer(r), this.gridSegments = e.SegmentVector.simpleSegment(0, 0, o.length, r.length), this.gridNoSkirtSegments = e.SegmentVector.simpleSegment(0, 0, o.length, n), this.proxyCoords = [], this.proxiedCoords = {}, this._visibleDemTiles = [], this._drapedRenderBatches = [], this._sourceTilesOverlap = {}, this.proxySourceCache = new xi(i.map), this.orthoMatrix = e.create(), e.ortho(this.orthoMatrix, 0, e.EXTENT, 0, e.EXTENT, 0, 1);\n        const s = a.gl;\n        this._overlapStencilMode = new e.StencilMode({\n          func: s.GEQUAL,\n          mask: 255\n        }, 0, 255, s.KEEP, s.KEEP, s.REPLACE), this._previousZoom = t.transform.zoom, this.pool = [], this._findCoveringTileCache = {}, this._tilesDirty = {}, this.style = i, this._useVertexMorphing = !0, this._exaggeration = 1, this._mockSourceCache = new vi(i.map);\n      }\n\n      set style(e) {\n        e.on(\"data\", this._onStyleDataEvent.bind(this)), e.on(\"neworder\", this._checkRenderCacheEfficiency.bind(this)), this._style = e, this._checkRenderCacheEfficiency();\n      }\n\n      update(t, i, o) {\n        if (t && t.terrain) {\n          this._style !== t && (this.style = t), this.enabled = !0;\n          const r = t.terrain.properties;\n          this.sourceCache = 0 === t.terrain.drapeRenderMode ? this._mockSourceCache : t._getSourceCache(r.get(\"source\")), this._exaggeration = r.get(\"exaggeration\");\n\n          const n = () => {\n            this.sourceCache.used && e.warnOnce(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.\\nThis leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);\n            const t = this.getScaledDemTileSize();\n            this.sourceCache.update(i, t, !0), this.resetTileLookupCache(this.sourceCache.id);\n          };\n\n          this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id), this.sourceCache.usedForTerrain = !0, n(), this._initializing = !0), n(), i.updateElevation(!o), this.resetTileLookupCache(this.proxySourceCache.id), this.proxySourceCache.update(i), this._emptyDEMTextureDirty = !0;\n        } else this._disable();\n      }\n\n      resetTileLookupCache(e) {\n        this._findCoveringTileCache[e] = {};\n      }\n\n      getScaledDemTileSize() {\n        return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize;\n      }\n\n      _checkRenderCacheEfficiency() {\n        const t = this.renderCacheEfficiency(this._style);\n        this._style.map._optimizeForTerrain || 100 !== t.efficiency && e.warnOnce(`Terrain render cache efficiency is not optimal (${t.efficiency}%) and performance\\n                may be affected negatively, consider placing all background, fill and line layers before layer\\n                with id '${t.firstUndrapedLayer}' or create a map using optimizeForTerrain: true option.`);\n      }\n\n      _onStyleDataEvent(e) {\n        e.coord && \"source\" === e.dataType ? this._clearRenderCacheForTile(e.sourceCacheId, e.coord) : \"style\" === e.dataType && (this._invalidateRenderCache = !0);\n      }\n\n      _disable() {\n        if (this.enabled && (this.enabled = !1, this._sharedDepthStencil = void 0, this.proxySourceCache.deallocRenderCache(), this._style)) for (const e in this._style._sourceCaches) this._style._sourceCaches[e].usedForTerrain = !1;\n      }\n\n      destroy() {\n        this._disable(), this._emptyDEMTexture && this._emptyDEMTexture.destroy(), this._emptyDepthBufferTexture && this._emptyDepthBufferTexture.destroy(), this.pool.forEach(e => e.fb.destroy()), this.pool = [], this._depthFBO && (this._depthFBO.destroy(), this._depthFBO = void 0, this._depthTexture = void 0);\n      }\n\n      _source() {\n        return this.enabled ? this.sourceCache : null;\n      }\n\n      exaggeration() {\n        return this._exaggeration;\n      }\n\n      get visibleDemTiles() {\n        return this._visibleDemTiles;\n      }\n\n      get drapeBufferSize() {\n        const e = 2 * this.proxySourceCache.getSource().tileSize;\n        return [e, e];\n      }\n\n      set useVertexMorphing(e) {\n        this._useVertexMorphing = e;\n      }\n\n      updateTileBinding(t) {\n        if (!this.enabled) return;\n        this.prevTerrainTileForTile = this.terrainTileForTile;\n        const i = this.proxySourceCache,\n              o = this.painter.transform;\n        this._initializing && (this._initializing = 0 === o._centerAltitude && -1 === this.getAtPointOrZero(e.MercatorCoordinate.fromLngLat(o.center), -1), this._emptyDEMTextureDirty = !this._initializing);\n        const r = this.proxyCoords = i.getIds().map(e => {\n          const t = i.getTileByID(e).tileID;\n          return t.projMatrix = o.calculateProjMatrix(t.toUnwrapped()), t;\n        });\n        !function (t, i) {\n          const o = i.transform.pointCoordinate(i.transform.getCameraPoint()),\n                r = new e.pointGeometry(o.x, o.y);\n          t.sort((t, i) => {\n            if (i.overscaledZ - t.overscaledZ) return i.overscaledZ - t.overscaledZ;\n            const o = new e.pointGeometry(t.canonical.x + (1 << t.canonical.z) * t.wrap, t.canonical.y),\n                  n = new e.pointGeometry(i.canonical.x + (1 << i.canonical.z) * i.wrap, i.canonical.y),\n                  a = r.mult(1 << t.canonical.z);\n            return a.x -= .5, a.y -= .5, a.distSqr(o) - a.distSqr(n);\n          });\n        }(r, this.painter), this._previousZoom = o.zoom;\n        const n = this.proxyToSource || {};\n        this.proxyToSource = {}, r.forEach(e => {\n          this.proxyToSource[e.key] = {};\n        }), this.terrainTileForTile = {};\n        const a = this._style._sourceCaches;\n\n        for (const e in a) {\n          const i = a[e];\n          if (!i.used) continue;\n          if (i !== this.sourceCache && this.resetTileLookupCache(i.id), this._setupProxiedCoordsForOrtho(i, t[e], n), i.usedForTerrain) continue;\n          const o = t[e];\n          i.getSource().reparseOverscaled && this._assignTerrainTiles(o);\n        }\n\n        this.proxiedCoords[i.id] = r.map(e => new yi(e, e.key, this.orthoMatrix)), this._assignTerrainTiles(r), this._prepareDEMTextures(), this._setupDrapedRenderBatches(), this._initFBOPool(), this._setupRenderCache(n), this.renderingToTexture = !1, this._updateTimestamp = e.exported.now();\n        const s = {};\n        this._visibleDemTiles = [];\n\n        for (const e of this.proxyCoords) {\n          const t = this.terrainTileForTile[e.key];\n          if (!t) continue;\n          const i = t.tileID.key;\n          i in s || (this._visibleDemTiles.push(t), s[i] = i);\n        }\n      }\n\n      _assignTerrainTiles(e) {\n        this._initializing || e.forEach(e => {\n          if (this.terrainTileForTile[e.key]) return;\n\n          const t = this._findTileCoveringTileID(e, this.sourceCache);\n\n          t && (this.terrainTileForTile[e.key] = t);\n        });\n      }\n\n      _prepareDEMTextures() {\n        const e = this.painter.context,\n              t = e.gl;\n\n        for (const i in this.terrainTileForTile) {\n          const o = this.terrainTileForTile[i],\n                r = o.dem;\n          !r || o.demTexture && !o.needsDEMTextureUpload || (e.activeTexture.set(t.TEXTURE1), ai(this.painter, o, r));\n        }\n      }\n\n      _prepareDemTileUniforms(e, t, i, o) {\n        if (!t || null == t.demTexture) return !1;\n        const r = e.tileID.canonical,\n              n = Math.pow(2, t.tileID.canonical.z - r.z),\n              a = o || \"\";\n        return i[`u_dem_tl${a}`] = [r.x * n % 1, r.y * n % 1], i[`u_dem_scale${a}`] = n, !0;\n      }\n\n      get emptyDEMTexture() {\n        return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture();\n      }\n\n      get emptyDepthBufferTexture() {\n        const t = this.painter.context,\n              i = t.gl;\n\n        if (!this._emptyDepthBufferTexture) {\n          const o = new e.RGBAImage({\n            width: 1,\n            height: 1\n          }, Uint8Array.of(255, 255, 255, 255));\n          this._emptyDepthBufferTexture = new e.Texture(t, o, i.RGBA, {\n            premultiply: !1\n          });\n        }\n\n        return this._emptyDepthBufferTexture;\n      }\n\n      _getLoadedAreaMinimum() {\n        let e = 0;\n\n        const t = this._visibleDemTiles.reduce((t, i) => {\n          if (!i.dem) return t;\n          const o = i.dem.tree.minimums[0];\n          return o > 0 && e++, t + o;\n        }, 0);\n\n        return e ? t / e : 0;\n      }\n\n      _updateEmptyDEMTexture() {\n        const t = this.painter.context,\n              i = t.gl;\n        t.activeTexture.set(i.TEXTURE2);\n\n        const o = this._getLoadedAreaMinimum(),\n              r = new e.RGBAImage({\n          width: 1,\n          height: 1\n        }, new Uint8Array(e.DEMData.pack(o, this.sourceCache.getSource().encoding)));\n\n        this._emptyDEMTextureDirty = !1;\n        let n = this._emptyDEMTexture;\n        return n ? n.update(r, {\n          premultiply: !1\n        }) : n = this._emptyDEMTexture = new e.Texture(t, r, i.RGBA, {\n          premultiply: !1\n        }), n;\n      }\n\n      setupElevationDraw(t, i, o) {\n        const r = this.painter.context,\n              n = r.gl,\n              a = (s = this.sourceCache.getSource().encoding, {\n          u_dem: 2,\n          u_dem_prev: 4,\n          u_dem_unpack: e.DEMData.getUnpackVector(s),\n          u_dem_tl: [0, 0],\n          u_dem_tl_prev: [0, 0],\n          u_dem_scale: 0,\n          u_dem_scale_prev: 0,\n          u_dem_size: 0,\n          u_dem_lerp: 1,\n          u_depth: 3,\n          u_depth_size_inv: [0, 0],\n          u_exaggeration: 0,\n          u_tile_tl_up: [0, 0, 1],\n          u_tile_tr_up: [0, 0, 1],\n          u_tile_br_up: [0, 0, 1],\n          u_tile_bl_up: [0, 0, 1],\n          u_tile_up_scale: 1\n        });\n        var s;\n        a.u_dem_size = this.sourceCache.getSource().tileSize, a.u_exaggeration = this.exaggeration();\n        const l = this.painter.transform,\n              c = l.projection,\n              h = t.tileID.canonical;\n        a.u_tile_tl_up = c.upVector(h, 0, 0), a.u_tile_tr_up = c.upVector(h, e.EXTENT, 0), a.u_tile_br_up = c.upVector(h, e.EXTENT, e.EXTENT), a.u_tile_bl_up = c.upVector(h, 0, e.EXTENT), a.u_tile_up_scale = o && o.useDenormalizedUpVectorScale ? gi : c.upVectorScale(h, l.center.lat, l.worldSize).metersToTile;\n        let _ = null,\n            u = null,\n            d = 1;\n\n        if (o && o.morphing && this._useVertexMorphing) {\n          const e = o.morphing.srcDemTile,\n                i = o.morphing.dstDemTile;\n          d = o.morphing.phase, e && i && (this._prepareDemTileUniforms(t, e, a, \"_prev\") && (u = e), this._prepareDemTileUniforms(t, i, a) && (_ = i));\n        }\n\n        if (u && _ ? (r.activeTexture.set(n.TEXTURE2), _.demTexture.bind(n.NEAREST, n.CLAMP_TO_EDGE, n.NEAREST), r.activeTexture.set(n.TEXTURE4), u.demTexture.bind(n.NEAREST, n.CLAMP_TO_EDGE, n.NEAREST), a.u_dem_lerp = d) : (_ = this.terrainTileForTile[t.tileID.key], r.activeTexture.set(n.TEXTURE2), (this._prepareDemTileUniforms(t, _, a) ? _.demTexture : this.emptyDEMTexture).bind(n.NEAREST, n.CLAMP_TO_EDGE)), r.activeTexture.set(n.TEXTURE3), o && o.useDepthForOcclusion ? (this._depthTexture && this._depthTexture.bind(n.NEAREST, n.CLAMP_TO_EDGE), this._depthFBO && (a.u_depth_size_inv = [1 / this._depthFBO.width, 1 / this._depthFBO.height])) : (this.emptyDepthBufferTexture.bind(n.NEAREST, n.CLAMP_TO_EDGE), a.u_depth_size_inv = [1, 1]), o && o.useMeterToDem && _) {\n          const t = (1 << _.tileID.canonical.z) * e.mercatorZfromAltitude(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;\n          a.u_meter_to_dem = t;\n        }\n\n        o && o.labelPlaneMatrixInv && (a.u_label_plane_matrix_inv = o.labelPlaneMatrixInv), i.setTerrainUniformValues(r, a);\n      }\n\n      renderToBackBuffer(t) {\n        const i = this.painter,\n              o = this.painter.context;\n        0 !== t.length && (o.bindFramebuffer.set(null), o.viewport.set([0, 0, i.width, i.height]), this.renderingToTexture = !1, function (t, i, o, r, n) {\n          if (\"globe\" === t.transform.projection.name) !function (t, i, o, r, n) {\n            const a = t.context,\n                  s = a.gl;\n            let l, c;\n\n            const h = t.options.showTerrainWireframe ? 2 : 0,\n                  _ = (e, i) => {\n              if (c === e) return;\n              const o = [di[e], \"PROJECTION_GLOBE_VIEW\"];\n              i && o.push(di[h]), l = t.useProgram(\"globeRaster\", null, o), c = e;\n            },\n                  u = t.colorModeForRenderPass(),\n                  d = new e.DepthMode(s.LEQUAL, e.DepthMode.ReadWrite, t.depthRangeFor3D);\n\n            ui.update(n);\n            const p = t.transform,\n                  m = e.calculateGlobeMercatorMatrix(p),\n                  f = [e.mercatorXfromLng(p.center.lng), e.mercatorYfromLat(p.center.lat)],\n                  g = t.globeSharedBuffers;\n\n            if ((h ? [!1, !0] : [!1]).forEach(h => {\n              c = -1;\n              const v = h ? s.LINES : s.TRIANGLES;\n\n              for (const c of r) {\n                const r = o.getTile(c),\n                      x = e.StencilMode.disabled,\n                      y = i.prevTerrainTileForTile[c.key],\n                      b = i.terrainTileForTile[c.key];\n                _i(y, b) && ui.newMorphing(c.key, y, b, n, 250), a.activeTexture.set(s.TEXTURE0), r.texture.bind(s.LINEAR, s.CLAMP_TO_EDGE);\n                const w = ui.getMorphValuesForProxy(c.key),\n                      T = w ? 1 : 0,\n                      E = {\n                  useDenormalizedUpVectorScale: !0\n                };\n                w && e.extend$1(E, {\n                  morphing: {\n                    srcDemTile: w.from,\n                    dstDemTile: w.to,\n                    phase: e.easeCubicInOut(w.phase)\n                  }\n                });\n                const C = Float32Array.from(p.globeMatrix),\n                      I = e.globeTileLatLngCorners(c.canonical),\n                      M = e.getGridMatrix(c.canonical, I),\n                      S = hi(p.projMatrix, C, m, e.globeToMercatorTransition(p.zoom), f, M);\n\n                if (_(T, h), i.setupElevationDraw(r, l, E), t.prepareDrawProgram(a, l, c.toUnwrapped()), g) {\n                  const [i, o, r] = h ? g.getWirefameBuffers(t.context) : g.getGridBuffers();\n                  l.draw(a, v, d, x, u, e.CullFaceMode.backCCW, S, \"globe_raster\", i, o, r);\n                }\n              }\n            }), g) {\n              l = t.useProgram(\"globeRaster\", null, [\"GLOBE_POLES\", \"PROJECTION_GLOBE_VIEW\"]);\n\n              for (const n of r) {\n                const {\n                  x: r,\n                  y: c,\n                  z: h\n                } = n.canonical,\n                      _ = 0 === c,\n                      m = c === (1 << h) - 1,\n                      [v, x, y, b] = g.getPoleBuffers(h);\n\n                if (b && (_ || m)) {\n                  const c = o.getTile(n);\n                  a.activeTexture.set(s.TEXTURE0), c.texture.bind(s.LINEAR, s.CLAMP_TO_EDGE);\n                  let g = e.globePoleMatrixForTile(h, r, p);\n\n                  const w = (t, i) => t.draw(a, s.TRIANGLES, d, e.StencilMode.disabled, u, e.CullFaceMode.disabled, hi(p.projMatrix, g, g, 0, f), \"globe_pole_raster\", i, y, b);\n\n                  i.setupElevationDraw(c, l, {}), t.prepareDrawProgram(a, l, n.toUnwrapped()), _ && w(l, v), m && (g = e.scale(e.create(), g, [1, -1, 1]), w(l, x));\n                }\n              }\n            }\n          }(t, i, o, r, n);else {\n            const a = t.context,\n                  s = a.gl;\n            let l, c;\n\n            const h = t.options.showTerrainWireframe ? 2 : 0,\n                  _ = (e, i) => {\n              if (c === e) return;\n              const o = [di[e]];\n              i && o.push(di[h]), l = t.useProgram(\"terrainRaster\", null, o), c = e;\n            },\n                  u = t.colorModeForRenderPass(),\n                  d = new e.DepthMode(s.LEQUAL, e.DepthMode.ReadWrite, t.depthRangeFor3D);\n\n            ui.update(n);\n            const p = t.transform,\n                  m = 6 * Math.pow(1.5, 22 - p.zoom) * i.exaggeration();\n            (h ? [!1, !0] : [!1]).forEach(h => {\n              c = -1;\n              const f = h ? s.LINES : s.TRIANGLES,\n                    [g, v] = h ? i.getWirefameBuffer() : [i.gridIndexBuffer, i.gridSegments];\n\n              for (const c of r) {\n                const r = o.getTile(c),\n                      x = e.StencilMode.disabled,\n                      y = i.prevTerrainTileForTile[c.key],\n                      b = i.terrainTileForTile[c.key];\n                _i(y, b) && ui.newMorphing(c.key, y, b, n, 250), a.activeTexture.set(s.TEXTURE0), r.texture.bind(s.LINEAR, s.CLAMP_TO_EDGE, s.LINEAR_MIPMAP_NEAREST);\n                const w = ui.getMorphValuesForProxy(c.key),\n                      T = w ? 1 : 0;\n                let E;\n                w && (E = {\n                  morphing: {\n                    srcDemTile: w.from,\n                    dstDemTile: w.to,\n                    phase: e.easeCubicInOut(w.phase)\n                  }\n                });\n                const C = ci(c.projMatrix, pi(c.canonical, p.renderWorldCopies) ? m / 10 : m);\n                _(T, h), i.setupElevationDraw(r, l, E), t.prepareDrawProgram(a, l, c.toUnwrapped()), l.draw(a, f, d, x, u, e.CullFaceMode.backCCW, C, \"terrain_raster\", i.gridBuffer, g, v);\n              }\n            });\n          }\n        }(i, this, this.proxySourceCache, t, this._updateTimestamp), this.renderingToTexture = !0, t.splice(0, t.length));\n      }\n\n      renderBatch(t) {\n        if (0 === this._drapedRenderBatches.length) return t + 1;\n        this.renderingToTexture = !0;\n\n        const i = this.painter,\n              o = this.painter.context,\n              r = this.proxySourceCache,\n              n = this.proxiedCoords[r.id],\n              a = this._drapedRenderBatches.shift(),\n              s = [],\n              l = i.style.order;\n\n        let c = 0;\n\n        for (const h of n) {\n          const n = r.getTileByID(h.proxyTileKey),\n                _ = r.proxyCachedFBO[h.key] ? r.proxyCachedFBO[h.key][t] : void 0,\n                u = void 0 !== _ ? r.renderCache[_] : this.pool[c++],\n                d = void 0 !== _;\n\n          if (n.texture = u.tex, d && !u.dirty) {\n            s.push(n.tileID);\n            continue;\n          }\n\n          let p;\n          o.bindFramebuffer.set(u.fb.framebuffer), this.renderedToTile = !1, u.dirty && (o.clear({\n            color: e.Color.transparent,\n            stencil: 0\n          }), u.dirty = !1);\n\n          for (let e = a.start; e <= a.end; ++e) {\n            const t = i.style._layers[l[e]];\n            if (t.isHidden(i.transform.zoom)) continue;\n\n            const r = i.style._getLayerSourceCache(t),\n                  n = r ? this.proxyToSource[h.key][r.id] : [h];\n\n            if (!n) continue;\n            const a = n;\n            o.viewport.set([0, 0, u.fb.width, u.fb.height]), p !== (r ? r.id : null) && (this._setupStencil(u, n, t, r), p = r ? r.id : null), i.renderLayer(i, r, t, a);\n          }\n\n          this.renderedToTile ? (u.dirty = !0, s.push(n.tileID)) : d || --c, 5 === c && (c = 0, this.renderToBackBuffer(s));\n        }\n\n        return this.renderToBackBuffer(s), this.renderingToTexture = !1, o.bindFramebuffer.set(null), o.viewport.set([0, 0, i.width, i.height]), a.end + 1;\n      }\n\n      postRender() {}\n\n      renderCacheEfficiency(e) {\n        const t = e.order.length;\n        if (0 === t) return {\n          efficiency: 100\n        };\n        let i,\n            o = 0,\n            r = 0,\n            n = !1;\n\n        for (let a = 0; a < t; ++a) {\n          const t = e._layers[e.order[a]];\n          this._style.isLayerDraped(t) ? (n && ++o, ++r) : n || (n = !0, i = t.id);\n        }\n\n        return 0 === r ? {\n          efficiency: 100\n        } : {\n          efficiency: 100 * (1 - o / r),\n          firstUndrapedLayer: i\n        };\n      }\n\n      getMinElevationBelowMSL() {\n        let e = 0;\n        return this._visibleDemTiles.filter(e => e.dem).forEach(t => {\n          e = Math.min(e, t.dem.tree.minimums[0]);\n        }), 0 === e ? e : (e - 30) * this._exaggeration;\n      }\n\n      raycast(e, t, i) {\n        if (!this._visibleDemTiles) return null;\n\n        const o = this._visibleDemTiles.filter(e => e.dem).map(o => {\n          const r = o.tileID,\n                n = Math.pow(2, r.overscaledZ),\n                {\n            x: a,\n            y: s\n          } = r.canonical,\n                l = a / n,\n                c = (a + 1) / n,\n                h = s / n,\n                _ = (s + 1) / n;\n\n          return {\n            minx: l,\n            miny: h,\n            maxx: c,\n            maxy: _,\n            t: o.dem.tree.raycastRoot(l, h, c, _, e, t, i),\n            tile: o\n          };\n        });\n\n        o.sort((e, t) => (null !== e.t ? e.t : Number.MAX_VALUE) - (null !== t.t ? t.t : Number.MAX_VALUE));\n\n        for (const r of o) {\n          if (null == r.t) return null;\n          const o = r.tile.dem.tree.raycast(r.minx, r.miny, r.maxx, r.maxy, e, t, i);\n          if (null != o) return o;\n        }\n\n        return null;\n      }\n\n      _createFBO() {\n        const t = this.painter.context,\n              i = t.gl,\n              o = this.drapeBufferSize;\n        t.activeTexture.set(i.TEXTURE0);\n        const r = new e.Texture(t, {\n          width: o[0],\n          height: o[1],\n          data: null\n        }, i.RGBA);\n        r.bind(i.LINEAR, i.CLAMP_TO_EDGE);\n        const n = t.createFramebuffer(o[0], o[1], !1);\n        return n.colorAttachment.set(r.texture), n.depthAttachment = new we(t, n.framebuffer), void 0 === this._sharedDepthStencil ? (this._sharedDepthStencil = t.createRenderbuffer(t.gl.DEPTH_STENCIL, o[0], o[1]), this._stencilRef = 0, n.depthAttachment.set(this._sharedDepthStencil), t.clear({\n          stencil: 0\n        })) : n.depthAttachment.set(this._sharedDepthStencil), t.extTextureFilterAnisotropic && !t.extTextureFilterAnisotropicForceOff && i.texParameterf(i.TEXTURE_2D, t.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, t.extTextureFilterAnisotropicMax), {\n          fb: n,\n          tex: r,\n          dirty: !1\n        };\n      }\n\n      _initFBOPool() {\n        for (; this.pool.length < Math.min(5, this.proxyCoords.length);) this.pool.push(this._createFBO());\n      }\n\n      _shouldDisableRenderCache() {\n        if (this._style.light && this._style.light.hasTransition()) return !0;\n\n        for (const e in this._style._sourceCaches) if (this._style._sourceCaches[e].hasTransition()) return !0;\n\n        return this._style.order.some(e => {\n          const t = this._style._layers[e],\n                i = t.isHidden(this.painter.transform.zoom),\n                o = t.getCrossfadeParameters(),\n                r = !!o && 1 !== o.t,\n                n = t.hasTransition();\n          return \"custom\" !== t.type && !i && (r || n);\n        });\n      }\n\n      _clearRasterFadeFromRenderCache() {\n        let e = !1;\n\n        for (const t in this._style._sourceCaches) if (this._style._sourceCaches[t]._source instanceof Ce) {\n          e = !0;\n          break;\n        }\n\n        if (e) for (let e = 0; e < this._style.order.length; ++e) {\n          const t = this._style._layers[this._style.order[e]],\n                i = t.isHidden(this.painter.transform.zoom),\n                o = this._style._getLayerSourceCache(t);\n\n          if (\"raster\" !== t.type || i || !o) continue;\n          const r = t.paint.get(\"raster-fade-duration\");\n\n          for (const e of this.proxyCoords) {\n            const t = this.proxyToSource[e.key][o.id];\n            if (t) for (const e of t) {\n              const t = fi(o.getTile(e), o.findLoadedParent(e, 0), o, this.painter.transform, r);\n              (1 !== t.opacity || 0 !== t.mix) && this._clearRenderCacheForTile(o.id, e);\n            }\n          }\n        }\n      }\n\n      _setupDrapedRenderBatches() {\n        const e = this._style.order,\n              t = e.length;\n        if (0 === t) return;\n        const i = [];\n        let o,\n            r = 0,\n            n = this._style._layers[e[r]];\n\n        for (; !this._style.isLayerDraped(n) && n.isHidden(this.painter.transform.zoom) && ++r < t;) n = this._style._layers[e[r]];\n\n        for (; r < t; ++r) {\n          const t = this._style._layers[e[r]];\n          t.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(t) ? void 0 === o && (o = r) : void 0 !== o && (i.push({\n            start: o,\n            end: r - 1\n          }), o = void 0));\n        }\n\n        void 0 !== o && i.push({\n          start: o,\n          end: r - 1\n        }), this._drapedRenderBatches = i;\n      }\n\n      _setupRenderCache(e) {\n        const t = this.proxySourceCache;\n\n        if (this._shouldDisableRenderCache() || this._invalidateRenderCache) {\n          if (this._invalidateRenderCache = !1, t.renderCache.length > t.renderCachePool.length) {\n            const e = Object.values(t.proxyCachedFBO);\n            t.proxyCachedFBO = {};\n\n            for (let i = 0; i < e.length; ++i) {\n              const o = Object.values(e[i]);\n              t.renderCachePool.push(...o);\n            }\n          }\n\n          return;\n        }\n\n        this._clearRasterFadeFromRenderCache();\n\n        const i = this.proxyCoords,\n              o = this._tilesDirty;\n\n        for (let r = i.length - 1; r >= 0; r--) {\n          const n = i[r];\n\n          if (t.getTileByID(n.key), void 0 !== t.proxyCachedFBO[n.key]) {\n            const i = e[n.key],\n                  r = this.proxyToSource[n.key];\n            let a = 0;\n\n            for (const e in r) {\n              const t = r[e],\n                    n = i[e];\n\n              if (!n || n.length !== t.length || t.some((t, i) => t !== n[i] || o[e] && o[e].hasOwnProperty(t.key))) {\n                a = -1;\n                break;\n              }\n\n              ++a;\n            }\n\n            for (const e in t.proxyCachedFBO[n.key]) t.renderCache[t.proxyCachedFBO[n.key][e]].dirty = a < 0 || a !== Object.values(i).length;\n          }\n        }\n\n        const r = [...this._drapedRenderBatches];\n        r.sort((e, t) => t.end - t.start - (e.end - e.start));\n\n        for (const e of r) for (const o of i) {\n          if (t.proxyCachedFBO[o.key]) continue;\n          let i = t.renderCachePool.pop();\n          void 0 === i && t.renderCache.length < 50 && (i = t.renderCache.length, t.renderCache.push(this._createFBO())), void 0 !== i && (t.proxyCachedFBO[o.key] = {}, t.proxyCachedFBO[o.key][e.start] = i, t.renderCache[i].dirty = !0);\n        }\n\n        this._tilesDirty = {};\n      }\n\n      _setupStencil(e, t, i, o) {\n        if (!o || !this._sourceTilesOverlap[o.id]) return void (this._overlapStencilType && (this._overlapStencilType = !1));\n        const r = this.painter.context,\n              n = r.gl;\n        if (t.length <= 1) return void (this._overlapStencilType = !1);\n        let a;\n        if (i.isTileClipped()) a = t.length, this._overlapStencilMode.test = {\n          func: n.EQUAL,\n          mask: 255\n        }, this._overlapStencilType = \"Clip\";else {\n          if (!(t[0].overscaledZ > t[t.length - 1].overscaledZ)) return void (this._overlapStencilType = !1);\n          a = 1, this._overlapStencilMode.test = {\n            func: n.GREATER,\n            mask: 255\n          }, this._overlapStencilType = \"Mask\";\n        }\n        this._stencilRef + a > 255 && (r.clear({\n          stencil: 0\n        }), this._stencilRef = 0), this._stencilRef += a, this._overlapStencilMode.ref = this._stencilRef, i.isTileClipped() && this._renderTileClippingMasks(t, this._overlapStencilMode.ref);\n      }\n\n      clipOrMaskOverlapStencilType() {\n        return \"Clip\" === this._overlapStencilType || \"Mask\" === this._overlapStencilType;\n      }\n\n      stencilModeForRTTOverlap(t) {\n        return this.renderingToTexture && this._overlapStencilType ? (\"Clip\" === this._overlapStencilType && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs.get(t.key) || 0), this._overlapStencilMode) : e.StencilMode.disabled;\n      }\n\n      _renderTileClippingMasks(t, i) {\n        const o = this.painter,\n              r = this.painter.context,\n              n = r.gl;\n        o._tileClippingMaskIDs.clear(), r.setColorMode(e.ColorMode.disabled), r.setDepthMode(e.DepthMode.disabled);\n        const a = o.useProgram(\"clippingMask\");\n\n        for (const s of t) {\n          const t = --i;\n          o._tileClippingMaskIDs.set(s.key, t), a.draw(r, n.TRIANGLES, e.DepthMode.disabled, new e.StencilMode({\n            func: n.ALWAYS,\n            mask: 0\n          }, t, 255, n.KEEP, n.KEEP, n.REPLACE), e.ColorMode.disabled, e.CullFaceMode.disabled, mi(s.projMatrix), \"$clipping\", o.tileExtentBuffer, o.quadTriangleIndexBuffer, o.tileExtentSegments);\n        }\n      }\n\n      pointCoordinate(t) {\n        const i = this.painter.transform;\n        if (t.x < 0 || t.x > i.width || t.y < 0 || t.y > i.height) return null;\n        const o = [t.x, t.y, 1, 1];\n        e.transformMat4$1(o, o, i.pixelMatrixInverse), e.scale$1(o, o, 1 / o[3]), o[0] /= i.worldSize, o[1] /= i.worldSize;\n        const r = i._camera.position,\n              n = e.mercatorZfromAltitude(1, i.center.lat),\n              a = [r[0], r[1], r[2] / n, 0],\n              s = e.subtract([], o.slice(0, 3), a);\n        e.normalize(s, s);\n        const l = this.raycast(a, s, this._exaggeration);\n        return null !== l && l ? (e.scaleAndAdd(a, a, s, l), a[3] = a[2], a[2] *= n, a) : null;\n      }\n\n      drawDepth() {\n        const t = this.painter,\n              i = t.context,\n              o = this.proxySourceCache,\n              r = Math.ceil(t.width),\n              n = Math.ceil(t.height);\n\n        if (!this._depthFBO || this._depthFBO.width === r && this._depthFBO.height === n || (this._depthFBO.destroy(), this._depthFBO = void 0, this._depthTexture = void 0), !this._depthFBO) {\n          const t = i.gl,\n                o = i.createFramebuffer(r, n, !0);\n          i.activeTexture.set(t.TEXTURE0);\n          const a = new e.Texture(i, {\n            width: r,\n            height: n,\n            data: null\n          }, t.RGBA);\n          a.bind(t.NEAREST, t.CLAMP_TO_EDGE), o.colorAttachment.set(a.texture);\n          const s = i.createRenderbuffer(i.gl.DEPTH_COMPONENT16, r, n);\n          o.depthAttachment.set(s), this._depthFBO = o, this._depthTexture = a;\n        }\n\n        i.bindFramebuffer.set(this._depthFBO.framebuffer), i.viewport.set([0, 0, r, n]), function (t, i, o, r) {\n          if (\"globe\" === t.transform.projection.name) return;\n          const n = t.context,\n                a = n.gl;\n          n.clear({\n            depth: 1\n          });\n          const s = t.useProgram(\"terrainDepth\"),\n                l = new e.DepthMode(a.LESS, e.DepthMode.ReadWrite, t.depthRangeFor3D);\n\n          for (const t of r) {\n            const r = o.getTile(t),\n                  c = ci(t.projMatrix, 0);\n            i.setupElevationDraw(r, s), s.draw(n, a.TRIANGLES, l, e.StencilMode.disabled, e.ColorMode.unblended, e.CullFaceMode.backCCW, c, \"terrain_depth\", i.gridBuffer, i.gridIndexBuffer, i.gridNoSkirtSegments);\n          }\n        }(t, this, o, this.proxyCoords);\n      }\n\n      _setupProxiedCoordsForOrtho(e, t, i) {\n        if (e.getSource() instanceof Se) return this._setupProxiedCoordsForImageSource(e, t, i);\n        this._findCoveringTileCache[e.id] = this._findCoveringTileCache[e.id] || {};\n        const o = this.proxiedCoords[e.id] = [],\n              r = this.proxyCoords;\n\n        for (let t = 0; t < r.length; t++) {\n          const n = r[t],\n                a = this._findTileCoveringTileID(n, e);\n\n          if (a) {\n            const t = this._createProxiedId(n, a, i[n.key] && i[n.key][e.id]);\n\n            o.push(t), this.proxyToSource[n.key][e.id] = [t];\n          }\n        }\n\n        let n = !1;\n\n        for (let r = 0; r < t.length; r++) {\n          const a = e.getTile(t[r]);\n          if (!a || !a.hasData()) continue;\n\n          const s = this._findTileCoveringTileID(a.tileID, this.proxySourceCache);\n\n          if (s && s.tileID.canonical.z !== a.tileID.canonical.z) {\n            const t = this.proxyToSource[s.tileID.key][e.id],\n                  r = this._createProxiedId(s.tileID, a, i[s.tileID.key] && i[s.tileID.key][e.id]);\n\n            t ? t.splice(t.length - 1, 0, r) : this.proxyToSource[s.tileID.key][e.id] = [r], o.push(r), n = !0;\n          }\n        }\n\n        this._sourceTilesOverlap[e.id] = n;\n      }\n\n      _setupProxiedCoordsForImageSource(t, i, o) {\n        if (!t.getSource().loaded()) return;\n\n        const r = this.proxiedCoords[t.id] = [],\n              n = this.proxyCoords,\n              a = t.getSource(),\n              s = new e.pointGeometry(a.tileID.x, a.tileID.y)._div(1 << a.tileID.z),\n              l = a.coordinates.map(e.MercatorCoordinate.fromLngLat).reduce((e, t) => (e.min.x = Math.min(e.min.x, t.x - s.x), e.min.y = Math.min(e.min.y, t.y - s.y), e.max.x = Math.max(e.max.x, t.x - s.x), e.max.y = Math.max(e.max.y, t.y - s.y), e), {\n          min: new e.pointGeometry(Number.MAX_VALUE, Number.MAX_VALUE),\n          max: new e.pointGeometry(-Number.MAX_VALUE, -Number.MAX_VALUE)\n        }),\n              c = (t, i) => {\n          const o = t.wrap + t.canonical.x / (1 << t.canonical.z),\n                r = t.canonical.y / (1 << t.canonical.z),\n                n = e.EXTENT / (1 << t.canonical.z),\n                a = i.wrap + i.canonical.x / (1 << i.canonical.z),\n                s = i.canonical.y / (1 << i.canonical.z);\n          return o + n < a + l.min.x || o > a + l.max.x || r + n < s + l.min.y || r > s + l.max.y;\n        };\n\n        for (let e = 0; e < n.length; e++) {\n          const a = n[e];\n\n          for (let e = 0; e < i.length; e++) {\n            const n = t.getTile(i[e]);\n            if (!n || !n.hasData()) continue;\n            if (c(a, n.tileID)) continue;\n\n            const s = this._createProxiedId(a, n, o[a.key] && o[a.key][t.id]),\n                  l = this.proxyToSource[a.key][t.id];\n\n            l ? l.push(s) : this.proxyToSource[a.key][t.id] = [s], r.push(s);\n          }\n        }\n      }\n\n      _createProxiedId(t, i, o) {\n        let r = this.orthoMatrix;\n\n        if (o) {\n          const e = o.find(e => e.key === i.tileID.key);\n          if (e) return e;\n        }\n\n        if (i.tileID.key !== t.key) {\n          const o = t.canonical.z - i.tileID.canonical.z;\n          let n, a, s;\n          r = e.create();\n          const l = i.tileID.wrap - t.wrap << t.overscaledZ;\n          o > 0 ? (n = e.EXTENT >> o, a = n * ((i.tileID.canonical.x << o) - t.canonical.x + l), s = n * ((i.tileID.canonical.y << o) - t.canonical.y)) : (n = e.EXTENT << -o, a = e.EXTENT * (i.tileID.canonical.x - (t.canonical.x + l << -o)), s = e.EXTENT * (i.tileID.canonical.y - (t.canonical.y << -o))), e.ortho(r, 0, n, 0, n, 0, 1), e.translate(r, r, [a, s, 0]);\n        }\n\n        return new yi(i.tileID, t.key, r);\n      }\n\n      _findTileCoveringTileID(t, i) {\n        let o = i.getTile(t);\n        if (o && o.hasData()) return o;\n        const r = this._findCoveringTileCache[i.id],\n              n = r[t.key];\n        if (o = n ? i.getTileByID(n) : null, o && o.hasData() || null === n) return o;\n        let a = o ? o.tileID : t,\n            s = a.overscaledZ;\n        const l = i.getSource().minzoom,\n              c = [];\n\n        if (!n) {\n          const r = i.getSource().maxzoom;\n\n          if (t.canonical.z >= r) {\n            const o = t.canonical.z - r;\n            i.getSource().reparseOverscaled ? (s = Math.max(t.canonical.z + 2, i.transform.tileZoom), a = new e.OverscaledTileID(s, t.wrap, r, t.canonical.x >> o, t.canonical.y >> o)) : 0 !== o && (s = r, a = new e.OverscaledTileID(s, t.wrap, r, t.canonical.x >> o, t.canonical.y >> o));\n          }\n\n          a.key !== t.key && (c.push(a.key), o = i.getTile(a));\n        }\n\n        const h = e => {\n          c.forEach(t => {\n            r[t] = e;\n          }), c.length = 0;\n        };\n\n        for (s -= 1; s >= l && (!o || !o.hasData()); s--) {\n          o && h(o.tileID.key);\n          const e = a.calculateScaledKey(s);\n          if (o = i.getTileByID(e), o && o.hasData()) break;\n          const t = r[e];\n          if (null === t) break;\n          void 0 === t ? c.push(e) : o = i.getTileByID(t);\n        }\n\n        return h(o ? o.tileID.key : null), o && o.hasData() ? o : null;\n      }\n\n      findDEMTileFor(e) {\n        return this.enabled ? this._findTileCoveringTileID(e, this.sourceCache) : null;\n      }\n\n      prepareDrawTile() {\n        this.renderedToTile = !0;\n      }\n\n      _clearRenderCacheForTile(e, t) {\n        let i = this._tilesDirty[e];\n        i || (i = this._tilesDirty[e] = {}), i[t.key] = !0;\n      }\n\n      getWirefameBuffer() {\n        if (!this.wireframeSegments) {\n          const t = function (t) {\n            let i = 0;\n            const o = new e.StructArrayLayout2ui4(),\n                  r = 131;\n\n            for (let e = 1; e < 129; e++) {\n              for (let t = 1; t < 129; t++) i = e * r + t, o.emplaceBack(i, i + 1), o.emplaceBack(i, i + r), o.emplaceBack(i + 1, i + r), 128 === e && o.emplaceBack(i + r, i + r + 1);\n\n              o.emplaceBack(i + 1, i + 1 + r);\n            }\n\n            return o;\n          }();\n\n          this.wireframeIndexBuffer = this.painter.context.createIndexBuffer(t), this.wireframeSegments = e.SegmentVector.simpleSegment(0, 0, this.gridBuffer.length, t.length);\n        }\n\n        return [this.wireframeIndexBuffer, this.wireframeSegments];\n      }\n\n    }\n\n    function wi(e) {\n      const t = [];\n\n      for (let i = 0; i < e.length; i++) {\n        if (null === e[i]) continue;\n        const o = e[i].split(\" \");\n        t.push(o.pop());\n      }\n\n      return t;\n    }\n\n    class Ti {\n      static cacheKey(e, t, i) {\n        let o = `${e}${i ? i.cacheKey : \"\"}`;\n\n        for (const e of t) o += `/${e}`;\n\n        return o;\n      }\n\n      constructor(t, i, o, r, n, a) {\n        const s = t.gl;\n        this.program = s.createProgram();\n\n        const l = wi(o.staticAttributes),\n              c = r ? r.getBinderAttributes() : [],\n              h = l.concat(c),\n              _ = o.staticUniforms ? wi(o.staticUniforms) : [],\n              u = r ? r.getBinderUniforms() : [],\n              d = _.concat(u),\n              p = [];\n\n        for (const e of d) p.indexOf(e) < 0 && p.push(e);\n\n        let m = r ? r.defines() : [];\n        m = m.concat(a.map(e => `#define ${e}`));\n        const f = m.concat(\"\\n#ifdef GL_ES\\nprecision mediump float;\\n#else\\n\\n#if !defined(lowp)\\n#define lowp\\n#endif\\n\\n#if !defined(mediump)\\n#define mediump\\n#endif\\n\\n#if !defined(highp)\\n#define highp\\n#endif\\n\\n#endif\", ei, Qt.fragmentSource, Jt.fragmentSource, o.fragmentSource).join(\"\\n\"),\n              g = m.concat(\"\\n#ifdef GL_ES\\nprecision highp float;\\n#else\\n\\n#if !defined(lowp)\\n#define lowp\\n#endif\\n\\n#if !defined(mediump)\\n#define mediump\\n#endif\\n\\n#if !defined(highp)\\n#define highp\\n#endif\\n\\n#endif\", ei, Qt.vertexSource, Jt.vertexSource, Yt.vertexSource, o.vertexSource).join(\"\\n\"),\n              v = s.createShader(s.FRAGMENT_SHADER);\n        if (s.isContextLost()) return void (this.failedToCreate = !0);\n        s.shaderSource(v, f), s.compileShader(v), s.attachShader(this.program, v);\n        const x = s.createShader(s.VERTEX_SHADER);\n        if (s.isContextLost()) return void (this.failedToCreate = !0);\n        s.shaderSource(x, g), s.compileShader(x), s.attachShader(this.program, x), this.attributes = {};\n        const y = {};\n        this.numAttributes = h.length;\n\n        for (let e = 0; e < this.numAttributes; e++) h[e] && (s.bindAttribLocation(this.program, e, h[e]), this.attributes[h[e]] = e);\n\n        s.linkProgram(this.program), s.deleteShader(x), s.deleteShader(v);\n\n        for (let e = 0; e < p.length; e++) {\n          const t = p[e];\n\n          if (t && !y[t]) {\n            const e = s.getUniformLocation(this.program, t);\n            e && (y[t] = e);\n          }\n        }\n\n        this.fixedUniforms = n(t, y), this.binderUniforms = r ? r.getUniforms(t, y) : [], -1 !== a.indexOf(\"TERRAIN\") && (this.terrainUniforms = ((t, i) => ({\n          u_dem: new e.Uniform1i(t, i.u_dem),\n          u_dem_prev: new e.Uniform1i(t, i.u_dem_prev),\n          u_dem_unpack: new e.Uniform4f(t, i.u_dem_unpack),\n          u_dem_tl: new e.Uniform2f(t, i.u_dem_tl),\n          u_dem_scale: new e.Uniform1f(t, i.u_dem_scale),\n          u_dem_tl_prev: new e.Uniform2f(t, i.u_dem_tl_prev),\n          u_dem_scale_prev: new e.Uniform1f(t, i.u_dem_scale_prev),\n          u_dem_size: new e.Uniform1f(t, i.u_dem_size),\n          u_dem_lerp: new e.Uniform1f(t, i.u_dem_lerp),\n          u_exaggeration: new e.Uniform1f(t, i.u_exaggeration),\n          u_depth: new e.Uniform1i(t, i.u_depth),\n          u_depth_size_inv: new e.Uniform2f(t, i.u_depth_size_inv),\n          u_meter_to_dem: new e.Uniform1f(t, i.u_meter_to_dem),\n          u_label_plane_matrix_inv: new e.UniformMatrix4f(t, i.u_label_plane_matrix_inv),\n          u_tile_tl_up: new e.Uniform3f(t, i.u_tile_tl_up),\n          u_tile_tr_up: new e.Uniform3f(t, i.u_tile_tr_up),\n          u_tile_br_up: new e.Uniform3f(t, i.u_tile_br_up),\n          u_tile_bl_up: new e.Uniform3f(t, i.u_tile_bl_up),\n          u_tile_up_scale: new e.Uniform1f(t, i.u_tile_up_scale)\n        }))(t, y)), -1 !== a.indexOf(\"FOG\") && (this.fogUniforms = ((t, i) => ({\n          u_fog_matrix: new e.UniformMatrix4f(t, i.u_fog_matrix),\n          u_fog_range: new e.Uniform2f(t, i.u_fog_range),\n          u_fog_color: new e.Uniform4f(t, i.u_fog_color),\n          u_fog_horizon_blend: new e.Uniform1f(t, i.u_fog_horizon_blend),\n          u_fog_temporal_offset: new e.Uniform1f(t, i.u_fog_temporal_offset)\n        }))(t, y));\n      }\n\n      setTerrainUniformValues(e, t) {\n        if (!this.terrainUniforms) return;\n        const i = this.terrainUniforms;\n\n        if (!this.failedToCreate) {\n          e.program.set(this.program);\n\n          for (const e in t) i[e].set(t[e]);\n        }\n      }\n\n      setFogUniformValues(e, t) {\n        if (!this.fogUniforms) return;\n        const i = this.fogUniforms;\n\n        if (!this.failedToCreate) {\n          e.program.set(this.program);\n\n          for (const e in t) i[e].location && i[e].set(t[e]);\n        }\n      }\n\n      draw(e, t, i, o, r, n, a, s, l, c, h, _, u, d, p, m) {\n        const f = e.gl;\n        if (this.failedToCreate) return;\n        e.program.set(this.program), e.setDepthMode(i), e.setStencilMode(o), e.setColorMode(r), e.setCullFace(n);\n\n        for (const e of Object.keys(this.fixedUniforms)) this.fixedUniforms[e].set(a[e]);\n\n        d && d.setUniforms(e, this.binderUniforms, _, {\n          zoom: u\n        });\n        const g = {\n          [f.LINES]: 2,\n          [f.TRIANGLES]: 3,\n          [f.LINE_STRIP]: 1\n        }[t];\n\n        for (const i of h.get()) {\n          const o = i.vaos || (i.vaos = {});\n          (o[s] || (o[s] = new oi())).bind(e, this, l, d ? d.getPaintVertexBuffers() : [], c, i.vertexOffset, p, m), f.drawElements(t, i.primitiveLength * g, f.UNSIGNED_SHORT, i.primitiveOffset * g * 2);\n        }\n      }\n\n    }\n\n    function Ei(e, t, i) {\n      const o = 1 / L(i, 1, t.transform.tileZoom),\n            r = Math.pow(2, i.tileID.overscaledZ),\n            n = i.tileSize * Math.pow(2, t.transform.tileZoom) / r,\n            a = n * (i.tileID.canonical.x + i.tileID.wrap * r),\n            s = n * i.tileID.canonical.y;\n      return {\n        u_image: 0,\n        u_texsize: i.imageAtlasTexture.size,\n        u_scale: [o, e.fromScale, e.toScale],\n        u_fade: e.t,\n        u_pixel_coord_upper: [a >> 16, s >> 16],\n        u_pixel_coord_lower: [65535 & a, 65535 & s]\n      };\n    }\n\n    const Ci = e.create(),\n          Ii = (t, i, o, r, n, a, s, l, c) => {\n      const h = i.style.light,\n            _ = h.properties.get(\"position\"),\n            u = [_.x, _.y, _.z],\n            d = e.create$1();\n\n      \"viewport\" === h.properties.get(\"anchor\") && (e.fromRotation(d, -i.transform.angle), e.transformMat3(u, u, d));\n      const p = h.properties.get(\"color\"),\n            m = i.transform,\n            f = {\n        u_matrix: t,\n        u_lightpos: u,\n        u_lightintensity: h.properties.get(\"intensity\"),\n        u_lightcolor: [p.r, p.g, p.b],\n        u_vertical_gradient: +o,\n        u_opacity: r,\n        u_tile_id: [0, 0, 0],\n        u_zoom_transition: 0,\n        u_inv_rot_matrix: Ci,\n        u_merc_center: [0, 0],\n        u_up_dir: [0, 0, 0],\n        u_height_lift: 0\n      };\n      return \"globe\" === m.projection.name && (f.u_tile_id = [n.canonical.x, n.canonical.y, 1 << n.canonical.z], f.u_zoom_transition = s, f.u_inv_rot_matrix = c, f.u_merc_center = l, f.u_up_dir = m.projection.upVector(new e.CanonicalTileID(0, 0, 0), l[0] * e.EXTENT, l[1] * e.EXTENT), f.u_height_lift = a), f;\n    },\n          Mi = (t, i, o, r, n, a, s, l, c, h, _) => {\n      const u = Ii(t, i, o, r, n, l, c, h, _),\n            d = {\n        u_height_factor: -Math.pow(2, n.overscaledZ) / s.tileSize / 8\n      };\n      return e.extend(u, Ei(a, i, s), d);\n    },\n          Si = e => ({\n      u_matrix: e\n    }),\n          zi = (t, i, o, r) => e.extend(Si(t), Ei(o, i, r)),\n          Di = (e, t) => ({\n      u_matrix: e,\n      u_world: t\n    }),\n          Pi = (t, i, o, r, n) => e.extend(zi(t, i, o, r), {\n      u_world: n\n    }),\n          Ai = e.create(),\n          Li = (t, i, o, r, n, a) => {\n      const s = t.transform,\n            l = \"globe\" === s.projection.name;\n      let c;\n      if (\"map\" === a.paint.get(\"circle-pitch-alignment\")) {\n        if (l) {\n          const t = e.globePixelsToTileUnits(s.zoom, i.canonical);\n          c = Float32Array.from([t, 0, 0, t]);\n        } else c = s.calculatePixelsToTileUnitsMatrix(o);\n      } else c = new Float32Array([s.pixelsToGLUnits[0], 0, 0, s.pixelsToGLUnits[1]]);\n      const h = {\n        u_camera_to_center_distance: s.cameraToCenterDistance,\n        u_matrix: t.translatePosMatrix(i.projMatrix, o, a.paint.get(\"circle-translate\"), a.paint.get(\"circle-translate-anchor\")),\n        u_device_pixel_ratio: e.exported.devicePixelRatio,\n        u_extrude_scale: c,\n        u_inv_rot_matrix: Ai,\n        u_merc_center: [0, 0],\n        u_tile_id: [0, 0, 0],\n        u_zoom_transition: 0,\n        u_up_dir: [0, 0, 0]\n      };\n      return l && (h.u_inv_rot_matrix = r, h.u_merc_center = n, h.u_tile_id = [i.canonical.x, i.canonical.y, 1 << i.canonical.z], h.u_zoom_transition = e.globeToMercatorTransition(s.zoom), h.u_up_dir = s.projection.upVector(i.canonical, n[0], n[1])), h;\n    },\n          Ri = e => {\n      const t = [];\n      return \"map\" === e.paint.get(\"circle-pitch-alignment\") && t.push(\"PITCH_WITH_MAP\"), \"map\" === e.paint.get(\"circle-pitch-scale\") && t.push(\"SCALE_WITH_MAP\"), t;\n    },\n          ki = (t, i, o) => {\n      const r = e.EXTENT / o.tileSize;\n      return {\n        u_matrix: t,\n        u_camera_to_center_distance: i.cameraToCenterDistance,\n        u_extrude_scale: [i.pixelsToGLUnits[0] / r, i.pixelsToGLUnits[1] / r]\n      };\n    },\n          Oi = (e, t, i = 1) => ({\n      u_matrix: e,\n      u_color: t,\n      u_overlay: 0,\n      u_overlay_scale: i\n    }),\n          Bi = e.create(),\n          Fi = (t, i, o, r, n, a, s) => {\n      const l = t.transform,\n            c = \"globe\" === l.projection.name,\n            h = c ? e.globePixelsToTileUnits(l.zoom, i.canonical) : L(o, 1, a),\n            _ = {\n        u_matrix: i.projMatrix,\n        u_extrude_scale: h,\n        u_intensity: s,\n        u_inv_rot_matrix: Bi,\n        u_merc_center: [0, 0],\n        u_tile_id: [0, 0, 0],\n        u_zoom_transition: 0,\n        u_up_dir: [0, 0, 0]\n      };\n      return c && (_.u_inv_rot_matrix = r, _.u_merc_center = n, _.u_tile_id = [i.canonical.x, i.canonical.y, 1 << i.canonical.z], _.u_zoom_transition = e.globeToMercatorTransition(l.zoom), _.u_up_dir = l.projection.upVector(i.canonical, n[0], n[1])), _;\n    },\n          Ui = (e, t, i, o, r, n, a) => {\n      const s = e.transform,\n            l = s.calculatePixelsToTileUnitsMatrix(t),\n            c = {\n        u_matrix: ji(e, t, i, r),\n        u_pixels_to_tile_units: l,\n        u_device_pixel_ratio: a,\n        u_units_to_pixels: [1 / s.pixelsToGLUnits[0], 1 / s.pixelsToGLUnits[1]],\n        u_dash_image: 0,\n        u_gradient_image: 1,\n        u_image_height: n,\n        u_texsize: [0, 0],\n        u_scale: [0, 0, 0],\n        u_mix: 0,\n        u_alpha_discard_threshold: 0\n      };\n\n      if (Zi(i)) {\n        const i = Gi(t, e.transform);\n        c.u_texsize = t.lineAtlasTexture.size, c.u_scale = [i, o.fromScale, o.toScale], c.u_mix = o.t;\n      }\n\n      return c;\n    },\n          Ni = (e, t, i, o, r, n) => {\n      const a = e.transform,\n            s = Gi(t, a);\n      return {\n        u_matrix: ji(e, t, i, r),\n        u_texsize: t.imageAtlasTexture.size,\n        u_pixels_to_tile_units: a.calculatePixelsToTileUnitsMatrix(t),\n        u_device_pixel_ratio: n,\n        u_image: 0,\n        u_scale: [s, o.fromScale, o.toScale],\n        u_fade: o.t,\n        u_units_to_pixels: [1 / a.pixelsToGLUnits[0], 1 / a.pixelsToGLUnits[1]],\n        u_alpha_discard_threshold: 0\n      };\n    };\n\n    function Gi(e, t) {\n      return 1 / L(e, 1, t.tileZoom);\n    }\n\n    function ji(e, t, i, o) {\n      return e.translatePosMatrix(o || t.tileID.projMatrix, t, i.paint.get(\"line-translate\"), i.paint.get(\"line-translate-anchor\"));\n    }\n\n    function Zi(e) {\n      const t = e.paint.get(\"line-dasharray\").value;\n      return t.value || \"constant\" !== t.kind;\n    }\n\n    const Vi = (e, t, i, o, r, n) => {\n      return {\n        u_matrix: e,\n        u_tl_parent: t,\n        u_scale_parent: i,\n        u_fade_t: o.mix,\n        u_opacity: o.opacity * r.paint.get(\"raster-opacity\"),\n        u_image0: 0,\n        u_image1: 1,\n        u_brightness_low: r.paint.get(\"raster-brightness-min\"),\n        u_brightness_high: r.paint.get(\"raster-brightness-max\"),\n        u_saturation_factor: (s = r.paint.get(\"raster-saturation\"), s > 0 ? 1 - 1 / (1.001 - s) : -s),\n        u_contrast_factor: (a = r.paint.get(\"raster-contrast\"), a > 0 ? 1 / (1 - a) : 1 + a),\n        u_spin_weights: Wi(r.paint.get(\"raster-hue-rotate\")),\n        u_perspective_transform: n\n      };\n      var a, s;\n    };\n\n    function Wi(e) {\n      e *= Math.PI / 180;\n      const t = Math.sin(e),\n            i = Math.cos(e);\n      return [(2 * i + 1) / 3, (-Math.sqrt(3) * t - i + 1) / 3, (Math.sqrt(3) * t - i + 1) / 3];\n    }\n\n    const qi = e.create(),\n          Xi = (t, i, o, r, n, a, s, l, c, h, _, u, d, p) => {\n      const m = n.transform,\n            f = {\n        u_is_size_zoom_constant: +(\"constant\" === t || \"source\" === t),\n        u_is_size_feature_constant: +(\"constant\" === t || \"camera\" === t),\n        u_size_t: i ? i.uSizeT : 0,\n        u_size: i ? i.uSize : 0,\n        u_camera_to_center_distance: m.cameraToCenterDistance,\n        u_rotate_symbol: +o,\n        u_aspect_ratio: m.width / m.height,\n        u_fade_change: n.options.fadeDuration ? n.symbolFadeChange : 1,\n        u_matrix: a,\n        u_label_plane_matrix: s,\n        u_coord_matrix: l,\n        u_is_text: +c,\n        u_pitch_with_map: +r,\n        u_texsize: h,\n        u_texture: 0,\n        u_tile_id: [0, 0, 0],\n        u_zoom_transition: 0,\n        u_inv_rot_matrix: qi,\n        u_merc_center: [0, 0],\n        u_camera_forward: [0, 0, 0],\n        u_ecef_origin: [0, 0, 0],\n        u_tile_matrix: qi\n      };\n      return \"globe\" === m.projection.name && (f.u_tile_id = [_.canonical.x, _.canonical.y, 1 << _.canonical.z], f.u_zoom_transition = u, f.u_inv_rot_matrix = p, f.u_merc_center = d, f.u_camera_forward = m._camera.forward(), f.u_ecef_origin = e.globeECEFOrigin(m.globeMatrix, _.toUnwrapped()), f.u_tile_matrix = Float32Array.from(m.globeMatrix)), f;\n    },\n          $i = (t, i, o, r, n, a, s, l, c, h, _, u, d, p, m) => {\n      const {\n        cameraToCenterDistance: f,\n        _pitch: g\n      } = n.transform;\n      return e.extend(Xi(t, i, o, r, n, a, s, l, c, h, u, d, p, m), {\n        u_gamma_scale: r ? f * Math.cos(n.terrain ? 0 : g) : 1,\n        u_device_pixel_ratio: e.exported.devicePixelRatio,\n        u_is_halo: +_\n      });\n    },\n          Hi = (t, i, o, r, n, a, s, l, c, h, _, u, d, p) => e.extend($i(t, i, o, r, n, a, s, l, !0, c, !0, _, u, d, p), {\n      u_texsize_icon: h,\n      u_texture_icon: 1\n    }),\n          Ki = (e, t, i) => ({\n      u_matrix: e,\n      u_opacity: t,\n      u_color: i\n    }),\n          Yi = (t, i, o, r, n, a) => e.extend(function (e, t, i, o) {\n      const r = i.imageManager.getPattern(e.from.toString()),\n            n = i.imageManager.getPattern(e.to.toString()),\n            {\n        width: a,\n        height: s\n      } = i.imageManager.getPixelSize(),\n            l = Math.pow(2, o.tileID.overscaledZ),\n            c = o.tileSize * Math.pow(2, i.transform.tileZoom) / l,\n            h = c * (o.tileID.canonical.x + o.tileID.wrap * l),\n            _ = c * o.tileID.canonical.y;\n\n      return {\n        u_image: 0,\n        u_pattern_tl_a: r.tl,\n        u_pattern_br_a: r.br,\n        u_pattern_tl_b: n.tl,\n        u_pattern_br_b: n.br,\n        u_texsize: [a, s],\n        u_mix: t.t,\n        u_pattern_size_a: r.displaySize,\n        u_pattern_size_b: n.displaySize,\n        u_scale_a: t.fromScale,\n        u_scale_b: t.toScale,\n        u_tile_units_to_pixels: 1 / L(o, 1, i.transform.tileZoom),\n        u_pixel_coord_upper: [h >> 16, _ >> 16],\n        u_pixel_coord_lower: [65535 & h, 65535 & _]\n      };\n    }(r, a, o, n), {\n      u_matrix: t,\n      u_opacity: i\n    }),\n          Ji = {\n      fillExtrusion: (t, i) => ({\n        u_matrix: new e.UniformMatrix4f(t, i.u_matrix),\n        u_lightpos: new e.Uniform3f(t, i.u_lightpos),\n        u_lightintensity: new e.Uniform1f(t, i.u_lightintensity),\n        u_lightcolor: new e.Uniform3f(t, i.u_lightcolor),\n        u_vertical_gradient: new e.Uniform1f(t, i.u_vertical_gradient),\n        u_opacity: new e.Uniform1f(t, i.u_opacity),\n        u_tile_id: new e.Uniform3f(t, i.u_tile_id),\n        u_zoom_transition: new e.Uniform1f(t, i.u_zoom_transition),\n        u_inv_rot_matrix: new e.UniformMatrix4f(t, i.u_inv_rot_matrix),\n        u_merc_center: new e.Uniform2f(t, i.u_merc_center),\n        u_up_dir: new e.Uniform3f(t, i.u_up_dir),\n        u_height_lift: new e.Uniform1f(t, i.u_height_lift)\n      }),\n      fillExtrusionPattern: (t, i) => ({\n        u_matrix: new e.UniformMatrix4f(t, i.u_matrix),\n        u_lightpos: new e.Uniform3f(t, i.u_lightpos),\n        u_lightintensity: new e.Uniform1f(t, i.u_lightintensity),\n        u_lightcolor: new e.Uniform3f(t, i.u_lightcolor),\n        u_vertical_gradient: new e.Uniform1f(t, i.u_vertical_gradient),\n        u_height_factor: new e.Uniform1f(t, i.u_height_factor),\n        u_tile_id: new e.Uniform3f(t, i.u_tile_id),\n        u_zoom_transition: new e.Uniform1f(t, i.u_zoom_transition),\n        u_inv_rot_matrix: new e.UniformMatrix4f(t, i.u_inv_rot_matrix),\n        u_merc_center: new e.Uniform2f(t, i.u_merc_center),\n        u_up_dir: new e.Uniform3f(t, i.u_up_dir),\n        u_height_lift: new e.Uniform1f(t, i.u_height_lift),\n        u_image: new e.Uniform1i(t, i.u_image),\n        u_texsize: new e.Uniform2f(t, i.u_texsize),\n        u_pixel_coord_upper: new e.Uniform2f(t, i.u_pixel_coord_upper),\n        u_pixel_coord_lower: new e.Uniform2f(t, i.u_pixel_coord_lower),\n        u_scale: new e.Uniform3f(t, i.u_scale),\n        u_fade: new e.Uniform1f(t, i.u_fade),\n        u_opacity: new e.Uniform1f(t, i.u_opacity)\n      }),\n      fill: (t, i) => ({\n        u_matrix: new e.UniformMatrix4f(t, i.u_matrix)\n      }),\n      fillPattern: (t, i) => ({\n        u_matrix: new e.UniformMatrix4f(t, i.u_matrix),\n        u_image: new e.Uniform1i(t, i.u_image),\n        u_texsize: new e.Uniform2f(t, i.u_texsize),\n        u_pixel_coord_upper: new e.Uniform2f(t, i.u_pixel_coord_upper),\n        u_pixel_coord_lower: new e.Uniform2f(t, i.u_pixel_coord_lower),\n        u_scale: new e.Uniform3f(t, i.u_scale),\n        u_fade: new e.Uniform1f(t, i.u_fade)\n      }),\n      fillOutline: (t, i) => ({\n        u_matrix: new e.UniformMatrix4f(t, i.u_matrix),\n        u_world: new e.Uniform2f(t, i.u_world)\n      }),\n      fillOutlinePattern: (t, i) => ({\n        u_matrix: new e.UniformMatrix4f(t, i.u_matrix),\n        u_world: new e.Uniform2f(t, i.u_world),\n        u_image: new e.Uniform1i(t, i.u_image),\n        u_texsize: new e.Uniform2f(t, i.u_texsize),\n        u_pixel_coord_upper: new e.Uniform2f(t, i.u_pixel_coord_upper),\n        u_pixel_coord_lower: new e.Uniform2f(t, i.u_pixel_coord_lower),\n        u_scale: new e.Uniform3f(t, i.u_scale),\n        u_fade: new e.Uniform1f(t, i.u_fade)\n      }),\n      circle: (t, i) => ({\n        u_camera_to_center_distance: new e.Uniform1f(t, i.u_camera_to_center_distance),\n        u_extrude_scale: new e.UniformMatrix2f(t, i.u_extrude_scale),\n        u_device_pixel_ratio: new e.Uniform1f(t, i.u_device_pixel_ratio),\n        u_matrix: new e.UniformMatrix4f(t, i.u_matrix),\n        u_inv_rot_matrix: new e.UniformMatrix4f(t, i.u_inv_rot_matrix),\n        u_merc_center: new e.Uniform2f(t, i.u_merc_center),\n        u_tile_id: new e.Uniform3f(t, i.u_tile_id),\n        u_zoom_transition: new e.Uniform1f(t, i.u_zoom_transition),\n        u_up_dir: new e.Uniform3f(t, i.u_up_dir)\n      }),\n      collisionBox: (t, i) => ({\n        u_matrix: new e.UniformMatrix4f(t, i.u_matrix),\n        u_camera_to_center_distance: new e.Uniform1f(t, i.u_camera_to_center_distance),\n        u_extrude_scale: new e.Uniform2f(t, i.u_extrude_scale)\n      }),\n      collisionCircle: (t, i) => ({\n        u_matrix: new e.UniformMatrix4f(t, i.u_matrix),\n        u_inv_matrix: new e.UniformMatrix4f(t, i.u_inv_matrix),\n        u_camera_to_center_distance: new e.Uniform1f(t, i.u_camera_to_center_distance),\n        u_viewport_size: new e.Uniform2f(t, i.u_viewport_size)\n      }),\n      debug: (t, i) => ({\n        u_color: new e.UniformColor(t, i.u_color),\n        u_matrix: new e.UniformMatrix4f(t, i.u_matrix),\n        u_overlay: new e.Uniform1i(t, i.u_overlay),\n        u_overlay_scale: new e.Uniform1f(t, i.u_overlay_scale)\n      }),\n      clippingMask: (t, i) => ({\n        u_matrix: new e.UniformMatrix4f(t, i.u_matrix)\n      }),\n      heatmap: (t, i) => ({\n        u_extrude_scale: new e.Uniform1f(t, i.u_extrude_scale),\n        u_intensity: new e.Uniform1f(t, i.u_intensity),\n        u_matrix: new e.UniformMatrix4f(t, i.u_matrix),\n        u_inv_rot_matrix: new e.UniformMatrix4f(t, i.u_inv_rot_matrix),\n        u_merc_center: new e.Uniform2f(t, i.u_merc_center),\n        u_tile_id: new e.Uniform3f(t, i.u_tile_id),\n        u_zoom_transition: new e.Uniform1f(t, i.u_zoom_transition),\n        u_up_dir: new e.Uniform3f(t, i.u_up_dir)\n      }),\n      heatmapTexture: (t, i) => ({\n        u_image: new e.Uniform1i(t, i.u_image),\n        u_color_ramp: new e.Uniform1i(t, i.u_color_ramp),\n        u_opacity: new e.Uniform1f(t, i.u_opacity)\n      }),\n      hillshade: (t, i) => ({\n        u_matrix: new e.UniformMatrix4f(t, i.u_matrix),\n        u_image: new e.Uniform1i(t, i.u_image),\n        u_latrange: new e.Uniform2f(t, i.u_latrange),\n        u_light: new e.Uniform2f(t, i.u_light),\n        u_shadow: new e.UniformColor(t, i.u_shadow),\n        u_highlight: new e.UniformColor(t, i.u_highlight),\n        u_accent: new e.UniformColor(t, i.u_accent)\n      }),\n      hillshadePrepare: (t, i) => ({\n        u_matrix: new e.UniformMatrix4f(t, i.u_matrix),\n        u_image: new e.Uniform1i(t, i.u_image),\n        u_dimension: new e.Uniform2f(t, i.u_dimension),\n        u_zoom: new e.Uniform1f(t, i.u_zoom),\n        u_unpack: new e.Uniform4f(t, i.u_unpack)\n      }),\n      line: (t, i) => ({\n        u_matrix: new e.UniformMatrix4f(t, i.u_matrix),\n        u_pixels_to_tile_units: new e.UniformMatrix2f(t, i.u_pixels_to_tile_units),\n        u_device_pixel_ratio: new e.Uniform1f(t, i.u_device_pixel_ratio),\n        u_units_to_pixels: new e.Uniform2f(t, i.u_units_to_pixels),\n        u_dash_image: new e.Uniform1i(t, i.u_dash_image),\n        u_gradient_image: new e.Uniform1i(t, i.u_gradient_image),\n        u_image_height: new e.Uniform1f(t, i.u_image_height),\n        u_texsize: new e.Uniform2f(t, i.u_texsize),\n        u_scale: new e.Uniform3f(t, i.u_scale),\n        u_mix: new e.Uniform1f(t, i.u_mix),\n        u_alpha_discard_threshold: new e.Uniform1f(t, i.u_alpha_discard_threshold)\n      }),\n      linePattern: (t, i) => ({\n        u_matrix: new e.UniformMatrix4f(t, i.u_matrix),\n        u_texsize: new e.Uniform2f(t, i.u_texsize),\n        u_pixels_to_tile_units: new e.UniformMatrix2f(t, i.u_pixels_to_tile_units),\n        u_device_pixel_ratio: new e.Uniform1f(t, i.u_device_pixel_ratio),\n        u_image: new e.Uniform1i(t, i.u_image),\n        u_units_to_pixels: new e.Uniform2f(t, i.u_units_to_pixels),\n        u_scale: new e.Uniform3f(t, i.u_scale),\n        u_fade: new e.Uniform1f(t, i.u_fade),\n        u_alpha_discard_threshold: new e.Uniform1f(t, i.u_alpha_discard_threshold)\n      }),\n      raster: (t, i) => ({\n        u_matrix: new e.UniformMatrix4f(t, i.u_matrix),\n        u_tl_parent: new e.Uniform2f(t, i.u_tl_parent),\n        u_scale_parent: new e.Uniform1f(t, i.u_scale_parent),\n        u_fade_t: new e.Uniform1f(t, i.u_fade_t),\n        u_opacity: new e.Uniform1f(t, i.u_opacity),\n        u_image0: new e.Uniform1i(t, i.u_image0),\n        u_image1: new e.Uniform1i(t, i.u_image1),\n        u_brightness_low: new e.Uniform1f(t, i.u_brightness_low),\n        u_brightness_high: new e.Uniform1f(t, i.u_brightness_high),\n        u_saturation_factor: new e.Uniform1f(t, i.u_saturation_factor),\n        u_contrast_factor: new e.Uniform1f(t, i.u_contrast_factor),\n        u_spin_weights: new e.Uniform3f(t, i.u_spin_weights),\n        u_perspective_transform: new e.Uniform2f(t, i.u_perspective_transform)\n      }),\n      symbolIcon: (t, i) => ({\n        u_is_size_zoom_constant: new e.Uniform1i(t, i.u_is_size_zoom_constant),\n        u_is_size_feature_constant: new e.Uniform1i(t, i.u_is_size_feature_constant),\n        u_size_t: new e.Uniform1f(t, i.u_size_t),\n        u_size: new e.Uniform1f(t, i.u_size),\n        u_camera_to_center_distance: new e.Uniform1f(t, i.u_camera_to_center_distance),\n        u_rotate_symbol: new e.Uniform1i(t, i.u_rotate_symbol),\n        u_aspect_ratio: new e.Uniform1f(t, i.u_aspect_ratio),\n        u_fade_change: new e.Uniform1f(t, i.u_fade_change),\n        u_matrix: new e.UniformMatrix4f(t, i.u_matrix),\n        u_label_plane_matrix: new e.UniformMatrix4f(t, i.u_label_plane_matrix),\n        u_coord_matrix: new e.UniformMatrix4f(t, i.u_coord_matrix),\n        u_is_text: new e.Uniform1i(t, i.u_is_text),\n        u_pitch_with_map: new e.Uniform1i(t, i.u_pitch_with_map),\n        u_texsize: new e.Uniform2f(t, i.u_texsize),\n        u_tile_id: new e.Uniform3f(t, i.u_tile_id),\n        u_zoom_transition: new e.Uniform1f(t, i.u_zoom_transition),\n        u_inv_rot_matrix: new e.UniformMatrix4f(t, i.u_inv_rot_matrix),\n        u_merc_center: new e.Uniform2f(t, i.u_merc_center),\n        u_camera_forward: new e.Uniform3f(t, i.u_camera_forward),\n        u_tile_matrix: new e.UniformMatrix4f(t, i.u_tile_matrix),\n        u_ecef_origin: new e.Uniform3f(t, i.u_ecef_origin),\n        u_texture: new e.Uniform1i(t, i.u_texture)\n      }),\n      symbolSDF: (t, i) => ({\n        u_is_size_zoom_constant: new e.Uniform1i(t, i.u_is_size_zoom_constant),\n        u_is_size_feature_constant: new e.Uniform1i(t, i.u_is_size_feature_constant),\n        u_size_t: new e.Uniform1f(t, i.u_size_t),\n        u_size: new e.Uniform1f(t, i.u_size),\n        u_camera_to_center_distance: new e.Uniform1f(t, i.u_camera_to_center_distance),\n        u_rotate_symbol: new e.Uniform1i(t, i.u_rotate_symbol),\n        u_aspect_ratio: new e.Uniform1f(t, i.u_aspect_ratio),\n        u_fade_change: new e.Uniform1f(t, i.u_fade_change),\n        u_matrix: new e.UniformMatrix4f(t, i.u_matrix),\n        u_label_plane_matrix: new e.UniformMatrix4f(t, i.u_label_plane_matrix),\n        u_coord_matrix: new e.UniformMatrix4f(t, i.u_coord_matrix),\n        u_is_text: new e.Uniform1i(t, i.u_is_text),\n        u_pitch_with_map: new e.Uniform1i(t, i.u_pitch_with_map),\n        u_texsize: new e.Uniform2f(t, i.u_texsize),\n        u_texture: new e.Uniform1i(t, i.u_texture),\n        u_gamma_scale: new e.Uniform1f(t, i.u_gamma_scale),\n        u_device_pixel_ratio: new e.Uniform1f(t, i.u_device_pixel_ratio),\n        u_tile_id: new e.Uniform3f(t, i.u_tile_id),\n        u_zoom_transition: new e.Uniform1f(t, i.u_zoom_transition),\n        u_inv_rot_matrix: new e.UniformMatrix4f(t, i.u_inv_rot_matrix),\n        u_merc_center: new e.Uniform2f(t, i.u_merc_center),\n        u_camera_forward: new e.Uniform3f(t, i.u_camera_forward),\n        u_tile_matrix: new e.UniformMatrix4f(t, i.u_tile_matrix),\n        u_ecef_origin: new e.Uniform3f(t, i.u_ecef_origin),\n        u_is_halo: new e.Uniform1i(t, i.u_is_halo)\n      }),\n      symbolTextAndIcon: (t, i) => ({\n        u_is_size_zoom_constant: new e.Uniform1i(t, i.u_is_size_zoom_constant),\n        u_is_size_feature_constant: new e.Uniform1i(t, i.u_is_size_feature_constant),\n        u_size_t: new e.Uniform1f(t, i.u_size_t),\n        u_size: new e.Uniform1f(t, i.u_size),\n        u_camera_to_center_distance: new e.Uniform1f(t, i.u_camera_to_center_distance),\n        u_rotate_symbol: new e.Uniform1i(t, i.u_rotate_symbol),\n        u_aspect_ratio: new e.Uniform1f(t, i.u_aspect_ratio),\n        u_fade_change: new e.Uniform1f(t, i.u_fade_change),\n        u_matrix: new e.UniformMatrix4f(t, i.u_matrix),\n        u_label_plane_matrix: new e.UniformMatrix4f(t, i.u_label_plane_matrix),\n        u_coord_matrix: new e.UniformMatrix4f(t, i.u_coord_matrix),\n        u_is_text: new e.Uniform1i(t, i.u_is_text),\n        u_pitch_with_map: new e.Uniform1i(t, i.u_pitch_with_map),\n        u_texsize: new e.Uniform2f(t, i.u_texsize),\n        u_texsize_icon: new e.Uniform2f(t, i.u_texsize_icon),\n        u_texture: new e.Uniform1i(t, i.u_texture),\n        u_texture_icon: new e.Uniform1i(t, i.u_texture_icon),\n        u_gamma_scale: new e.Uniform1f(t, i.u_gamma_scale),\n        u_device_pixel_ratio: new e.Uniform1f(t, i.u_device_pixel_ratio),\n        u_is_halo: new e.Uniform1i(t, i.u_is_halo)\n      }),\n      background: (t, i) => ({\n        u_matrix: new e.UniformMatrix4f(t, i.u_matrix),\n        u_opacity: new e.Uniform1f(t, i.u_opacity),\n        u_color: new e.UniformColor(t, i.u_color)\n      }),\n      backgroundPattern: (t, i) => ({\n        u_matrix: new e.UniformMatrix4f(t, i.u_matrix),\n        u_opacity: new e.Uniform1f(t, i.u_opacity),\n        u_image: new e.Uniform1i(t, i.u_image),\n        u_pattern_tl_a: new e.Uniform2f(t, i.u_pattern_tl_a),\n        u_pattern_br_a: new e.Uniform2f(t, i.u_pattern_br_a),\n        u_pattern_tl_b: new e.Uniform2f(t, i.u_pattern_tl_b),\n        u_pattern_br_b: new e.Uniform2f(t, i.u_pattern_br_b),\n        u_texsize: new e.Uniform2f(t, i.u_texsize),\n        u_mix: new e.Uniform1f(t, i.u_mix),\n        u_pattern_size_a: new e.Uniform2f(t, i.u_pattern_size_a),\n        u_pattern_size_b: new e.Uniform2f(t, i.u_pattern_size_b),\n        u_scale_a: new e.Uniform1f(t, i.u_scale_a),\n        u_scale_b: new e.Uniform1f(t, i.u_scale_b),\n        u_pixel_coord_upper: new e.Uniform2f(t, i.u_pixel_coord_upper),\n        u_pixel_coord_lower: new e.Uniform2f(t, i.u_pixel_coord_lower),\n        u_tile_units_to_pixels: new e.Uniform1f(t, i.u_tile_units_to_pixels)\n      }),\n      terrainRaster: li,\n      terrainDepth: li,\n      skybox: (t, i) => ({\n        u_matrix: new e.UniformMatrix4f(t, i.u_matrix),\n        u_sun_direction: new e.Uniform3f(t, i.u_sun_direction),\n        u_cubemap: new e.Uniform1i(t, i.u_cubemap),\n        u_opacity: new e.Uniform1f(t, i.u_opacity),\n        u_temporal_offset: new e.Uniform1f(t, i.u_temporal_offset)\n      }),\n      skyboxGradient: (t, i) => ({\n        u_matrix: new e.UniformMatrix4f(t, i.u_matrix),\n        u_color_ramp: new e.Uniform1i(t, i.u_color_ramp),\n        u_center_direction: new e.Uniform3f(t, i.u_center_direction),\n        u_radius: new e.Uniform1f(t, i.u_radius),\n        u_opacity: new e.Uniform1f(t, i.u_opacity),\n        u_temporal_offset: new e.Uniform1f(t, i.u_temporal_offset)\n      }),\n      skyboxCapture: (t, i) => ({\n        u_matrix_3f: new e.UniformMatrix3f(t, i.u_matrix_3f),\n        u_sun_direction: new e.Uniform3f(t, i.u_sun_direction),\n        u_sun_intensity: new e.Uniform1f(t, i.u_sun_intensity),\n        u_color_tint_r: new e.Uniform4f(t, i.u_color_tint_r),\n        u_color_tint_m: new e.Uniform4f(t, i.u_color_tint_m),\n        u_luminance: new e.Uniform1f(t, i.u_luminance)\n      }),\n      globeRaster: (t, i) => ({\n        u_proj_matrix: new e.UniformMatrix4f(t, i.u_proj_matrix),\n        u_globe_matrix: new e.UniformMatrix4f(t, i.u_globe_matrix),\n        u_merc_matrix: new e.UniformMatrix4f(t, i.u_merc_matrix),\n        u_zoom_transition: new e.Uniform1f(t, i.u_zoom_transition),\n        u_merc_center: new e.Uniform2f(t, i.u_merc_center),\n        u_image0: new e.Uniform1i(t, i.u_image0),\n        u_grid_matrix: new e.UniformMatrix3f(t, i.u_grid_matrix)\n      }),\n      globeAtmosphere: (t, i) => ({\n        u_frustum_tl: new e.Uniform3f(t, i.u_frustum_tl),\n        u_frustum_tr: new e.Uniform3f(t, i.u_frustum_tr),\n        u_frustum_br: new e.Uniform3f(t, i.u_frustum_br),\n        u_frustum_bl: new e.Uniform3f(t, i.u_frustum_bl),\n        u_globe_pos: new e.Uniform3f(t, i.u_globe_pos),\n        u_globe_radius: new e.Uniform1f(t, i.u_globe_radius),\n        u_opacity: new e.Uniform1f(t, i.u_opacity),\n        u_fadeout_range: new e.Uniform1f(t, i.u_fadeout_range),\n        u_start_color: new e.Uniform3f(t, i.u_start_color),\n        u_end_color: new e.Uniform3f(t, i.u_end_color)\n      })\n    };\n\n    let Qi;\n\n    function eo(t, i, o, r, n, a, s) {\n      const l = t.context,\n            c = l.gl,\n            h = t.useProgram(\"collisionBox\"),\n            _ = [];\n      let u = 0,\n          d = 0;\n\n      for (let p = 0; p < r.length; p++) {\n        const m = r[p],\n              f = i.getTile(m),\n              g = f.getBucket(o);\n        if (!g) continue;\n        let v = m.projMatrix;\n        0 === n[0] && 0 === n[1] || (v = t.translatePosMatrix(m.projMatrix, f, n, a));\n        const x = s ? g.textCollisionBox : g.iconCollisionBox,\n              y = g.collisionCircleArray;\n\n        if (y.length > 0) {\n          const i = e.create(),\n                o = v;\n          e.mul(i, g.placementInvProjMatrix, t.transform.glCoordMatrix), e.mul(i, i, g.placementViewportMatrix), _.push({\n            circleArray: y,\n            circleOffset: d,\n            transform: o,\n            invTransform: i\n          }), u += y.length / 4, d = u;\n        }\n\n        x && (t.terrain && t.terrain.setupElevationDraw(f, h), h.draw(l, c.LINES, e.DepthMode.disabled, e.StencilMode.disabled, t.colorModeForRenderPass(), e.CullFaceMode.disabled, ki(v, t.transform, f), o.id, x.layoutVertexBuffer, x.indexBuffer, x.segments, null, t.transform.zoom, null, x.collisionVertexBuffer, x.collisionVertexBufferExt));\n      }\n\n      if (!s || !_.length) return;\n      const p = t.useProgram(\"collisionCircle\"),\n            m = new e.StructArrayLayout2f1f2i16();\n      m.resize(4 * u), m._trim();\n      let f = 0;\n\n      for (const e of _) for (let t = 0; t < e.circleArray.length / 4; t++) {\n        const i = 4 * t,\n              o = e.circleArray[i + 0],\n              r = e.circleArray[i + 1],\n              n = e.circleArray[i + 2],\n              a = e.circleArray[i + 3];\n        m.emplace(f++, o, r, n, a, 0), m.emplace(f++, o, r, n, a, 1), m.emplace(f++, o, r, n, a, 2), m.emplace(f++, o, r, n, a, 3);\n      }\n\n      (!Qi || Qi.length < 2 * u) && (Qi = function (t) {\n        const i = 2 * t,\n              o = new e.StructArrayLayout3ui6();\n        o.resize(i), o._trim();\n\n        for (let e = 0; e < i; e++) {\n          const t = 6 * e;\n          o.uint16[t + 0] = 4 * e + 0, o.uint16[t + 1] = 4 * e + 1, o.uint16[t + 2] = 4 * e + 2, o.uint16[t + 3] = 4 * e + 2, o.uint16[t + 4] = 4 * e + 3, o.uint16[t + 5] = 4 * e + 0;\n        }\n\n        return o;\n      }(u));\n      const g = l.createIndexBuffer(Qi, !0),\n            v = l.createVertexBuffer(m, e.collisionCircleLayout.members, !0);\n\n      for (const i of _) {\n        const r = {\n          u_matrix: i.transform,\n          u_inv_matrix: i.invTransform,\n          u_camera_to_center_distance: (x = t.transform).cameraToCenterDistance,\n          u_viewport_size: [x.width, x.height]\n        };\n        p.draw(l, c.TRIANGLES, e.DepthMode.disabled, e.StencilMode.disabled, t.colorModeForRenderPass(), e.CullFaceMode.disabled, r, o.id, v, g, e.SegmentVector.simpleSegment(0, 2 * i.circleOffset, i.circleArray.length, i.circleArray.length / 2), null, t.transform.zoom, null, null, null);\n      }\n\n      var x;\n      v.destroy(), g.destroy();\n    }\n\n    const to = e.create();\n\n    function io(t, i, o, r, n, a) {\n      const {\n        horizontalAlign: s,\n        verticalAlign: l\n      } = e.getAnchorAlignment(t),\n            c = -(s - .5) * i,\n            h = -(l - .5) * o,\n            _ = e.evaluateVariableOffset(t, r);\n\n      return new e.pointGeometry((c / n + _[0]) * a, (h / n + _[1]) * a);\n    }\n\n    function oo(t, i, o, r, n, a, s, l, c, h, _, u) {\n      const d = t.text.placedSymbolArray,\n            p = t.text.dynamicLayoutVertexArray,\n            m = t.icon.dynamicLayoutVertexArray,\n            f = {},\n            g = l.projMatrix,\n            v = a.elevation,\n            x = u.upVectorScale(l.canonical, a.center.lat, a.worldSize);\n      p.clear();\n\n      for (let m = 0; m < d.length; m++) {\n        const y = d.get(m),\n              b = t.allowVerticalPlacement && !y.placedOrientation,\n              w = y.hidden || !y.crossTileID || b ? null : r[y.crossTileID];\n\n        if (w) {\n          const r = new e.pointGeometry(y.tileAnchorX, y.tileAnchorY),\n                d = u.upVector(l.canonical, r.x, r.y),\n                m = v ? v.getAtTileOffset(l, r.x, r.y) : 0,\n                b = it([y.projectedAnchorX + m * d[0] * x.metersToTile, y.projectedAnchorY + m * d[1] * x.metersToTile, y.projectedAnchorZ + m * d[2] * x.metersToTile], o ? g : s),\n                T = ot(a.cameraToCenterDistance, b.signedDistanceFromCamera);\n          let E = n.evaluateSizeForFeature(t.textSizeData, h, y) * T / e.ONE_EM;\n          o && (E *= t.tilePixelRatio / c);\n          const {\n            width: C,\n            height: I,\n            anchor: M,\n            textOffset: S,\n            textScale: z\n          } = w,\n                D = io(M, C, I, S, z, E),\n                P = o ? tt(r.add(D), s, m * x.metersToLabelSpace).point : b.point.add(i ? D.rotate(-a.angle) : D),\n                A = t.allowVerticalPlacement && y.placedOrientation === e.WritingMode.vertical ? Math.PI / 2 : 0;\n\n          for (let t = 0; t < y.numGlyphs; t++) e.addDynamicAttributes(p, P, A);\n\n          _ && y.associatedIconIndex >= 0 && (f[y.associatedIconIndex] = {\n            shiftedAnchor: P,\n            angle: A\n          });\n        } else dt(y.numGlyphs, p);\n      }\n\n      if (_) {\n        m.clear();\n        const i = t.icon.placedSymbolArray;\n\n        for (let t = 0; t < i.length; t++) {\n          const o = i.get(t);\n          if (o.hidden) dt(o.numGlyphs, m);else {\n            const i = f[t];\n            if (i) for (let t = 0; t < o.numGlyphs; t++) e.addDynamicAttributes(m, i.shiftedAnchor, i.angle);else dt(o.numGlyphs, m);\n          }\n        }\n\n        t.icon.dynamicLayoutVertexBuffer.updateData(m);\n      }\n\n      t.text.dynamicLayoutVertexBuffer.updateData(p);\n    }\n\n    function ro(e, t, i) {\n      return i.iconsInText && t ? \"symbolTextAndIcon\" : e ? \"symbolSDF\" : \"symbolIcon\";\n    }\n\n    function no(t, i, o, r, n, a, s, l, c, h, _, u) {\n      const d = t.context,\n            p = d.gl,\n            m = t.transform,\n            f = \"map\" === l,\n            g = \"map\" === c,\n            v = f && \"point\" !== o.layout.get(\"symbol-placement\"),\n            x = f && !g && !v,\n            y = void 0 !== o.layout.get(\"symbol-sort-key\").constantOr(1);\n      let b = !1;\n      const w = t.depthModeForSublayer(0, e.DepthMode.ReadOnly),\n            T = [e.mercatorXfromLng(m.center.lng), e.mercatorYfromLat(m.center.lat)],\n            E = o.layout.get(\"text-variable-anchor\"),\n            C = \"globe\" === m.projection.name,\n            I = C ? e.globeToMercatorTransition(m.zoom) : 0,\n            M = [],\n            S = [];\n      t.terrain && g && S.push(\"PITCH_WITH_MAP_TERRAIN\"), C && S.push(\"PROJECTION_GLOBE_VIEW\");\n\n      for (const l of r) {\n        const r = i.getTile(l),\n              c = r.getBucket(o);\n        if (!c || c.projection !== m.projection.name) continue;\n\n        const _ = n ? c.text : c.icon;\n\n        if (!_ || c.fullyClipped || !_.segments.get().length) continue;\n\n        const u = _.programConfigurations.get(o.id),\n              d = n || c.sdfIcons,\n              w = n ? c.textSizeData : c.iconSizeData,\n              C = g || 0 !== m.pitch,\n              z = e.evaluateSizeForZoom(w, m.zoom);\n\n        let D,\n            P,\n            A,\n            L,\n            R = [0, 0],\n            k = null;\n\n        if (n) {\n          if (P = r.glyphAtlasTexture, A = p.LINEAR, D = r.glyphAtlasTexture.size, c.iconsInText) {\n            R = r.imageAtlasTexture.size, k = r.imageAtlasTexture;\n            const e = \"composite\" === w.kind || \"camera\" === w.kind;\n            L = C || t.options.rotating || t.options.zooming || e ? p.LINEAR : p.NEAREST;\n          }\n        } else {\n          const e = 1 !== o.layout.get(\"icon-size\").constantOr(0) || c.iconsNeedLinear;\n          P = r.imageAtlasTexture, A = d || t.options.rotating || t.options.zooming || e || C ? p.LINEAR : p.NEAREST, D = r.imageAtlasTexture.size;\n        }\n\n        const O = t.transform.calculatePixelsToTileUnitsMatrix(r),\n              B = Qe(l.projMatrix, r.tileID.canonical, g, f, t.transform, O),\n              F = t.terrain && g && v ? e.invert(e.create(), B) : to,\n              U = et(l.projMatrix, r.tileID.canonical, g, f, t.transform, O),\n              N = E && c.hasTextData(),\n              G = \"none\" !== o.layout.get(\"icon-text-fit\") && N && c.hasIconData();\n\n        if (v) {\n          const e = m.elevation,\n                i = e ? e.getAtTileOffsetFunc(l, m.center.lat, m.worldSize, m.projection) : e => [0, 0, 0];\n          nt(c, l.projMatrix, t, n, B, U, g, h, i, l);\n        }\n\n        const j = v || n && E || G,\n              Z = t.translatePosMatrix(l.projMatrix, r, a, s),\n              V = j ? to : B,\n              W = t.translatePosMatrix(U, r, a, s, !0),\n              q = m.projection.createInversionMatrix(m, l.canonical),\n              X = j ? S.concat([\"PROJECTED_POS_ON_VIEWPORT\"]) : S,\n              $ = d && 0 !== o.paint.get(n ? \"text-halo-width\" : \"icon-halo-width\").constantOr(1);\n        let H;\n        H = d ? c.iconsInText ? Hi(w.kind, z, x, g, t, Z, V, W, D, R, l, I, T, q) : $i(w.kind, z, x, g, t, Z, V, W, n, D, !0, l, I, T, q) : Xi(w.kind, z, x, g, t, Z, V, W, n, D, l, I, T, q);\n        const K = {\n          program: t.useProgram(ro(d, n, c), u, X),\n          buffers: _,\n          uniformValues: H,\n          atlasTexture: P,\n          atlasTextureIcon: k,\n          atlasInterpolation: A,\n          atlasInterpolationIcon: L,\n          isSDF: d,\n          hasHalo: $,\n          tile: r,\n          labelPlaneMatrixInv: F\n        };\n\n        if (y && c.canOverlap) {\n          b = !0;\n\n          const t = _.segments.get();\n\n          for (const i of t) M.push({\n            segments: new e.SegmentVector([i]),\n            sortKey: i.sortKey,\n            state: K\n          });\n        } else M.push({\n          segments: _.segments,\n          sortKey: 0,\n          state: K\n        });\n      }\n\n      b && M.sort((e, t) => e.sortKey - t.sortKey);\n\n      for (const e of M) {\n        const i = e.state;\n\n        if (t.terrain && t.terrain.setupElevationDraw(i.tile, i.program, {\n          useDepthForOcclusion: !C,\n          labelPlaneMatrixInv: i.labelPlaneMatrixInv\n        }), d.activeTexture.set(p.TEXTURE0), i.atlasTexture.bind(i.atlasInterpolation, p.CLAMP_TO_EDGE), i.atlasTextureIcon && (d.activeTexture.set(p.TEXTURE1), i.atlasTextureIcon && i.atlasTextureIcon.bind(i.atlasInterpolationIcon, p.CLAMP_TO_EDGE)), i.isSDF) {\n          const r = i.uniformValues;\n          i.hasHalo && (r.u_is_halo = 1, ao(i.buffers, e.segments, o, t, i.program, w, _, u, r)), r.u_is_halo = 0;\n        }\n\n        ao(i.buffers, e.segments, o, t, i.program, w, _, u, i.uniformValues);\n      }\n    }\n\n    function ao(t, i, o, r, n, a, s, l, c) {\n      const h = r.context;\n      n.draw(h, h.gl.TRIANGLES, a, s, l, e.CullFaceMode.disabled, c, o.id, t.layoutVertexBuffer, t.indexBuffer, i, o.paint, r.transform.zoom, t.programConfigurations.get(o.id), t.dynamicLayoutVertexBuffer, t.opacityVertexBuffer);\n    }\n\n    function so(t, i, o, r, n, a, s) {\n      const l = t.context.gl,\n            c = o.paint.get(\"fill-pattern\"),\n            h = c && c.constantOr(1),\n            _ = o.getCrossfadeParameters();\n\n      let u, d, p, m, f;\n      s ? (d = h && !o.getPaintProperty(\"fill-outline-color\") ? \"fillOutlinePattern\" : \"fillOutline\", u = l.LINES) : (d = h ? \"fillPattern\" : \"fill\", u = l.TRIANGLES);\n\n      for (const g of r) {\n        const r = i.getTile(g);\n        if (h && !r.patternsLoaded()) continue;\n        const v = r.getBucket(o);\n        if (!v) continue;\n        t.prepareDrawTile();\n        const x = v.programConfigurations.get(o.id),\n              y = t.useProgram(d, x);\n        h && (t.context.activeTexture.set(l.TEXTURE0), r.imageAtlasTexture.bind(l.LINEAR, l.CLAMP_TO_EDGE), x.updatePaintBuffers(_));\n        const b = c.constantOr(null);\n\n        if (b && r.imageAtlas) {\n          const e = r.imageAtlas,\n                t = e.patternPositions[b.to.toString()],\n                i = e.patternPositions[b.from.toString()];\n          t && i && x.setConstantPatternPositions(t, i);\n        }\n\n        const w = t.translatePosMatrix(g.projMatrix, r, o.paint.get(\"fill-translate\"), o.paint.get(\"fill-translate-anchor\"));\n\n        if (s) {\n          m = v.indexBuffer2, f = v.segments2;\n          const e = t.terrain && t.terrain.renderingToTexture ? t.terrain.drapeBufferSize : [l.drawingBufferWidth, l.drawingBufferHeight];\n          p = \"fillOutlinePattern\" === d && h ? Pi(w, t, _, r, e) : Di(w, e);\n        } else m = v.indexBuffer, f = v.segments, p = h ? zi(w, t, _, r) : Si(w);\n\n        t.prepareDrawProgram(t.context, y, g.toUnwrapped()), y.draw(t.context, u, n, t.stencilModeForClipping(g), a, e.CullFaceMode.disabled, p, o.id, v.layoutVertexBuffer, m, f, o.paint, t.transform.zoom, x);\n      }\n    }\n\n    function lo(t, i, o, r, n, a, s) {\n      const l = t.context,\n            c = l.gl,\n            h = t.transform,\n            _ = o.paint.get(\"fill-extrusion-pattern\"),\n            u = _.constantOr(1),\n            d = o.getCrossfadeParameters(),\n            p = o.paint.get(\"fill-extrusion-opacity\"),\n            m = function (t) {\n        if (\"globe\" !== t.projection.name) return 0;\n        const i = Math.PI / 32,\n              o = Math.tan(i),\n              r = e.earthRadius;\n        return r * Math.sqrt(1 + 2 * o * o) - r;\n      }(h),\n            f = \"globe\" === h.projection.name,\n            g = f ? e.globeToMercatorTransition(h.zoom) : 0,\n            v = [e.mercatorXfromLng(h.center.lng), e.mercatorYfromLat(h.center.lat)],\n            x = [];\n\n      f && x.push(\"PROJECTION_GLOBE_VIEW\");\n\n      for (const y of r) {\n        const r = i.getTile(y),\n              b = r.getBucket(o);\n        if (!b || b.projection !== h.projection.name) continue;\n        const w = b.programConfigurations.get(o.id),\n              T = t.useProgram(u ? \"fillExtrusionPattern\" : \"fillExtrusion\", w, x);\n\n        if (t.terrain) {\n          const e = t.terrain;\n          if (t.style.terrainSetForDrapingOnly()) e.setupElevationDraw(r, T, {\n            useMeterToDem: !0\n          });else {\n            if (!b.enableTerrain) continue;\n\n            if (e.setupElevationDraw(r, T, {\n              useMeterToDem: !0\n            }), co(l, i, y, b, o, e), !b.centroidVertexBuffer) {\n              const e = T.attributes.a_centroid_pos;\n              void 0 !== e && c.vertexAttrib2f(e, 0, 0);\n            }\n          }\n        }\n\n        u && (t.context.activeTexture.set(c.TEXTURE0), r.imageAtlasTexture.bind(c.LINEAR, c.CLAMP_TO_EDGE), w.updatePaintBuffers(d));\n\n        const E = _.constantOr(null);\n\n        if (E && r.imageAtlas) {\n          const e = r.imageAtlas,\n                t = e.patternPositions[E.to.toString()],\n                i = e.patternPositions[E.from.toString()];\n          t && i && w.setConstantPatternPositions(t, i);\n        }\n\n        const C = t.translatePosMatrix(y.projMatrix, r, o.paint.get(\"fill-extrusion-translate\"), o.paint.get(\"fill-extrusion-translate-anchor\")),\n              I = h.projection.createInversionMatrix(h, y.canonical),\n              M = o.paint.get(\"fill-extrusion-vertical-gradient\"),\n              S = u ? Mi(C, t, M, p, y, d, r, m, g, v, I) : Ii(C, t, M, p, y, m, g, v, I);\n        t.prepareDrawProgram(l, T, y.toUnwrapped()), T.draw(l, l.gl.TRIANGLES, n, a, s, e.CullFaceMode.backCCW, S, o.id, b.layoutVertexBuffer, b.indexBuffer, b.segments, o.paint, t.transform.zoom, w, t.terrain ? b.centroidVertexBuffer : null, f ? b.layoutVertexExtBuffer : null);\n      }\n    }\n\n    function co(t, i, o, r, n, a) {\n      const s = [t => {\n        let i = t.canonical.x - 1,\n            o = t.wrap;\n        return i < 0 && (i = (1 << t.canonical.z) - 1, o--), new e.OverscaledTileID(t.overscaledZ, o, t.canonical.z, i, t.canonical.y);\n      }, t => {\n        let i = t.canonical.x + 1,\n            o = t.wrap;\n        return i === 1 << t.canonical.z && (i = 0, o++), new e.OverscaledTileID(t.overscaledZ, o, t.canonical.z, i, t.canonical.y);\n      }, t => new e.OverscaledTileID(t.overscaledZ, t.wrap, t.canonical.z, t.canonical.x, (0 === t.canonical.y ? 1 << t.canonical.z : t.canonical.y) - 1), t => new e.OverscaledTileID(t.overscaledZ, t.wrap, t.canonical.z, t.canonical.x, t.canonical.y === (1 << t.canonical.z) - 1 ? 0 : t.canonical.y + 1)],\n            l = e => {\n        const t = i.getSource().minzoom,\n              o = e => {\n          const t = i.getTileByID(e);\n          if (t && t.hasData()) return t.getBucket(n);\n        },\n              r = [0, -1, 1];\n\n        for (const i of r) {\n          if (e.overscaledZ + i < t) continue;\n          const r = o(e.calculateScaledKey(e.overscaledZ + i));\n          if (r) return r;\n        }\n      },\n            c = [0, 0, 0],\n            h = (t, i) => (c[0] = Math.min(t.min.y, i.min.y), c[1] = Math.max(t.max.y, i.max.y), c[2] = e.EXTENT - i.min.x > t.max.x ? i.min.x - e.EXTENT : t.max.x, c),\n            _ = (t, i) => (c[0] = Math.min(t.min.x, i.min.x), c[1] = Math.max(t.max.x, i.max.x), c[2] = e.EXTENT - i.min.y > t.max.y ? i.min.y - e.EXTENT : t.max.y, c),\n            u = [(e, t) => h(e, t), (e, t) => h(t, e), (e, t) => _(e, t), (e, t) => _(t, e)],\n            d = new e.pointGeometry(0, 0);\n\n      let p, m, f;\n\n      const g = (t, i, r, n, s) => {\n        const l = [[n ? r : t, n ? t : r, 0], [n ? r : i, n ? i : r, 0]],\n              c = s < 0 ? e.EXTENT + s : s,\n              h = [n ? c : (t + i) / 2, n ? (t + i) / 2 : c, 0];\n        return 0 === r && s < 0 || 0 !== r && s > 0 ? a.getForTilePoints(f, [h], !0, m) : l.push(h), a.getForTilePoints(o, l, !0, p), Math.max(l[0][2], l[1][2], h[2]) / a.exaggeration();\n      };\n\n      for (let t = 0; t < 4; t++) {\n        const i = (t < 2 ? 1 : 5) - t,\n              n = r.borders[t];\n        if (0 === n.length) continue;\n        const c = f = s[t](o),\n              h = l(c);\n        if (!(h && h instanceof e.FillExtrusionBucket && h.enableTerrain)) continue;\n        if (r.borderDoneWithNeighborZ[t] === h.canonical.z && h.borderDoneWithNeighborZ[i] === r.canonical.z) continue;\n        if (m = a.findDEMTileFor(c), !m || !m.dem) continue;\n\n        if (!p) {\n          const e = a.findDEMTileFor(o);\n          if (!e || !e.dem) return;\n          p = e;\n        }\n\n        const _ = h.borders[i];\n        let v = 0;\n        const x = h.borderDoneWithNeighborZ[i] !== r.canonical.z;\n\n        if (r.canonical.z === h.canonical.z) {\n          for (let o = 0; o < n.length; o++) {\n            const a = r.featuresOnBorder[n[o]],\n                  s = a.borders[t];\n            let l;\n\n            for (; v < _.length && (l = h.featuresOnBorder[_[v]], !(l.borders[i][1] > s[0] + 3));) x && h.encodeCentroid(void 0, l, !1), v++;\n\n            if (l && v < _.length) {\n              const o = v;\n              let n = 0;\n\n              for (; !(l.borders[i][0] > s[1] - 3) && (n++, ++v !== _.length);) l = h.featuresOnBorder[_[v]];\n\n              if (l = h.featuresOnBorder[_[o]], a.intersectsCount() > 1 || l.intersectsCount() > 1 || 1 !== n) {\n                1 !== n && (v = o), r.encodeCentroid(void 0, a, !1), x && h.encodeCentroid(void 0, l, !1);\n                continue;\n              }\n\n              const c = u[t](a, l),\n                    p = t % 2 ? e.EXTENT - 1 : 0;\n              d.x = g(c[0], Math.min(e.EXTENT - 1, c[1]), p, t < 2, c[2]), d.y = 0, r.encodeCentroid(d, a, !1), x && h.encodeCentroid(d, l, !1);\n            } else r.encodeCentroid(void 0, a, !1);\n          }\n\n          r.borderDoneWithNeighborZ[t] = h.canonical.z, r.needsCentroidUpdate = !0, x && (h.borderDoneWithNeighborZ[i] = r.canonical.z, h.needsCentroidUpdate = !0);\n        } else {\n          for (const e of n) r.encodeCentroid(void 0, r.featuresOnBorder[e], !1);\n\n          if (x) {\n            for (const e of _) h.encodeCentroid(void 0, h.featuresOnBorder[e], !1);\n\n            h.borderDoneWithNeighborZ[i] = r.canonical.z, h.needsCentroidUpdate = !0;\n          }\n\n          r.borderDoneWithNeighborZ[t] = h.canonical.z, r.needsCentroidUpdate = !0;\n        }\n      }\n\n      (r.needsCentroidUpdate || !r.centroidVertexBuffer && 0 !== r.centroidVertexArray.length) && r.uploadCentroid(t);\n    }\n\n    const ho = new e.Color(1, 0, 0, 1),\n          _o = new e.Color(0, 1, 0, 1),\n          uo = new e.Color(0, 0, 1, 1),\n          po = new e.Color(1, 0, 1, 1),\n          mo = new e.Color(0, 1, 1, 1);\n\n    function fo(e, t, i, o) {\n      vo(e, 0, t + i / 2, e.transform.width, i, o);\n    }\n\n    function go(e, t, i, o) {\n      vo(e, t - i / 2, 0, i, e.transform.height, o);\n    }\n\n    function vo(t, i, o, r, n, a) {\n      const s = t.context,\n            l = s.gl;\n      l.enable(l.SCISSOR_TEST), l.scissor(i * e.exported.devicePixelRatio, o * e.exported.devicePixelRatio, r * e.exported.devicePixelRatio, n * e.exported.devicePixelRatio), s.clear({\n        color: a\n      }), l.disable(l.SCISSOR_TEST);\n    }\n\n    function xo(t, i, o) {\n      const r = t.context,\n            n = r.gl,\n            a = \"globe\" === t.transform.projection.name,\n            s = o.projMatrix,\n            l = t.useProgram(\"debug\", null, a ? [\"PROJECTION_GLOBE_VIEW\"] : null),\n            c = i.getTileByID(o.key);\n      t.terrain && t.terrain.setupElevationDraw(c, l);\n      const h = e.DepthMode.disabled,\n            _ = e.StencilMode.disabled,\n            u = t.colorModeForRenderPass(),\n            d = \"$debug\";\n      r.activeTexture.set(n.TEXTURE0), t.emptyTexture.bind(n.LINEAR, n.CLAMP_TO_EDGE), a ? c._makeGlobeTileDebugBuffers(t.context, t.transform.projection) : c._makeDebugTileBoundsBuffers(t.context, t.transform.projection);\n      const p = c._tileDebugBuffer || t.debugBuffer,\n            m = c._tileDebugIndexBuffer || t.debugIndexBuffer,\n            f = c._tileDebugSegments || t.debugSegments;\n      l.draw(r, n.LINE_STRIP, h, _, u, e.CullFaceMode.disabled, Oi(s, e.Color.red), d, p, m, f, null, null, null, c._globeTileDebugBorderBuffer);\n      const g = c.latestRawTileData,\n            v = Math.floor((g && g.byteLength || 0) / 1024),\n            x = i.getTile(o).tileSize,\n            y = 512 / Math.min(x, 512) * (o.overscaledZ / t.transform.zoom) * .5;\n      let b = o.canonical.toString();\n      o.overscaledZ !== o.canonical.z && (b += ` => ${o.overscaledZ}`), function (e, t) {\n        e.initDebugOverlayCanvas();\n        const i = e.debugOverlayCanvas,\n              o = e.context.gl,\n              r = e.debugOverlayCanvas.getContext(\"2d\");\n        r.clearRect(0, 0, i.width, i.height), r.shadowColor = \"white\", r.shadowBlur = 2, r.lineWidth = 1.5, r.strokeStyle = \"white\", r.textBaseline = \"top\", r.font = \"bold 36px Open Sans, sans-serif\", r.fillText(t, 5, 5), r.strokeText(t, 5, 5), e.debugOverlayTexture.update(i), e.debugOverlayTexture.bind(o.LINEAR, o.CLAMP_TO_EDGE);\n      }(t, `${b} ${v}kb`);\n      const w = c._tileDebugTextBuffer || t.debugBuffer,\n            T = c._tileDebugTextIndexBuffer || t.quadTriangleIndexBuffer,\n            E = c._tileDebugTextSegments || t.debugSegments;\n      l.draw(r, n.TRIANGLES, h, _, e.ColorMode.alphaBlended, e.CullFaceMode.disabled, Oi(s, e.Color.transparent, y), d, w, T, E, null, null, null, c._globeTileDebugTextBuffer);\n    }\n\n    const yo = e.createLayout([{\n      name: \"a_pos_3f\",\n      components: 3,\n      type: \"Float32\"\n    }]),\n          {\n      members: bo\n    } = yo;\n\n    function wo(e, t, i, o) {\n      e.emplaceBack(t, i, o);\n    }\n\n    class To {\n      constructor(t) {\n        this.vertexArray = new e.StructArrayLayout3f12(), this.indices = new e.StructArrayLayout3ui6(), wo(this.vertexArray, -1, -1, 1), wo(this.vertexArray, 1, -1, 1), wo(this.vertexArray, -1, 1, 1), wo(this.vertexArray, 1, 1, 1), wo(this.vertexArray, -1, -1, -1), wo(this.vertexArray, 1, -1, -1), wo(this.vertexArray, -1, 1, -1), wo(this.vertexArray, 1, 1, -1), this.indices.emplaceBack(5, 1, 3), this.indices.emplaceBack(3, 7, 5), this.indices.emplaceBack(6, 2, 0), this.indices.emplaceBack(0, 4, 6), this.indices.emplaceBack(2, 6, 7), this.indices.emplaceBack(7, 3, 2), this.indices.emplaceBack(5, 4, 0), this.indices.emplaceBack(0, 1, 5), this.indices.emplaceBack(0, 2, 3), this.indices.emplaceBack(3, 1, 0), this.indices.emplaceBack(7, 6, 4), this.indices.emplaceBack(4, 5, 7), this.vertexBuffer = t.createVertexBuffer(this.vertexArray, bo), this.indexBuffer = t.createIndexBuffer(this.indices), this.segment = e.SegmentVector.simpleSegment(0, 0, 36, 12);\n      }\n\n    }\n\n    function Eo(t, i, o, r, n, a) {\n      const s = t.gl,\n            l = i.paint.get(\"sky-atmosphere-color\"),\n            c = i.paint.get(\"sky-atmosphere-halo-color\"),\n            h = i.paint.get(\"sky-atmosphere-sun-intensity\"),\n            _ = ((e, t, i, o, r) => ({\n        u_matrix_3f: e,\n        u_sun_direction: t,\n        u_sun_intensity: i,\n        u_color_tint_r: [o.r, o.g, o.b, o.a],\n        u_color_tint_m: [r.r, r.g, r.b, r.a],\n        u_luminance: 5e-5\n      }))(e.fromMat4(e.create$1(), r), n, h, l, c);\n\n      s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + a, i.skyboxTexture, 0), o.draw(t, s.TRIANGLES, e.DepthMode.disabled, e.StencilMode.disabled, e.ColorMode.unblended, e.CullFaceMode.frontCW, _, \"skyboxCapture\", i.skyboxGeometry.vertexBuffer, i.skyboxGeometry.indexBuffer, i.skyboxGeometry.segment);\n    }\n\n    function Co(t, i) {\n      return e.transformMat4(t, t, i);\n    }\n\n    const Io = {\n      symbol: function (t, i, o, r, n) {\n        if (\"translucent\" !== t.renderPass) return;\n        const a = e.StencilMode.disabled,\n              s = t.colorModeForRenderPass();\n        o.layout.get(\"text-variable-anchor\") && function (t, i, o, r, n, a, s) {\n          const l = i.transform,\n                c = \"map\" === n,\n                h = \"map\" === a;\n\n          for (const n of t) {\n            const t = r.getTile(n),\n                  a = t.getBucket(o);\n            if (!a || a.projection !== l.projection.name || !a.text || !a.text.segments.get().length) continue;\n\n            const _ = e.evaluateSizeForZoom(a.textSizeData, l.zoom),\n                  u = i.transform.calculatePixelsToTileUnitsMatrix(t),\n                  d = Qe(n.projMatrix, t.tileID.canonical, h, c, i.transform, u),\n                  p = \"none\" !== o.layout.get(\"icon-text-fit\") && a.hasIconData();\n\n            if (_) {\n              const i = Math.pow(2, l.zoom - t.tileID.overscaledZ);\n              oo(a, c, h, s, e.symbolSize, l, d, n, i, _, p, l.projection);\n            }\n          }\n        }(r, t, o, i, o.layout.get(\"text-rotation-alignment\"), o.layout.get(\"text-pitch-alignment\"), n), 0 !== o.paint.get(\"icon-opacity\").constantOr(1) && no(t, i, o, r, !1, o.paint.get(\"icon-translate\"), o.paint.get(\"icon-translate-anchor\"), o.layout.get(\"icon-rotation-alignment\"), o.layout.get(\"icon-pitch-alignment\"), o.layout.get(\"icon-keep-upright\"), a, s), 0 !== o.paint.get(\"text-opacity\").constantOr(1) && no(t, i, o, r, !0, o.paint.get(\"text-translate\"), o.paint.get(\"text-translate-anchor\"), o.layout.get(\"text-rotation-alignment\"), o.layout.get(\"text-pitch-alignment\"), o.layout.get(\"text-keep-upright\"), a, s), i.map.showCollisionBoxes && (eo(t, i, o, r, o.paint.get(\"text-translate\"), o.paint.get(\"text-translate-anchor\"), !0), eo(t, i, o, r, o.paint.get(\"icon-translate\"), o.paint.get(\"icon-translate-anchor\"), !1));\n      },\n      circle: function (t, i, o, r) {\n        if (\"translucent\" !== t.renderPass) return;\n        const n = o.paint.get(\"circle-opacity\"),\n              a = o.paint.get(\"circle-stroke-width\"),\n              s = o.paint.get(\"circle-stroke-opacity\"),\n              l = void 0 !== o.layout.get(\"circle-sort-key\").constantOr(1);\n        if (0 === n.constantOr(1) && (0 === a.constantOr(1) || 0 === s.constantOr(1))) return;\n        const c = t.context,\n              h = c.gl,\n              _ = t.transform,\n              u = t.depthModeForSublayer(0, e.DepthMode.ReadOnly),\n              d = e.StencilMode.disabled,\n              p = t.colorModeForRenderPass(),\n              m = \"globe\" === _.projection.name,\n              f = [e.mercatorXfromLng(_.center.lng), e.mercatorYfromLat(_.center.lat)],\n              g = [];\n\n        for (let n = 0; n < r.length; n++) {\n          const a = r[n],\n                s = i.getTile(a),\n                c = s.getBucket(o);\n          if (!c) continue;\n          const h = c.programConfigurations.get(o.id),\n                u = Ri(o);\n          m && u.push(\"PROJECTION_GLOBE_VIEW\");\n\n          const d = t.useProgram(\"circle\", h, u),\n                p = c.layoutVertexBuffer,\n                v = c.globeExtVertexBuffer,\n                x = c.indexBuffer,\n                y = _.projection.createInversionMatrix(_, a.canonical),\n                b = {\n            programConfiguration: h,\n            program: d,\n            layoutVertexBuffer: p,\n            globeExtVertexBuffer: v,\n            indexBuffer: x,\n            uniformValues: Li(t, a, s, y, f, o),\n            tile: s\n          };\n\n          if (l) {\n            const t = c.segments.get();\n\n            for (const i of t) g.push({\n              segments: new e.SegmentVector([i]),\n              sortKey: i.sortKey,\n              state: b\n            });\n          } else g.push({\n            segments: c.segments,\n            sortKey: 0,\n            state: b\n          });\n        }\n\n        l && g.sort((e, t) => e.sortKey - t.sortKey);\n        const v = {\n          useDepthForOcclusion: !m\n        };\n\n        for (const i of g) {\n          const {\n            programConfiguration: r,\n            program: n,\n            layoutVertexBuffer: a,\n            globeExtVertexBuffer: s,\n            indexBuffer: l,\n            uniformValues: f,\n            tile: g\n          } = i.state,\n                x = i.segments;\n          t.terrain && t.terrain.setupElevationDraw(g, n, v), t.prepareDrawProgram(c, n, g.tileID.toUnwrapped()), n.draw(c, h.TRIANGLES, u, d, p, e.CullFaceMode.disabled, f, o.id, a, l, x, o.paint, _.zoom, r, m ? s : null);\n        }\n      },\n      heatmap: function (t, i, o, r) {\n        if (0 !== o.paint.get(\"heatmap-opacity\")) if (\"offscreen\" === t.renderPass) {\n          const n = t.context,\n                a = n.gl,\n                s = e.StencilMode.disabled,\n                l = new e.ColorMode([a.ONE, a.ONE], e.Color.transparent, [!0, !0, !0, !0]);\n          !function (e, t, i) {\n            const o = e.gl;\n            e.activeTexture.set(o.TEXTURE1), e.viewport.set([0, 0, t.width / 4, t.height / 4]);\n            let r = i.heatmapFbo;\n            if (r) o.bindTexture(o.TEXTURE_2D, r.colorAttachment.get()), e.bindFramebuffer.set(r.framebuffer);else {\n              const n = o.createTexture();\n              o.bindTexture(o.TEXTURE_2D, n), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_S, o.CLAMP_TO_EDGE), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_T, o.CLAMP_TO_EDGE), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MIN_FILTER, o.LINEAR), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MAG_FILTER, o.LINEAR), r = i.heatmapFbo = e.createFramebuffer(t.width / 4, t.height / 4, !1), function (e, t, i, o) {\n                const r = e.gl;\n                r.texImage2D(r.TEXTURE_2D, 0, r.RGBA, t.width / 4, t.height / 4, 0, r.RGBA, e.extRenderToTextureHalfFloat ? e.extTextureHalfFloat.HALF_FLOAT_OES : r.UNSIGNED_BYTE, null), o.colorAttachment.set(i);\n              }(e, t, n, r);\n            }\n          }(n, t, o), n.clear({\n            color: e.Color.transparent\n          });\n\n          const c = t.transform,\n                h = \"globe\" === c.projection.name,\n                _ = h ? [\"PROJECTION_GLOBE_VIEW\"] : null,\n                u = [e.mercatorXfromLng(c.center.lng), e.mercatorYfromLat(c.center.lat)];\n\n          for (let d = 0; d < r.length; d++) {\n            const p = r[d];\n            if (i.hasRenderableParent(p)) continue;\n            const m = i.getTile(p),\n                  f = m.getBucket(o);\n            if (!f) continue;\n            const g = f.programConfigurations.get(o.id),\n                  v = t.useProgram(\"heatmap\", g, _),\n                  {\n              zoom: x\n            } = t.transform;\n            t.terrain && t.terrain.setupElevationDraw(m, v), t.prepareDrawProgram(n, v, p.toUnwrapped());\n            const y = c.projection.createInversionMatrix(c, p.canonical);\n            v.draw(n, a.TRIANGLES, e.DepthMode.disabled, s, l, e.CullFaceMode.disabled, Fi(t, p, m, y, u, x, o.paint.get(\"heatmap-intensity\")), o.id, f.layoutVertexBuffer, f.indexBuffer, f.segments, o.paint, t.transform.zoom, g, h ? f.globeExtVertexBuffer : null);\n          }\n\n          n.viewport.set([0, 0, t.width, t.height]);\n        } else \"translucent\" === t.renderPass && (t.context.setColorMode(t.colorModeForRenderPass()), function (t, i) {\n          const o = t.context,\n                r = o.gl,\n                n = i.heatmapFbo;\n          if (!n) return;\n          o.activeTexture.set(r.TEXTURE0), r.bindTexture(r.TEXTURE_2D, n.colorAttachment.get()), o.activeTexture.set(r.TEXTURE1);\n          let a = i.colorRampTexture;\n          a || (a = i.colorRampTexture = new e.Texture(o, i.colorRamp, r.RGBA)), a.bind(r.LINEAR, r.CLAMP_TO_EDGE), t.useProgram(\"heatmapTexture\").draw(o, r.TRIANGLES, e.DepthMode.disabled, e.StencilMode.disabled, t.colorModeForRenderPass(), e.CullFaceMode.disabled, ((e, t, i, o) => ({\n            u_image: 0,\n            u_color_ramp: 1,\n            u_opacity: t.paint.get(\"heatmap-opacity\")\n          }))(0, i), i.id, t.viewportBuffer, t.quadTriangleIndexBuffer, t.viewportSegments, i.paint, t.transform.zoom);\n        }(t, o));\n      },\n      line: function (t, i, o, r) {\n        if (\"translucent\" !== t.renderPass) return;\n        const n = o.paint.get(\"line-opacity\"),\n              a = o.paint.get(\"line-width\");\n        if (0 === n.constantOr(1) || 0 === a.constantOr(1)) return;\n\n        const s = t.depthModeForSublayer(0, e.DepthMode.ReadOnly),\n              l = t.colorModeForRenderPass(),\n              c = t.terrain && t.terrain.renderingToTexture ? 1 : e.exported.devicePixelRatio,\n              h = o.paint.get(\"line-dasharray\"),\n              _ = h.constantOr(1),\n              u = o.layout.get(\"line-cap\"),\n              d = o.paint.get(\"line-pattern\"),\n              p = d.constantOr(1),\n              m = o.paint.get(\"line-gradient\"),\n              f = o.getCrossfadeParameters(),\n              g = p ? \"linePattern\" : \"line\",\n              v = t.context,\n              x = v.gl,\n              y = (e => {\n          const t = [];\n          Zi(e) && t.push(\"RENDER_LINE_DASH\"), e.paint.get(\"line-gradient\") && t.push(\"RENDER_LINE_GRADIENT\");\n          const i = e.paint.get(\"line-pattern\").constantOr(1),\n                o = 1 !== e.paint.get(\"line-opacity\").constantOr(1);\n          return !i && o && t.push(\"RENDER_LINE_ALPHA_DISCARD\"), t;\n        })(o);\n\n        let b = y.includes(\"RENDER_LINE_ALPHA_DISCARD\");\n        t.terrain && t.terrain.clipOrMaskOverlapStencilType() && (b = !1);\n\n        for (const n of r) {\n          const r = i.getTile(n);\n          if (p && !r.patternsLoaded()) continue;\n          const a = r.getBucket(o);\n          if (!a) continue;\n          t.prepareDrawTile();\n          const w = a.programConfigurations.get(o.id),\n                T = t.useProgram(g, w, y),\n                E = d.constantOr(null);\n\n          if (E && r.imageAtlas) {\n            const e = r.imageAtlas,\n                  t = e.patternPositions[E.to.toString()],\n                  i = e.patternPositions[E.from.toString()];\n            t && i && w.setConstantPatternPositions(t, i);\n          }\n\n          const C = h.constantOr(null),\n                I = u.constantOr(null);\n\n          if (!p && C && I && r.lineAtlas) {\n            const e = r.lineAtlas,\n                  t = e.getDash(C.to, I),\n                  i = e.getDash(C.from, I);\n            t && i && w.setConstantPatternPositions(t, i);\n          }\n\n          const M = t.terrain ? n.projMatrix : null,\n                S = p ? Ni(t, r, o, f, M, c) : Ui(t, r, o, f, M, a.lineClipsArray.length, c);\n\n          if (m) {\n            const r = a.gradients[o.id];\n            let s = r.texture;\n\n            if (o.gradientVersion !== r.version) {\n              let l = 256;\n\n              if (o.stepInterpolant) {\n                const o = i.getSource().maxzoom,\n                      r = n.canonical.z === o ? Math.ceil(1 << t.transform.maxZoom - n.canonical.z) : 1;\n                l = e.clamp(e.nextPowerOfTwo(a.maxLineLength / e.EXTENT * 1024 * r), 256, v.maxTextureSize);\n              }\n\n              r.gradient = e.renderColorRamp({\n                expression: o.gradientExpression(),\n                evaluationKey: \"lineProgress\",\n                resolution: l,\n                image: r.gradient || void 0,\n                clips: a.lineClipsArray\n              }), r.texture ? r.texture.update(r.gradient) : r.texture = new e.Texture(v, r.gradient, x.RGBA), r.version = o.gradientVersion, s = r.texture;\n            }\n\n            v.activeTexture.set(x.TEXTURE1), s.bind(o.stepInterpolant ? x.NEAREST : x.LINEAR, x.CLAMP_TO_EDGE);\n          }\n\n          _ && (v.activeTexture.set(x.TEXTURE0), r.lineAtlasTexture.bind(x.LINEAR, x.REPEAT), w.updatePaintBuffers(f)), p && (v.activeTexture.set(x.TEXTURE0), r.imageAtlasTexture.bind(x.LINEAR, x.CLAMP_TO_EDGE), w.updatePaintBuffers(f)), t.prepareDrawProgram(v, T, n.toUnwrapped());\n\n          const z = i => {\n            T.draw(v, x.TRIANGLES, s, i, l, e.CullFaceMode.disabled, S, o.id, a.layoutVertexBuffer, a.indexBuffer, a.segments, o.paint, t.transform.zoom, w, a.layoutVertexBuffer2);\n          };\n\n          if (b) {\n            const i = t.stencilModeForClipping(n).ref;\n            0 === i && t.terrain && v.clear({\n              stencil: 0\n            });\n            const o = {\n              func: x.EQUAL,\n              mask: 255\n            };\n            S.u_alpha_discard_threshold = .8, z(new e.StencilMode(o, i, 255, x.KEEP, x.KEEP, x.INVERT)), S.u_alpha_discard_threshold = 0, z(new e.StencilMode(o, i, 255, x.KEEP, x.KEEP, x.KEEP));\n          } else z(t.stencilModeForClipping(n));\n        }\n\n        b && (t.resetStencilClippingMasks(), t.terrain && v.clear({\n          stencil: 0\n        }));\n      },\n      fill: function (t, i, o, r) {\n        const n = o.paint.get(\"fill-color\"),\n              a = o.paint.get(\"fill-opacity\");\n        if (0 === a.constantOr(1)) return;\n        const s = t.colorModeForRenderPass(),\n              l = o.paint.get(\"fill-pattern\"),\n              c = t.opaquePassEnabledForLayer() && !l.constantOr(1) && 1 === n.constantOr(e.Color.transparent).a && 1 === a.constantOr(0) ? \"opaque\" : \"translucent\";\n\n        if (t.renderPass === c) {\n          const n = t.depthModeForSublayer(1, \"opaque\" === t.renderPass ? e.DepthMode.ReadWrite : e.DepthMode.ReadOnly);\n          so(t, i, o, r, n, s, !1);\n        }\n\n        if (\"translucent\" === t.renderPass && o.paint.get(\"fill-antialias\")) {\n          const n = t.depthModeForSublayer(o.getPaintProperty(\"fill-outline-color\") ? 2 : 0, e.DepthMode.ReadOnly);\n          so(t, i, o, r, n, s, !0);\n        }\n      },\n      \"fill-extrusion\": function (t, i, o, r) {\n        const n = o.paint.get(\"fill-extrusion-opacity\");\n\n        if (0 !== n && \"translucent\" === t.renderPass) {\n          const a = new e.DepthMode(t.context.gl.LEQUAL, e.DepthMode.ReadWrite, t.depthRangeFor3D);\n          if (1 !== n || o.paint.get(\"fill-extrusion-pattern\").constantOr(1)) lo(t, i, o, r, a, e.StencilMode.disabled, e.ColorMode.disabled), lo(t, i, o, r, a, t.stencilModeFor3D(), t.colorModeForRenderPass()), t.resetStencilClippingMasks();else {\n            const n = t.colorModeForRenderPass();\n            lo(t, i, o, r, a, e.StencilMode.disabled, n);\n          }\n        }\n      },\n      hillshade: function (t, i, o, r) {\n        if (\"offscreen\" !== t.renderPass && \"translucent\" !== t.renderPass) return;\n        const n = t.context,\n              a = t.depthModeForSublayer(0, e.DepthMode.ReadOnly),\n              s = t.colorModeForRenderPass(),\n              l = t.terrain && t.terrain.renderingToTexture,\n              [c, h] = \"translucent\" !== t.renderPass || l ? [{}, r] : t.stencilConfigForOverlap(r);\n\n        for (const r of h) {\n          const n = i.getTile(r);\n          if (n.needsHillshadePrepare && \"offscreen\" === t.renderPass) si(t, n, o, a, e.StencilMode.disabled, s);else if (\"translucent\" === t.renderPass) {\n            const e = l && t.terrain ? t.terrain.stencilModeForRTTOverlap(r) : c[r.overscaledZ];\n            ni(t, r, n, o, a, e, s);\n          }\n        }\n\n        n.viewport.set([0, 0, t.width, t.height]), t.resetStencilClippingMasks();\n      },\n      raster: function (t, i, o, r, n, a) {\n        if (\"translucent\" !== t.renderPass) return;\n        if (0 === o.paint.get(\"raster-opacity\")) return;\n        if (!r.length) return;\n\n        const s = t.context,\n              l = s.gl,\n              c = i.getSource(),\n              h = t.useProgram(\"raster\"),\n              _ = t.colorModeForRenderPass(),\n              u = t.terrain && t.terrain.renderingToTexture,\n              [d, p] = c instanceof Se || u ? [{}, r] : t.stencilConfigForOverlap(r),\n              m = p[p.length - 1].overscaledZ,\n              f = !t.options.moving;\n\n        for (const r of p) {\n          const n = u ? e.DepthMode.disabled : t.depthModeForSublayer(r.overscaledZ - m, 1 === o.paint.get(\"raster-opacity\") ? e.DepthMode.ReadWrite : e.DepthMode.ReadOnly, l.LESS),\n                p = r.toUnwrapped(),\n                g = i.getTile(r);\n          if (u && (!g || !g.hasData())) continue;\n          const v = u ? r.projMatrix : t.transform.calculateProjMatrix(p, f),\n                x = t.terrain && u ? t.terrain.stencilModeForRTTOverlap(r) : d[r.overscaledZ],\n                y = a ? 0 : o.paint.get(\"raster-fade-duration\");\n          g.registerFadeDuration(y);\n          const b = i.findLoadedParent(r, 0),\n                w = fi(g, b, i, t.transform, y);\n          let T, E;\n          t.terrain && t.terrain.prepareDrawTile();\n          const C = \"nearest\" === o.paint.get(\"raster-resampling\") ? l.NEAREST : l.LINEAR;\n          s.activeTexture.set(l.TEXTURE0), g.texture.bind(C, l.CLAMP_TO_EDGE), s.activeTexture.set(l.TEXTURE1), b ? (b.texture.bind(C, l.CLAMP_TO_EDGE), T = Math.pow(2, b.tileID.overscaledZ - g.tileID.overscaledZ), E = [g.tileID.canonical.x * T % 1, g.tileID.canonical.y * T % 1]) : g.texture.bind(C, l.CLAMP_TO_EDGE);\n          const I = Vi(v, E || [0, 0], T || 1, w, o, c instanceof Se ? c.perspectiveTransform : [0, 0]);\n          if (t.prepareDrawProgram(s, h, p), c instanceof Se) c.boundsBuffer && c.boundsSegments && h.draw(s, l.TRIANGLES, n, e.StencilMode.disabled, _, e.CullFaceMode.disabled, I, o.id, c.boundsBuffer, t.quadTriangleIndexBuffer, c.boundsSegments);else {\n            const {\n              tileBoundsBuffer: i,\n              tileBoundsIndexBuffer: r,\n              tileBoundsSegments: a\n            } = t.getTileBoundsBuffers(g);\n            h.draw(s, l.TRIANGLES, n, x, _, e.CullFaceMode.disabled, I, o.id, i, r, a);\n          }\n        }\n\n        t.resetStencilClippingMasks();\n      },\n      background: function (t, i, o, r) {\n        const n = o.paint.get(\"background-color\"),\n              a = o.paint.get(\"background-opacity\");\n        if (0 === a) return;\n\n        const s = t.context,\n              l = s.gl,\n              c = t.transform,\n              h = c.tileSize,\n              _ = o.paint.get(\"background-pattern\");\n\n        if (t.isPatternMissing(_)) return;\n        const u = !_ && 1 === n.a && 1 === a && t.opaquePassEnabledForLayer() ? \"opaque\" : \"translucent\";\n        if (t.renderPass !== u) return;\n        const d = e.StencilMode.disabled,\n              p = t.depthModeForSublayer(0, \"opaque\" === u ? e.DepthMode.ReadWrite : e.DepthMode.ReadOnly),\n              m = t.colorModeForRenderPass(),\n              f = t.useProgram(_ ? \"backgroundPattern\" : \"background\");\n        let g,\n            v = r;\n        v || (g = t.getBackgroundTiles(), v = Object.values(g).map(e => e.tileID)), _ && (s.activeTexture.set(l.TEXTURE0), t.imageManager.bind(t.context));\n        const x = o.getCrossfadeParameters();\n\n        for (const u of v) {\n          const v = u.toUnwrapped(),\n                y = r ? u.projMatrix : t.transform.calculateProjMatrix(v);\n          t.prepareDrawTile();\n          const b = i ? i.getTile(u) : g ? g[u.key] : new e.Tile(u, h, c.zoom, t),\n                w = _ ? Yi(y, a, t, _, {\n            tileID: u,\n            tileSize: h\n          }, x) : Ki(y, a, n);\n          t.prepareDrawProgram(s, f, v);\n          const {\n            tileBoundsBuffer: T,\n            tileBoundsIndexBuffer: E,\n            tileBoundsSegments: C\n          } = t.getTileBoundsBuffers(b);\n          f.draw(s, l.TRIANGLES, p, d, m, e.CullFaceMode.disabled, w, o.id, T, E, C);\n        }\n      },\n      sky: function (t, i, o) {\n        const r = t.transform,\n              n = \"mercator\" === r.projection.name || \"globe\" === r.projection.name ? 1 : e.smoothstep(7, 8, r.zoom),\n              a = o.paint.get(\"sky-opacity\") * n;\n        if (0 === a) return;\n        const s = t.context,\n              l = o.paint.get(\"sky-type\"),\n              c = new e.DepthMode(s.gl.LEQUAL, e.DepthMode.ReadOnly, [0, 1]),\n              h = t.frameCounter / 1e3 % 1;\n        \"atmosphere\" === l ? \"offscreen\" === t.renderPass ? o.needsSkyboxCapture(t) && (function (t, i, o, r) {\n          const n = t.context,\n                a = n.gl;\n          let s = i.skyboxFbo;\n\n          if (!s) {\n            s = i.skyboxFbo = n.createFramebuffer(32, 32, !1), i.skyboxGeometry = new To(n), i.skyboxTexture = n.gl.createTexture(), a.bindTexture(a.TEXTURE_CUBE_MAP, i.skyboxTexture), a.texParameteri(a.TEXTURE_CUBE_MAP, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE), a.texParameteri(a.TEXTURE_CUBE_MAP, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE), a.texParameteri(a.TEXTURE_CUBE_MAP, a.TEXTURE_MIN_FILTER, a.LINEAR), a.texParameteri(a.TEXTURE_CUBE_MAP, a.TEXTURE_MAG_FILTER, a.LINEAR);\n\n            for (let e = 0; e < 6; ++e) a.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, a.RGBA, 32, 32, 0, a.RGBA, a.UNSIGNED_BYTE, null);\n          }\n\n          n.bindFramebuffer.set(s.framebuffer), n.viewport.set([0, 0, 32, 32]);\n          const l = i.getCenter(t, !0),\n                c = t.useProgram(\"skyboxCapture\"),\n                h = new Float64Array(16);\n          e.identity(h), e.rotateY(h, h, .5 * -Math.PI), Eo(n, i, c, h, l, 0), e.identity(h), e.rotateY(h, h, .5 * Math.PI), Eo(n, i, c, h, l, 1), e.identity(h), e.rotateX(h, h, .5 * -Math.PI), Eo(n, i, c, h, l, 2), e.identity(h), e.rotateX(h, h, .5 * Math.PI), Eo(n, i, c, h, l, 3), e.identity(h), Eo(n, i, c, h, l, 4), e.identity(h), e.rotateY(h, h, Math.PI), Eo(n, i, c, h, l, 5), n.viewport.set([0, 0, t.width, t.height]);\n        }(t, o), o.markSkyboxValid(t)) : \"sky\" === t.renderPass && function (t, i, o, r, n) {\n          const a = t.context,\n                s = a.gl,\n                l = t.transform,\n                c = t.useProgram(\"skybox\");\n          a.activeTexture.set(s.TEXTURE0), s.bindTexture(s.TEXTURE_CUBE_MAP, i.skyboxTexture);\n\n          const h = ((e, t, i, o, r) => ({\n            u_matrix: e,\n            u_sun_direction: t,\n            u_cubemap: 0,\n            u_opacity: o,\n            u_temporal_offset: r\n          }))(l.skyboxMatrix, i.getCenter(t, !1), 0, r, n);\n\n          t.prepareDrawProgram(a, c), c.draw(a, s.TRIANGLES, o, e.StencilMode.disabled, t.colorModeForRenderPass(), e.CullFaceMode.backCW, h, \"skybox\", i.skyboxGeometry.vertexBuffer, i.skyboxGeometry.indexBuffer, i.skyboxGeometry.segment);\n        }(t, o, c, a, h) : \"gradient\" === l && \"sky\" === t.renderPass && function (t, i, o, r, n) {\n          const a = t.context,\n                s = a.gl,\n                l = t.transform,\n                c = t.useProgram(\"skyboxGradient\");\n          i.skyboxGeometry || (i.skyboxGeometry = new To(a)), a.activeTexture.set(s.TEXTURE0);\n          let h = i.colorRampTexture;\n          h || (h = i.colorRampTexture = new e.Texture(a, i.colorRamp, s.RGBA)), h.bind(s.LINEAR, s.CLAMP_TO_EDGE);\n\n          const _ = ((t, i, o, r, n) => ({\n            u_matrix: t,\n            u_color_ramp: 0,\n            u_center_direction: i,\n            u_radius: e.degToRad(o),\n            u_opacity: r,\n            u_temporal_offset: n\n          }))(l.skyboxMatrix, i.getCenter(t, !1), i.paint.get(\"sky-gradient-radius\"), r, n);\n\n          t.prepareDrawProgram(a, c), c.draw(a, s.TRIANGLES, o, e.StencilMode.disabled, t.colorModeForRenderPass(), e.CullFaceMode.backCW, _, \"skyboxGradient\", i.skyboxGeometry.vertexBuffer, i.skyboxGeometry.indexBuffer, i.skyboxGeometry.segment);\n        }(t, o, c, a, h);\n      },\n      debug: function (e, t, i) {\n        for (let o = 0; o < i.length; o++) xo(e, t, i[o]);\n      },\n      custom: function (t, i, o) {\n        const r = t.context,\n              n = o.implementation;\n        if (t.transform.projection.unsupportedLayers && t.transform.projection.unsupportedLayers.includes(\"custom\")) e.warnOnce(\"Custom layers are not yet supported with non-mercator projections. Use mercator to enable custom layers.\");else if (\"offscreen\" === t.renderPass) {\n          const e = n.prerender;\n          e && (t.setCustomLayerDefaults(), r.setColorMode(t.colorModeForRenderPass()), e.call(n, r.gl, t.transform.customLayerMatrix()), r.setDirty(), t.setBaseState());\n        } else if (\"translucent\" === t.renderPass) {\n          t.setCustomLayerDefaults(), r.setColorMode(t.colorModeForRenderPass()), r.setStencilMode(e.StencilMode.disabled);\n          const i = \"3d\" === n.renderingMode ? new e.DepthMode(t.context.gl.LEQUAL, e.DepthMode.ReadWrite, t.depthRangeFor3D) : t.depthModeForSublayer(0, e.DepthMode.ReadOnly);\n          r.setDepthMode(i), n.render(r.gl, t.transform.customLayerMatrix()), r.setDirty(), t.setBaseState(), r.bindFramebuffer.set(null);\n        }\n      }\n    };\n\n    class Mo {\n      constructor(t, i) {\n        this.context = new Ee(t), this.transform = i, this._tileTextures = {}, this.frameCopies = [], this.loadTimeStamps = [], this.setup(), this.numSublayers = e.SourceCache.maxUnderzooming + e.SourceCache.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new jt(), this.gpuTimers = {}, this.frameCounter = 0, this._backgroundTiles = {}, this._tileClippingMaskIDs = new Map(), this._skippedStencilTileIDs = new Set();\n      }\n\n      updateTerrain(e, t) {\n        const i = !!e && !!e.terrain && this.transform.projection.supportsTerrain;\n        if (!(i || this._terrain && this._terrain.enabled)) return;\n        this._terrain || (this._terrain = new bi(this, e));\n        const o = this._terrain;\n        this.transform.elevation = i ? o : null, o.update(e, this.transform, t);\n      }\n\n      _updateFog(e) {\n        const t = e.fog;\n        if (!t || t.getOpacity(this.transform.pitch) < 1 || t.properties.get(\"horizon-blend\") < .03) return void (this.transform.fogCullDistSq = null);\n        const [i, o] = t.getFovAdjustedRange(this.transform._fov);\n        if (i > o) return void (this.transform.fogCullDistSq = null);\n        const r = i + .78 * (o - i);\n        this.transform.fogCullDistSq = r * r;\n      }\n\n      get terrain() {\n        return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled ? this._terrain : null;\n      }\n\n      resize(t, i) {\n        if (this.width = t * e.exported.devicePixelRatio, this.height = i * e.exported.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const e of this.style.order) this.style._layers[e].resize();\n      }\n\n      setup() {\n        const t = this.context,\n              i = new e.StructArrayLayout2i4();\n        i.emplaceBack(0, 0), i.emplaceBack(e.EXTENT, 0), i.emplaceBack(0, e.EXTENT), i.emplaceBack(e.EXTENT, e.EXTENT), this.tileExtentBuffer = t.createVertexBuffer(i, e.posAttributes.members), this.tileExtentSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);\n        const o = new e.StructArrayLayout2i4();\n        o.emplaceBack(0, 0), o.emplaceBack(e.EXTENT, 0), o.emplaceBack(0, e.EXTENT), o.emplaceBack(e.EXTENT, e.EXTENT), this.debugBuffer = t.createVertexBuffer(o, e.posAttributes.members), this.debugSegments = e.SegmentVector.simpleSegment(0, 0, 4, 5);\n        const r = new e.StructArrayLayout2i4();\n        r.emplaceBack(-1, -1), r.emplaceBack(1, -1), r.emplaceBack(-1, 1), r.emplaceBack(1, 1), this.viewportBuffer = t.createVertexBuffer(r, e.posAttributes.members), this.viewportSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);\n        const n = new e.StructArrayLayout4i8();\n        n.emplaceBack(0, 0, 0, 0), n.emplaceBack(e.EXTENT, 0, e.EXTENT, 0), n.emplaceBack(0, e.EXTENT, 0, e.EXTENT), n.emplaceBack(e.EXTENT, e.EXTENT, e.EXTENT, e.EXTENT), this.mercatorBoundsBuffer = t.createVertexBuffer(n, e.boundsAttributes.members), this.mercatorBoundsSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);\n        const a = new e.StructArrayLayout3ui6();\n        a.emplaceBack(0, 1, 2), a.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t.createIndexBuffer(a);\n        const s = new e.StructArrayLayout1ui2();\n\n        for (const e of [0, 1, 3, 2, 0]) s.emplaceBack(e);\n\n        this.debugIndexBuffer = t.createIndexBuffer(s), this.emptyTexture = new e.Texture(t, new e.RGBAImage({\n          width: 1,\n          height: 1\n        }, Uint8Array.of(0, 0, 0, 0)), t.gl.RGBA), this.identityMat = e.create();\n        const l = this.context.gl;\n        this.stencilClearMode = new e.StencilMode({\n          func: l.ALWAYS,\n          mask: 0\n        }, 0, 255, l.ZERO, l.ZERO, l.ZERO), this.loadTimeStamps.push(e.window.performance.now());\n      }\n\n      getMercatorTileBoundsBuffers() {\n        return {\n          tileBoundsBuffer: this.mercatorBoundsBuffer,\n          tileBoundsIndexBuffer: this.quadTriangleIndexBuffer,\n          tileBoundsSegments: this.mercatorBoundsSegments\n        };\n      }\n\n      getTileBoundsBuffers(e) {\n        return e._makeTileBoundsBuffers(this.context, this.transform.projection), e._tileBoundsBuffer ? {\n          tileBoundsBuffer: e._tileBoundsBuffer,\n          tileBoundsIndexBuffer: e._tileBoundsIndexBuffer,\n          tileBoundsSegments: e._tileBoundsSegments\n        } : this.getMercatorTileBoundsBuffers();\n      }\n\n      clearStencil() {\n        const t = this.context,\n              i = t.gl;\n        this.nextStencilID = 1, this.currentStencilSource = void 0, this._tileClippingMaskIDs.clear(), this._skippedStencilTileIDs.clear(), this.useProgram(\"clippingMask\").draw(t, i.TRIANGLES, e.DepthMode.disabled, this.stencilClearMode, e.ColorMode.disabled, e.CullFaceMode.disabled, mi(this.identityMat), \"$clipping\", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);\n      }\n\n      resetStencilClippingMasks() {\n        this.terrain || (this.currentStencilSource = void 0, this._tileClippingMaskIDs.clear(), this._skippedStencilTileIDs.clear());\n      }\n\n      _renderTileClippingMasks(t, i, o) {\n        if (!i || this.currentStencilSource === i.id || !t.isTileClipped() || !o || 0 === o.length) return;\n        const r = [];\n        let n = !1;\n\n        if (this._tileClippingMaskIDs && !this.terrain) {\n          for (const e of o) if (this._tileClippingMaskIDs.has(e.key) || (n = !0), this._skippedStencilTileIDs.has(e.key)) {\n            if (!i.getTile(e).getBucket(t)) continue;\n            this._skippedStencilTileIDs.delete(e.key), r.push(e);\n          }\n\n          if (!n && 0 === r.length) return;\n        }\n\n        const a = this.context,\n              s = a.gl;\n        a.setColorMode(e.ColorMode.disabled), a.setDepthMode(e.DepthMode.disabled);\n\n        const l = this.useProgram(\"clippingMask\"),\n              c = t => {\n          const o = i.getTile(t),\n                {\n            tileBoundsBuffer: r,\n            tileBoundsIndexBuffer: n,\n            tileBoundsSegments: c\n          } = this.getTileBoundsBuffers(o);\n          l.draw(a, s.TRIANGLES, e.DepthMode.disabled, new e.StencilMode({\n            func: s.GREATER,\n            mask: 255\n          }, this._tileClippingMaskIDs.get(t.key) || 0, 255, s.KEEP, s.KEEP, s.REPLACE), e.ColorMode.disabled, e.CullFaceMode.disabled, mi(t.projMatrix), \"$clipping\", r, n, c);\n        };\n\n        if (!n && r.length > 0) for (const e of r) c(e);else {\n          (0 === this._tileClippingMaskIDs.size || this.nextStencilID + o.length > 256) && this.clearStencil(), this._tileClippingMaskIDs.clear(), this._skippedStencilTileIDs.clear();\n\n          for (const e of o) this._tileClippingMaskIDs.set(e.key, this.nextStencilID++), i.getTile(e).getBucket(t) ? c(e) : this._skippedStencilTileIDs.add(e.key);\n        }\n        0 === this._skippedStencilTileIDs.size && (this.currentStencilSource = i.id);\n      }\n\n      stencilModeFor3D() {\n        this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();\n        const t = this.nextStencilID++,\n              i = this.context.gl;\n        return new e.StencilMode({\n          func: i.NOTEQUAL,\n          mask: 255\n        }, t, 255, i.KEEP, i.KEEP, i.REPLACE);\n      }\n\n      stencilModeForClipping(t) {\n        if (this.terrain) return this.terrain.stencilModeForRTTOverlap(t);\n        const i = this.context.gl;\n        return new e.StencilMode({\n          func: i.EQUAL,\n          mask: 255\n        }, this._tileClippingMaskIDs.get(t.key) || 0, 0, i.KEEP, i.KEEP, i.REPLACE);\n      }\n\n      stencilConfigForOverlap(t) {\n        const i = this.context.gl,\n              o = t.sort((e, t) => t.overscaledZ - e.overscaledZ),\n              r = o[o.length - 1].overscaledZ,\n              n = o[0].overscaledZ - r + 1;\n\n        if (n > 1) {\n          this.currentStencilSource = void 0, this.nextStencilID + n > 256 && this.clearStencil();\n          const t = {};\n\n          for (let o = 0; o < n; o++) t[o + r] = new e.StencilMode({\n            func: i.GEQUAL,\n            mask: 255\n          }, o + this.nextStencilID, 255, i.KEEP, i.KEEP, i.REPLACE);\n\n          return this.nextStencilID += n, [t, o];\n        }\n\n        return [{\n          [r]: e.StencilMode.disabled\n        }, o];\n      }\n\n      colorModeForRenderPass() {\n        const t = this.context.gl;\n\n        if (this._showOverdrawInspector) {\n          const i = 1 / 8;\n          return new e.ColorMode([t.CONSTANT_COLOR, t.ONE], new e.Color(i, i, i, 0), [!0, !0, !0, !0]);\n        }\n\n        return \"opaque\" === this.renderPass ? e.ColorMode.unblended : e.ColorMode.alphaBlended;\n      }\n\n      depthModeForSublayer(t, i, o) {\n        if (!this.opaquePassEnabledForLayer()) return e.DepthMode.disabled;\n        const r = 1 - ((1 + this.currentLayer) * this.numSublayers + t) * this.depthEpsilon;\n        return new e.DepthMode(o || this.context.gl.LEQUAL, i, [r, r]);\n      }\n\n      opaquePassEnabledForLayer() {\n        return this.currentLayer < this.opaquePassCutoff;\n      }\n\n      render(t, i) {\n        this.style = t, this.options = i, this.lineAtlas = t.lineAtlas, this.imageManager = t.imageManager, this.glyphManager = t.glyphManager, this.symbolFadeChange = t.placement.symbolFadeChange(e.exported.now()), this.imageManager.beginFrame();\n        const o = this.style.order,\n              r = this.style._sourceCaches;\n\n        for (const e in r) {\n          const t = r[e];\n          t.used && t.prepare(this.context);\n        }\n\n        const n = {},\n              a = {},\n              s = {};\n\n        for (const e in r) {\n          const t = r[e];\n          n[e] = t.getVisibleCoordinates(), a[e] = n[e].slice().reverse(), s[e] = t.getVisibleCoordinates(!0).reverse();\n        }\n\n        this.opaquePassCutoff = 1 / 0;\n\n        for (let e = 0; e < o.length; e++) if (this.style._layers[o[e]].is3D()) {\n          this.opaquePassCutoff = e;\n          break;\n        }\n\n        if (this.terrain && (this.terrain.updateTileBinding(s), this.opaquePassCutoff = 0), \"globe\" !== this.transform.projection.name || this.globeSharedBuffers || (this.globeSharedBuffers = new e.GlobeSharedBuffers(this.context)), !e.isMapAuthenticated(this.context.gl)) return;\n        this.renderPass = \"offscreen\";\n\n        for (const e of o) {\n          const i = this.style._layers[e],\n                o = t._getLayerSourceCache(i);\n\n          if (!i.hasOffscreenPass() || i.isHidden(this.transform.zoom)) continue;\n          const r = o ? a[o.id] : void 0;\n          (\"custom\" === i.type || i.isSky() || r && r.length) && this.renderLayer(this, o, i, r);\n        }\n\n        this.depthRangeFor3D = [0, 1 - (t.order.length + 2) * this.numSublayers * this.depthEpsilon], this.terrain && (this.style.hasSymbolLayers() || this.style.hasCircleLayers()) && this.terrain.drawDepth(), this.context.bindFramebuffer.set(null), this.context.viewport.set([0, 0, this.width, this.height]);\n        let l = e.Color.transparent;\n        if (this.style.fog && this.style.fog.getOpacity(this.transform.pitch) && (l = this.style.fog.properties.get(\"color\")), this.context.clear({\n          color: i.showOverdrawInspector ? e.Color.black : l,\n          depth: 1\n        }), this.clearStencil(), this._showOverdrawInspector = i.showOverdrawInspector, this.renderPass = \"opaque\", !this.terrain) for (this.currentLayer = o.length - 1; this.currentLayer >= 0; this.currentLayer--) {\n          const e = this.style._layers[o[this.currentLayer]],\n                i = t._getLayerSourceCache(e);\n\n          if (e.isSky()) continue;\n          const r = i ? a[i.id] : void 0;\n          this._renderTileClippingMasks(e, i, r), this.renderLayer(this, i, e, r);\n        }\n        if (this.renderPass = \"sky\", (e.globeToMercatorTransition(this.transform.zoom) > 0 || \"globe\" !== this.transform.projection.name) && this.transform.isHorizonVisible()) for (this.currentLayer = 0; this.currentLayer < o.length; this.currentLayer++) {\n          const e = this.style._layers[o[this.currentLayer]],\n                i = t._getLayerSourceCache(e);\n\n          e.isSky() && this.renderLayer(this, i, e, i ? a[i.id] : void 0);\n        }\n\n        for (\"globe\" === this.transform.projection.name && function (t) {\n          const i = t.context,\n                o = i.gl,\n                r = t.transform,\n                n = new e.DepthMode(o.LEQUAL, e.DepthMode.ReadOnly, [0, 1]),\n                a = t.useProgram(\"globeAtmosphere\"),\n                s = r.centerOffset,\n                l = r._camera.getCameraToClipPerspective(r._fov, r.width / r.height, r._nearZ, r._farZ);\n\n          l[8] = 2 * -s.x / r.width, l[9] = 2 * s.y / r.height;\n          const c = e.invert([], l),\n                h = e.mul([], c, r.projMatrix),\n                _ = {\n            u_frustum_tl: Co([-1, 1, 1], c),\n            u_frustum_tr: Co([1, 1, 1], c),\n            u_frustum_br: Co([1, -1, 1], c),\n            u_frustum_bl: Co([-1, -1, 1], c),\n            u_globe_pos: Co([r.globeMatrix[12], r.globeMatrix[13], r.globeMatrix[14]], h),\n            u_globe_radius: r.worldSize / 2 / Math.PI - 1,\n            u_opacity: 1 - e.globeToMercatorTransition(r.zoom),\n            u_fadeout_range: 2,\n            u_start_color: [1, 1, 1],\n            u_end_color: [.0118, .7451, .9882]\n          };\n          t.prepareDrawProgram(i, a);\n          const u = t.globeSharedBuffers;\n          u && a.draw(i, o.TRIANGLES, n, e.StencilMode.disabled, e.ColorMode.alphaBlended, e.CullFaceMode.backCW, _, \"skybox\", u.atmosphereVertexBuffer, u.atmosphereIndexBuffer, u.atmosphereSegments);\n        }(this), this.renderPass = \"translucent\", this.currentLayer = 0; this.currentLayer < o.length;) {\n          const e = this.style._layers[o[this.currentLayer]],\n                i = t._getLayerSourceCache(e);\n\n          if (e.isSky()) {\n            ++this.currentLayer;\n            continue;\n          }\n\n          if (this.terrain && this.style.isLayerDraped(e)) {\n            if (e.isHidden(this.transform.zoom)) {\n              ++this.currentLayer;\n              continue;\n            }\n\n            this.currentLayer = this.terrain.renderBatch(this.currentLayer);\n            continue;\n          }\n\n          const r = i ? (\"symbol\" === e.type ? s : a)[i.id] : void 0;\n          this._renderTileClippingMasks(e, i, i ? n[i.id] : void 0), this.renderLayer(this, i, e, r), ++this.currentLayer;\n        }\n\n        if (this.terrain && this.terrain.postRender(), this.options.showTileBoundaries || this.options.showQueryGeometry) {\n          let i = null;\n          e.values(this.style._layers).forEach(e => {\n            const o = t._getLayerSourceCache(e);\n\n            o && !e.isHidden(this.transform.zoom) && (!i || i.getSource().maxzoom < o.getSource().maxzoom) && (i = o);\n          }), i && this.options.showTileBoundaries && Io.debug(this, i, i.getVisibleCoordinates());\n        }\n\n        this.options.showPadding && function (e) {\n          const t = e.transform.padding;\n          fo(e, e.transform.height - (t.top || 0), 3, ho), fo(e, t.bottom || 0, 3, _o), go(e, t.left || 0, 3, uo), go(e, e.transform.width - (t.right || 0), 3, po);\n          const i = e.transform.centerPoint;\n          !function (e, t, i, o) {\n            vo(e, t - 1, i - 10, 2, 20, o), vo(e, t - 10, i - 1, 20, 2, o);\n          }(e, i.x, e.transform.height - i.y, mo);\n        }(this), this.context.setDefault(), this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER, this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(e.window.performance.now()), this.saveCanvasCopy());\n      }\n\n      renderLayer(e, t, i, o) {\n        i.isHidden(this.transform.zoom) || (\"background\" === i.type || \"sky\" === i.type || \"custom\" === i.type || o && o.length) && (this.id = i.id, this.gpuTimingStart(i), e.transform.projection.unsupportedLayers && e.transform.projection.unsupportedLayers.includes(i.type) || Io[i.type](e, t, i, o, this.style.placement.variableOffsets, this.options.isInitialLoad), this.gpuTimingEnd());\n      }\n\n      gpuTimingStart(e) {\n        if (!this.options.gpuTiming) return;\n        const t = this.context.extTimerQuery;\n        let i = this.gpuTimers[e.id];\n        i || (i = this.gpuTimers[e.id] = {\n          calls: 0,\n          cpuTime: 0,\n          query: t.createQueryEXT()\n        }), i.calls++, t.beginQueryEXT(t.TIME_ELAPSED_EXT, i.query);\n      }\n\n      gpuTimingEnd() {\n        if (!this.options.gpuTiming) return;\n        const e = this.context.extTimerQuery;\n        e.endQueryEXT(e.TIME_ELAPSED_EXT);\n      }\n\n      collectGpuTimers() {\n        const e = this.gpuTimers;\n        return this.gpuTimers = {}, e;\n      }\n\n      queryGpuTimers(e) {\n        const t = {};\n\n        for (const i in e) {\n          const o = e[i],\n                r = this.context.extTimerQuery,\n                n = r.getQueryObjectEXT(o.query, r.QUERY_RESULT_EXT) / 1e6;\n          r.deleteQueryEXT(o.query), t[i] = n;\n        }\n\n        return t;\n      }\n\n      translatePosMatrix(t, i, o, r, n) {\n        if (!o[0] && !o[1]) return t;\n        const a = n ? \"map\" === r ? this.transform.angle : 0 : \"viewport\" === r ? -this.transform.angle : 0;\n\n        if (a) {\n          const e = Math.sin(a),\n                t = Math.cos(a);\n          o = [o[0] * t - o[1] * e, o[0] * e + o[1] * t];\n        }\n\n        const s = [n ? o[0] : L(i, o[0], this.transform.zoom), n ? o[1] : L(i, o[1], this.transform.zoom), 0],\n              l = new Float32Array(16);\n        return e.translate(l, t, s), l;\n      }\n\n      saveTileTexture(e) {\n        const t = this._tileTextures[e.size[0]];\n        t ? t.push(e) : this._tileTextures[e.size[0]] = [e];\n      }\n\n      getTileTexture(e) {\n        const t = this._tileTextures[e];\n        return t && t.length > 0 ? t.pop() : null;\n      }\n\n      isPatternMissing(e) {\n        if (!e) return !1;\n        if (!e.from || !e.to) return !0;\n        const t = this.imageManager.getPattern(e.from.toString()),\n              i = this.imageManager.getPattern(e.to.toString());\n        return !t || !i;\n      }\n\n      currentGlobalDefines() {\n        const e = this.terrain && this.terrain.renderingToTexture,\n              t = this.style && this.style.fog,\n              i = [];\n        return this.terrain && !this.terrain.renderingToTexture && i.push(\"TERRAIN\"), t && !e && 0 !== t.getOpacity(this.transform.pitch) && i.push(\"FOG\"), e && i.push(\"RENDER_TO_TEXTURE\"), this._showOverdrawInspector && i.push(\"OVERDRAW_INSPECTOR\"), i;\n      }\n\n      useProgram(e, t, i) {\n        this.cache = this.cache || {};\n        const o = i || [],\n              r = this.currentGlobalDefines().concat(o),\n              n = Ti.cacheKey(e, r, t);\n        return this.cache[n] || (this.cache[n] = new Ti(this.context, e, ti[e], t, Ji[e], r)), this.cache[n];\n      }\n\n      setCustomLayerDefaults() {\n        this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.frontFace.setDefault(), this.context.cullFaceSide.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();\n      }\n\n      setBaseState() {\n        const e = this.context.gl;\n        this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e.FUNC_ADD);\n      }\n\n      initDebugOverlayCanvas() {\n        null == this.debugOverlayCanvas && (this.debugOverlayCanvas = e.window.document.createElement(\"canvas\"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new e.Texture(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));\n      }\n\n      destroy() {\n        this._terrain && this._terrain.destroy(), this.globeSharedBuffers && this.globeSharedBuffers.destroy(), this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy();\n      }\n\n      prepareDrawTile() {\n        this.terrain && this.terrain.prepareDrawTile();\n      }\n\n      prepareDrawProgram(e, t, i) {\n        if (this.terrain && this.terrain.renderingToTexture) return;\n        const o = this.style.fog;\n\n        if (o) {\n          const r = o.getOpacity(this.transform.pitch);\n          0 !== r && t.setFogUniformValues(e, ((e, t, i, o) => {\n            const r = t.properties.get(\"color\"),\n                  n = e.frameCounter / 1e3 % 1,\n                  a = [r.r / r.a, r.g / r.a, r.b / r.a, o];\n            return {\n              u_fog_matrix: i ? e.transform.calculateFogTileMatrix(i) : e.identityMat,\n              u_fog_range: t.getFovAdjustedRange(e.transform._fov),\n              u_fog_color: a,\n              u_fog_horizon_blend: t.properties.get(\"horizon-blend\"),\n              u_fog_temporal_offset: n\n            };\n          })(this, o, i, r));\n        }\n      }\n\n      setTileLoadedFlag(e) {\n        this.tileLoaded = e;\n      }\n\n      saveCanvasCopy() {\n        this.frameCopies.push(this.canvasCopy()), this.tileLoaded = !1;\n      }\n\n      canvasCopy() {\n        const e = this.context.gl,\n              t = e.createTexture();\n        return e.bindTexture(e.TEXTURE_2D, t), e.copyTexImage2D(e.TEXTURE_2D, 0, e.RGBA, 0, 0, e.drawingBufferWidth, e.drawingBufferHeight, 0), t;\n      }\n\n      getCanvasCopiesAndTimestamps() {\n        return {\n          canvasCopies: this.frameCopies,\n          timeStamps: this.loadTimeStamps\n        };\n      }\n\n      averageElevationNeedsEasing() {\n        if (!this.transform._elevation) return !1;\n        const e = this.style && this.style.fog;\n        return !!e && 0 !== e.getOpacity(this.transform.pitch);\n      }\n\n      getBackgroundTiles() {\n        const t = this._backgroundTiles,\n              i = this._backgroundTiles = {},\n              o = this.transform.coveringTiles({\n          tileSize: 512\n        });\n\n        for (const r of o) i[r.key] = t[r.key] || new e.Tile(r, 512, this.transform.tileZoom, this);\n\n        return i;\n      }\n\n      clearBackgroundTiles() {\n        this._backgroundTiles = {};\n      }\n\n    }\n\n    class So {\n      constructor(e = 0, t = 0, i = 0, o = 0) {\n        if (isNaN(e) || e < 0 || isNaN(t) || t < 0 || isNaN(i) || i < 0 || isNaN(o) || o < 0) throw new Error(\"Invalid value for edge-insets, top, bottom, left and right must all be numbers\");\n        this.top = e, this.bottom = t, this.left = i, this.right = o;\n      }\n\n      interpolate(t, i, o) {\n        return null != i.top && null != t.top && (this.top = e.number(t.top, i.top, o)), null != i.bottom && null != t.bottom && (this.bottom = e.number(t.bottom, i.bottom, o)), null != i.left && null != t.left && (this.left = e.number(t.left, i.left, o)), null != i.right && null != t.right && (this.right = e.number(t.right, i.right, o)), this;\n      }\n\n      getCenter(t, i) {\n        const o = e.clamp((this.left + t - this.right) / 2, 0, t),\n              r = e.clamp((this.top + i - this.bottom) / 2, 0, i);\n        return new e.pointGeometry(o, r);\n      }\n\n      equals(e) {\n        return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right;\n      }\n\n      clone() {\n        return new So(this.top, this.bottom, this.left, this.right);\n      }\n\n      toJSON() {\n        return {\n          top: this.top,\n          bottom: this.bottom,\n          left: this.left,\n          right: this.right\n        };\n      }\n\n    }\n\n    function zo(t, i) {\n      const o = e.getColumn(t, 3);\n      e.fromQuat(t, i), e.setColumn(t, 3, o);\n    }\n\n    function Do(t, i) {\n      const o = e.identity$1([]);\n      return e.rotateZ$1(o, o, -i), e.rotateX$1(o, o, -t), o;\n    }\n\n    function Po(t, i) {\n      const o = [t[0], t[1], 0],\n            r = [i[0], i[1], 0];\n\n      if (e.length(o) >= 1e-15) {\n        const t = e.normalize([], o);\n        e.scale$2(r, t, e.dot(r, t)), i[0] = r[0], i[1] = r[1];\n      }\n\n      const n = e.cross([], i, t);\n      if (e.len(n) < 1e-15) return null;\n      const a = Math.atan2(-n[1], n[0]);\n      return Do(Math.atan2(Math.sqrt(t[0] * t[0] + t[1] * t[1]), -t[2]), a);\n    }\n\n    class Ao {\n      constructor(e, t) {\n        this.position = e, this.orientation = t;\n      }\n\n      get position() {\n        return this._position;\n      }\n\n      set position(t) {\n        if (t) {\n          const i = t instanceof e.MercatorCoordinate ? t : new e.MercatorCoordinate(t[0], t[1], t[2]);\n          this._renderWorldCopies && (i.x = e.wrap(i.x, 0, 1)), this._position = i;\n        } else this._position = null;\n      }\n\n      lookAtPoint(t, i) {\n        if (this.orientation = null, !this.position) return;\n        const o = this._elevation ? this._elevation.getAtPointOrZero(e.MercatorCoordinate.fromLngLat(t)) : 0,\n              r = this.position,\n              n = e.MercatorCoordinate.fromLngLat(t, o),\n              a = [n.x - r.x, n.y - r.y, n.z - r.z];\n        i || (i = [0, 0, 1]), i[2] = Math.abs(i[2]), this.orientation = Po(a, i);\n      }\n\n      setPitchBearing(t, i) {\n        this.orientation = Do(e.degToRad(t), e.degToRad(-i));\n      }\n\n    }\n\n    class Lo {\n      constructor(t, i) {\n        this._transform = e.identity([]), this.orientation = i, this.position = t;\n      }\n\n      get mercatorPosition() {\n        const t = this.position;\n        return new e.MercatorCoordinate(t[0], t[1], t[2]);\n      }\n\n      get position() {\n        const t = e.getColumn(this._transform, 3);\n        return [t[0], t[1], t[2]];\n      }\n\n      set position(t) {\n        var i;\n        t && e.setColumn(this._transform, 3, [(i = t)[0], i[1], i[2], 1]);\n      }\n\n      get orientation() {\n        return this._orientation;\n      }\n\n      set orientation(t) {\n        this._orientation = t || e.identity$1([]), t && zo(this._transform, this._orientation);\n      }\n\n      getPitchBearing() {\n        const e = this.forward(),\n              t = this.right();\n        return {\n          bearing: Math.atan2(-t[1], t[0]),\n          pitch: Math.atan2(Math.sqrt(e[0] * e[0] + e[1] * e[1]), -e[2])\n        };\n      }\n\n      setPitchBearing(e, t) {\n        this._orientation = Do(e, t), zo(this._transform, this._orientation);\n      }\n\n      forward() {\n        const t = e.getColumn(this._transform, 2);\n        return [-t[0], -t[1], -t[2]];\n      }\n\n      up() {\n        const t = e.getColumn(this._transform, 1);\n        return [-t[0], -t[1], -t[2]];\n      }\n\n      right() {\n        const t = e.getColumn(this._transform, 0);\n        return [t[0], t[1], t[2]];\n      }\n\n      getCameraToWorld(t, i) {\n        const o = new Float64Array(16);\n        return e.invert(o, this.getWorldToCamera(t, i)), o;\n      }\n\n      getWorldToCameraPosition(t, i, o) {\n        const r = this.position;\n        e.scale$2(r, r, -t);\n        const n = new Float64Array(16);\n        return e.fromScaling(n, [o, o, o]), e.translate(n, n, r), n[10] *= i, n;\n      }\n\n      getWorldToCamera(t, i) {\n        const o = new Float64Array(16),\n              r = new Float64Array(4),\n              n = this.position;\n        return e.conjugate(r, this._orientation), e.scale$2(n, n, -t), e.fromQuat(o, r), e.translate(o, o, n), o[1] *= -1, o[5] *= -1, o[9] *= -1, o[13] *= -1, o[8] *= i, o[9] *= i, o[10] *= i, o[11] *= i, o;\n      }\n\n      getCameraToClipPerspective(t, i, o, r) {\n        const n = new Float64Array(16);\n        return e.perspective(n, t, i, o, r), n;\n      }\n\n      getDistanceToElevation(t) {\n        const i = 0 === t ? 0 : e.mercatorZfromAltitude(t, this.position[1]),\n              o = this.forward();\n        return (i - this.position[2]) / o[2];\n      }\n\n      clone() {\n        return new Lo([...this.position], [...this.orientation]);\n      }\n\n    }\n\n    function Ro(t, i) {\n      const o = Oo(t),\n            r = function (t, i, o, r, n) {\n        const a = new e.LngLat(o.lng - 180 * Bo, o.lat),\n              s = new e.LngLat(o.lng + 180 * Bo, o.lat),\n              l = t.project(a.lng, a.lat),\n              c = t.project(s.lng, s.lat),\n              h = -Math.atan2(c.y - l.y, c.x - l.x),\n              _ = e.MercatorCoordinate.fromLngLat(o);\n\n        _.y = e.clamp(_.y, -.999975, .999975);\n\n        const u = _.toLngLat(),\n              d = t.project(u.lng, u.lat),\n              p = e.MercatorCoordinate.fromLngLat(u);\n\n        p.x += Bo;\n        const m = p.toLngLat(),\n              f = t.project(m.lng, m.lat),\n              g = Uo(f.x - d.x, f.y - d.y, h),\n              v = e.MercatorCoordinate.fromLngLat(u);\n        v.y += Bo;\n        const x = v.toLngLat(),\n              y = t.project(x.lng, x.lat),\n              b = Uo(y.x - d.x, y.y - d.y, h),\n              w = Math.abs(g.x) / Math.abs(b.y),\n              T = e.identity([]);\n        e.rotateZ(T, T, -h * (1 - (n ? 0 : r)));\n        const E = e.identity([]);\n        return e.scale(E, E, [1, 1 - (1 - w) * r, 1]), E[4] = -b.x / b.y * r, e.rotateZ(E, E, h), e.multiply$1(E, T, E), E;\n      }(t.projection, 0, t.center, o, i),\n            n = ko(t);\n\n      return e.scale(r, r, [n, n, 1]), r;\n    }\n\n    function ko(t) {\n      const i = t.projection,\n            o = Oo(t),\n            r = Fo(i, t.center),\n            n = Fo(i, e.LngLat.convert(i.center));\n      return Math.pow(2, r * o + (1 - o) * n);\n    }\n\n    function Oo(t) {\n      const i = t.projection.range;\n      if (!i) return 0;\n      const o = Math.max(t.width, t.height),\n            r = Math.log(o / 1024) / Math.LN2;\n      return e.smoothstep(i[0] + r, i[1] + r, t.zoom);\n    }\n\n    const Bo = 1 / 4e4;\n\n    function Fo(t, i) {\n      const o = e.clamp(i.lat, -e.MAX_MERCATOR_LATITUDE, e.MAX_MERCATOR_LATITUDE),\n            r = new e.LngLat(i.lng - 180 * Bo, o),\n            n = new e.LngLat(i.lng + 180 * Bo, o),\n            a = t.project(r.lng, o),\n            s = t.project(n.lng, o),\n            l = e.MercatorCoordinate.fromLngLat(r),\n            c = e.MercatorCoordinate.fromLngLat(n),\n            h = s.x - a.x,\n            _ = s.y - a.y,\n            u = c.x - l.x,\n            d = c.y - l.y,\n            p = Math.sqrt((u * u + d * d) / (h * h + _ * _));\n\n      return Math.log(p) / Math.LN2;\n    }\n\n    function Uo(e, t, i) {\n      const o = Math.cos(i),\n            r = Math.sin(i);\n      return {\n        x: e * o - t * r,\n        y: e * r + t * o\n      };\n    }\n\n    class No {\n      constructor(t, i, o, r, n, a, s) {\n        this.tileSize = 512, this._renderWorldCopies = void 0 === n || n, this._minZoom = t || 0, this._maxZoom = i || 22, this._minPitch = null == o ? 0 : o, this._maxPitch = null == r ? 60 : r, this.setProjection(a), this.setMaxBounds(s), this.width = 0, this.height = 0, this._center = new e.LngLat(0, 0), this.zoom = 0, this.angle = 0, this._fov = .6435011087932844, this._pitch = 0, this._nearZ = 0, this._farZ = 0, this._unmodified = !0, this._edgeInsets = new So(), this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._fogTileMatrixCache = {}, this._distanceTileDataCache = {}, this._camera = new Lo(), this._centerAltitude = 0, this._centerAltitudeValidForExaggeration = 0, this._averageElevation = 0, this.cameraElevationReference = \"ground\", this._projectionScaler = 1, this._horizonShift = .1;\n      }\n\n      clone() {\n        const e = new No(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies, this.getProjection());\n        return e._elevation = this._elevation, e._centerAltitude = this._centerAltitude, e._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration, e.tileSize = this.tileSize, e.width = this.width, e.height = this.height, e.cameraElevationReference = this.cameraElevationReference, e._center = this._center, e._setZoom(this.zoom), e._seaLevelZoom = this._seaLevelZoom, e.angle = this.angle, e._fov = this._fov, e._pitch = this._pitch, e._nearZ = this._nearZ, e._farZ = this._farZ, e._averageElevation = this._averageElevation, e._unmodified = this._unmodified, e._edgeInsets = this._edgeInsets.clone(), e._camera = this._camera.clone(), e._calcMatrices(), e.freezeTileCoverage = this.freezeTileCoverage, e;\n      }\n\n      get elevation() {\n        return this._elevation;\n      }\n\n      set elevation(e) {\n        this._elevation !== e && (this._elevation = e, this._updateCameraOnTerrain(), this._calcMatrices());\n      }\n\n      updateElevation(e) {\n        const t = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration;\n\n        (null == this._seaLevelZoom || t) && this._updateCameraOnTerrain(), (e || t) && this._constrainCameraAltitude(), this._calcMatrices();\n      }\n\n      getProjection() {\n        return e.pick(this.projection, [\"name\", \"center\", \"parallels\"]);\n      }\n\n      setProjection(t) {\n        null == t && (t = {\n          name: \"mercator\"\n        }), this.projectionOptions = t;\n        const i = this.projection ? this.getProjection() : void 0;\n        this.projection = e.getProjection(t);\n        const o = this.getProjection();\n        return r(i, o) ? null : (this._calcMatrices(), o);\n      }\n\n      get minZoom() {\n        return this._minZoom;\n      }\n\n      set minZoom(e) {\n        this._minZoom !== e && (this._minZoom = e, this.zoom = Math.max(this.zoom, e));\n      }\n\n      get maxZoom() {\n        return this._maxZoom;\n      }\n\n      set maxZoom(e) {\n        this._maxZoom !== e && (this._maxZoom = e, this.zoom = Math.min(this.zoom, e));\n      }\n\n      get minPitch() {\n        return this._minPitch;\n      }\n\n      set minPitch(e) {\n        this._minPitch !== e && (this._minPitch = e, this.pitch = Math.max(this.pitch, e));\n      }\n\n      get maxPitch() {\n        return this._maxPitch;\n      }\n\n      set maxPitch(e) {\n        this._maxPitch !== e && (this._maxPitch = e, this.pitch = Math.min(this.pitch, e));\n      }\n\n      get renderWorldCopies() {\n        return this._renderWorldCopies && !0 === this.projection.supportsWorldCopies;\n      }\n\n      set renderWorldCopies(e) {\n        void 0 === e ? e = !0 : null === e && (e = !1), this._renderWorldCopies = e;\n      }\n\n      get worldSize() {\n        return this.tileSize * this.scale;\n      }\n\n      get cameraWorldSize() {\n        const e = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);\n        return this._worldSizeFromZoom(this._zoomFromMercatorZ(e));\n      }\n\n      get pixelsPerMeter() {\n        return this.projection.pixelsPerMeter(this.center.lat, this.worldSize);\n      }\n\n      get cameraPixelsPerMeter() {\n        return this.projection.pixelsPerMeter(this.center.lat, this.cameraWorldSize);\n      }\n\n      get centerOffset() {\n        return this.centerPoint._sub(this.size._div(2));\n      }\n\n      get size() {\n        return new e.pointGeometry(this.width, this.height);\n      }\n\n      get bearing() {\n        return e.wrap(this.rotation, -180, 180);\n      }\n\n      set bearing(e) {\n        this.rotation = e;\n      }\n\n      get rotation() {\n        return -this.angle / Math.PI * 180;\n      }\n\n      set rotation(t) {\n        const i = -t * Math.PI / 180;\n        var o;\n        this.angle !== i && (this._unmodified = !1, this.angle = i, this._calcMatrices(), this.rotationMatrix = (o = new e.ARRAY_TYPE(4), e.ARRAY_TYPE != Float32Array && (o[1] = 0, o[2] = 0), o[0] = 1, o[3] = 1, o), function (e, t, i) {\n          var o = t[0],\n              r = t[1],\n              n = t[2],\n              a = t[3],\n              s = Math.sin(i),\n              l = Math.cos(i);\n          e[0] = o * l + n * s, e[1] = r * l + a * s, e[2] = o * -s + n * l, e[3] = r * -s + a * l;\n        }(this.rotationMatrix, this.rotationMatrix, this.angle));\n      }\n\n      get pitch() {\n        return this._pitch / Math.PI * 180;\n      }\n\n      set pitch(t) {\n        const i = e.clamp(t, this.minPitch, this.maxPitch) / 180 * Math.PI;\n        this._pitch !== i && (this._unmodified = !1, this._pitch = i, this._calcMatrices());\n      }\n\n      get fov() {\n        return this._fov / Math.PI * 180;\n      }\n\n      set fov(e) {\n        e = Math.max(.01, Math.min(60, e)), this._fov !== e && (this._unmodified = !1, this._fov = e / 180 * Math.PI, this._calcMatrices());\n      }\n\n      get averageElevation() {\n        return this._averageElevation;\n      }\n\n      set averageElevation(e) {\n        this._averageElevation = e, this._calcFogMatrices(), this._distanceTileDataCache = {};\n      }\n\n      get zoom() {\n        return this._zoom;\n      }\n\n      set zoom(e) {\n        const t = Math.min(Math.max(e, this.minZoom), this.maxZoom);\n        this._zoom !== t && (this._unmodified = !1, this._setZoom(t), this._updateSeaLevelZoom(), this._constrain(), this._calcMatrices());\n      }\n\n      _setZoom(e) {\n        this._zoom = e, this.scale = this.zoomScale(e), this.tileZoom = Math.floor(e), this.zoomFraction = e - this.tileZoom;\n      }\n\n      _updateCameraOnTerrain() {\n        if (!this._elevation || !this._elevation.isDataAvailableAtPoint(this.locationCoordinate(this.center))) return this._centerAltitude = 0, this._seaLevelZoom = null, void (this._centerAltitudeValidForExaggeration = 0);\n        const e = this._elevation;\n        this._centerAltitude = e.getAtPointOrZero(this.locationCoordinate(this.center)), this._centerAltitudeValidForExaggeration = e.exaggeration(), this._updateSeaLevelZoom();\n      }\n\n      _updateSeaLevelZoom() {\n        0 !== this._centerAltitudeValidForExaggeration && (this._seaLevelZoom = this._zoomFromMercatorZ((this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize));\n      }\n\n      sampleAverageElevation() {\n        if (!this._elevation) return 0;\n        const t = this._elevation,\n              i = [[.5, .2], [.3, .5], [.5, .5], [.7, .5], [.5, .8]],\n              o = this.horizonLineFromTop();\n        let r = 0,\n            n = 0;\n\n        for (let a = 0; a < i.length; a++) {\n          const s = new e.pointGeometry(i[a][0] * this.width, o + i[a][1] * (this.height - o)),\n                l = t.pointCoordinate(s);\n          if (!l) continue;\n          const c = 1 / Math.hypot(l[0] - this._camera.position[0], l[1] - this._camera.position[1]);\n          r += l[3] * c, n += c;\n        }\n\n        return 0 === n ? NaN : r / n;\n      }\n\n      get center() {\n        return this._center;\n      }\n\n      set center(e) {\n        e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = !1, this._center = e, this._terrainEnabled() && (\"ground\" === this.cameraElevationReference ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()), this._constrain(), this._calcMatrices());\n      }\n\n      _updateZoomFromElevation() {\n        if (null == this._seaLevelZoom || !this._elevation) return;\n\n        const e = this._seaLevelZoom,\n              t = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center)),\n              i = this.pixelsPerMeter / this.worldSize * t,\n              o = this._mercatorZfromZoom(e),\n              r = this._mercatorZfromZoom(this._maxZoom),\n              n = Math.max(o - i, r);\n\n        this._setZoom(this._zoomFromMercatorZ(n));\n      }\n\n      get padding() {\n        return this._edgeInsets.toJSON();\n      }\n\n      set padding(e) {\n        this._edgeInsets.equals(e) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices());\n      }\n\n      computeZoomRelativeTo(t) {\n        const i = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, t.toAltitude()));\n        let o;\n        o = t.z < this._camera.position[2] ? [i.x, i.y, i.z] : [t.x, t.y, t.z];\n        const r = e.length(e.sub([], this._camera.position, o));\n        return e.clamp(this._zoomFromMercatorZ(r), this._minZoom, this._maxZoom);\n      }\n\n      setFreeCameraOptions(t) {\n        if (!this.height) return;\n        if (!t.position && !t.orientation) return;\n\n        this._updateCameraState();\n\n        let i = !1;\n\n        if (t.orientation && !e.exactEquals(t.orientation, this._camera.orientation) && (i = this._setCameraOrientation(t.orientation)), t.position) {\n          const o = [t.position.x, t.position.y, t.position.z];\n          e.exactEquals$1(o, this._camera.position) || (this._setCameraPosition(o), i = !0);\n        }\n\n        i && (this._updateStateFromCamera(), this.recenterOnTerrain());\n      }\n\n      getFreeCameraOptions() {\n        this._updateCameraState();\n\n        const t = this._camera.position,\n              i = new Ao();\n        return i.position = new e.MercatorCoordinate(t[0], t[1], t[2]), i.orientation = this._camera.orientation, i._elevation = this.elevation, i._renderWorldCopies = this.renderWorldCopies, i;\n      }\n\n      _setCameraOrientation(t) {\n        if (!e.length$1(t)) return !1;\n        e.normalize$1(t, t);\n        const i = e.transformQuat([], [0, 0, -1], t),\n              o = e.transformQuat([], [0, -1, 0], t);\n        if (o[2] < 0) return !1;\n        const r = Po(i, o);\n        return !!r && (this._camera.orientation = r, !0);\n      }\n\n      _setCameraPosition(t) {\n        const i = this.zoomScale(this.minZoom) * this.tileSize,\n              o = this.zoomScale(this.maxZoom) * this.tileSize,\n              r = this.cameraToCenterDistance;\n        t[2] = e.clamp(t[2], r / o, r / i), this._camera.position = t;\n      }\n\n      get centerPoint() {\n        return this._edgeInsets.getCenter(this.width, this.height);\n      }\n\n      get fovAboveCenter() {\n        return this._fov * (.5 + this.centerOffset.y / this.height);\n      }\n\n      isPaddingEqual(e) {\n        return this._edgeInsets.equals(e);\n      }\n\n      interpolatePadding(e, t, i) {\n        this._unmodified = !1, this._edgeInsets.interpolate(e, t, i), this._constrain(), this._calcMatrices();\n      }\n\n      coveringZoomLevel(e) {\n        const t = (e.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / e.tileSize));\n        return Math.max(0, t);\n      }\n\n      getVisibleUnwrappedCoordinates(t) {\n        const i = [new e.UnwrappedTileID(0, t)];\n\n        if (this.renderWorldCopies) {\n          const o = this.pointCoordinate(new e.pointGeometry(0, 0)),\n                r = this.pointCoordinate(new e.pointGeometry(this.width, 0)),\n                n = this.pointCoordinate(new e.pointGeometry(this.width, this.height)),\n                a = this.pointCoordinate(new e.pointGeometry(0, this.height)),\n                s = Math.floor(Math.min(o.x, r.x, n.x, a.x)),\n                l = Math.floor(Math.max(o.x, r.x, n.x, a.x)),\n                c = 1;\n\n          for (let o = s - c; o <= l + c; o++) 0 !== o && i.push(new e.UnwrappedTileID(o, t));\n        }\n\n        return i;\n      }\n\n      coveringTiles(t) {\n        let i = this.coveringZoomLevel(t);\n        const o = i,\n              r = this.elevation && !t.isTerrainDEM,\n              n = \"mercator\" === this.projection.name;\n        if (void 0 !== t.minzoom && i < t.minzoom) return [];\n        void 0 !== t.maxzoom && i > t.maxzoom && (i = t.maxzoom);\n\n        const a = this.locationCoordinate(this.center),\n              s = this.center.lat,\n              l = 1 << i,\n              c = [l * a.x, l * a.y, 0],\n              h = \"globe\" === this.projection.name,\n              _ = !h,\n              u = e.Frustum.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i, _),\n              d = h ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()),\n              p = l * e.mercatorZfromAltitude(1, this.center.lat),\n              m = this._camera.position[2] / e.mercatorZfromAltitude(1, this.center.lat),\n              f = [l * d.x, l * d.y, m * (_ ? 1 : p)],\n              g = this.cameraToCenterDistance / t.tileSize * (t.roundZoom ? 1 : .502),\n              v = this.pitch <= 60 && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace ? i : 0,\n              x = t.isTerrainDEM && this._elevation ? 1e4 * this._elevation.exaggeration() : this._centerAltitude,\n              y = t.isTerrainDEM ? -x : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0,\n              b = this.projection.isReprojectedInTileSpace ? ko(this) : 1,\n              w = t => {\n          const i = 1 / 4e4,\n                o = new e.MercatorCoordinate(t.x + i, t.y, t.z),\n                r = new e.MercatorCoordinate(t.x, t.y + i, t.z),\n                n = t.toLngLat(),\n                a = o.toLngLat(),\n                s = r.toLngLat(),\n                l = this.locationCoordinate(n),\n                c = this.locationCoordinate(a),\n                h = this.locationCoordinate(s),\n                _ = Math.hypot(c.x - l.x, c.y - l.y),\n                u = Math.hypot(h.x - l.x, h.y - l.y);\n\n          return Math.sqrt(_ * u) * b / i;\n        },\n              T = t => {\n          const i = x,\n                o = y;\n          return {\n            aabb: e.tileAABB(this, l, 0, 0, 0, t, o, i, this.projection),\n            zoom: 0,\n            x: 0,\n            y: 0,\n            minZ: o,\n            maxZ: i,\n            wrap: t,\n            fullyVisible: !1\n          };\n        },\n              E = [];\n\n        let C = [];\n\n        const I = i,\n              M = t.reparseOverscaled ? o : i,\n              S = e => e * e,\n              z = S((m - this._centerAltitude) * p),\n              D = e => {\n          if (!this._elevation || !e.tileID || !n) return;\n\n          const t = this._elevation.getMinMaxForTile(e.tileID),\n                i = e.aabb;\n\n          t ? (i.min[2] = t.min, i.max[2] = t.max, i.center[2] = (i.min[2] + i.max[2]) / 2) : (e.shouldSplit = P(e), e.shouldSplit || (i.min[2] = i.max[2] = i.center[2] = this._centerAltitude));\n        },\n              P = t => {\n          if (t.zoom < v) return !0;\n          if (t.zoom === I) return !1;\n          if (null != t.shouldSplit) return t.shouldSplit;\n          const i = t.aabb.distanceX(f),\n                n = t.aabb.distanceY(f);\n          let a = z,\n              l = 1;\n\n          if (h) {\n            a = S(t.aabb.distanceZ(f));\n            const i = Math.pow(2, t.zoom),\n                  o = e.latFromMercatorY((t.y + 1) / i),\n                  r = e.latFromMercatorY(t.y / i),\n                  n = Math.min(Math.max(s, o), r),\n                  c = e.circumferenceAtLatitude(n) / e.circumferenceAtLatitude(s);\n            l = Math.min(c, 1);\n          } else if (r && (a = S(t.aabb.distanceZ(f) * p)), this.projection.isReprojectedInTileSpace && o <= 5) {\n            const i = Math.pow(2, t.zoom),\n                  o = w(new e.MercatorCoordinate((t.x + .5) / i, (t.y + .5) / i));\n            l = o > .85 ? 1 : o;\n          }\n\n          const c = i * i + n * n + a;\n          return c < S((1 << I - t.zoom) * g * l * ((e, t) => {\n            if (t * S(.707) < e) return 1;\n            const i = Math.sqrt(t / e);\n            return i / (1.4144271570014144 + (Math.pow(1.1, i - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1);\n          })(Math.max(a, z), c));\n        };\n\n        if (this.renderWorldCopies) for (let e = 1; e <= 3; e++) E.push(T(-e)), E.push(T(e));\n\n        for (E.push(T(0)); E.length > 0;) {\n          const o = E.pop(),\n                a = o.x,\n                s = o.y;\n          let _ = o.fullyVisible;\n\n          if (!_) {\n            const e = o.aabb.intersects(u);\n            if (0 === e) continue;\n            _ = 2 === e;\n          }\n\n          if (o.zoom !== I && P(o)) for (let t = 0; t < 4; t++) {\n            const i = (a << 1) + t % 2,\n                  c = (s << 1) + (t >> 1),\n                  u = {\n              aabb: n ? o.aabb.quadrant(t) : e.tileAABB(this, l, o.zoom + 1, i, c, o.wrap, o.minZ, o.maxZ, this.projection),\n              zoom: o.zoom + 1,\n              x: i,\n              y: c,\n              wrap: o.wrap,\n              fullyVisible: _,\n              tileID: void 0,\n              shouldSplit: void 0,\n              minZ: o.minZ,\n              maxZ: o.maxZ\n            };\n            r && !h && (u.tileID = new e.OverscaledTileID(o.zoom + 1 === I ? M : o.zoom + 1, o.wrap, o.zoom + 1, i, c), D(u)), E.push(u);\n          } else {\n            const r = o.zoom === I ? M : o.zoom;\n            if (t.minzoom && t.minzoom > r) continue;\n            const n = c[0] - (.5 + a + (o.wrap << o.zoom)) * (1 << i - o.zoom),\n                  l = c[1] - .5 - s,\n                  h = o.tileID ? o.tileID : new e.OverscaledTileID(r, o.wrap, o.zoom, a, s);\n            C.push({\n              tileID: h,\n              distanceSq: n * n + l * l\n            });\n          }\n        }\n\n        if (this.fogCullDistSq) {\n          const i = this.fogCullDistSq,\n                o = this.horizonLineFromTop();\n          C = C.filter(r => {\n            const n = [0, 0, 0, 1],\n                  a = [e.EXTENT, e.EXTENT, 0, 1],\n                  s = this.calculateFogTileMatrix(r.tileID.toUnwrapped());\n            e.transformMat4$1(n, n, s), e.transformMat4$1(a, a, s);\n            const l = e.getAABBPointSquareDist(n, a);\n            if (0 === l) return !0;\n            let c = !1;\n            const h = this._elevation;\n\n            if (h && l > i && 0 !== o) {\n              const i = this.calculateProjMatrix(r.tileID.toUnwrapped());\n              let n;\n              t.isTerrainDEM || (n = h.getMinMaxForTile(r.tileID)), n || (n = {\n                min: y,\n                max: x\n              });\n              const a = e.furthestTileCorner(this.rotation),\n                    s = [a[0] * e.EXTENT, a[1] * e.EXTENT, n.max];\n              e.transformMat4(s, s, i), c = (1 - s[1]) * this.height * .5 < o;\n            }\n\n            return l < i || c;\n          });\n        }\n\n        return C.sort((e, t) => e.distanceSq - t.distanceSq).map(e => e.tileID);\n      }\n\n      resize(e, t) {\n        this.width = e, this.height = t, this.pixelsToGLUnits = [2 / e, -2 / t], this._constrain(), this._calcMatrices();\n      }\n\n      get unmodified() {\n        return this._unmodified;\n      }\n\n      zoomScale(e) {\n        return Math.pow(2, e);\n      }\n\n      scaleZoom(e) {\n        return Math.log(e) / Math.LN2;\n      }\n\n      project(t) {\n        const i = e.clamp(t.lat, -e.MAX_MERCATOR_LATITUDE, e.MAX_MERCATOR_LATITUDE),\n              o = this.projection.project(t.lng, i);\n        return new e.pointGeometry(o.x * this.worldSize, o.y * this.worldSize);\n      }\n\n      unproject(e) {\n        return this.projection.unproject(e.x / this.worldSize, e.y / this.worldSize);\n      }\n\n      get point() {\n        return this.project(this.center);\n      }\n\n      setLocationAtPoint(t, i) {\n        let o, r;\n        const n = this.centerPoint;\n\n        if (\"globe\" === this.projection.name) {\n          const e = this.worldSize;\n          o = (i.x - n.x) / e, r = (i.y - n.y) / e;\n        } else {\n          const e = this.pointCoordinate(i),\n                t = this.pointCoordinate(n);\n          o = e.x - t.x, r = e.y - t.y;\n        }\n\n        const a = this.locationCoordinate(t);\n        this.setLocation(new e.MercatorCoordinate(a.x - o, a.y - r));\n      }\n\n      setLocation(e) {\n        this.center = this.coordinateLocation(e), this.projection.wrap && (this.center = this.center.wrap());\n      }\n\n      locationPoint(e) {\n        return this.projection.locationPoint(this, e);\n      }\n\n      locationPoint3D(e) {\n        return this._coordinatePoint(this.locationCoordinate(e), !0);\n      }\n\n      pointLocation(e) {\n        return this.coordinateLocation(this.pointCoordinate(e));\n      }\n\n      pointLocation3D(e) {\n        return this.coordinateLocation(this.pointCoordinate3D(e));\n      }\n\n      locationCoordinate(t, i) {\n        const o = i ? e.mercatorZfromAltitude(i, t.lat) : void 0,\n              r = this.projection.project(t.lng, t.lat);\n        return new e.MercatorCoordinate(r.x, r.y, o);\n      }\n\n      coordinateLocation(e) {\n        return this.projection.unproject(e.x, e.y);\n      }\n\n      pointRayIntersection(t, i) {\n        const o = null != i ? i : this._centerAltitude,\n              r = [t.x, t.y, 0, 1],\n              n = [t.x, t.y, 1, 1];\n        e.transformMat4$1(r, r, this.pixelMatrixInverse), e.transformMat4$1(n, n, this.pixelMatrixInverse);\n        const a = n[3];\n        e.scale$1(r, r, 1 / r[3]), e.scale$1(n, n, 1 / a);\n        const s = r[2],\n              l = n[2];\n        return {\n          p0: r,\n          p1: n,\n          t: s === l ? 0 : (o - s) / (l - s)\n        };\n      }\n\n      screenPointToMercatorRay(t) {\n        const i = [t.x, t.y, 0, 1],\n              o = [t.x, t.y, 1, 1];\n        return e.transformMat4$1(i, i, this.pixelMatrixInverse), e.transformMat4$1(o, o, this.pixelMatrixInverse), e.scale$1(i, i, 1 / i[3]), e.scale$1(o, o, 1 / o[3]), i[2] = e.mercatorZfromAltitude(i[2], this._center.lat) * this.worldSize, o[2] = e.mercatorZfromAltitude(o[2], this._center.lat) * this.worldSize, e.scale$1(i, i, 1 / this.worldSize), e.scale$1(o, o, 1 / this.worldSize), new e.Ray([i[0], i[1], i[2]], e.normalize([], e.sub([], o, i)));\n      }\n\n      rayIntersectionCoordinate(t) {\n        const {\n          p0: i,\n          p1: o,\n          t: r\n        } = t,\n              n = e.mercatorZfromAltitude(i[2], this._center.lat),\n              a = e.mercatorZfromAltitude(o[2], this._center.lat);\n        return new e.MercatorCoordinate(e.number(i[0], o[0], r) / this.worldSize, e.number(i[1], o[1], r) / this.worldSize, e.number(n, a, r));\n      }\n\n      pointCoordinate(e, t = this._centerAltitude) {\n        return this.projection.pointCoordinate(this, e.x, e.y, t);\n      }\n\n      pointCoordinate3D(t) {\n        if (!this.elevation) return this.pointCoordinate(t);\n        const i = this.elevation;\n        let o = this.elevation.pointCoordinate(t);\n        if (o) return new e.MercatorCoordinate(o[0], o[1], o[2]);\n        let r = 0,\n            n = this.horizonLineFromTop();\n        if (t.y > n) return this.pointCoordinate(t);\n        const a = .02 * n,\n              s = t.clone();\n\n        for (let t = 0; t < 10 && n - r > a; t++) {\n          s.y = e.number(r, n, .66);\n          const t = i.pointCoordinate(s);\n          t ? (n = s.y, o = t) : r = s.y;\n        }\n\n        return o ? new e.MercatorCoordinate(o[0], o[1], o[2]) : this.pointCoordinate(t);\n      }\n\n      isPointAboveHorizon(e) {\n        if (this.elevation) return !this.elevation.pointCoordinate(e);\n        {\n          const t = this.horizonLineFromTop();\n          return e.y < t;\n        }\n      }\n\n      _coordinatePoint(t, i) {\n        const o = i && this.elevation ? this.elevation.getAtPointOrZero(t, this._centerAltitude) : this._centerAltitude,\n              r = [t.x * this.worldSize, t.y * this.worldSize, o + t.toAltitude(), 1];\n        return e.transformMat4$1(r, r, this.pixelMatrix), r[3] > 0 ? new e.pointGeometry(r[0] / r[3], r[1] / r[3]) : new e.pointGeometry(Number.MAX_VALUE, Number.MAX_VALUE);\n      }\n\n      _getBounds(t, i) {\n        const o = new e.pointGeometry(this._edgeInsets.left, this._edgeInsets.top),\n              r = new e.pointGeometry(this.width - this._edgeInsets.right, this._edgeInsets.top),\n              n = new e.pointGeometry(this.width - this._edgeInsets.right, this.height - this._edgeInsets.bottom),\n              a = new e.pointGeometry(this._edgeInsets.left, this.height - this._edgeInsets.bottom);\n        let s = this.pointCoordinate(o, t),\n            l = this.pointCoordinate(r, t);\n\n        const c = this.pointCoordinate(n, i),\n              h = this.pointCoordinate(a, i),\n              _ = (e, t) => (t.y - e.y) / (t.x - e.x);\n\n        return s.y > 1 && l.y >= 0 ? s = new e.MercatorCoordinate((1 - h.y) / _(h, s) + h.x, 1) : s.y < 0 && l.y <= 1 && (s = new e.MercatorCoordinate(-h.y / _(h, s) + h.x, 0)), l.y > 1 && s.y >= 0 ? l = new e.MercatorCoordinate((1 - c.y) / _(c, l) + c.x, 1) : l.y < 0 && s.y <= 1 && (l = new e.MercatorCoordinate(-c.y / _(c, l) + c.x, 0)), new e.LngLatBounds().extend(this.coordinateLocation(s)).extend(this.coordinateLocation(l)).extend(this.coordinateLocation(h)).extend(this.coordinateLocation(c));\n      }\n\n      _getBounds3D() {\n        const e = this.elevation;\n        if (!e.visibleDemTiles.length) return this._getBounds(0, 0);\n        const t = e.visibleDemTiles.reduce((e, t) => {\n          if (t.dem) {\n            const i = t.dem.tree;\n            e.min = Math.min(e.min, i.minimums[0]), e.max = Math.max(e.max, i.maximums[0]);\n          }\n\n          return e;\n        }, {\n          min: Number.MAX_VALUE,\n          max: 0\n        });\n        return this._getBounds(t.min * e.exaggeration(), t.max * e.exaggeration());\n      }\n\n      getBounds() {\n        return this._terrainEnabled() ? this._getBounds3D() : this._getBounds(0, 0);\n      }\n\n      horizonLineFromTop(e = !0) {\n        const t = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, .1)) + this.centerOffset.y,\n              i = this.height / 2 - t * (1 - this._horizonShift);\n        return e ? Math.max(0, i) : i;\n      }\n\n      getMaxBounds() {\n        return this.maxBounds;\n      }\n\n      setMaxBounds(t) {\n        this.maxBounds = t, this.minLat = -e.MAX_MERCATOR_LATITUDE, this.maxLat = e.MAX_MERCATOR_LATITUDE, this.minLng = -180, this.maxLng = 180, t && (this.minLat = t.getSouth(), this.maxLat = t.getNorth(), this.minLng = t.getWest(), this.maxLng = t.getEast(), this.maxLng < this.minLng && (this.maxLng += 360)), this.worldMinX = e.mercatorXfromLng(this.minLng) * this.tileSize, this.worldMaxX = e.mercatorXfromLng(this.maxLng) * this.tileSize, this.worldMinY = e.mercatorYfromLat(this.maxLat) * this.tileSize, this.worldMaxY = e.mercatorYfromLat(this.minLat) * this.tileSize, this._constrain();\n      }\n\n      calculatePosMatrix(e, t) {\n        return this.projection.createTileMatrix(this, t, e);\n      }\n\n      calculateDistanceTileData(t) {\n        const i = t.key,\n              o = this._distanceTileDataCache;\n        if (o[i]) return o[i];\n\n        const r = t.canonical,\n              n = 1 / this.height,\n              a = this.cameraWorldSize / this.zoomScale(r.z),\n              s = (r.x + Math.pow(2, r.z) * t.wrap) * a,\n              l = r.y * a,\n              c = this.point,\n              h = this.angle,\n              _ = Math.sin(-h),\n              u = -Math.cos(-h);\n\n        return o[i] = {\n          bearing: [_, u],\n          center: [(c.x - s) * n, (c.y - l) * n],\n          scale: a / e.EXTENT * n\n        }, o[i];\n      }\n\n      calculateFogTileMatrix(t) {\n        const i = t.key,\n              o = this._fogTileMatrixCache;\n        if (o[i]) return o[i];\n        const r = this.calculatePosMatrix(t, this.cameraWorldSize);\n        return e.multiply$1(r, this.worldToFogMatrix, r), o[i] = new Float32Array(r), o[i];\n      }\n\n      calculateProjMatrix(t, i = !1) {\n        const o = t.key,\n              r = i ? this._alignedProjMatrixCache : this._projMatrixCache;\n        if (r[o]) return r[o];\n        const n = this.calculatePosMatrix(t, this.worldSize);\n        return e.multiply$1(n, this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : i ? this.alignedProjMatrix : this.projMatrix, n), r[o] = new Float32Array(n), r[o];\n      }\n\n      calculatePixelsToTileUnitsMatrix(t) {\n        const i = t.tileID.key,\n              o = this._pixelsToTileUnitsCache;\n        if (o[i]) return o[i];\n\n        const r = function (t, i) {\n          const {\n            scale: o\n          } = t.tileTransform,\n                r = o * e.EXTENT / (t.tileSize * Math.pow(2, i.zoom - t.tileID.overscaledZ + t.tileID.canonical.z));\n          return n = new Float32Array(4), l = (a = i.inverseAdjustmentMatrix)[1], c = a[2], h = a[3], u = (s = [r, r])[1], n[0] = a[0] * (_ = s[0]), n[1] = l * _, n[2] = c * u, n[3] = h * u, n;\n\n          var n, a, s, l, c, h, _, u;\n        }(t, this);\n\n        return o[i] = r, o[i];\n      }\n\n      customLayerMatrix() {\n        return this.mercatorMatrix.slice();\n      }\n\n      recenterOnTerrain() {\n        if (!this._elevation) return;\n        const t = this._elevation;\n\n        this._updateCameraState();\n\n        const i = e.mercatorZfromAltitude(1, this._center.lat) * this.worldSize,\n              o = this._computeCameraPosition(i),\n              r = this._camera.forward(),\n              n = e.mercatorZfromAltitude(1, this._center.lat);\n\n        o[2] /= n, r[2] /= n, e.normalize(r, r);\n        const a = t.raycast(o, r, t.exaggeration());\n\n        if (a) {\n          const t = e.scaleAndAdd([], o, r, a),\n                i = new e.MercatorCoordinate(t[0], t[1], e.mercatorZfromAltitude(t[2], e.latFromMercatorY(t[1]))),\n                s = (i.z + e.length([i.x - o[0], i.y - o[1], i.z - o[2] * n])) * this._projectionScaler;\n\n          this._seaLevelZoom = this._zoomFromMercatorZ(s), this._centerAltitude = i.toAltitude(), this._center = this.coordinateLocation(i), this._updateZoomFromElevation(), this._constrain(), this._calcMatrices();\n        }\n      }\n\n      _constrainCameraAltitude() {\n        if (!this._elevation) return;\n        const t = this._elevation;\n\n        this._updateCameraState();\n\n        const i = e.mercatorZfromAltitude(1, this._center.lat) * this.worldSize,\n              o = this._computeCameraPosition(i),\n              r = t.getAtPointOrZero(new e.MercatorCoordinate(...o)),\n              n = this._minimumHeightOverTerrain() * Math.cos(e.degToRad(this._maxPitch)),\n              a = this._camera.position[2] - this.pixelsPerMeter / this.worldSize * r;\n\n        if (a < n) {\n          const t = this.locationCoordinate(this._center, this._centerAltitude),\n                i = [t.x - o[0], t.y - o[1], t.z - o[2]],\n                r = e.length(i);\n          i[2] -= (n - a) / this._projectionScaler;\n          const s = e.length(i);\n          if (0 === s) return;\n          e.scale$2(i, i, r / s * this._projectionScaler), this._camera.position = [t.x - i[0], t.y - i[1], t.z * this._projectionScaler - i[2]], this._camera.orientation = Po(i, this._camera.up()), this._updateStateFromCamera();\n        }\n      }\n\n      _constrain() {\n        if (!this.center || !this.width || !this.height || this._constraining) return;\n\n        if (this._constraining = !0, this.projection.isReprojectedInTileSpace) {\n          const t = this.center;\n          return t.lat = e.clamp(t.lat, this.minLat, this.maxLat), !this.maxBounds && this.renderWorldCopies || (t.lng = e.clamp(t.lng, this.minLng, this.maxLng)), this.center = t, void (this._constraining = !1);\n        }\n\n        const t = this._unmodified,\n              {\n          x: i,\n          y: o\n        } = this.point;\n        let r = 0,\n            n = i,\n            a = o;\n        const s = this.width / 2,\n              l = this.height / 2,\n              c = this.worldMinY * this.scale,\n              h = this.worldMaxY * this.scale;\n\n        if (o - l < c && (a = c + l), o + l > h && (a = h - l), h - c < this.height && (r = Math.max(r, this.height / (h - c)), a = (h + c) / 2), this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {\n          const e = this.worldMinX * this.scale,\n                t = this.worldMaxX * this.scale,\n                o = this.worldSize / 2 - (e + t) / 2;\n          n = (i + o + this.worldSize) % this.worldSize - o, n - s < e && (n = e + s), n + s > t && (n = t - s), t - e < this.width && (r = Math.max(r, this.width / (t - e)), n = (t + e) / 2);\n        }\n\n        n === i && a === o || (this.center = this.unproject(new e.pointGeometry(n, a))), r && (this.zoom += this.scaleZoom(r)), this._constrainCameraAltitude(), this._unmodified = t, this._constraining = !1;\n      }\n\n      _minZoomForBounds() {\n        let e = Math.max(0, this.scaleZoom(this.height / (this.worldMaxY - this.worldMinY)));\n        return this.maxBounds && (e = Math.max(e, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))), e;\n      }\n\n      _maxCameraBoundsDistance() {\n        return this._mercatorZfromZoom(this._minZoomForBounds());\n      }\n\n      _calcMatrices() {\n        if (!this.height) return;\n        const t = this._fov / 2,\n              i = this.centerOffset,\n              o = this.pixelsPerMeter;\n        this._projectionScaler = o / (e.mercatorZfromAltitude(1, this.center.lat) * this.worldSize), this.cameraToCenterDistance = .5 / Math.tan(t) * this.height * this._projectionScaler, this._updateCameraState(), this._farZ = this.projection.farthestPixelDistance(this), this._nearZ = this.height / 50;\n\n        const r = this._camera.getWorldToCamera(this.worldSize, \"meters\" === this.projection.zAxisUnit ? o : 1),\n              n = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);\n\n        n[8] = 2 * -i.x / this.width, n[9] = 2 * i.y / this.height;\n        let a = e.mul([], n, r);\n\n        if (this.projection.isReprojectedInTileSpace) {\n          const t = this.locationCoordinate(this.center),\n                i = e.identity([]);\n          e.translate(i, i, [t.x * this.worldSize, t.y * this.worldSize, 0]), e.multiply$1(i, i, Ro(this)), e.translate(i, i, [-t.x * this.worldSize, -t.y * this.worldSize, 0]), e.multiply$1(a, a, i), this.inverseAdjustmentMatrix = function (e) {\n            const t = Ro(e, !0);\n            return v([], [t[0], t[1], t[4], t[5]]);\n          }(this);\n        } else this.inverseAdjustmentMatrix = [1, 0, 0, 1];\n\n        this.mercatorMatrix = e.scale([], a, [this.worldSize, this.worldSize, this.worldSize / o, 1]), this.projMatrix = a, this.invProjMatrix = e.invert(new Float64Array(16), this.projMatrix);\n        const s = new Float32Array(16);\n        e.identity(s), e.scale(s, s, [1, -1, 1]), e.rotateX(s, s, this._pitch), e.rotateZ(s, s, this.angle);\n        const l = e.perspective(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ),\n              c = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;\n        l[8] = 2 * -i.x / this.width, l[9] = 2 * (i.y + c) / this.height, this.skyboxMatrix = e.multiply$1(s, l, s);\n        const h = this.point,\n              _ = h.x,\n              u = h.y,\n              d = this.width % 2 / 2,\n              p = this.height % 2 / 2,\n              m = Math.cos(this.angle),\n              f = Math.sin(this.angle),\n              g = _ - Math.round(_) + m * d + f * p,\n              x = u - Math.round(u) + m * p + f * d,\n              y = new Float64Array(a);\n        if (e.translate(y, y, [g > .5 ? g - 1 : g, x > .5 ? x - 1 : x, 0]), this.alignedProjMatrix = y, a = e.create(), e.scale(a, a, [this.width / 2, -this.height / 2, 1]), e.translate(a, a, [1, -1, 0]), this.labelPlaneMatrix = a, a = e.create(), e.scale(a, a, [1, -1, 1]), e.translate(a, a, [-1, -1, 0]), e.scale(a, a, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = a, this.pixelMatrix = e.multiply$1(new Float64Array(16), this.labelPlaneMatrix, this.projMatrix), this._calcFogMatrices(), this._distanceTileDataCache = {}, a = e.invert(new Float64Array(16), this.pixelMatrix), !a) throw new Error(\"failed to invert matrix\");\n        this.pixelMatrixInverse = a, this.globeMatrix = \"globe\" === this.projection.name ? e.calculateGlobeMatrix(this) : a, this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._pixelsToTileUnitsCache = {};\n      }\n\n      _calcFogMatrices() {\n        this._fogTileMatrixCache = {};\n        const t = this.cameraWorldSize,\n              i = this.cameraPixelsPerMeter,\n              o = this._camera.position,\n              r = 1 / this.height,\n              n = [t, t, i];\n        e.scale$2(n, n, r), e.scale$2(o, o, -1), e.multiply$2(o, o, n);\n        const a = e.create();\n        e.translate(a, a, o), e.scale(a, a, n), this.mercatorFogMatrix = a, this.worldToFogMatrix = this._camera.getWorldToCameraPosition(t, i, r);\n      }\n\n      _computeCameraPosition(e) {\n        const t = (e = e || this.pixelsPerMeter) / this.pixelsPerMeter,\n              i = this._camera.forward(),\n              o = this.point,\n              r = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * t - e / this.worldSize * this._centerAltitude;\n\n        return [o.x / this.worldSize - i[0] * r, o.y / this.worldSize - i[1] * r, e / this.worldSize * this._centerAltitude - i[2] * r];\n      }\n\n      _updateCameraState() {\n        this.height && (this._camera.setPitchBearing(this._pitch, this.angle), this._camera.position = this._computeCameraPosition());\n      }\n\n      _translateCameraConstrained(t) {\n        const i = this._maxCameraBoundsDistance() * Math.cos(this._pitch),\n              o = t[2];\n        let r = 1;\n        o > 0 && (r = Math.min((i - this._camera.position[2]) / o, 1)), this._camera.position = e.scaleAndAdd([], this._camera.position, t, r), this._updateStateFromCamera(), this.projection.wrap && (this.center = this.center.wrap());\n      }\n\n      _updateStateFromCamera() {\n        const t = this._camera.position,\n              i = this._camera.forward(),\n              {\n          pitch: o,\n          bearing: r\n        } = this._camera.getPitchBearing(),\n              n = e.mercatorZfromAltitude(this._centerAltitude, this.center.lat) * this._projectionScaler,\n              a = this._mercatorZfromZoom(this._maxZoom) * Math.cos(e.degToRad(this._maxPitch)),\n              s = Math.max((t[2] - n) / Math.cos(o), a),\n              l = this._zoomFromMercatorZ(s);\n\n        e.scaleAndAdd(t, t, i, s), this._pitch = e.clamp(o, e.degToRad(this.minPitch), e.degToRad(this.maxPitch)), this.angle = e.wrap(r, -Math.PI, Math.PI), this._setZoom(e.clamp(l, this._minZoom, this._maxZoom)), this._updateSeaLevelZoom(), this._center = this.coordinateLocation(new e.MercatorCoordinate(t[0], t[1], t[2])), this._unmodified = !1, this._constrain(), this._calcMatrices();\n      }\n\n      _worldSizeFromZoom(e) {\n        return Math.pow(2, e) * this.tileSize;\n      }\n\n      _mercatorZfromZoom(e) {\n        return this.cameraToCenterDistance / this._worldSizeFromZoom(e);\n      }\n\n      _minimumHeightOverTerrain() {\n        const e = Math.min((null != this._seaLevelZoom ? this._seaLevelZoom : this._zoom) + 2, this._maxZoom);\n        return this._mercatorZfromZoom(e);\n      }\n\n      _zoomFromMercatorZ(e) {\n        return this.scaleZoom(this.cameraToCenterDistance / (e * this.tileSize));\n      }\n\n      _terrainEnabled() {\n        return !(!this._elevation || !this.projection.supportsTerrain && (e.warnOnce(\"Terrain is not yet supported with alternate projections. Use mercator to enable terrain.\"), 1));\n      }\n\n      anyCornerOffEdge(t, i) {\n        const o = Math.min(t.x, i.x),\n              r = Math.max(t.x, i.x),\n              n = Math.min(t.y, i.y),\n              a = Math.max(t.y, i.y);\n        if (n < this.horizonLineFromTop(!1)) return !0;\n        if (\"mercator\" !== this.projection.name) return !1;\n        const s = [new e.pointGeometry(o, n), new e.pointGeometry(r, a), new e.pointGeometry(o, a), new e.pointGeometry(r, n)],\n              l = this.renderWorldCopies ? -3 : 0,\n              c = this.renderWorldCopies ? 4 : 1;\n\n        for (const e of s) {\n          const t = this.pointRayIntersection(e);\n          if (t.t < 0) return !0;\n          const i = this.rayIntersectionCoordinate(t);\n          if (i.x < l || i.y < 0 || i.x > c || i.y > 1) return !0;\n        }\n\n        return !1;\n      }\n\n      isHorizonVisible() {\n        return this.pitch + e.radToDeg(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new e.pointGeometry(0, 0), new e.pointGeometry(this.width, this.height));\n      }\n\n      zoomDeltaToMovement(t, i) {\n        const o = e.length(e.sub([], this._camera.position, t)),\n              r = this._zoomFromMercatorZ(o) + i;\n        return o - this._mercatorZfromZoom(r);\n      }\n\n      getCameraPoint() {\n        const t = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);\n        return this.centerPoint.add(new e.pointGeometry(0, t));\n      }\n\n    }\n\n    function Go(e, t) {\n      let i = !1,\n          o = null;\n\n      const r = () => {\n        o = null, i && (e(), o = setTimeout(r, t), i = !1);\n      };\n\n      return () => (i = !0, o || r(), o);\n    }\n\n    class jo {\n      constructor(t) {\n        this._hashName = t && encodeURIComponent(t), e.bindAll([\"_getCurrentHash\", \"_onHashChange\", \"_updateHash\"], this), this._updateHash = Go(this._updateHashUnthrottled.bind(this), 300);\n      }\n\n      addTo(t) {\n        return this._map = t, e.window.addEventListener(\"hashchange\", this._onHashChange, !1), t.on(\"moveend\", this._updateHash), this;\n      }\n\n      remove() {\n        return this._map ? (this._map.off(\"moveend\", this._updateHash), e.window.removeEventListener(\"hashchange\", this._onHashChange, !1), clearTimeout(this._updateHash()), this._map = void 0, this) : this;\n      }\n\n      getHashString(t) {\n        const i = this._map;\n        if (!i) return \"\";\n        const o = i.getCenter(),\n              r = Math.round(100 * i.getZoom()) / 100,\n              n = Math.ceil((r * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10),\n              a = Math.pow(10, n),\n              s = Math.round(o.lng * a) / a,\n              l = Math.round(o.lat * a) / a,\n              c = i.getBearing(),\n              h = i.getPitch();\n        let _ = \"\";\n\n        if (_ += t ? `/${s}/${l}/${r}` : `${r}/${l}/${s}`, (c || h) && (_ += \"/\" + Math.round(10 * c) / 10), h && (_ += `/${Math.round(h)}`), this._hashName) {\n          const t = this._hashName;\n          let i = !1;\n          const o = e.window.location.hash.slice(1).split(\"&\").map(e => {\n            const o = e.split(\"=\")[0];\n            return o === t ? (i = !0, `${o}=${_}`) : e;\n          }).filter(e => e);\n          return i || o.push(`${t}=${_}`), `#${o.join(\"&\")}`;\n        }\n\n        return `#${_}`;\n      }\n\n      _getCurrentHash() {\n        const t = e.window.location.hash.replace(\"#\", \"\");\n\n        if (this._hashName) {\n          let e;\n          return t.split(\"&\").map(e => e.split(\"=\")).forEach(t => {\n            t[0] === this._hashName && (e = t);\n          }), (e && e[1] || \"\").split(\"/\");\n        }\n\n        return t.split(\"/\");\n      }\n\n      _onHashChange() {\n        const e = this._map;\n        if (!e) return !1;\n\n        const t = this._getCurrentHash();\n\n        if (t.length >= 3 && !t.some(e => isNaN(e))) {\n          const i = e.dragRotate.isEnabled() && e.touchZoomRotate.isEnabled() ? +(t[3] || 0) : e.getBearing();\n          return e.jumpTo({\n            center: [+t[2], +t[1]],\n            zoom: +t[0],\n            bearing: i,\n            pitch: +(t[4] || 0)\n          }), !0;\n        }\n\n        return !1;\n      }\n\n      _updateHashUnthrottled() {\n        const t = e.window.location.href.replace(/(#.+)?$/, this.getHashString());\n        e.window.history.replaceState(e.window.history.state, null, t);\n      }\n\n    }\n\n    const Zo = {\n      linearity: .3,\n      easing: e.bezier(0, 0, .3, 1)\n    },\n          Vo = e.extend({\n      deceleration: 2500,\n      maxSpeed: 1400\n    }, Zo),\n          Wo = e.extend({\n      deceleration: 20,\n      maxSpeed: 1400\n    }, Zo),\n          qo = e.extend({\n      deceleration: 1e3,\n      maxSpeed: 360\n    }, Zo),\n          Xo = e.extend({\n      deceleration: 1e3,\n      maxSpeed: 90\n    }, Zo);\n\n    class $o {\n      constructor(e) {\n        this._map = e, this.clear();\n      }\n\n      clear() {\n        this._inertiaBuffer = [];\n      }\n\n      record(t) {\n        this._drainInertiaBuffer(), this._inertiaBuffer.push({\n          time: e.exported.now(),\n          settings: t\n        });\n      }\n\n      _drainInertiaBuffer() {\n        const t = this._inertiaBuffer,\n              i = e.exported.now();\n\n        for (; t.length > 0 && i - t[0].time > 160;) t.shift();\n      }\n\n      _onMoveEnd(t) {\n        if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;\n        const i = {\n          zoom: 0,\n          bearing: 0,\n          pitch: 0,\n          pan: new e.pointGeometry(0, 0),\n          pinchAround: void 0,\n          around: void 0\n        };\n\n        for (const {\n          settings: e\n        } of this._inertiaBuffer) i.zoom += e.zoomDelta || 0, i.bearing += e.bearingDelta || 0, i.pitch += e.pitchDelta || 0, e.panDelta && i.pan._add(e.panDelta), e.around && (i.around = e.around), e.pinchAround && (i.pinchAround = e.pinchAround);\n\n        const o = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time,\n              r = {};\n\n        if (i.pan.mag()) {\n          const n = Ko(i.pan.mag(), o, e.extend({}, Vo, t || {}));\n          r.offset = i.pan.mult(n.amount / i.pan.mag()), r.center = this._map.transform.center, Ho(r, n);\n        }\n\n        if (i.zoom) {\n          const e = Ko(i.zoom, o, Wo);\n          r.zoom = this._map.transform.zoom + e.amount, Ho(r, e);\n        }\n\n        if (i.bearing) {\n          const t = Ko(i.bearing, o, qo);\n          r.bearing = this._map.transform.bearing + e.clamp(t.amount, -179, 179), Ho(r, t);\n        }\n\n        if (i.pitch) {\n          const e = Ko(i.pitch, o, Xo);\n          r.pitch = this._map.transform.pitch + e.amount, Ho(r, e);\n        }\n\n        if (r.zoom || r.bearing) {\n          const e = void 0 === i.pinchAround ? i.around : i.pinchAround;\n          r.around = e ? this._map.unproject(e) : this._map.getCenter();\n        }\n\n        return this.clear(), r.noMoveStart = !0, r;\n      }\n\n    }\n\n    function Ho(e, t) {\n      (!e.duration || e.duration < t.duration) && (e.duration = t.duration, e.easing = t.easing);\n    }\n\n    function Ko(t, i, o) {\n      const {\n        maxSpeed: r,\n        linearity: n,\n        deceleration: a\n      } = o,\n            s = e.clamp(t * n / (i / 1e3), -r, r),\n            l = Math.abs(s) / (a * n);\n      return {\n        easing: o.easing,\n        duration: 1e3 * l,\n        amount: s * (l / 2)\n      };\n    }\n\n    class Yo extends e.Event {\n      preventDefault() {\n        this._defaultPrevented = !0;\n      }\n\n      get defaultPrevented() {\n        return this._defaultPrevented;\n      }\n\n      constructor(t, i, o, r = {}) {\n        const n = p(i.getCanvasContainer(), o),\n              a = i.unproject(n);\n        super(t, e.extend({\n          point: n,\n          lngLat: a,\n          originalEvent: o\n        }, r)), this._defaultPrevented = !1, this.target = i;\n      }\n\n    }\n\n    class Jo extends e.Event {\n      preventDefault() {\n        this._defaultPrevented = !0;\n      }\n\n      get defaultPrevented() {\n        return this._defaultPrevented;\n      }\n\n      constructor(t, i, o) {\n        const r = \"touchend\" === t ? o.changedTouches : o.touches,\n              n = m(i.getCanvasContainer(), r),\n              a = n.map(e => i.unproject(e)),\n              s = n.reduce((e, t, i, o) => e.add(t.div(o.length)), new e.pointGeometry(0, 0));\n        super(t, {\n          points: n,\n          point: s,\n          lngLats: a,\n          lngLat: i.unproject(s),\n          originalEvent: o\n        }), this._defaultPrevented = !1;\n      }\n\n    }\n\n    class Qo extends e.Event {\n      preventDefault() {\n        this._defaultPrevented = !0;\n      }\n\n      get defaultPrevented() {\n        return this._defaultPrevented;\n      }\n\n      constructor(e, t, i) {\n        super(e, {\n          originalEvent: i\n        }), this._defaultPrevented = !1;\n      }\n\n    }\n\n    class er {\n      constructor(e, t) {\n        this._map = e, this._clickTolerance = t.clickTolerance;\n      }\n\n      reset() {\n        this._mousedownPos = void 0;\n      }\n\n      wheel(e) {\n        return this._firePreventable(new Qo(e.type, this._map, e));\n      }\n\n      mousedown(e, t) {\n        return this._mousedownPos = t, this._firePreventable(new Yo(e.type, this._map, e));\n      }\n\n      mouseup(e) {\n        this._map.fire(new Yo(e.type, this._map, e));\n      }\n\n      preclick(t) {\n        const i = e.extend({}, t);\n        i.type = \"preclick\", this._map.fire(new Yo(i.type, this._map, i));\n      }\n\n      click(e, t) {\n        this._mousedownPos && this._mousedownPos.dist(t) >= this._clickTolerance || (this.preclick(e), this._map.fire(new Yo(e.type, this._map, e)));\n      }\n\n      dblclick(e) {\n        return this._firePreventable(new Yo(e.type, this._map, e));\n      }\n\n      mouseover(e) {\n        this._map.fire(new Yo(e.type, this._map, e));\n      }\n\n      mouseout(e) {\n        this._map.fire(new Yo(e.type, this._map, e));\n      }\n\n      touchstart(e) {\n        return this._firePreventable(new Jo(e.type, this._map, e));\n      }\n\n      touchmove(e) {\n        this._map.fire(new Jo(e.type, this._map, e));\n      }\n\n      touchend(e) {\n        this._map.fire(new Jo(e.type, this._map, e));\n      }\n\n      touchcancel(e) {\n        this._map.fire(new Jo(e.type, this._map, e));\n      }\n\n      _firePreventable(e) {\n        if (this._map.fire(e), e.defaultPrevented) return {};\n      }\n\n      isEnabled() {\n        return !0;\n      }\n\n      isActive() {\n        return !1;\n      }\n\n      enable() {}\n\n      disable() {}\n\n    }\n\n    class tr {\n      constructor(e) {\n        this._map = e;\n      }\n\n      reset() {\n        this._delayContextMenu = !1, this._contextMenuEvent = void 0;\n      }\n\n      mousemove(e) {\n        this._map.fire(new Yo(e.type, this._map, e));\n      }\n\n      mousedown() {\n        this._delayContextMenu = !0;\n      }\n\n      mouseup() {\n        this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new Yo(\"contextmenu\", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);\n      }\n\n      contextmenu(e) {\n        this._delayContextMenu ? this._contextMenuEvent = e : this._map.fire(new Yo(e.type, this._map, e)), this._map.listens(\"contextmenu\") && e.preventDefault();\n      }\n\n      isEnabled() {\n        return !0;\n      }\n\n      isActive() {\n        return !1;\n      }\n\n      enable() {}\n\n      disable() {}\n\n    }\n\n    class ir {\n      constructor(e, t) {\n        this._map = e, this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = t.clickTolerance || 1;\n      }\n\n      isEnabled() {\n        return !!this._enabled;\n      }\n\n      isActive() {\n        return !!this._active;\n      }\n\n      enable() {\n        this.isEnabled() || (this._enabled = !0);\n      }\n\n      disable() {\n        this.isEnabled() && (this._enabled = !1);\n      }\n\n      mousedown(e, t) {\n        this.isEnabled() && e.shiftKey && 0 === e.button && (h(), this._startPos = this._lastPos = t, this._active = !0);\n      }\n\n      mousemoveWindow(e, t) {\n        if (!this._active) return;\n        const i = t;\n        if (this._lastPos.equals(i) || !this._box && i.dist(this._startPos) < this._clickTolerance) return;\n        const o = this._startPos;\n        this._lastPos = i, this._box || (this._box = n(\"div\", \"mapboxgl-boxzoom\", this._container), this._container.classList.add(\"mapboxgl-crosshair\"), this._fireEvent(\"boxzoomstart\", e));\n        const r = Math.min(o.x, i.x),\n              a = Math.max(o.x, i.x),\n              s = Math.min(o.y, i.y),\n              l = Math.max(o.y, i.y);\n\n        this._map._requestDomTask(() => {\n          this._box && (this._box.style.transform = `translate(${r}px,${s}px)`, this._box.style.width = a - r + \"px\", this._box.style.height = l - s + \"px\");\n        });\n      }\n\n      mouseupWindow(t, i) {\n        if (!this._active) return;\n        if (0 !== t.button) return;\n        const o = this._startPos,\n              r = i;\n        if (this.reset(), d(), o.x !== r.x || o.y !== r.y) return this._map.fire(new e.Event(\"boxzoomend\", {\n          originalEvent: t\n        })), {\n          cameraAnimation: e => e.fitScreenCoordinates(o, r, this._map.getBearing(), {\n            linear: !1\n          })\n        };\n\n        this._fireEvent(\"boxzoomcancel\", t);\n      }\n\n      keydown(e) {\n        this._active && 27 === e.keyCode && (this.reset(), this._fireEvent(\"boxzoomcancel\", e));\n      }\n\n      blur() {\n        this.reset();\n      }\n\n      reset() {\n        this._active = !1, this._container.classList.remove(\"mapboxgl-crosshair\"), this._box && (this._box.remove(), this._box = null), _(), delete this._startPos, delete this._lastPos;\n      }\n\n      _fireEvent(t, i) {\n        return this._map.fire(new e.Event(t, {\n          originalEvent: i\n        }));\n      }\n\n    }\n\n    function or(e, t) {\n      const i = {};\n\n      for (let o = 0; o < e.length; o++) i[e[o].identifier] = t[o];\n\n      return i;\n    }\n\n    class rr {\n      constructor(e) {\n        this.reset(), this.numTouches = e.numTouches;\n      }\n\n      reset() {\n        this.centroid = void 0, this.startTime = 0, this.touches = {}, this.aborted = !1;\n      }\n\n      touchstart(t, i, o) {\n        (this.centroid || o.length > this.numTouches) && (this.aborted = !0), this.aborted || (0 === this.startTime && (this.startTime = t.timeStamp), o.length === this.numTouches && (this.centroid = function (t) {\n          const i = new e.pointGeometry(0, 0);\n\n          for (const e of t) i._add(e);\n\n          return i.div(t.length);\n        }(i), this.touches = or(o, i)));\n      }\n\n      touchmove(e, t, i) {\n        if (this.aborted || !this.centroid) return;\n        const o = or(i, t);\n\n        for (const e in this.touches) {\n          const t = this.touches[e],\n                i = o[e];\n          (!i || i.dist(t) > 30) && (this.aborted = !0);\n        }\n      }\n\n      touchend(e, t, i) {\n        if ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = !0), 0 === i.length) {\n          const e = !this.aborted && this.centroid;\n          if (this.reset(), e) return e;\n        }\n      }\n\n    }\n\n    class nr {\n      constructor(e) {\n        this.singleTap = new rr(e), this.numTaps = e.numTaps, this.reset();\n      }\n\n      reset() {\n        this.lastTime = 1 / 0, this.lastTap = void 0, this.count = 0, this.singleTap.reset();\n      }\n\n      touchstart(e, t, i) {\n        this.singleTap.touchstart(e, t, i);\n      }\n\n      touchmove(e, t, i) {\n        this.singleTap.touchmove(e, t, i);\n      }\n\n      touchend(e, t, i) {\n        const o = this.singleTap.touchend(e, t, i);\n\n        if (o) {\n          const t = e.timeStamp - this.lastTime < 500,\n                i = !this.lastTap || this.lastTap.dist(o) < 30;\n          if (t && i || this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = o, this.count === this.numTaps) return this.reset(), o;\n        }\n      }\n\n    }\n\n    class ar {\n      constructor() {\n        this._zoomIn = new nr({\n          numTouches: 1,\n          numTaps: 2\n        }), this._zoomOut = new nr({\n          numTouches: 2,\n          numTaps: 1\n        }), this.reset();\n      }\n\n      reset() {\n        this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();\n      }\n\n      touchstart(e, t, i) {\n        this._zoomIn.touchstart(e, t, i), this._zoomOut.touchstart(e, t, i);\n      }\n\n      touchmove(e, t, i) {\n        this._zoomIn.touchmove(e, t, i), this._zoomOut.touchmove(e, t, i);\n      }\n\n      touchend(e, t, i) {\n        const o = this._zoomIn.touchend(e, t, i),\n              r = this._zoomOut.touchend(e, t, i);\n\n        return o ? (this._active = !0, e.preventDefault(), setTimeout(() => this.reset(), 0), {\n          cameraAnimation: t => t.easeTo({\n            duration: 300,\n            zoom: t.getZoom() + 1,\n            around: t.unproject(o)\n          }, {\n            originalEvent: e\n          })\n        }) : r ? (this._active = !0, e.preventDefault(), setTimeout(() => this.reset(), 0), {\n          cameraAnimation: t => t.easeTo({\n            duration: 300,\n            zoom: t.getZoom() - 1,\n            around: t.unproject(r)\n          }, {\n            originalEvent: e\n          })\n        }) : void 0;\n      }\n\n      touchcancel() {\n        this.reset();\n      }\n\n      enable() {\n        this._enabled = !0;\n      }\n\n      disable() {\n        this._enabled = !1, this.reset();\n      }\n\n      isEnabled() {\n        return this._enabled;\n      }\n\n      isActive() {\n        return this._active;\n      }\n\n    }\n\n    const sr = {\n      0: 1,\n      2: 2\n    };\n\n    class lr {\n      constructor(e) {\n        this.reset(), this._clickTolerance = e.clickTolerance || 1;\n      }\n\n      blur() {\n        this.reset();\n      }\n\n      reset() {\n        this._active = !1, this._moved = !1, this._lastPoint = void 0, this._eventButton = void 0;\n      }\n\n      _correctButton(e, t) {\n        return !1;\n      }\n\n      _move(e, t) {\n        return {};\n      }\n\n      mousedown(e, t) {\n        if (this._lastPoint) return;\n        const i = f(e);\n        this._correctButton(e, i) && (this._lastPoint = t, this._eventButton = i);\n      }\n\n      mousemoveWindow(e, t) {\n        const i = this._lastPoint;\n        if (i) if (e.preventDefault(), null != this._eventButton && function (e, t) {\n          const i = sr[t];\n          return void 0 === e.buttons || (e.buttons & i) !== i;\n        }(e, this._eventButton)) this.reset();else if (this._moved || !(t.dist(i) < this._clickTolerance)) return this._moved = !0, this._lastPoint = t, this._move(i, t);\n      }\n\n      mouseupWindow(e) {\n        this._lastPoint && f(e) === this._eventButton && (this._moved && d(), this.reset());\n      }\n\n      enable() {\n        this._enabled = !0;\n      }\n\n      disable() {\n        this._enabled = !1, this.reset();\n      }\n\n      isEnabled() {\n        return this._enabled;\n      }\n\n      isActive() {\n        return this._active;\n      }\n\n    }\n\n    class cr extends lr {\n      mousedown(e, t) {\n        super.mousedown(e, t), this._lastPoint && (this._active = !0);\n      }\n\n      _correctButton(e, t) {\n        return 0 === t && !e.ctrlKey;\n      }\n\n      _move(e, t) {\n        return {\n          around: t,\n          panDelta: t.sub(e)\n        };\n      }\n\n    }\n\n    class hr extends lr {\n      _correctButton(e, t) {\n        return 0 === t && e.ctrlKey || 2 === t;\n      }\n\n      _move(e, t) {\n        const i = .8 * (t.x - e.x);\n        if (i) return this._active = !0, {\n          bearingDelta: i\n        };\n      }\n\n      contextmenu(e) {\n        e.preventDefault();\n      }\n\n    }\n\n    class _r extends lr {\n      _correctButton(e, t) {\n        return 0 === t && e.ctrlKey || 2 === t;\n      }\n\n      _move(e, t) {\n        const i = -.5 * (t.y - e.y);\n        if (i) return this._active = !0, {\n          pitchDelta: i\n        };\n      }\n\n      contextmenu(e) {\n        e.preventDefault();\n      }\n\n    }\n\n    class ur {\n      constructor(t, i) {\n        this._map = t, this._el = t.getCanvasContainer(), this._minTouches = 1, this._clickTolerance = i.clickTolerance || 1, this.reset(), e.bindAll([\"_addTouchPanBlocker\", \"_showTouchPanBlockerAlert\"], this);\n      }\n\n      reset() {\n        this._active = !1, this._touches = {}, this._sum = new e.pointGeometry(0, 0);\n      }\n\n      touchstart(e, t, i) {\n        return this._calculateTransform(e, t, i);\n      }\n\n      touchmove(e, t, i) {\n        if (this._active && !(i.length < this._minTouches)) {\n          if (this._map._cooperativeGestures && !this._map.isMoving()) {\n            if (1 === i.length) return void this._showTouchPanBlockerAlert();\n            \"hidden\" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = \"hidden\", clearTimeout(this._alertTimer));\n          }\n\n          return e.preventDefault(), this._calculateTransform(e, t, i);\n        }\n      }\n\n      touchend(e, t, i) {\n        this._calculateTransform(e, t, i), this._active && i.length < this._minTouches && this.reset();\n      }\n\n      touchcancel() {\n        this.reset();\n      }\n\n      _calculateTransform(t, i, o) {\n        o.length > 0 && (this._active = !0);\n        const r = or(o, i),\n              n = new e.pointGeometry(0, 0),\n              a = new e.pointGeometry(0, 0);\n        let s = 0;\n\n        for (const e in r) {\n          const t = r[e],\n                i = this._touches[e];\n          i && (n._add(t), a._add(t.sub(i)), s++, r[e] = t);\n        }\n\n        if (this._touches = r, s < this._minTouches || !a.mag()) return;\n        const l = a.div(s);\n        return this._sum._add(l), this._sum.mag() < this._clickTolerance ? void 0 : {\n          around: n.div(s),\n          panDelta: l\n        };\n      }\n\n      enable() {\n        this._enabled = !0, this._map._cooperativeGestures && (this._addTouchPanBlocker(), this._el.classList.add(\"mapboxgl-touch-pan-blocker-override\", \"mapboxgl-scrollable-page\"));\n      }\n\n      disable() {\n        this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove(), this._el.classList.remove(\"mapboxgl-touch-pan-blocker-override\", \"mapboxgl-scrollable-page\")), this.reset();\n      }\n\n      isEnabled() {\n        return this._enabled;\n      }\n\n      isActive() {\n        return this._active;\n      }\n\n      _addTouchPanBlocker() {\n        this._map && !this._alertContainer && (this._alertContainer = n(\"div\", \"mapboxgl-touch-pan-blocker\", this._map._container), this._alertContainer.textContent = this._map._getUIString(\"TouchPanBlocker.Message\"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth)))}px`);\n      }\n\n      _showTouchPanBlockerAlert() {\n        \"hidden\" === this._alertContainer.style.visibility && (this._alertContainer.style.visibility = \"visible\"), this._alertContainer.classList.add(\"mapboxgl-touch-pan-blocker-show\"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(() => {\n          this._alertContainer.classList.remove(\"mapboxgl-touch-pan-blocker-show\");\n        }, 500);\n      }\n\n    }\n\n    class dr {\n      constructor() {\n        this.reset();\n      }\n\n      reset() {\n        this._active = !1, this._firstTwoTouches = void 0;\n      }\n\n      _start(e) {}\n\n      _move(e, t, i) {\n        return {};\n      }\n\n      touchstart(e, t, i) {\n        this._firstTwoTouches || i.length < 2 || (this._firstTwoTouches = [i[0].identifier, i[1].identifier], this._start([t[0], t[1]]));\n      }\n\n      touchmove(e, t, i) {\n        const o = this._firstTwoTouches;\n        if (!o) return;\n        e.preventDefault();\n        const [r, n] = o,\n              a = pr(i, t, r),\n              s = pr(i, t, n);\n        if (!a || !s) return;\n        const l = this._aroundCenter ? null : a.add(s).div(2);\n        return this._move([a, s], l, e);\n      }\n\n      touchend(e, t, i) {\n        if (!this._firstTwoTouches) return;\n        const [o, r] = this._firstTwoTouches,\n              n = pr(i, t, o),\n              a = pr(i, t, r);\n        n && a || (this._active && d(), this.reset());\n      }\n\n      touchcancel() {\n        this.reset();\n      }\n\n      enable(e) {\n        this._enabled = !0, this._aroundCenter = !!e && \"center\" === e.around;\n      }\n\n      disable() {\n        this._enabled = !1, this.reset();\n      }\n\n      isEnabled() {\n        return this._enabled;\n      }\n\n      isActive() {\n        return this._active;\n      }\n\n    }\n\n    function pr(e, t, i) {\n      for (let o = 0; o < e.length; o++) if (e[o].identifier === i) return t[o];\n    }\n\n    function mr(e, t) {\n      return Math.log(e / t) / Math.LN2;\n    }\n\n    class fr extends dr {\n      reset() {\n        super.reset(), this._distance = 0, this._startDistance = 0;\n      }\n\n      _start(e) {\n        this._startDistance = this._distance = e[0].dist(e[1]);\n      }\n\n      _move(e, t) {\n        const i = this._distance;\n        if (this._distance = e[0].dist(e[1]), this._active || !(Math.abs(mr(this._distance, this._startDistance)) < .1)) return this._active = !0, {\n          zoomDelta: mr(this._distance, i),\n          pinchAround: t\n        };\n      }\n\n    }\n\n    function gr(e, t) {\n      return 180 * e.angleWith(t) / Math.PI;\n    }\n\n    class vr extends dr {\n      reset() {\n        super.reset(), this._minDiameter = 0, this._startVector = void 0, this._vector = void 0;\n      }\n\n      _start(e) {\n        this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1]);\n      }\n\n      _move(e, t) {\n        const i = this._vector;\n        if (this._vector = e[0].sub(e[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, {\n          bearingDelta: gr(this._vector, i),\n          pinchAround: t\n        };\n      }\n\n      _isBelowThreshold(e) {\n        this._minDiameter = Math.min(this._minDiameter, e.mag());\n        const t = 25 / (Math.PI * this._minDiameter) * 360,\n              i = gr(e, this._startVector);\n        return Math.abs(i) < t;\n      }\n\n    }\n\n    function xr(e) {\n      return Math.abs(e.y) > Math.abs(e.x);\n    }\n\n    class yr extends dr {\n      constructor(e) {\n        super(), this._map = e;\n      }\n\n      reset() {\n        super.reset(), this._valid = void 0, this._firstMove = void 0, this._lastPoints = void 0;\n      }\n\n      _start(e) {\n        this._lastPoints = e, xr(e[0].sub(e[1])) && (this._valid = !1);\n      }\n\n      _move(e, t, i) {\n        const o = this._lastPoints;\n        if (!o) return;\n        const r = e[0].sub(o[0]),\n              n = e[1].sub(o[1]);\n        return this._map._cooperativeGestures && i.touches.length < 3 || (this._valid = this.gestureBeginsVertically(r, n, i.timeStamp), !this._valid) ? void 0 : (this._lastPoints = e, this._active = !0, {\n          pitchDelta: (r.y + n.y) / 2 * -.5\n        });\n      }\n\n      gestureBeginsVertically(e, t, i) {\n        if (void 0 !== this._valid) return this._valid;\n        const o = e.mag() >= 2,\n              r = t.mag() >= 2;\n        if (!o && !r) return;\n        if (!o || !r) return null == this._firstMove && (this._firstMove = i), i - this._firstMove < 100 && void 0;\n        const n = e.y > 0 == t.y > 0;\n        return xr(e) && xr(t) && n;\n      }\n\n    }\n\n    const br = {\n      panStep: 100,\n      bearingStep: 15,\n      pitchStep: 10\n    };\n\n    class wr {\n      constructor() {\n        const e = br;\n        this._panStep = e.panStep, this._bearingStep = e.bearingStep, this._pitchStep = e.pitchStep, this._rotationDisabled = !1;\n      }\n\n      blur() {\n        this.reset();\n      }\n\n      reset() {\n        this._active = !1;\n      }\n\n      keydown(e) {\n        if (e.altKey || e.ctrlKey || e.metaKey) return;\n        let t = 0,\n            i = 0,\n            o = 0,\n            r = 0,\n            n = 0;\n\n        switch (e.keyCode) {\n          case 61:\n          case 107:\n          case 171:\n          case 187:\n            t = 1;\n            break;\n\n          case 189:\n          case 109:\n          case 173:\n            t = -1;\n            break;\n\n          case 37:\n            e.shiftKey ? i = -1 : (e.preventDefault(), r = -1);\n            break;\n\n          case 39:\n            e.shiftKey ? i = 1 : (e.preventDefault(), r = 1);\n            break;\n\n          case 38:\n            e.shiftKey ? o = 1 : (e.preventDefault(), n = -1);\n            break;\n\n          case 40:\n            e.shiftKey ? o = -1 : (e.preventDefault(), n = 1);\n            break;\n\n          default:\n            return;\n        }\n\n        return this._rotationDisabled && (i = 0, o = 0), {\n          cameraAnimation: a => {\n            const s = a.getZoom();\n            a.easeTo({\n              duration: 300,\n              easeId: \"keyboardHandler\",\n              easing: Tr,\n              zoom: t ? Math.round(s) + t * (e.shiftKey ? 2 : 1) : s,\n              bearing: a.getBearing() + i * this._bearingStep,\n              pitch: a.getPitch() + o * this._pitchStep,\n              offset: [-r * this._panStep, -n * this._panStep],\n              center: a.getCenter()\n            }, {\n              originalEvent: e\n            });\n          }\n        };\n      }\n\n      enable() {\n        this._enabled = !0;\n      }\n\n      disable() {\n        this._enabled = !1, this.reset();\n      }\n\n      isEnabled() {\n        return this._enabled;\n      }\n\n      isActive() {\n        return this._active;\n      }\n\n      disableRotation() {\n        this._rotationDisabled = !0;\n      }\n\n      enableRotation() {\n        this._rotationDisabled = !1;\n      }\n\n    }\n\n    function Tr(e) {\n      return e * (2 - e);\n    }\n\n    const Er = 4.000244140625;\n\n    class Cr {\n      constructor(t, i) {\n        this._map = t, this._el = t.getCanvasContainer(), this._handler = i, this._delta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = .0022222222222222222, e.bindAll([\"_onTimeout\", \"_addScrollZoomBlocker\", \"_showBlockerAlert\", \"_isFullscreen\"], this);\n      }\n\n      setZoomRate(e) {\n        this._defaultZoomRate = e;\n      }\n\n      setWheelZoomRate(e) {\n        this._wheelZoomRate = e;\n      }\n\n      isEnabled() {\n        return !!this._enabled;\n      }\n\n      isActive() {\n        return !!this._active || void 0 !== this._finishTimeout;\n      }\n\n      isZooming() {\n        return !!this._zooming;\n      }\n\n      enable(e) {\n        this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!e && \"center\" === e.around, this._map._cooperativeGestures && this._addScrollZoomBlocker());\n      }\n\n      disable() {\n        this.isEnabled() && (this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove()));\n      }\n\n      wheel(t) {\n        if (!this.isEnabled()) return;\n\n        if (this._map._cooperativeGestures) {\n          if (!(t.ctrlKey || t.metaKey || this.isZooming() || this._isFullscreen())) return void this._showBlockerAlert();\n          \"hidden\" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = \"hidden\", clearTimeout(this._alertTimer));\n        }\n\n        let i = t.deltaMode === e.window.WheelEvent.DOM_DELTA_LINE ? 40 * t.deltaY : t.deltaY;\n        const o = e.exported.now(),\n              r = o - (this._lastWheelEventTime || 0);\n        this._lastWheelEventTime = o, 0 !== i && i % Er == 0 ? this._type = \"wheel\" : 0 !== i && Math.abs(i) < 4 ? this._type = \"trackpad\" : r > 400 ? (this._type = null, this._lastValue = i, this._timeout = setTimeout(this._onTimeout, 40, t)) : this._type || (this._type = Math.abs(r * i) < 200 ? \"trackpad\" : \"wheel\", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i += this._lastValue)), t.shiftKey && i && (i /= 4), this._type && (this._lastWheelEvent = t, this._delta -= i, this._active || this._start(t)), t.preventDefault();\n      }\n\n      _onTimeout(e) {\n        this._type = \"wheel\", this._delta -= this._lastValue, this._active || this._start(e);\n      }\n\n      _start(e) {\n        if (!this._delta) return;\n        this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);\n        const t = p(this._el, e);\n        this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : t, this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint), this._targetZoom = void 0, this._frameId || (this._frameId = !0, this._handler._triggerRenderFrame());\n      }\n\n      renderFrame() {\n        if (!this._frameId) return;\n        if (this._frameId = null, !this.isActive()) return;\n\n        const t = this._map.transform,\n              i = () => t._terrainEnabled() && this._aroundCoord ? t.computeZoomRelativeTo(this._aroundCoord) : t.zoom;\n\n        if (0 !== this._delta) {\n          const e = \"wheel\" === this._type && Math.abs(this._delta) > Er ? this._wheelZoomRate : this._defaultZoomRate;\n          let o = 2 / (1 + Math.exp(-Math.abs(this._delta * e)));\n          this._delta < 0 && 0 !== o && (o = 1 / o);\n          const r = i(),\n                n = Math.pow(2, r),\n                a = \"number\" == typeof this._targetZoom ? t.zoomScale(this._targetZoom) : n;\n          this._targetZoom = Math.min(t.maxZoom, Math.max(t.minZoom, t.scaleZoom(a * o))), \"wheel\" === this._type && (this._startZoom = i(), this._easing = this._smoothOutEasing(200)), this._delta = 0;\n        }\n\n        const o = \"number\" == typeof this._targetZoom ? this._targetZoom : i(),\n              r = this._startZoom,\n              n = this._easing;\n        let a,\n            s = !1;\n\n        if (\"wheel\" === this._type && r && n) {\n          const t = Math.min((e.exported.now() - this._lastWheelEventTime) / 200, 1),\n                i = n(t);\n          a = e.number(r, o, i), t < 1 ? this._frameId || (this._frameId = !0) : s = !0;\n        } else a = o, s = !0;\n\n        return this._active = !0, s && (this._active = !1, this._finishTimeout = setTimeout(() => {\n          this._zooming = !1, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;\n        }, 200)), {\n          noInertia: !0,\n          needsRenderFrame: !s,\n          zoomDelta: a - i(),\n          around: this._aroundPoint,\n          aroundCoord: this._aroundCoord,\n          originalEvent: this._lastWheelEvent\n        };\n      }\n\n      _smoothOutEasing(t) {\n        let i = e.ease;\n\n        if (this._prevEase) {\n          const t = this._prevEase,\n                o = (e.exported.now() - t.start) / t.duration,\n                r = t.easing(o + .01) - t.easing(o),\n                n = .27 / Math.sqrt(r * r + 1e-4) * .01,\n                a = Math.sqrt(.0729 - n * n);\n          i = e.bezier(n, a, .25, 1);\n        }\n\n        return this._prevEase = {\n          start: e.exported.now(),\n          duration: t,\n          easing: i\n        }, i;\n      }\n\n      blur() {\n        this.reset();\n      }\n\n      reset() {\n        this._active = !1;\n      }\n\n      _addScrollZoomBlocker() {\n        this._map && !this._alertContainer && (this._alertContainer = n(\"div\", \"mapboxgl-scroll-zoom-blocker\", this._map._container), this._alertContainer.textContent = /(Mac|iPad)/i.test(e.window.navigator.userAgent) ? this._map._getUIString(\"ScrollZoomBlocker.CmdMessage\") : this._map._getUIString(\"ScrollZoomBlocker.CtrlMessage\"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth)))}px`);\n      }\n\n      _isFullscreen() {\n        return !!e.window.document.fullscreenElement || !!e.window.document.webkitFullscreenElement;\n      }\n\n      _showBlockerAlert() {\n        \"hidden\" === this._alertContainer.style.visibility && (this._alertContainer.style.visibility = \"visible\"), this._alertContainer.classList.add(\"mapboxgl-scroll-zoom-blocker-show\"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(() => {\n          this._alertContainer.classList.remove(\"mapboxgl-scroll-zoom-blocker-show\");\n        }, 200);\n      }\n\n    }\n\n    class Ir {\n      constructor(e, t) {\n        this._clickZoom = e, this._tapZoom = t;\n      }\n\n      enable() {\n        this._clickZoom.enable(), this._tapZoom.enable();\n      }\n\n      disable() {\n        this._clickZoom.disable(), this._tapZoom.disable();\n      }\n\n      isEnabled() {\n        return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();\n      }\n\n      isActive() {\n        return this._clickZoom.isActive() || this._tapZoom.isActive();\n      }\n\n    }\n\n    class Mr {\n      constructor() {\n        this.reset();\n      }\n\n      reset() {\n        this._active = !1;\n      }\n\n      blur() {\n        this.reset();\n      }\n\n      dblclick(e, t) {\n        return e.preventDefault(), {\n          cameraAnimation: i => {\n            i.easeTo({\n              duration: 300,\n              zoom: i.getZoom() + (e.shiftKey ? -1 : 1),\n              around: i.unproject(t)\n            }, {\n              originalEvent: e\n            });\n          }\n        };\n      }\n\n      enable() {\n        this._enabled = !0;\n      }\n\n      disable() {\n        this._enabled = !1, this.reset();\n      }\n\n      isEnabled() {\n        return this._enabled;\n      }\n\n      isActive() {\n        return this._active;\n      }\n\n    }\n\n    class Sr {\n      constructor() {\n        this._tap = new nr({\n          numTouches: 1,\n          numTaps: 1\n        }), this.reset();\n      }\n\n      reset() {\n        this._active = !1, this._swipePoint = void 0, this._swipeTouch = 0, this._tapTime = 0, this._tap.reset();\n      }\n\n      touchstart(e, t, i) {\n        this._swipePoint || (this._tapTime && e.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i.length > 0 && (this._swipePoint = t[0], this._swipeTouch = i[0].identifier) : this._tap.touchstart(e, t, i));\n      }\n\n      touchmove(e, t, i) {\n        if (this._tapTime) {\n          if (this._swipePoint) {\n            if (i[0].identifier !== this._swipeTouch) return;\n            const o = t[0],\n                  r = o.y - this._swipePoint.y;\n            return this._swipePoint = o, e.preventDefault(), this._active = !0, {\n              zoomDelta: r / 128\n            };\n          }\n        } else this._tap.touchmove(e, t, i);\n      }\n\n      touchend(e, t, i) {\n        this._tapTime ? this._swipePoint && 0 === i.length && this.reset() : this._tap.touchend(e, t, i) && (this._tapTime = e.timeStamp);\n      }\n\n      touchcancel() {\n        this.reset();\n      }\n\n      enable() {\n        this._enabled = !0;\n      }\n\n      disable() {\n        this._enabled = !1, this.reset();\n      }\n\n      isEnabled() {\n        return this._enabled;\n      }\n\n      isActive() {\n        return this._active;\n      }\n\n    }\n\n    class zr {\n      constructor(e, t, i) {\n        this._el = e, this._mousePan = t, this._touchPan = i;\n      }\n\n      enable(e) {\n        this._inertiaOptions = e || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add(\"mapboxgl-touch-drag-pan\");\n      }\n\n      disable() {\n        this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove(\"mapboxgl-touch-drag-pan\");\n      }\n\n      isEnabled() {\n        return this._mousePan.isEnabled() && this._touchPan.isEnabled();\n      }\n\n      isActive() {\n        return this._mousePan.isActive() || this._touchPan.isActive();\n      }\n\n    }\n\n    class Dr {\n      constructor(e, t, i) {\n        this._pitchWithRotate = e.pitchWithRotate, this._mouseRotate = t, this._mousePitch = i;\n      }\n\n      enable() {\n        this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();\n      }\n\n      disable() {\n        this._mouseRotate.disable(), this._mousePitch.disable();\n      }\n\n      isEnabled() {\n        return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());\n      }\n\n      isActive() {\n        return this._mouseRotate.isActive() || this._mousePitch.isActive();\n      }\n\n    }\n\n    class Pr {\n      constructor(e, t, i, o) {\n        this._el = e, this._touchZoom = t, this._touchRotate = i, this._tapDragZoom = o, this._rotationDisabled = !1, this._enabled = !0;\n      }\n\n      enable(e) {\n        this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add(\"mapboxgl-touch-zoom-rotate\");\n      }\n\n      disable() {\n        this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove(\"mapboxgl-touch-zoom-rotate\");\n      }\n\n      isEnabled() {\n        return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();\n      }\n\n      isActive() {\n        return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();\n      }\n\n      disableRotation() {\n        this._rotationDisabled = !0, this._touchRotate.disable();\n      }\n\n      enableRotation() {\n        this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();\n      }\n\n    }\n\n    const Ar = e => e.zoom || e.drag || e.pitch || e.rotate;\n\n    class Lr extends e.Event {}\n\n    class Rr {\n      constructor() {\n        this.constants = [1, 1, .01], this.radius = 0;\n      }\n\n      setup(t, i) {\n        const o = e.sub([], i, t);\n        this.radius = e.length(o[2] < 0 ? e.div([], o, this.constants) : [o[0], o[1], 0]);\n      }\n\n      projectRay(t) {\n        e.div(t, t, this.constants), e.normalize(t, t), e.mul$1(t, t, this.constants);\n        const i = e.scale$2([], t, this.radius);\n\n        if (i[2] > 0) {\n          const t = e.scale$2([], [0, 0, 1], e.dot(i, [0, 0, 1])),\n                o = e.scale$2([], e.normalize([], [i[0], i[1], 0]), this.radius),\n                r = e.add([], i, e.scale$2([], e.sub([], e.add([], o, t), i), 2));\n          i[0] = r[0], i[1] = r[1];\n        }\n\n        return i;\n      }\n\n    }\n\n    function kr(e) {\n      return e.panDelta && e.panDelta.mag() || e.zoomDelta || e.bearingDelta || e.pitchDelta;\n    }\n\n    class Or {\n      constructor(t, i) {\n        this._map = t, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new $o(t), this._bearingSnap = i.bearingSnap, this._previousActiveHandlers = {}, this._trackingEllipsoid = new Rr(), this._dragOrigin = null, this._eventsInProgress = {}, this._addDefaultHandlers(i), e.bindAll([\"handleEvent\", \"handleWindowEvent\"], this);\n        const o = this._el;\n        this._listeners = [[o, \"touchstart\", {\n          passive: !0\n        }], [o, \"touchmove\", {\n          passive: !1\n        }], [o, \"touchend\", void 0], [o, \"touchcancel\", void 0], [o, \"mousedown\", void 0], [o, \"mousemove\", void 0], [o, \"mouseup\", void 0], [e.window.document, \"mousemove\", {\n          capture: !0\n        }], [e.window.document, \"mouseup\", void 0], [o, \"mouseover\", void 0], [o, \"mouseout\", void 0], [o, \"dblclick\", void 0], [o, \"click\", void 0], [o, \"keydown\", {\n          capture: !1\n        }], [o, \"keyup\", void 0], [o, \"wheel\", {\n          passive: !1\n        }], [o, \"contextmenu\", void 0], [e.window, \"blur\", void 0]];\n\n        for (const [t, i, o] of this._listeners) t.addEventListener(i, t === e.window.document ? this.handleWindowEvent : this.handleEvent, o);\n      }\n\n      destroy() {\n        for (const [t, i, o] of this._listeners) t.removeEventListener(i, t === e.window.document ? this.handleWindowEvent : this.handleEvent, o);\n      }\n\n      _addDefaultHandlers(e) {\n        const t = this._map,\n              i = t.getCanvasContainer();\n\n        this._add(\"mapEvent\", new er(t, e));\n\n        const o = t.boxZoom = new ir(t, e);\n\n        this._add(\"boxZoom\", o);\n\n        const r = new ar(),\n              n = new Mr();\n        t.doubleClickZoom = new Ir(n, r), this._add(\"tapZoom\", r), this._add(\"clickZoom\", n);\n        const a = new Sr();\n\n        this._add(\"tapDragZoom\", a);\n\n        const s = t.touchPitch = new yr(t);\n\n        this._add(\"touchPitch\", s);\n\n        const l = new hr(e),\n              c = new _r(e);\n        t.dragRotate = new Dr(e, l, c), this._add(\"mouseRotate\", l, [\"mousePitch\"]), this._add(\"mousePitch\", c, [\"mouseRotate\"]);\n\n        const h = new cr(e),\n              _ = new ur(t, e);\n\n        t.dragPan = new zr(i, h, _), this._add(\"mousePan\", h), this._add(\"touchPan\", _, [\"touchZoom\", \"touchRotate\"]);\n        const u = new vr(),\n              d = new fr();\n        t.touchZoomRotate = new Pr(i, d, u, a), this._add(\"touchRotate\", u, [\"touchPan\", \"touchZoom\"]), this._add(\"touchZoom\", d, [\"touchPan\", \"touchRotate\"]), this._add(\"blockableMapEvent\", new tr(t));\n        const p = t.scrollZoom = new Cr(t, this);\n\n        this._add(\"scrollZoom\", p, [\"mousePan\"]);\n\n        const m = t.keyboard = new wr();\n\n        this._add(\"keyboard\", m);\n\n        for (const i of [\"boxZoom\", \"doubleClickZoom\", \"tapDragZoom\", \"touchPitch\", \"dragRotate\", \"dragPan\", \"touchZoomRotate\", \"scrollZoom\", \"keyboard\"]) e.interactive && e[i] && t[i].enable(e[i]);\n      }\n\n      _add(e, t, i) {\n        this._handlers.push({\n          handlerName: e,\n          handler: t,\n          allowed: i\n        }), this._handlersById[e] = t;\n      }\n\n      stop(e) {\n        if (!this._updatingCamera) {\n          for (const {\n            handler: e\n          } of this._handlers) e.reset();\n\n          this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = [];\n        }\n      }\n\n      isActive() {\n        for (const {\n          handler: e\n        } of this._handlers) if (e.isActive()) return !0;\n\n        return !1;\n      }\n\n      isZooming() {\n        return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();\n      }\n\n      isRotating() {\n        return !!this._eventsInProgress.rotate;\n      }\n\n      isMoving() {\n        return !!Ar(this._eventsInProgress) || this.isZooming();\n      }\n\n      _blockedByActive(e, t, i) {\n        for (const o in e) if (o !== i && (!t || t.indexOf(o) < 0)) return !0;\n\n        return !1;\n      }\n\n      handleWindowEvent(e) {\n        this.handleEvent(e, `${e.type}Window`);\n      }\n\n      _getMapTouches(e) {\n        const t = [];\n\n        for (const i of e) this._el.contains(i.target) && t.push(i);\n\n        return t;\n      }\n\n      handleEvent(e, t) {\n        this._updatingCamera = !0;\n        const i = \"renderFrame\" === e.type,\n              o = i ? void 0 : e,\n              r = {\n          needsRenderFrame: !1\n        },\n              n = {},\n              a = {},\n              s = e.touches ? this._getMapTouches(e.touches) : void 0,\n              l = s ? m(this._el, s) : i ? void 0 : p(this._el, e);\n\n        for (const {\n          handlerName: i,\n          handler: c,\n          allowed: h\n        } of this._handlers) {\n          if (!c.isEnabled()) continue;\n\n          let _;\n\n          this._blockedByActive(a, h, i) ? c.reset() : c[t || e.type] && (_ = c[t || e.type](e, l, s), this.mergeHandlerResult(r, n, _, i, o), _ && _.needsRenderFrame && this._triggerRenderFrame()), (_ || c.isActive()) && (a[i] = c);\n        }\n\n        const c = {};\n\n        for (const e in this._previousActiveHandlers) a[e] || (c[e] = o);\n\n        this._previousActiveHandlers = a, (Object.keys(c).length || kr(r)) && (this._changes.push([r, n, c]), this._triggerRenderFrame()), (Object.keys(a).length || kr(r)) && this._map._stop(!0), this._updatingCamera = !1;\n        const {\n          cameraAnimation: h\n        } = r;\n        h && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], h(this._map));\n      }\n\n      mergeHandlerResult(t, i, o, r, n) {\n        if (!o) return;\n        e.extend(t, o);\n        const a = {\n          handlerName: r,\n          originalEvent: o.originalEvent || n\n        };\n        void 0 !== o.zoomDelta && (i.zoom = a), void 0 !== o.panDelta && (i.drag = a), void 0 !== o.pitchDelta && (i.pitch = a), void 0 !== o.bearingDelta && (i.rotate = a);\n      }\n\n      _applyChanges() {\n        const t = {},\n              i = {},\n              o = {};\n\n        for (const [r, n, a] of this._changes) r.panDelta && (t.panDelta = (t.panDelta || new e.pointGeometry(0, 0))._add(r.panDelta)), r.zoomDelta && (t.zoomDelta = (t.zoomDelta || 0) + r.zoomDelta), r.bearingDelta && (t.bearingDelta = (t.bearingDelta || 0) + r.bearingDelta), r.pitchDelta && (t.pitchDelta = (t.pitchDelta || 0) + r.pitchDelta), void 0 !== r.around && (t.around = r.around), void 0 !== r.aroundCoord && (t.aroundCoord = r.aroundCoord), void 0 !== r.pinchAround && (t.pinchAround = r.pinchAround), r.noInertia && (t.noInertia = r.noInertia), e.extend(i, n), e.extend(o, a);\n\n        this._updateMapTransform(t, i, o), this._changes = [];\n      }\n\n      _updateMapTransform(t, i, o) {\n        const r = this._map,\n              n = r.transform,\n              a = e => [e.x, e.y, e.z];\n\n        if ((e => {\n          const t = this._eventsInProgress.drag;\n          return t && !this._handlersById[t.handlerName].isActive();\n        })() && !kr(t)) {\n          const e = n.zoom;\n          n.cameraElevationReference = \"sea\", n.recenterOnTerrain(), n.cameraElevationReference = \"ground\", e !== n.zoom && this._map._update(!0);\n        }\n\n        if (!kr(t)) return void this._fireEvents(i, o, !0);\n        let {\n          panDelta: s,\n          zoomDelta: l,\n          bearingDelta: c,\n          pitchDelta: h,\n          around: _,\n          aroundCoord: u,\n          pinchAround: d\n        } = t;\n        void 0 !== d && (_ = d), (e => i.drag && !this._eventsInProgress.drag)() && _ && (this._dragOrigin = a(n.pointCoordinate3D(_)), this._trackingEllipsoid.setup(n._camera.position, this._dragOrigin)), n.cameraElevationReference = \"sea\", r._stop(!0), _ = _ || r.transform.centerPoint, c && (n.bearing += c), h && (n.pitch += h), n._updateCameraState();\n        const p = [0, 0, 0];\n\n        if (s) {\n          const t = n.pointCoordinate(_);\n\n          if (\"globe\" === n.projection.name) {\n            const i = e.latFromMercatorY(t.y),\n                  o = n.center.lat,\n                  r = Math.min(e.mercatorZfromAltitude(1, i) / e.mercatorZfromAltitude(1, o), 2);\n            s = s.rotate(-n.angle), p[0] = -s.x / n.worldSize * r, p[1] = -s.y / n.worldSize * r;\n          } else {\n            const e = n.pointCoordinate(_.sub(s));\n            t && e && (p[0] = e.x - t.x, p[1] = e.y - t.y);\n          }\n        }\n\n        const m = n.zoom,\n              f = [0, 0, 0];\n\n        if (l) {\n          const t = a(u || n.pointCoordinate3D(_)),\n                i = {\n            dir: e.normalize([], e.sub([], t, n._camera.position))\n          };\n\n          if (i.dir[2] < 0) {\n            const o = n.zoomDeltaToMovement(t, l);\n            e.scale$2(f, i.dir, o);\n          }\n        }\n\n        const g = e.add(p, p, f);\n        n._translateCameraConstrained(g), l && Math.abs(n.zoom - m) > 1e-4 && n.recenterOnTerrain(), n.cameraElevationReference = \"ground\", this._map._update(), t.noInertia || this._inertia.record(t), this._fireEvents(i, o, !0);\n      }\n\n      _fireEvents(t, i, o) {\n        const r = Ar(this._eventsInProgress),\n              n = Ar(t),\n              a = {};\n\n        for (const e in t) {\n          const {\n            originalEvent: i\n          } = t[e];\n          this._eventsInProgress[e] || (a[`${e}start`] = i), this._eventsInProgress[e] = t[e];\n        }\n\n        !r && n && this._fireEvent(\"movestart\", n.originalEvent);\n\n        for (const e in a) this._fireEvent(e, a[e]);\n\n        n && this._fireEvent(\"move\", n.originalEvent);\n\n        for (const e in t) {\n          const {\n            originalEvent: i\n          } = t[e];\n\n          this._fireEvent(e, i);\n        }\n\n        const s = {};\n        let l;\n\n        for (const e in this._eventsInProgress) {\n          const {\n            handlerName: t,\n            originalEvent: o\n          } = this._eventsInProgress[e];\n          this._handlersById[t].isActive() || (delete this._eventsInProgress[e], l = i[t] || o, s[`${e}end`] = l);\n        }\n\n        for (const e in s) this._fireEvent(e, s[e]);\n\n        const c = Ar(this._eventsInProgress);\n\n        if (o && (r || n) && !c) {\n          this._updatingCamera = !0;\n\n          const t = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions),\n                i = e => 0 !== e && -this._bearingSnap < e && e < this._bearingSnap;\n\n          t ? (i(t.bearing || this._map.getBearing()) && (t.bearing = 0), this._map.easeTo(t, {\n            originalEvent: l\n          })) : (this._map.fire(new e.Event(\"moveend\", {\n            originalEvent: l\n          })), i(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = !1;\n        }\n      }\n\n      _fireEvent(t, i) {\n        this._map.fire(new e.Event(t, i ? {\n          originalEvent: i\n        } : {}));\n      }\n\n      _requestFrame() {\n        return this._map.triggerRepaint(), this._map._renderTaskQueue.add(e => {\n          this._frameId = void 0, this.handleEvent(new Lr(\"renderFrame\", {\n            timeStamp: e\n          })), this._applyChanges();\n        });\n      }\n\n      _triggerRenderFrame() {\n        void 0 === this._frameId && (this._frameId = this._requestFrame());\n      }\n\n    }\n\n    const Br = \"map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.\";\n\n    class Fr extends e.Evented {\n      constructor(t, i) {\n        super(), this._moving = !1, this._zooming = !1, this.transform = t, this._bearingSnap = i.bearingSnap, e.bindAll([\"_renderFrameCallback\"], this);\n      }\n\n      getCenter() {\n        return new e.LngLat(this.transform.center.lng, this.transform.center.lat);\n      }\n\n      setCenter(e, t) {\n        return this.jumpTo({\n          center: e\n        }, t);\n      }\n\n      panBy(t, i, o) {\n        return t = e.pointGeometry.convert(t).mult(-1), this.panTo(this.transform.center, e.extend({\n          offset: t\n        }, i), o);\n      }\n\n      panTo(t, i, o) {\n        return this.easeTo(e.extend({\n          center: t\n        }, i), o);\n      }\n\n      getZoom() {\n        return this.transform.zoom;\n      }\n\n      setZoom(e, t) {\n        return this.jumpTo({\n          zoom: e\n        }, t), this;\n      }\n\n      zoomTo(t, i, o) {\n        return this.easeTo(e.extend({\n          zoom: t\n        }, i), o);\n      }\n\n      zoomIn(e, t) {\n        return this.zoomTo(this.getZoom() + 1, e, t), this;\n      }\n\n      zoomOut(e, t) {\n        return this.zoomTo(this.getZoom() - 1, e, t), this;\n      }\n\n      getBearing() {\n        return this.transform.bearing;\n      }\n\n      setBearing(e, t) {\n        return this.jumpTo({\n          bearing: e\n        }, t), this;\n      }\n\n      getPadding() {\n        return this.transform.padding;\n      }\n\n      setPadding(e, t) {\n        return this.jumpTo({\n          padding: e\n        }, t), this;\n      }\n\n      rotateTo(t, i, o) {\n        return this.easeTo(e.extend({\n          bearing: t\n        }, i), o);\n      }\n\n      resetNorth(t, i) {\n        return this.rotateTo(0, e.extend({\n          duration: 1e3\n        }, t), i), this;\n      }\n\n      resetNorthPitch(t, i) {\n        return this.easeTo(e.extend({\n          bearing: 0,\n          pitch: 0,\n          duration: 1e3\n        }, t), i), this;\n      }\n\n      snapToNorth(e, t) {\n        return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, t) : this;\n      }\n\n      getPitch() {\n        return this.transform.pitch;\n      }\n\n      setPitch(e, t) {\n        return this.jumpTo({\n          pitch: e\n        }, t), this;\n      }\n\n      cameraForBounds(t, i) {\n        t = e.LngLatBounds.convert(t);\n        const o = i && i.bearing || 0;\n        return this._cameraForBoxAndBearing(t.getNorthWest(), t.getSouthEast(), o, i);\n      }\n\n      _extendCameraOptions(t) {\n        const i = {\n          top: 0,\n          bottom: 0,\n          right: 0,\n          left: 0\n        };\n\n        if (\"number\" == typeof (t = e.extend({\n          padding: i,\n          offset: [0, 0],\n          maxZoom: this.transform.maxZoom\n        }, t)).padding) {\n          const e = t.padding;\n          t.padding = {\n            top: e,\n            bottom: e,\n            right: e,\n            left: e\n          };\n        }\n\n        return t.padding = e.extend(i, t.padding), t;\n      }\n\n      _cameraForBoxAndBearing(t, i, o, r) {\n        const n = this._extendCameraOptions(r),\n              a = this.transform,\n              s = a.padding,\n              l = a.project(e.LngLat.convert(t)),\n              c = a.project(e.LngLat.convert(i)),\n              h = new e.pointGeometry(l.x, c.y),\n              _ = new e.pointGeometry(c.x, l.y),\n              u = -e.degToRad(o),\n              d = l.rotate(u),\n              p = c.rotate(u),\n              m = h.rotate(u),\n              f = _.rotate(u),\n              g = new e.pointGeometry(Math.max(d.x, p.x, m.x, f.x), Math.max(d.y, p.y, m.y, f.y)),\n              v = new e.pointGeometry(Math.min(d.x, p.x, m.x, f.x), Math.min(d.y, p.y, m.y, f.y)),\n              x = g.sub(v),\n              y = (a.width - ((s.left || 0) + (s.right || 0) + n.padding.left + n.padding.right)) / x.x,\n              b = (a.height - ((s.top || 0) + (s.bottom || 0) + n.padding.top + n.padding.bottom)) / x.y;\n\n        if (b < 0 || y < 0) return void e.warnOnce(\"Map cannot fit within canvas with the given bounds, padding, and/or offset.\");\n        const w = Math.min(a.scaleZoom(a.scale * Math.min(y, b)), n.maxZoom),\n              T = \"number\" == typeof n.offset.x && \"number\" == typeof n.offset.y ? new e.pointGeometry(n.offset.x, n.offset.y) : e.pointGeometry.convert(n.offset),\n              E = new e.pointGeometry((n.padding.left - n.padding.right) / 2, (n.padding.top - n.padding.bottom) / 2).rotate(o * Math.PI / 180),\n              C = T.add(E).mult(a.scale / a.zoomScale(w));\n        return {\n          center: a.unproject(l.add(c).div(2).sub(C)),\n          zoom: w,\n          bearing: o\n        };\n      }\n\n      _cameraForBox(t, i, o, r, n) {\n        const a = this._extendCameraOptions(n);\n\n        o = o || 0, r = r || 0, t = e.LngLat.convert(t), i = e.LngLat.convert(i);\n        const s = this.transform.clone();\n        s.padding = a.padding;\n        const l = this.getFreeCameraOptions(),\n              c = new e.LngLat(.5 * (t.lng + i.lng), .5 * (t.lat + i.lat)),\n              h = .5 * (o + r);\n        if (s._camera.position[2] < e.mercatorZfromAltitude(h, c.lat)) return void e.warnOnce(\"Map cannot fit within canvas with the given bounds, padding, and/or offset.\");\n        l.lookAtPoint(c), s.setFreeCameraOptions(l);\n\n        const _ = e.MercatorCoordinate.fromLngLat(t),\n              u = e.MercatorCoordinate.fromLngLat(i),\n              d = s.pointRayIntersection(s.centerPoint, h),\n              p = [(m = s.rayIntersectionCoordinate(d)).x, m.y, m.z];\n\n        var m;\n        const f = s.screenPointToMercatorRay(s.centerPoint),\n              g = \"globe\" !== s.projection.name;\n        let v,\n            x = 0;\n\n        do {\n          const t = Math.floor(s.zoom),\n                i = 1 << t,\n                n = Math.min(i * _.x, i * u.x),\n                a = Math.min(i * _.y, i * u.y),\n                l = Math.max(i * _.x, i * u.x),\n                c = Math.max(i * _.y, i * u.y),\n                h = new e.Aabb([n, a, o], [l, c, r]),\n                d = e.Frustum.fromInvProjectionMatrix(s.invProjMatrix, s.worldSize, t, g);\n\n          if (2 !== h.intersects(d)) {\n            v && (s._camera.position = e.scaleAndAdd([], s._camera.position, f.dir, -v), s._updateStateFromCamera());\n            break;\n          }\n\n          const m = e.sub([], s._camera.position, p);\n          v = .5 * e.length(m), s._camera.position = e.scaleAndAdd([], s._camera.position, f.dir, v);\n\n          try {\n            s._updateStateFromCamera();\n          } catch (t) {\n            return void e.warnOnce(\"Map cannot fit within canvas with the given bounds, padding, and/or offset.\");\n          }\n        } while (++x < 10);\n\n        return {\n          center: s.center,\n          zoom: s.zoom,\n          bearing: s.bearing,\n          pitch: s.pitch\n        };\n      }\n\n      fitBounds(e, t, i) {\n        return this._fitInternal(this.cameraForBounds(e, t), t, i);\n      }\n\n      _raycastElevationBox(t, i) {\n        const o = this.transform.elevation;\n        if (!o) return;\n        const r = new e.pointGeometry(t.x, i.y),\n              n = new e.pointGeometry(i.x, t.y),\n              a = o.pointCoordinate(t);\n        if (!a) return;\n        const s = o.pointCoordinate(i);\n        if (!s) return;\n        const l = o.pointCoordinate(r);\n        if (!l) return;\n        const c = o.pointCoordinate(n);\n        if (!c) return;\n\n        const h = new e.MercatorCoordinate(a[0], a[1]).toLngLat(),\n              _ = new e.MercatorCoordinate(s[0], s[1]).toLngLat(),\n              u = new e.MercatorCoordinate(l[0], l[1]).toLngLat(),\n              d = new e.MercatorCoordinate(c[0], c[1]).toLngLat(),\n              p = Math.min(h.lng, Math.min(_.lng, Math.min(u.lng, d.lng))),\n              m = Math.min(h.lat, Math.min(_.lat, Math.min(u.lat, d.lat))),\n              f = Math.max(h.lng, Math.max(_.lng, Math.max(u.lng, d.lng))),\n              g = Math.max(h.lat, Math.max(_.lat, Math.max(u.lat, d.lat))),\n              v = Math.min(a[3], Math.min(s[3], Math.min(l[3], c[3]))),\n              x = Math.max(a[3], Math.max(s[3], Math.max(l[3], c[3])));\n\n        return {\n          minLngLat: new e.LngLat(p, m),\n          maxLngLat: new e.LngLat(f, g),\n          minAltitude: v,\n          maxAltitude: x\n        };\n      }\n\n      fitScreenCoordinates(t, i, o, r, n) {\n        let a, s, l, c;\n\n        const h = e.pointGeometry.convert(t),\n              _ = e.pointGeometry.convert(i),\n              u = this._raycastElevationBox(h, _);\n\n        if (u) a = u.minLngLat, s = u.maxLngLat, l = u.minAltitude, c = u.maxAltitude;else {\n          if (this.transform.anyCornerOffEdge(h, _)) return this;\n          a = this.transform.pointLocation(h), s = this.transform.pointLocation(_);\n        }\n        return this._fitInternal(0 === this.transform.pitch ? this._cameraForBoxAndBearing(this.transform.pointLocation(e.pointGeometry.convert(t)), this.transform.pointLocation(e.pointGeometry.convert(i)), o, r) : this._cameraForBox(a, s, l, c, r), r, n);\n      }\n\n      _fitInternal(t, i, o) {\n        return t ? (delete (i = e.extend(t, i)).padding, i.linear ? this.easeTo(i, o) : this.flyTo(i, o)) : this;\n      }\n\n      jumpTo(t, i) {\n        this.stop();\n        const o = t.preloadOnly ? this.transform.clone() : this.transform;\n        let r = !1,\n            n = !1,\n            a = !1;\n        return \"zoom\" in t && o.zoom !== +t.zoom && (r = !0, o.zoom = +t.zoom), void 0 !== t.center && (o.center = e.LngLat.convert(t.center)), \"bearing\" in t && o.bearing !== +t.bearing && (n = !0, o.bearing = +t.bearing), \"pitch\" in t && o.pitch !== +t.pitch && (a = !0, o.pitch = +t.pitch), null == t.padding || o.isPaddingEqual(t.padding) || (o.padding = t.padding), t.preloadOnly ? (this._preloadTiles(o), this) : (this.fire(new e.Event(\"movestart\", i)).fire(new e.Event(\"move\", i)), r && this.fire(new e.Event(\"zoomstart\", i)).fire(new e.Event(\"zoom\", i)).fire(new e.Event(\"zoomend\", i)), n && this.fire(new e.Event(\"rotatestart\", i)).fire(new e.Event(\"rotate\", i)).fire(new e.Event(\"rotateend\", i)), a && this.fire(new e.Event(\"pitchstart\", i)).fire(new e.Event(\"pitch\", i)).fire(new e.Event(\"pitchend\", i)), this.fire(new e.Event(\"moveend\", i)));\n      }\n\n      getFreeCameraOptions() {\n        return this.transform.projection.supportsFreeCamera || e.warnOnce(Br), this.transform.getFreeCameraOptions();\n      }\n\n      setFreeCameraOptions(t, i) {\n        const o = this.transform;\n        if (!o.projection.supportsFreeCamera) return e.warnOnce(Br), this;\n        this.stop();\n        const r = o.zoom,\n              n = o.pitch,\n              a = o.bearing;\n        o.setFreeCameraOptions(t);\n        const s = r !== o.zoom,\n              l = n !== o.pitch,\n              c = a !== o.bearing;\n        return this.fire(new e.Event(\"movestart\", i)).fire(new e.Event(\"move\", i)), s && this.fire(new e.Event(\"zoomstart\", i)).fire(new e.Event(\"zoom\", i)).fire(new e.Event(\"zoomend\", i)), c && this.fire(new e.Event(\"rotatestart\", i)).fire(new e.Event(\"rotate\", i)).fire(new e.Event(\"rotateend\", i)), l && this.fire(new e.Event(\"pitchstart\", i)).fire(new e.Event(\"pitch\", i)).fire(new e.Event(\"pitchend\", i)), this.fire(new e.Event(\"moveend\", i)), this;\n      }\n\n      easeTo(t, i) {\n        this._stop(!1, t.easeId), (!1 === (t = e.extend({\n          offset: [0, 0],\n          duration: 500,\n          easing: e.ease\n        }, t)).animate || !t.essential && e.exported.prefersReducedMotion) && (t.duration = 0);\n\n        const o = this.transform,\n              r = this.getZoom(),\n              n = this.getBearing(),\n              a = this.getPitch(),\n              s = this.getPadding(),\n              l = \"zoom\" in t ? +t.zoom : r,\n              c = \"bearing\" in t ? this._normalizeBearing(t.bearing, n) : n,\n              h = \"pitch\" in t ? +t.pitch : a,\n              _ = \"padding\" in t ? t.padding : o.padding,\n              u = e.pointGeometry.convert(t.offset);\n\n        let d, p, m;\n\n        if (\"globe\" === o.projection.name) {\n          const i = e.MercatorCoordinate.fromLngLat(o.center),\n                r = u.rotate(-o.angle);\n          i.x += r.x / o.worldSize, i.y += r.y / o.worldSize;\n          const n = i.toLngLat(),\n                a = e.LngLat.convert(t.center || n);\n          this._normalizeCenter(a), d = o.centerPoint.add(r), p = new e.pointGeometry(i.x, i.y).mult(o.worldSize), m = new e.pointGeometry(e.mercatorXfromLng(a.lng), e.mercatorYfromLat(a.lat)).mult(o.worldSize).sub(p);\n        } else {\n          d = o.centerPoint.add(u);\n          const i = o.pointLocation(d),\n                r = e.LngLat.convert(t.center || i);\n          this._normalizeCenter(r), p = o.project(i), m = o.project(r).sub(p);\n        }\n\n        const f = o.zoomScale(l - r);\n        let g, v;\n        t.around && (g = e.LngLat.convert(t.around), v = o.locationPoint(g));\n\n        const x = this._zooming || l !== r,\n              y = this._rotating || n !== c,\n              b = this._pitching || h !== a,\n              w = !o.isPaddingEqual(_),\n              T = o => T => {\n          if (x && (o.zoom = e.number(r, l, T)), y && (o.bearing = e.number(n, c, T)), b && (o.pitch = e.number(a, h, T)), w && (o.interpolatePadding(s, _, T), d = o.centerPoint.add(u)), g) o.setLocationAtPoint(g, v);else {\n            const e = o.zoomScale(o.zoom - r),\n                  t = l > r ? Math.min(2, f) : Math.max(.5, f),\n                  i = Math.pow(t, 1 - T),\n                  n = o.unproject(p.add(m.mult(T * i)).mult(e));\n            o.setLocationAtPoint(o.renderWorldCopies ? n.wrap() : n, d);\n          }\n          return t.preloadOnly || this._fireMoveEvents(i), o;\n        };\n\n        if (t.preloadOnly) {\n          const e = this._emulate(T, t.duration, o);\n\n          return this._preloadTiles(e), this;\n        }\n\n        const E = {\n          moving: this._moving,\n          zooming: this._zooming,\n          rotating: this._rotating,\n          pitching: this._pitching\n        };\n        return this._zooming = x, this._rotating = y, this._pitching = b, this._padding = w, this._easeId = t.easeId, this._prepareEase(i, t.noMoveStart, E), this._ease(T(o), e => {\n          o.recenterOnTerrain(), this._afterEase(i, e);\n        }, t), this;\n      }\n\n      _prepareEase(t, i, o = {}) {\n        this._moving = !0, this.transform.cameraElevationReference = \"sea\", i || o.moving || this.fire(new e.Event(\"movestart\", t)), this._zooming && !o.zooming && this.fire(new e.Event(\"zoomstart\", t)), this._rotating && !o.rotating && this.fire(new e.Event(\"rotatestart\", t)), this._pitching && !o.pitching && this.fire(new e.Event(\"pitchstart\", t));\n      }\n\n      _fireMoveEvents(t) {\n        this.fire(new e.Event(\"move\", t)), this._zooming && this.fire(new e.Event(\"zoom\", t)), this._rotating && this.fire(new e.Event(\"rotate\", t)), this._pitching && this.fire(new e.Event(\"pitch\", t));\n      }\n\n      _afterEase(t, i) {\n        if (this._easeId && i && this._easeId === i) return;\n        this._easeId = void 0, this.transform.cameraElevationReference = \"ground\";\n        const o = this._zooming,\n              r = this._rotating,\n              n = this._pitching;\n        this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, o && this.fire(new e.Event(\"zoomend\", t)), r && this.fire(new e.Event(\"rotateend\", t)), n && this.fire(new e.Event(\"pitchend\", t)), this.fire(new e.Event(\"moveend\", t));\n      }\n\n      flyTo(t, i) {\n        if (!t.essential && e.exported.prefersReducedMotion) {\n          const o = e.pick(t, [\"center\", \"zoom\", \"bearing\", \"pitch\", \"around\"]);\n          return this.jumpTo(o, i);\n        }\n\n        this.stop(), t = e.extend({\n          offset: [0, 0],\n          speed: 1.2,\n          curve: 1.42,\n          easing: e.ease\n        }, t);\n\n        const o = this.transform,\n              r = this.getZoom(),\n              n = this.getBearing(),\n              a = this.getPitch(),\n              s = this.getPadding(),\n              l = \"zoom\" in t ? e.clamp(+t.zoom, o.minZoom, o.maxZoom) : r,\n              c = \"bearing\" in t ? this._normalizeBearing(t.bearing, n) : n,\n              h = \"pitch\" in t ? +t.pitch : a,\n              _ = \"padding\" in t ? t.padding : o.padding,\n              u = o.zoomScale(l - r),\n              d = e.pointGeometry.convert(t.offset);\n\n        let p = o.centerPoint.add(d);\n        const m = o.pointLocation(p),\n              f = e.LngLat.convert(t.center || m);\n\n        this._normalizeCenter(f);\n\n        const g = o.project(m),\n              v = o.project(f).sub(g);\n        let x = t.curve;\n        const y = Math.max(o.width, o.height),\n              b = y / u,\n              w = v.mag();\n\n        if (\"minZoom\" in t) {\n          const i = e.clamp(Math.min(t.minZoom, r, l), o.minZoom, o.maxZoom),\n                n = y / o.zoomScale(i - r);\n          x = Math.sqrt(n / w * 2);\n        }\n\n        const T = x * x;\n\n        function E(e) {\n          const t = (b * b - y * y + (e ? -1 : 1) * T * T * w * w) / (2 * (e ? b : y) * T * w);\n          return Math.log(Math.sqrt(t * t + 1) - t);\n        }\n\n        function C(e) {\n          return (Math.exp(e) - Math.exp(-e)) / 2;\n        }\n\n        function I(e) {\n          return (Math.exp(e) + Math.exp(-e)) / 2;\n        }\n\n        const M = E(0);\n\n        let S = function (e) {\n          return I(M) / I(M + x * e);\n        },\n            z = function (e) {\n          return y * ((I(M) * (C(t = M + x * e) / I(t)) - C(M)) / T) / w;\n          var t;\n        },\n            D = (E(1) - M) / x;\n\n        if (Math.abs(w) < 1e-6 || !isFinite(D)) {\n          if (Math.abs(y - b) < 1e-6) return this.easeTo(t, i);\n          const e = b < y ? -1 : 1;\n          D = Math.abs(Math.log(b / y)) / x, z = function () {\n            return 0;\n          }, S = function (t) {\n            return Math.exp(e * x * t);\n          };\n        }\n\n        t.duration = \"duration\" in t ? +t.duration : 1e3 * D / (\"screenSpeed\" in t ? +t.screenSpeed / x : +t.speed), t.maxDuration && t.duration > t.maxDuration && (t.duration = 0);\n\n        const P = n !== c,\n              A = h !== a,\n              L = !o.isPaddingEqual(_),\n              R = o => u => {\n          const m = u * D,\n                x = 1 / S(m);\n          o.zoom = 1 === u ? l : r + o.scaleZoom(x), P && (o.bearing = e.number(n, c, u)), A && (o.pitch = e.number(a, h, u)), L && (o.interpolatePadding(s, _, u), p = o.centerPoint.add(d));\n          const y = 1 === u ? f : o.unproject(g.add(v.mult(z(m))).mult(x));\n          return o.setLocationAtPoint(o.renderWorldCopies ? y.wrap() : y, p), o._updateCameraOnTerrain(), t.preloadOnly || this._fireMoveEvents(i), o;\n        };\n\n        if (t.preloadOnly) {\n          const e = this._emulate(R, t.duration, o);\n\n          return this._preloadTiles(e), this;\n        }\n\n        return this._zooming = !0, this._rotating = P, this._pitching = A, this._padding = L, this._prepareEase(i, !1), this._ease(R(o), () => this._afterEase(i), t), this;\n      }\n\n      isEasing() {\n        return !!this._easeFrameId;\n      }\n\n      stop() {\n        return this._stop();\n      }\n\n      _stop(e, t) {\n        if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), this._easeFrameId = void 0, this._onEaseFrame = void 0), this._onEaseEnd) {\n          const e = this._onEaseEnd;\n          this._onEaseEnd = void 0, e.call(this, t);\n        }\n\n        if (!e) {\n          const e = this.handlers;\n          e && e.stop(!1);\n        }\n\n        return this;\n      }\n\n      _ease(t, i, o) {\n        !1 === o.animate || 0 === o.duration ? (t(1), i()) : (this._easeStart = e.exported.now(), this._easeOptions = o, this._onEaseFrame = t, this._onEaseEnd = i, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));\n      }\n\n      _renderFrameCallback() {\n        const t = Math.min((e.exported.now() - this._easeStart) / this._easeOptions.duration, 1),\n              i = this._onEaseFrame;\n        i && i(this._easeOptions.easing(t)), t < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();\n      }\n\n      _normalizeBearing(t, i) {\n        t = e.wrap(t, -180, 180);\n        const o = Math.abs(t - i);\n        return Math.abs(t - 360 - i) < o && (t -= 360), Math.abs(t + 360 - i) < o && (t += 360), t;\n      }\n\n      _normalizeCenter(e) {\n        const t = this.transform;\n        if (!t.renderWorldCopies || t.maxBounds) return;\n        const i = e.lng - t.center.lng;\n        e.lng += i > 180 ? -360 : i < -180 ? 360 : 0;\n      }\n\n      _emulate(e, t, i) {\n        const o = Math.ceil(15 * t / 1e3),\n              r = [],\n              n = e(i.clone());\n\n        for (let e = 0; e <= o; e++) {\n          const t = n(e / o);\n          r.push(t.clone());\n        }\n\n        return r;\n      }\n\n    }\n\n    class Ur {\n      constructor(t = {}) {\n        this.options = t, e.bindAll([\"_toggleAttribution\", \"_updateEditLink\", \"_updateData\", \"_updateCompact\"], this);\n      }\n\n      getDefaultPosition() {\n        return \"bottom-right\";\n      }\n\n      onAdd(e) {\n        const t = this.options && this.options.compact;\n        return this._map = e, this._container = n(\"div\", \"mapboxgl-ctrl mapboxgl-ctrl-attrib\"), this._compactButton = n(\"button\", \"mapboxgl-ctrl-attrib-button\", this._container), n(\"span\", \"mapboxgl-ctrl-icon\", this._compactButton).setAttribute(\"aria-hidden\", \"true\"), this._compactButton.type = \"button\", this._compactButton.addEventListener(\"click\", this._toggleAttribution), this._setElementTitle(this._compactButton, \"ToggleAttribution\"), this._innerContainer = n(\"div\", \"mapboxgl-ctrl-attrib-inner\", this._container), this._innerContainer.setAttribute(\"role\", \"list\"), t && this._container.classList.add(\"mapboxgl-compact\"), this._updateAttributions(), this._updateEditLink(), this._map.on(\"styledata\", this._updateData), this._map.on(\"sourcedata\", this._updateData), this._map.on(\"moveend\", this._updateEditLink), void 0 === t && (this._map.on(\"resize\", this._updateCompact), this._updateCompact()), this._container;\n      }\n\n      onRemove() {\n        this._container.remove(), this._map.off(\"styledata\", this._updateData), this._map.off(\"sourcedata\", this._updateData), this._map.off(\"moveend\", this._updateEditLink), this._map.off(\"resize\", this._updateCompact), this._map = void 0, this._attribHTML = void 0;\n      }\n\n      _setElementTitle(e, t) {\n        const i = this._map._getUIString(`AttributionControl.${t}`);\n\n        e.setAttribute(\"aria-label\", i), e.removeAttribute(\"title\"), e.firstElementChild && e.firstElementChild.setAttribute(\"title\", i);\n      }\n\n      _toggleAttribution() {\n        this._container.classList.contains(\"mapboxgl-compact-show\") ? (this._container.classList.remove(\"mapboxgl-compact-show\"), this._compactButton.setAttribute(\"aria-expanded\", \"false\")) : (this._container.classList.add(\"mapboxgl-compact-show\"), this._compactButton.setAttribute(\"aria-expanded\", \"true\"));\n      }\n\n      _updateEditLink() {\n        let t = this._editLink;\n        t || (t = this._editLink = this._container.querySelector(\".mapbox-improve-map\"));\n        const i = [{\n          key: \"owner\",\n          value: this.styleOwner\n        }, {\n          key: \"id\",\n          value: this.styleId\n        }, {\n          key: \"access_token\",\n          value: this._map._requestManager._customAccessToken || e.config.ACCESS_TOKEN\n        }];\n\n        if (t) {\n          const o = i.reduce((e, t, o) => (t.value && (e += `${t.key}=${t.value}${o < i.length - 1 ? \"&\" : \"\"}`), e), \"?\");\n          t.href = `${e.config.FEEDBACK_URL}/${o}${this._map._hash ? this._map._hash.getHashString(!0) : \"\"}`, t.rel = \"noopener nofollow\", this._setElementTitle(t, \"MapFeedback\");\n        }\n      }\n\n      _updateData(e) {\n        !e || \"metadata\" !== e.sourceDataType && \"visibility\" !== e.sourceDataType && \"style\" !== e.dataType || (this._updateAttributions(), this._updateEditLink());\n      }\n\n      _updateAttributions() {\n        if (!this._map.style) return;\n        let e = [];\n\n        if (this._map.style.stylesheet) {\n          const e = this._map.style.stylesheet;\n          this.styleOwner = e.owner, this.styleId = e.id;\n        }\n\n        const t = this._map.style._sourceCaches;\n\n        for (const i in t) {\n          const o = t[i];\n\n          if (o.used) {\n            const t = o.getSource();\n            t.attribution && e.indexOf(t.attribution) < 0 && e.push(t.attribution);\n          }\n        }\n\n        e.sort((e, t) => e.length - t.length), e = e.filter((t, i) => {\n          for (let o = i + 1; o < e.length; o++) if (e[o].indexOf(t) >= 0) return !1;\n\n          return !0;\n        }), this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = [...this.options.customAttribution, ...e] : e.unshift(this.options.customAttribution));\n        const i = e.join(\" | \");\n        i !== this._attribHTML && (this._attribHTML = i, e.length ? (this._innerContainer.innerHTML = i, this._container.classList.remove(\"mapboxgl-attrib-empty\")) : this._container.classList.add(\"mapboxgl-attrib-empty\"), this._editLink = null);\n      }\n\n      _updateCompact() {\n        this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add(\"mapboxgl-compact\") : this._container.classList.remove(\"mapboxgl-compact\", \"mapboxgl-compact-show\");\n      }\n\n    }\n\n    class Nr {\n      constructor() {\n        e.bindAll([\"_updateLogo\", \"_updateCompact\"], this);\n      }\n\n      onAdd(e) {\n        this._map = e, this._container = n(\"div\", \"mapboxgl-ctrl\");\n        const t = n(\"a\", \"mapboxgl-ctrl-logo\");\n        return t.target = \"_blank\", t.rel = \"noopener nofollow\", t.href = \"https://www.mapbox.com/\", t.setAttribute(\"aria-label\", this._map._getUIString(\"LogoControl.Title\")), t.setAttribute(\"rel\", \"noopener nofollow\"), this._container.appendChild(t), this._container.style.display = \"none\", this._map.on(\"sourcedata\", this._updateLogo), this._updateLogo(), this._map.on(\"resize\", this._updateCompact), this._updateCompact(), this._container;\n      }\n\n      onRemove() {\n        this._container.remove(), this._map.off(\"sourcedata\", this._updateLogo), this._map.off(\"resize\", this._updateCompact);\n      }\n\n      getDefaultPosition() {\n        return \"bottom-left\";\n      }\n\n      _updateLogo(e) {\n        e && \"metadata\" !== e.sourceDataType || (this._container.style.display = this._logoRequired() ? \"block\" : \"none\");\n      }\n\n      _logoRequired() {\n        if (!this._map.style) return !0;\n        const e = this._map.style._sourceCaches;\n        if (0 === Object.entries(e).length) return !0;\n\n        for (const t in e) {\n          const i = e[t].getSource();\n          if (i.hasOwnProperty(\"mapbox_logo\") && !i.mapbox_logo) return !1;\n        }\n\n        return !0;\n      }\n\n      _updateCompact() {\n        const e = this._container.children;\n\n        if (e.length) {\n          const t = e[0];\n          this._map.getCanvasContainer().offsetWidth < 250 ? t.classList.add(\"mapboxgl-compact\") : t.classList.remove(\"mapboxgl-compact\");\n        }\n      }\n\n    }\n\n    class Gr {\n      constructor() {\n        this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;\n      }\n\n      add(e) {\n        const t = ++this._id;\n        return this._queue.push({\n          callback: e,\n          id: t,\n          cancelled: !1\n        }), t;\n      }\n\n      remove(e) {\n        const t = this._currentlyRunning,\n              i = t ? this._queue.concat(t) : this._queue;\n\n        for (const t of i) if (t.id === e) return void (t.cancelled = !0);\n      }\n\n      run(e = 0) {\n        const t = this._currentlyRunning = this._queue;\n        this._queue = [];\n\n        for (const i of t) if (!i.cancelled && (i.callback(e), this._cleared)) break;\n\n        this._cleared = !1, this._currentlyRunning = !1;\n      }\n\n      clear() {\n        this._currentlyRunning && (this._cleared = !0), this._queue = [];\n      }\n\n    }\n\n    function jr(t, i, o) {\n      if (t = new e.LngLat(t.lng, t.lat), i) {\n        const r = new e.LngLat(t.lng - 360, t.lat),\n              n = new e.LngLat(t.lng + 360, t.lat),\n              a = 360 * Math.ceil(Math.abs(t.lng - o.center.lng) / 360),\n              s = o.locationPoint(t).distSqr(i),\n              l = i.x < 0 || i.y < 0 || i.x > o.width || i.y > o.height;\n        o.locationPoint(r).distSqr(i) < s && (l || Math.abs(r.lng - o.center.lng) < a) ? t = r : o.locationPoint(n).distSqr(i) < s && (l || Math.abs(n.lng - o.center.lng) < a) && (t = n);\n      }\n\n      for (; Math.abs(t.lng - o.center.lng) > 180;) {\n        const e = o.locationPoint(t);\n        if (e.x >= 0 && e.y >= 0 && e.x <= o.width && e.y <= o.height) break;\n        t.lng > o.center.lng ? t.lng -= 360 : t.lng += 360;\n      }\n\n      return t;\n    }\n\n    const Zr = {\n      center: \"translate(-50%,-50%)\",\n      top: \"translate(-50%,0)\",\n      \"top-left\": \"translate(0,0)\",\n      \"top-right\": \"translate(-100%,0)\",\n      bottom: \"translate(-50%,-100%)\",\n      \"bottom-left\": \"translate(0,-100%)\",\n      \"bottom-right\": \"translate(-100%,-100%)\",\n      left: \"translate(0,-50%)\",\n      right: \"translate(-100%,-50%)\"\n    };\n\n    class Vr extends e.Evented {\n      constructor(t, i) {\n        if (super(), (t instanceof e.window.HTMLElement || i) && (t = e.extend({\n          element: t\n        }, i)), e.bindAll([\"_update\", \"_onMove\", \"_onUp\", \"_addDragHandler\", \"_onMapClick\", \"_onKeyPress\", \"_clearFadeTimer\"], this), this._anchor = t && t.anchor || \"center\", this._color = t && t.color || \"#3FB1CE\", this._scale = t && t.scale || 1, this._draggable = t && t.draggable || !1, this._clickTolerance = t && t.clickTolerance || 0, this._isDragging = !1, this._state = \"inactive\", this._rotation = t && t.rotation || 0, this._rotationAlignment = t && t.rotationAlignment || \"auto\", this._pitchAlignment = t && t.pitchAlignment && \"auto\" !== t.pitchAlignment ? t.pitchAlignment : this._rotationAlignment, this._updateMoving = () => this._update(!0), t && t.element) this._element = t.element, this._offset = e.pointGeometry.convert(t && t.offset || [0, 0]);else {\n          this._defaultMarker = !0, this._element = n(\"div\");\n          const i = 41,\n                o = 27,\n                r = a(\"svg\", {\n            display: \"block\",\n            height: i * this._scale + \"px\",\n            width: o * this._scale + \"px\",\n            viewBox: `0 0 ${o} ${i}`\n          }, this._element),\n                s = a(\"radialGradient\", {\n            id: \"shadowGradient\"\n          }, a(\"defs\", {}, r));\n          a(\"stop\", {\n            offset: \"10%\",\n            \"stop-opacity\": .4\n          }, s), a(\"stop\", {\n            offset: \"100%\",\n            \"stop-opacity\": .05\n          }, s), a(\"ellipse\", {\n            cx: 13.5,\n            cy: 34.8,\n            rx: 10.5,\n            ry: 5.25,\n            fill: \"url(#shadowGradient)\"\n          }, r), a(\"path\", {\n            fill: this._color,\n            d: \"M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z\"\n          }, r), a(\"path\", {\n            opacity: .25,\n            d: \"M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z\"\n          }, r), a(\"circle\", {\n            fill: \"white\",\n            cx: 13.5,\n            cy: 13.5,\n            r: 5.5\n          }, r), this._offset = e.pointGeometry.convert(t && t.offset || [0, -14]);\n        }\n        this._element.hasAttribute(\"aria-label\") || this._element.setAttribute(\"aria-label\", \"Map marker\"), this._element.classList.add(\"mapboxgl-marker\"), this._element.addEventListener(\"dragstart\", e => {\n          e.preventDefault();\n        }), this._element.addEventListener(\"mousedown\", e => {\n          e.preventDefault();\n        });\n        const o = this._element.classList;\n\n        for (const e in Zr) o.remove(`mapboxgl-marker-anchor-${e}`);\n\n        o.add(`mapboxgl-marker-anchor-${this._anchor}`), this._popup = null;\n      }\n\n      addTo(e) {\n        return e === this._map || (this.remove(), this._map = e, e.getCanvasContainer().appendChild(this._element), e.on(\"move\", this._updateMoving), e.on(\"moveend\", this._update), e.on(\"remove\", this._clearFadeTimer), e._addMarker(this), this.setDraggable(this._draggable), this._update(), e.on(\"click\", this._onMapClick)), this;\n      }\n\n      remove() {\n        const e = this._map;\n        return e && (e.off(\"click\", this._onMapClick), e.off(\"move\", this._updateMoving), e.off(\"moveend\", this._update), e.off(\"mousedown\", this._addDragHandler), e.off(\"touchstart\", this._addDragHandler), e.off(\"mouseup\", this._onUp), e.off(\"touchend\", this._onUp), e.off(\"mousemove\", this._onMove), e.off(\"touchmove\", this._onMove), e.off(\"remove\", this._clearFadeTimer), e._removeMarker(this), this._map = void 0), this._clearFadeTimer(), this._element.remove(), this._popup && this._popup.remove(), this;\n      }\n\n      getLngLat() {\n        return this._lngLat;\n      }\n\n      setLngLat(t) {\n        return this._lngLat = e.LngLat.convert(t), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(!0), this;\n      }\n\n      getElement() {\n        return this._element;\n      }\n\n      setPopup(e) {\n        if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeAttribute(\"role\"), this._element.removeEventListener(\"keypress\", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute(\"tabindex\")), e) {\n          if (!(\"offset\" in e.options)) {\n            const t = 38.1,\n                  i = 13.5,\n                  o = Math.sqrt(Math.pow(i, 2) / 2);\n            e.options.offset = this._defaultMarker ? {\n              top: [0, 0],\n              \"top-left\": [0, 0],\n              \"top-right\": [0, 0],\n              bottom: [0, -t],\n              \"bottom-left\": [o, -1 * (t - i + o)],\n              \"bottom-right\": [-o, -1 * (t - i + o)],\n              left: [i, -1 * (t - i)],\n              right: [-i, -1 * (t - i)]\n            } : this._offset;\n          }\n\n          this._popup = e, this._lngLat && this._popup.setLngLat(this._lngLat), this._element.setAttribute(\"role\", \"button\"), this._originalTabIndex = this._element.getAttribute(\"tabindex\"), this._originalTabIndex || this._element.setAttribute(\"tabindex\", \"0\"), this._element.addEventListener(\"keypress\", this._onKeyPress), this._element.setAttribute(\"aria-expanded\", \"false\");\n        }\n\n        return this;\n      }\n\n      _onKeyPress(e) {\n        const t = e.code,\n              i = e.charCode || e.keyCode;\n        \"Space\" !== t && \"Enter\" !== t && 32 !== i && 13 !== i || this.togglePopup();\n      }\n\n      _onMapClick(e) {\n        const t = e.originalEvent.target,\n              i = this._element;\n        this._popup && (t === i || i.contains(t)) && this.togglePopup();\n      }\n\n      getPopup() {\n        return this._popup;\n      }\n\n      togglePopup() {\n        const e = this._popup;\n        return e ? (e.isOpen() ? (e.remove(), this._element.setAttribute(\"aria-expanded\", \"false\")) : this._map && (e.addTo(this._map), this._element.setAttribute(\"aria-expanded\", \"true\")), this) : this;\n      }\n\n      _evaluateOpacity() {\n        const e = this._map;\n        if (!e) return;\n        const t = this._pos;\n        if (!t || t.x < 0 || t.x > e.transform.width || t.y < 0 || t.y > e.transform.height) return void this._clearFadeTimer();\n        const i = e.unproject(t);\n        let o = !1;\n\n        if (e.transform._terrainEnabled() && e.getTerrain()) {\n          const t = e.getFreeCameraOptions();\n\n          if (t.position) {\n            const e = t.position.toLngLat();\n            o = e.distanceTo(i) < .9 * e.distanceTo(this._lngLat);\n          }\n        }\n\n        const r = (1 - e._queryFogOpacity(i)) * (o ? .2 : 1);\n        this._element.style.opacity = `${r}`, this._popup && this._popup._setOpacity(`${r}`), this._fadeTimer = null;\n      }\n\n      _clearFadeTimer() {\n        this._fadeTimer && (clearTimeout(this._fadeTimer), this._fadeTimer = null);\n      }\n\n      _updateDOM() {\n        const e = this._pos;\n        if (!e) return;\n\n        const t = this._offset.mult(this._scale),\n              i = this._calculatePitch(),\n              o = this._calculateRotation();\n\n        this._element.style.transform = `\\n            translate(${e.x}px, ${e.y}px) ${Zr[this._anchor]}\\n            rotateX(${i}deg) rotateZ(${o}deg)\\n            translate(${t.x}px, ${t.y}px)\\n        `;\n      }\n\n      _calculatePitch() {\n        return \"viewport\" === this._pitchAlignment || \"auto\" === this._pitchAlignment ? 0 : this._map && \"map\" === this._pitchAlignment ? this._map.getPitch() : 0;\n      }\n\n      _calculateRotation() {\n        return \"viewport\" === this._rotationAlignment || \"auto\" === this._rotationAlignment ? this._rotation : this._map && \"map\" === this._rotationAlignment ? this._rotation - this._map.getBearing() : 0;\n      }\n\n      _update(t) {\n        e.window.cancelAnimationFrame(this._updateFrameId);\n        const i = this._map;\n        i && (i.transform.renderWorldCopies && (this._lngLat = jr(this._lngLat, this._pos, i.transform)), this._pos = i.project(this._lngLat), !0 === t ? this._updateFrameId = e.window.requestAnimationFrame(() => {\n          this._element && this._pos && this._anchor && (this._pos = this._pos.round(), this._updateDOM());\n        }) : this._pos = this._pos.round(), i._requestDomTask(() => {\n          this._map && (this._element && this._pos && this._anchor && this._updateDOM(), !i.getTerrain() && !i.getFog() || this._fadeTimer || (this._fadeTimer = setTimeout(this._evaluateOpacity.bind(this), 60)));\n        }));\n      }\n\n      getOffset() {\n        return this._offset;\n      }\n\n      setOffset(t) {\n        return this._offset = e.pointGeometry.convert(t), this._update(), this;\n      }\n\n      _onMove(t) {\n        const i = this._map;\n\n        if (i) {\n          if (!this._isDragging) {\n            const e = this._clickTolerance || i._clickTolerance;\n            this._isDragging = t.point.dist(this._pointerdownPos) >= e;\n          }\n\n          this._isDragging && (this._pos = t.point.sub(this._positionDelta), this._lngLat = i.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = \"none\", \"pending\" === this._state && (this._state = \"active\", this.fire(new e.Event(\"dragstart\"))), this.fire(new e.Event(\"drag\")));\n        }\n      }\n\n      _onUp() {\n        this._element.style.pointerEvents = \"auto\", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1;\n        const t = this._map;\n        t && (t.off(\"mousemove\", this._onMove), t.off(\"touchmove\", this._onMove)), \"active\" === this._state && this.fire(new e.Event(\"dragend\")), this._state = \"inactive\";\n      }\n\n      _addDragHandler(e) {\n        const t = this._map;\n        t && this._element.contains(e.originalEvent.target) && (e.preventDefault(), this._positionDelta = e.point.sub(this._pos), this._pointerdownPos = e.point, this._state = \"pending\", t.on(\"mousemove\", this._onMove), t.on(\"touchmove\", this._onMove), t.once(\"mouseup\", this._onUp), t.once(\"touchend\", this._onUp));\n      }\n\n      setDraggable(e) {\n        this._draggable = !!e;\n        const t = this._map;\n        return t && (e ? (t.on(\"mousedown\", this._addDragHandler), t.on(\"touchstart\", this._addDragHandler)) : (t.off(\"mousedown\", this._addDragHandler), t.off(\"touchstart\", this._addDragHandler))), this;\n      }\n\n      isDraggable() {\n        return this._draggable;\n      }\n\n      setRotation(e) {\n        return this._rotation = e || 0, this._update(), this;\n      }\n\n      getRotation() {\n        return this._rotation;\n      }\n\n      setRotationAlignment(e) {\n        return this._rotationAlignment = e || \"auto\", this._update(), this;\n      }\n\n      getRotationAlignment() {\n        return this._rotationAlignment;\n      }\n\n      setPitchAlignment(e) {\n        return this._pitchAlignment = e && \"auto\" !== e ? e : this._rotationAlignment, this._update(), this;\n      }\n\n      getPitchAlignment() {\n        return this._pitchAlignment;\n      }\n\n    }\n\n    class Wr {\n      constructor(e) {\n        this.jumpTo(e);\n      }\n\n      getValue(t) {\n        if (t <= this._startTime) return this._start;\n        if (t >= this._endTime) return this._end;\n        const i = e.easeCubicInOut((t - this._startTime) / (this._endTime - this._startTime));\n        return this._start * (1 - i) + this._end * i;\n      }\n\n      isEasing(e) {\n        return e >= this._startTime && e <= this._endTime;\n      }\n\n      jumpTo(e) {\n        this._startTime = -1 / 0, this._endTime = -1 / 0, this._start = e, this._end = e;\n      }\n\n      easeTo(e, t, i) {\n        this._start = this.getValue(t), this._end = e, this._startTime = t, this._endTime = t + i;\n      }\n\n    }\n\n    const qr = {\n      \"AttributionControl.ToggleAttribution\": \"Toggle attribution\",\n      \"AttributionControl.MapFeedback\": \"Map feedback\",\n      \"FullscreenControl.Enter\": \"Enter fullscreen\",\n      \"FullscreenControl.Exit\": \"Exit fullscreen\",\n      \"GeolocateControl.FindMyLocation\": \"Find my location\",\n      \"GeolocateControl.LocationNotAvailable\": \"Location not available\",\n      \"LogoControl.Title\": \"Mapbox logo\",\n      \"NavigationControl.ResetBearing\": \"Reset bearing to north\",\n      \"NavigationControl.ZoomIn\": \"Zoom in\",\n      \"NavigationControl.ZoomOut\": \"Zoom out\",\n      \"ScaleControl.Feet\": \"ft\",\n      \"ScaleControl.Meters\": \"m\",\n      \"ScaleControl.Kilometers\": \"km\",\n      \"ScaleControl.Miles\": \"mi\",\n      \"ScaleControl.NauticalMiles\": \"nm\",\n      \"ScrollZoomBlocker.CtrlMessage\": \"Use ctrl + scroll to zoom the map\",\n      \"ScrollZoomBlocker.CmdMessage\": \"Use â + scroll to zoom the map\",\n      \"TouchPanBlocker.Message\": \"Use two fingers to move the map\"\n    },\n          Xr = {\n      center: [0, 0],\n      zoom: 0,\n      bearing: 0,\n      pitch: 0,\n      minZoom: -2,\n      maxZoom: 22,\n      minPitch: 0,\n      maxPitch: 85,\n      interactive: !0,\n      scrollZoom: !0,\n      boxZoom: !0,\n      dragRotate: !0,\n      dragPan: !0,\n      keyboard: !0,\n      doubleClickZoom: !0,\n      touchZoomRotate: !0,\n      touchPitch: !0,\n      cooperativeGestures: !1,\n      bearingSnap: 7,\n      clickTolerance: 3,\n      pitchWithRotate: !0,\n      hash: !1,\n      attributionControl: !0,\n      failIfMajorPerformanceCaveat: !1,\n      preserveDrawingBuffer: !1,\n      trackResize: !0,\n      optimizeForTerrain: !0,\n      renderWorldCopies: !0,\n      refreshExpiredTiles: !0,\n      minTileCacheSize: null,\n      maxTileCacheSize: null,\n      localIdeographFontFamily: \"sans-serif\",\n      localFontFamily: null,\n      transformRequest: null,\n      accessToken: null,\n      fadeDuration: 300,\n      crossSourceCollisions: !0\n    };\n\n    function $r(e) {\n      e.parentNode && e.parentNode.removeChild(e);\n    }\n\n    const Hr = {\n      showCompass: !0,\n      showZoom: !0,\n      visualizePitch: !1\n    };\n\n    class Kr {\n      constructor(t, i, o = !1) {\n        this._clickTolerance = 10, this.element = i, this.mouseRotate = new hr({\n          clickTolerance: t.dragRotate._mouseRotate._clickTolerance\n        }), this.map = t, o && (this.mousePitch = new _r({\n          clickTolerance: t.dragRotate._mousePitch._clickTolerance\n        })), e.bindAll([\"mousedown\", \"mousemove\", \"mouseup\", \"touchstart\", \"touchmove\", \"touchend\", \"reset\"], this), i.addEventListener(\"mousedown\", this.mousedown), i.addEventListener(\"touchstart\", this.touchstart, {\n          passive: !1\n        }), i.addEventListener(\"touchmove\", this.touchmove), i.addEventListener(\"touchend\", this.touchend), i.addEventListener(\"touchcancel\", this.reset);\n      }\n\n      down(e, t) {\n        this.mouseRotate.mousedown(e, t), this.mousePitch && this.mousePitch.mousedown(e, t), h();\n      }\n\n      move(e, t) {\n        const i = this.map,\n              o = this.mouseRotate.mousemoveWindow(e, t),\n              r = o && o.bearingDelta;\n\n        if (r && i.setBearing(i.getBearing() + r), this.mousePitch) {\n          const o = this.mousePitch.mousemoveWindow(e, t),\n                r = o && o.pitchDelta;\n          r && i.setPitch(i.getPitch() + r);\n        }\n      }\n\n      off() {\n        const e = this.element;\n        e.removeEventListener(\"mousedown\", this.mousedown), e.removeEventListener(\"touchstart\", this.touchstart, {\n          passive: !1\n        }), e.removeEventListener(\"touchmove\", this.touchmove), e.removeEventListener(\"touchend\", this.touchend), e.removeEventListener(\"touchcancel\", this.reset), this.offTemp();\n      }\n\n      offTemp() {\n        _(), e.window.removeEventListener(\"mousemove\", this.mousemove), e.window.removeEventListener(\"mouseup\", this.mouseup);\n      }\n\n      mousedown(t) {\n        this.down(e.extend({}, t, {\n          ctrlKey: !0,\n          preventDefault: () => t.preventDefault()\n        }), p(this.element, t)), e.window.addEventListener(\"mousemove\", this.mousemove), e.window.addEventListener(\"mouseup\", this.mouseup);\n      }\n\n      mousemove(e) {\n        this.move(e, p(this.element, e));\n      }\n\n      mouseup(e) {\n        this.mouseRotate.mouseupWindow(e), this.mousePitch && this.mousePitch.mouseupWindow(e), this.offTemp();\n      }\n\n      touchstart(e) {\n        1 !== e.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = m(this.element, e.targetTouches)[0], this.down({\n          type: \"mousedown\",\n          button: 0,\n          ctrlKey: !0,\n          preventDefault: () => e.preventDefault()\n        }, this._startPos));\n      }\n\n      touchmove(e) {\n        1 !== e.targetTouches.length ? this.reset() : (this._lastPos = m(this.element, e.targetTouches)[0], this.move({\n          preventDefault: () => e.preventDefault()\n        }, this._lastPos));\n      }\n\n      touchend(e) {\n        0 === e.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();\n      }\n\n      reset() {\n        this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();\n      }\n\n    }\n\n    const Yr = {\n      positionOptions: {\n        enableHighAccuracy: !1,\n        maximumAge: 0,\n        timeout: 6e3\n      },\n      fitBoundsOptions: {\n        maxZoom: 15\n      },\n      trackUserLocation: !1,\n      showAccuracyCircle: !0,\n      showUserLocation: !0,\n      showUserHeading: !1\n    };\n    let Jr,\n        Qr = 0,\n        en = !1;\n    const tn = {\n      maxWidth: 100,\n      unit: \"metric\"\n    };\n\n    function on(e, t, i) {\n      const o = i && i.maxWidth || 100,\n            r = e._containerHeight / 2,\n            n = e._containerWidth / 2 - o / 2,\n            a = e.unproject([n, r]),\n            s = e.unproject([n + o, r]),\n            l = a.distanceTo(s);\n\n      if (i && \"imperial\" === i.unit) {\n        const i = 3.2808 * l;\n        i > 5280 ? rn(t, o, i / 5280, e._getUIString(\"ScaleControl.Miles\"), e) : rn(t, o, i, e._getUIString(\"ScaleControl.Feet\"), e);\n      } else i && \"nautical\" === i.unit ? rn(t, o, l / 1852, e._getUIString(\"ScaleControl.NauticalMiles\"), e) : l >= 1e3 ? rn(t, o, l / 1e3, e._getUIString(\"ScaleControl.Kilometers\"), e) : rn(t, o, l, e._getUIString(\"ScaleControl.Meters\"), e);\n    }\n\n    function rn(e, t, i, o, r) {\n      const n = function (e) {\n        const t = Math.pow(10, `${Math.floor(e)}`.length - 1);\n        let i = e / t;\n        return i = i >= 10 ? 10 : i >= 5 ? 5 : i >= 3 ? 3 : i >= 2 ? 2 : i >= 1 ? 1 : function (e) {\n          const t = Math.pow(10, Math.ceil(-Math.log(e) / Math.LN10));\n          return Math.round(e * t) / t;\n        }(i), t * i;\n      }(i),\n            a = n / i;\n\n      r._requestDomTask(() => {\n        e.style.width = t * a + \"px\", e.innerHTML = `${n}&nbsp;${o}`;\n      });\n    }\n\n    const nn = {\n      closeButton: !0,\n      closeOnClick: !0,\n      focusAfterOpen: !0,\n      className: \"\",\n      maxWidth: \"240px\"\n    },\n          an = [\"a[href]\", \"[tabindex]:not([tabindex='-1'])\", \"[contenteditable]:not([contenteditable='false'])\", \"button:not([disabled])\", \"input:not([disabled])\", \"select:not([disabled])\", \"textarea:not([disabled])\"].join(\", \");\n\n    function sn(t = new e.pointGeometry(0, 0), i = \"bottom\") {\n      if (\"number\" == typeof t) {\n        const o = Math.round(Math.sqrt(.5 * Math.pow(t, 2)));\n\n        switch (i) {\n          case \"top\":\n            return new e.pointGeometry(0, t);\n\n          case \"top-left\":\n            return new e.pointGeometry(o, o);\n\n          case \"top-right\":\n            return new e.pointGeometry(-o, o);\n\n          case \"bottom\":\n            return new e.pointGeometry(0, -t);\n\n          case \"bottom-left\":\n            return new e.pointGeometry(o, -o);\n\n          case \"bottom-right\":\n            return new e.pointGeometry(-o, -o);\n\n          case \"left\":\n            return new e.pointGeometry(t, 0);\n\n          case \"right\":\n            return new e.pointGeometry(-t, 0);\n        }\n\n        return new e.pointGeometry(0, 0);\n      }\n\n      return t instanceof e.pointGeometry || Array.isArray(t) ? e.pointGeometry.convert(t) : e.pointGeometry.convert(t[i] || [0, 0]);\n    }\n\n    const ln = {\n      version: e.version,\n      supported: t,\n      setRTLTextPlugin: e.setRTLTextPlugin,\n      getRTLTextPluginStatus: e.getRTLTextPluginStatus,\n      Map: class extends Fr {\n        constructor(t) {\n          if (null != (t = e.extend({}, Xr, t)).minZoom && null != t.maxZoom && t.minZoom > t.maxZoom) throw new Error(\"maxZoom must be greater than or equal to minZoom\");\n          if (null != t.minPitch && null != t.maxPitch && t.minPitch > t.maxPitch) throw new Error(\"maxPitch must be greater than or equal to minPitch\");\n          if (null != t.minPitch && t.minPitch < 0) throw new Error(\"minPitch must be greater than or equal to 0\");\n          if (null != t.maxPitch && t.maxPitch > 85) throw new Error(\"maxPitch must be less than or equal to 85\");\n\n          if (t.antialias && e.isSafariWithAntialiasingBug(e.window) && (t.antialias = !1, e.warnOnce(\"Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609\")), super(new No(t.minZoom, t.maxZoom, t.minPitch, t.maxPitch, t.renderWorldCopies), t), this._interactive = t.interactive, this._minTileCacheSize = t.minTileCacheSize, this._maxTileCacheSize = t.maxTileCacheSize, this._failIfMajorPerformanceCaveat = t.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = t.preserveDrawingBuffer, this._antialias = t.antialias, this._trackResize = t.trackResize, this._bearingSnap = t.bearingSnap, this._refreshExpiredTiles = t.refreshExpiredTiles, this._fadeDuration = t.fadeDuration, this._isInitialLoad = !0, this._crossSourceCollisions = t.crossSourceCollisions, this._crossFadingFactor = 1, this._collectResourceTiming = t.collectResourceTiming, this._optimizeForTerrain = t.optimizeForTerrain, this._renderTaskQueue = new Gr(), this._domRenderTaskQueue = new Gr(), this._controls = [], this._markers = [], this._mapId = e.uniqueId(), this._locale = e.extend({}, qr, t.locale), this._clickTolerance = t.clickTolerance, this._cooperativeGestures = t.cooperativeGestures, this._containerWidth = 0, this._containerHeight = 0, this._averageElevationLastSampledAt = -1 / 0, this._averageElevationExaggeration = 0, this._averageElevation = new Wr(0), this._explicitProjection = null, this._requestManager = new e.RequestManager(t.transformRequest, t.accessToken, t.testMode), this._silenceAuthErrors = !!t.testMode, \"string\" == typeof t.container) {\n            if (this._container = e.window.document.getElementById(t.container), !this._container) throw new Error(`Container '${t.container}' not found.`);\n          } else {\n            if (!(t.container instanceof e.window.HTMLElement)) throw new Error(\"Invalid type: 'container' must be a String or HTMLElement.\");\n            this._container = t.container;\n          }\n\n          if (this._container.childNodes.length > 0 && e.warnOnce(\"The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead.\"), t.maxBounds && this.setMaxBounds(t.maxBounds), e.bindAll([\"_onWindowOnline\", \"_onWindowResize\", \"_onMapScroll\", \"_contextLost\", \"_contextRestored\"], this), this._setupContainer(), this._setupPainter(), void 0 === this.painter) throw new Error(\"Failed to initialize WebGL.\");\n          this.on(\"move\", () => this._update(!1)), this.on(\"moveend\", () => this._update(!1)), this.on(\"zoom\", () => this._update(!0)), void 0 !== e.window && (e.window.addEventListener(\"online\", this._onWindowOnline, !1), e.window.addEventListener(\"resize\", this._onWindowResize, !1), e.window.addEventListener(\"orientationchange\", this._onWindowResize, !1), e.window.addEventListener(\"webkitfullscreenchange\", this._onWindowResize, !1)), this.handlers = new Or(this, t), this._localFontFamily = t.localFontFamily, this._localIdeographFontFamily = t.localIdeographFontFamily, t.style && this.setStyle(t.style, {\n            localFontFamily: this._localFontFamily,\n            localIdeographFontFamily: this._localIdeographFontFamily\n          }), t.projection && this.setProjection(t.projection), this._hash = t.hash && new jo(\"string\" == typeof t.hash && t.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({\n            center: t.center,\n            zoom: t.zoom,\n            bearing: t.bearing,\n            pitch: t.pitch\n          }), t.bounds && (this.resize(), this.fitBounds(t.bounds, e.extend({}, t.fitBoundsOptions, {\n            duration: 0\n          })))), this.resize(), t.attributionControl && this.addControl(new Ur({\n            customAttribution: t.customAttribution\n          })), this._logoControl = new Nr(), this.addControl(this._logoControl, t.logoPosition), this.on(\"style.load\", () => {\n            this.transform.unmodified && this.jumpTo(this.style.stylesheet);\n          }), this.on(\"data\", t => {\n            this._update(\"style\" === t.dataType), this.fire(new e.Event(`${t.dataType}data`, t));\n          }), this.on(\"dataloading\", t => {\n            this.fire(new e.Event(`${t.dataType}dataloading`, t));\n          });\n        }\n\n        _getMapId() {\n          return this._mapId;\n        }\n\n        addControl(t, i) {\n          if (void 0 === i && (i = t.getDefaultPosition ? t.getDefaultPosition() : \"top-right\"), !t || !t.onAdd) return this.fire(new e.ErrorEvent(new Error(\"Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.\")));\n          const o = t.onAdd(this);\n\n          this._controls.push(t);\n\n          const r = this._controlPositions[i];\n          return -1 !== i.indexOf(\"bottom\") ? r.insertBefore(o, r.firstChild) : r.appendChild(o), this;\n        }\n\n        removeControl(t) {\n          if (!t || !t.onRemove) return this.fire(new e.ErrorEvent(new Error(\"Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.\")));\n\n          const i = this._controls.indexOf(t);\n\n          return i > -1 && this._controls.splice(i, 1), t.onRemove(this), this;\n        }\n\n        hasControl(e) {\n          return this._controls.indexOf(e) > -1;\n        }\n\n        getContainer() {\n          return this._container;\n        }\n\n        getCanvasContainer() {\n          return this._canvasContainer;\n        }\n\n        getCanvas() {\n          return this._canvas;\n        }\n\n        resize(t) {\n          if (this._updateContainerDimensions(), this._containerWidth === this.transform.width && this._containerHeight === this.transform.height) return this;\n          this._resizeCanvas(this._containerWidth, this._containerHeight), this.transform.resize(this._containerWidth, this._containerHeight), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));\n          const i = !this._moving;\n          return i && this.fire(new e.Event(\"movestart\", t)).fire(new e.Event(\"move\", t)), this.fire(new e.Event(\"resize\", t)), i && this.fire(new e.Event(\"moveend\", t)), this;\n        }\n\n        getBounds() {\n          return this.transform.getBounds();\n        }\n\n        getMaxBounds() {\n          return this.transform.getMaxBounds() || null;\n        }\n\n        setMaxBounds(t) {\n          return this.transform.setMaxBounds(e.LngLatBounds.convert(t)), this._update();\n        }\n\n        setMinZoom(t) {\n          if ((t = null == t ? -2 : t) >= -2 && t <= this.transform.maxZoom) return this.transform.minZoom = t, this._update(), this.getZoom() < t ? this.setZoom(t) : this.fire(new e.Event(\"zoomstart\")).fire(new e.Event(\"zoom\")).fire(new e.Event(\"zoomend\")), this;\n          throw new Error(\"minZoom must be between -2 and the current maxZoom, inclusive\");\n        }\n\n        getMinZoom() {\n          return this.transform.minZoom;\n        }\n\n        setMaxZoom(t) {\n          if ((t = null == t ? 22 : t) >= this.transform.minZoom) return this.transform.maxZoom = t, this._update(), this.getZoom() > t ? this.setZoom(t) : this.fire(new e.Event(\"zoomstart\")).fire(new e.Event(\"zoom\")).fire(new e.Event(\"zoomend\")), this;\n          throw new Error(\"maxZoom must be greater than the current minZoom\");\n        }\n\n        getMaxZoom() {\n          return this.transform.maxZoom;\n        }\n\n        setMinPitch(t) {\n          if ((t = null == t ? 0 : t) < 0) throw new Error(\"minPitch must be greater than or equal to 0\");\n          if (t >= 0 && t <= this.transform.maxPitch) return this.transform.minPitch = t, this._update(), this.getPitch() < t ? this.setPitch(t) : this.fire(new e.Event(\"pitchstart\")).fire(new e.Event(\"pitch\")).fire(new e.Event(\"pitchend\")), this;\n          throw new Error(\"minPitch must be between 0 and the current maxPitch, inclusive\");\n        }\n\n        getMinPitch() {\n          return this.transform.minPitch;\n        }\n\n        setMaxPitch(t) {\n          if ((t = null == t ? 85 : t) > 85) throw new Error(\"maxPitch must be less than or equal to 85\");\n          if (t >= this.transform.minPitch) return this.transform.maxPitch = t, this._update(), this.getPitch() > t ? this.setPitch(t) : this.fire(new e.Event(\"pitchstart\")).fire(new e.Event(\"pitch\")).fire(new e.Event(\"pitchend\")), this;\n          throw new Error(\"maxPitch must be greater than the current minPitch\");\n        }\n\n        getMaxPitch() {\n          return this.transform.maxPitch;\n        }\n\n        getRenderWorldCopies() {\n          return this.transform.renderWorldCopies;\n        }\n\n        setRenderWorldCopies(e) {\n          return this.transform.renderWorldCopies = e, this._update();\n        }\n\n        getProjection() {\n          return this._explicitProjection ? this._explicitProjection : this.style && this.style.stylesheet && this.style.stylesheet.projection ? this.style.stylesheet.projection : {\n            name: \"mercator\",\n            center: [0, 0]\n          };\n        }\n\n        setProjection(e) {\n          return this._lazyInitEmptyStyle(), e ? \"string\" == typeof e && (e = {\n            name: e\n          }) : e = null, this._updateProjection(e);\n        }\n\n        _updateProjection(e) {\n          null === e && (this._explicitProjection = null);\n          const t = e || this.getProjection(),\n                i = this.transform.setProjection(t);\n\n          if (e && (this._explicitProjection = this.transform.getProjection()), i) {\n            this.painter.clearBackgroundTiles();\n\n            for (const e in this.style._sourceCaches) this.style._sourceCaches[e].clearTiles();\n\n            this.style.applyProjectionUpdate(), this._update(!0);\n          }\n\n          return this;\n        }\n\n        project(t) {\n          return this.transform.locationPoint3D(e.LngLat.convert(t));\n        }\n\n        unproject(t) {\n          return this.transform.pointLocation3D(e.pointGeometry.convert(t));\n        }\n\n        isMoving() {\n          return this._moving || this.handlers && this.handlers.isMoving() || !1;\n        }\n\n        isZooming() {\n          return this._zooming || this.handlers && this.handlers.isZooming() || !1;\n        }\n\n        isRotating() {\n          return this._rotating || this.handlers && this.handlers.isRotating() || !1;\n        }\n\n        _createDelegatedListener(e, t, i) {\n          if (\"mouseenter\" === e || \"mouseover\" === e) {\n            let o = !1;\n\n            const r = r => {\n              const n = t.filter(e => this.getLayer(e)),\n                    a = n.length ? this.queryRenderedFeatures(r.point, {\n                layers: n\n              }) : [];\n              a.length ? o || (o = !0, i.call(this, new Yo(e, this, r.originalEvent, {\n                features: a\n              }))) : o = !1;\n            },\n                  n = () => {\n              o = !1;\n            };\n\n            return {\n              layers: new Set(t),\n              listener: i,\n              delegates: {\n                mousemove: r,\n                mouseout: n\n              }\n            };\n          }\n\n          if (\"mouseleave\" === e || \"mouseout\" === e) {\n            let o = !1;\n\n            const r = r => {\n              const n = t.filter(e => this.getLayer(e));\n              (n.length ? this.queryRenderedFeatures(r.point, {\n                layers: n\n              }) : []).length ? o = !0 : o && (o = !1, i.call(this, new Yo(e, this, r.originalEvent)));\n            },\n                  n = t => {\n              o && (o = !1, i.call(this, new Yo(e, this, t.originalEvent)));\n            };\n\n            return {\n              layers: new Set(t),\n              listener: i,\n              delegates: {\n                mousemove: r,\n                mouseout: n\n              }\n            };\n          }\n\n          {\n            const o = e => {\n              const o = t.filter(e => this.getLayer(e)),\n                    r = o.length ? this.queryRenderedFeatures(e.point, {\n                layers: o\n              }) : [];\n              r.length && (e.features = r, i.call(this, e), delete e.features);\n            };\n\n            return {\n              layers: new Set(t),\n              listener: i,\n              delegates: {\n                [e]: o\n              }\n            };\n          }\n        }\n\n        on(e, t, i) {\n          if (void 0 === i) return super.on(e, t);\n          Array.isArray(t) || (t = [t]);\n\n          const o = this._createDelegatedListener(e, t, i);\n\n          this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e] = this._delegatedListeners[e] || [], this._delegatedListeners[e].push(o);\n\n          for (const e in o.delegates) this.on(e, o.delegates[e]);\n\n          return this;\n        }\n\n        once(e, t, i) {\n          if (void 0 === i) return super.once(e, t);\n          Array.isArray(t) || (t = [t]);\n\n          const o = this._createDelegatedListener(e, t, i);\n\n          for (const e in o.delegates) this.once(e, o.delegates[e]);\n\n          return this;\n        }\n\n        off(e, t, i) {\n          if (void 0 === i) return super.off(e, t);\n          t = new Set(Array.isArray(t) ? t : [t]);\n\n          const o = (e, t) => {\n            if (e.size !== t.size) return !1;\n\n            for (const i of e) if (!t.has(i)) return !1;\n\n            return !0;\n          },\n                r = this._delegatedListeners ? this._delegatedListeners[e] : void 0;\n\n          return r && (e => {\n            for (let r = 0; r < e.length; r++) {\n              const n = e[r];\n\n              if (n.listener === i && o(n.layers, t)) {\n                for (const e in n.delegates) this.off(e, n.delegates[e]);\n\n                return e.splice(r, 1), this;\n              }\n            }\n          })(r), this;\n        }\n\n        queryRenderedFeatures(t, i) {\n          return this.style ? (void 0 !== i || void 0 === t || t instanceof e.pointGeometry || Array.isArray(t) || (i = t, t = void 0), this.style.queryRenderedFeatures(t = t || [[0, 0], [this.transform.width, this.transform.height]], i = i || {}, this.transform)) : [];\n        }\n\n        querySourceFeatures(e, t) {\n          return this.style.querySourceFeatures(e, t);\n        }\n\n        queryTerrainElevation(t, i) {\n          const o = this.transform.elevation;\n          return o ? (i = e.extend({}, {\n            exaggerated: !0\n          }, i), o.getAtPoint(e.MercatorCoordinate.fromLngLat(t), null, i.exaggerated)) : null;\n        }\n\n        setStyle(t, i) {\n          return !1 !== (i = e.extend({}, {\n            localIdeographFontFamily: this._localIdeographFontFamily,\n            localFontFamily: this._localFontFamily\n          }, i)).diff && i.localIdeographFontFamily === this._localIdeographFontFamily && i.localFontFamily === this._localFontFamily && this.style && t ? (this._diffStyle(t, i), this) : (this._localIdeographFontFamily = i.localIdeographFontFamily, this._localFontFamily = i.localFontFamily, this._updateStyle(t, i));\n        }\n\n        _getUIString(e) {\n          const t = this._locale[e];\n          if (null == t) throw new Error(`Missing UI string '${e}'`);\n          return t;\n        }\n\n        _updateStyle(e, t) {\n          return this.style && (this.style.setEventedParent(null), this.style._remove(), this.style = void 0), e && (this.style = new $t(this, t || {}), this.style.setEventedParent(this, {\n            style: this.style\n          }), \"string\" == typeof e ? this.style.loadURL(e) : this.style.loadJSON(e)), this._updateTerrain(), this;\n        }\n\n        _lazyInitEmptyStyle() {\n          this.style || (this.style = new $t(this, {}), this.style.setEventedParent(this, {\n            style: this.style\n          }), this.style.loadEmpty());\n        }\n\n        _diffStyle(t, i) {\n          if (\"string\" == typeof t) {\n            const o = this._requestManager.normalizeStyleURL(t),\n                  r = this._requestManager.transformRequest(o, e.ResourceType.Style);\n\n            e.getJSON(r, (t, o) => {\n              t ? this.fire(new e.ErrorEvent(t)) : o && this._updateDiff(o, i);\n            });\n          } else \"object\" == typeof t && this._updateDiff(t, i);\n        }\n\n        _updateDiff(t, i) {\n          try {\n            this.style.setState(t) && this._update(!0);\n          } catch (o) {\n            e.warnOnce(`Unable to perform style diff: ${o.message || o.error || o}.  Rebuilding the style from scratch.`), this._updateStyle(t, i);\n          }\n        }\n\n        getStyle() {\n          if (this.style) return this.style.serialize();\n        }\n\n        isStyleLoaded() {\n          return this.style ? this.style.loaded() : (e.warnOnce(\"There is no style added to the map.\"), !1);\n        }\n\n        addSource(e, t) {\n          return this._lazyInitEmptyStyle(), this.style.addSource(e, t), this._update(!0);\n        }\n\n        isSourceLoaded(e) {\n          return !!this.style && this.style._isSourceCacheLoaded(e);\n        }\n\n        areTilesLoaded() {\n          const e = this.style && this.style._sourceCaches;\n\n          for (const t in e) {\n            const i = e[t]._tiles;\n\n            for (const e in i) {\n              const t = i[e];\n              if (\"loaded\" !== t.state && \"errored\" !== t.state) return !1;\n            }\n          }\n\n          return !0;\n        }\n\n        addSourceType(e, t, i) {\n          this._lazyInitEmptyStyle(), this.style.addSourceType(e, t, i);\n        }\n\n        removeSource(e) {\n          return this.style.removeSource(e), this._updateTerrain(), this._update(!0);\n        }\n\n        getSource(e) {\n          return this.style.getSource(e);\n        }\n\n        addImage(t, i, {\n          pixelRatio: o = 1,\n          sdf: r = !1,\n          stretchX: n,\n          stretchY: a,\n          content: s\n        } = {}) {\n          if (this._lazyInitEmptyStyle(), i instanceof e.window.HTMLImageElement || e.window.ImageBitmap && i instanceof e.window.ImageBitmap) {\n            const {\n              width: l,\n              height: c,\n              data: h\n            } = e.exported.getImageData(i);\n            this.style.addImage(t, {\n              data: new e.RGBAImage({\n                width: l,\n                height: c\n              }, h),\n              pixelRatio: o,\n              stretchX: n,\n              stretchY: a,\n              content: s,\n              sdf: r,\n              version: 0\n            });\n          } else if (void 0 === i.width || void 0 === i.height) this.fire(new e.ErrorEvent(new Error(\"Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`\")));else {\n            const {\n              width: l,\n              height: c\n            } = i,\n                  h = i;\n            this.style.addImage(t, {\n              data: new e.RGBAImage({\n                width: l,\n                height: c\n              }, new Uint8Array(h.data)),\n              pixelRatio: o,\n              stretchX: n,\n              stretchY: a,\n              content: s,\n              sdf: r,\n              version: 0,\n              userImage: h\n            }), h.onAdd && h.onAdd(this, t);\n          }\n        }\n\n        updateImage(t, i) {\n          const o = this.style.getImage(t);\n          if (!o) return void this.fire(new e.ErrorEvent(new Error(\"The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.\")));\n          const r = i instanceof e.window.HTMLImageElement || e.window.ImageBitmap && i instanceof e.window.ImageBitmap ? e.exported.getImageData(i) : i,\n                {\n            width: n,\n            height: a\n          } = r;\n          void 0 !== n && void 0 !== a ? n === o.data.width && a === o.data.height ? (o.data.replace(r.data, !(i instanceof e.window.HTMLImageElement || e.window.ImageBitmap && i instanceof e.window.ImageBitmap)), this.style.updateImage(t, o)) : this.fire(new e.ErrorEvent(new Error(\"The width and height of the updated image must be that same as the previous version of the image\"))) : this.fire(new e.ErrorEvent(new Error(\"Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`\")));\n        }\n\n        hasImage(t) {\n          return t ? !!this.style.getImage(t) : (this.fire(new e.ErrorEvent(new Error(\"Missing required image id\"))), !1);\n        }\n\n        removeImage(e) {\n          this.style.removeImage(e);\n        }\n\n        loadImage(t, i) {\n          e.getImage(this._requestManager.transformRequest(t, e.ResourceType.Image), (t, o) => {\n            i(t, o instanceof e.window.HTMLImageElement ? e.exported.getImageData(o) : o);\n          });\n        }\n\n        listImages() {\n          return this.style.listImages();\n        }\n\n        addLayer(e, t) {\n          return this._lazyInitEmptyStyle(), this.style.addLayer(e, t), this._update(!0);\n        }\n\n        moveLayer(e, t) {\n          return this.style.moveLayer(e, t), this._update(!0);\n        }\n\n        removeLayer(e) {\n          return this.style.removeLayer(e), this._update(!0);\n        }\n\n        getLayer(e) {\n          return this.style.getLayer(e);\n        }\n\n        setLayerZoomRange(e, t, i) {\n          return this.style.setLayerZoomRange(e, t, i), this._update(!0);\n        }\n\n        setFilter(e, t, i = {}) {\n          return this.style.setFilter(e, t, i), this._update(!0);\n        }\n\n        getFilter(e) {\n          return this.style.getFilter(e);\n        }\n\n        setPaintProperty(e, t, i, o = {}) {\n          return this.style.setPaintProperty(e, t, i, o), this._update(!0);\n        }\n\n        getPaintProperty(e, t) {\n          return this.style.getPaintProperty(e, t);\n        }\n\n        setLayoutProperty(e, t, i, o = {}) {\n          return this.style.setLayoutProperty(e, t, i, o), this._update(!0);\n        }\n\n        getLayoutProperty(e, t) {\n          return this.style.getLayoutProperty(e, t);\n        }\n\n        setLight(e, t = {}) {\n          return this._lazyInitEmptyStyle(), this.style.setLight(e, t), this._update(!0);\n        }\n\n        getLight() {\n          return this.style.getLight();\n        }\n\n        setTerrain(e) {\n          return this._lazyInitEmptyStyle(), !e && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(e), this._averageElevationLastSampledAt = -1 / 0, this._update(!0);\n        }\n\n        getTerrain() {\n          return this.style ? this.style.getTerrain() : null;\n        }\n\n        setFog(e) {\n          return this._lazyInitEmptyStyle(), this.style.setFog(e), this._update(!0);\n        }\n\n        getFog() {\n          return this.style ? this.style.getFog() : null;\n        }\n\n        _queryFogOpacity(t) {\n          return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(e.LngLat.convert(t), this.transform) : 0;\n        }\n\n        setFeatureState(e, t) {\n          return this.style.setFeatureState(e, t), this._update();\n        }\n\n        removeFeatureState(e, t) {\n          return this.style.removeFeatureState(e, t), this._update();\n        }\n\n        getFeatureState(e) {\n          return this.style.getFeatureState(e);\n        }\n\n        _updateContainerDimensions() {\n          if (!this._container) return;\n          const t = this._container.getBoundingClientRect().width || 400,\n                i = this._container.getBoundingClientRect().height || 300;\n          let o,\n              r,\n              n,\n              a = this._container;\n\n          for (; a && (!r || !n);) {\n            const t = e.window.getComputedStyle(a).transform;\n            t && \"none\" !== t && (o = t.match(/matrix.*\\((.+)\\)/)[1].split(\", \"), o[0] && \"0\" !== o[0] && \"1\" !== o[0] && (r = o[0]), o[3] && \"0\" !== o[3] && \"1\" !== o[3] && (n = o[3])), a = a.parentElement;\n          }\n\n          this._containerWidth = r ? Math.abs(t / r) : t, this._containerHeight = n ? Math.abs(i / n) : i;\n        }\n\n        _detectMissingCSS() {\n          \"rgb(250, 128, 114)\" !== e.window.getComputedStyle(this._missingCSSCanary).getPropertyValue(\"background-color\") && e.warnOnce(\"This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.\");\n        }\n\n        _setupContainer() {\n          const e = this._container;\n          e.classList.add(\"mapboxgl-map\"), (this._missingCSSCanary = n(\"div\", \"mapboxgl-canary\", e)).style.visibility = \"hidden\", this._detectMissingCSS();\n          const t = this._canvasContainer = n(\"div\", \"mapboxgl-canvas-container\", e);\n          this._interactive && t.classList.add(\"mapboxgl-interactive\"), this._canvas = n(\"canvas\", \"mapboxgl-canvas\", t), this._canvas.addEventListener(\"webglcontextlost\", this._contextLost, !1), this._canvas.addEventListener(\"webglcontextrestored\", this._contextRestored, !1), this._canvas.setAttribute(\"tabindex\", \"0\"), this._canvas.setAttribute(\"aria-label\", \"Map\"), this._canvas.setAttribute(\"role\", \"region\"), this._updateContainerDimensions(), this._resizeCanvas(this._containerWidth, this._containerHeight);\n          const i = this._controlContainer = n(\"div\", \"mapboxgl-control-container\", e),\n                o = this._controlPositions = {};\n          [\"top-left\", \"top-right\", \"bottom-left\", \"bottom-right\"].forEach(e => {\n            o[e] = n(\"div\", `mapboxgl-ctrl-${e}`, i);\n          }), this._container.addEventListener(\"scroll\", this._onMapScroll, !1);\n        }\n\n        _resizeCanvas(t, i) {\n          const o = e.exported.devicePixelRatio || 1;\n          this._canvas.width = o * Math.ceil(t), this._canvas.height = o * Math.ceil(i), this._canvas.style.width = `${t}px`, this._canvas.style.height = `${i}px`;\n        }\n\n        _addMarker(e) {\n          this._markers.push(e);\n        }\n\n        _removeMarker(e) {\n          const t = this._markers.indexOf(e);\n\n          -1 !== t && this._markers.splice(t, 1);\n        }\n\n        _setupPainter() {\n          const i = e.extend({}, t.webGLContextAttributes, {\n            failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat,\n            preserveDrawingBuffer: this._preserveDrawingBuffer,\n            antialias: this._antialias || !1\n          }),\n                o = this._canvas.getContext(\"webgl\", i) || this._canvas.getContext(\"experimental-webgl\", i);\n\n          o ? (e.storeAuthState(o, !0), this.painter = new Mo(o, this.transform), this.on(\"data\", e => {\n            \"source\" === e.dataType && this.painter.setTileLoadedFlag(!0);\n          }), e.exported$1.testSupport(o)) : this.fire(new e.ErrorEvent(new Error(\"Failed to initialize WebGL\")));\n        }\n\n        _contextLost(t) {\n          t.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new e.Event(\"webglcontextlost\", {\n            originalEvent: t\n          }));\n        }\n\n        _contextRestored(t) {\n          this._setupPainter(), this.resize(), this._update(), this.fire(new e.Event(\"webglcontextrestored\", {\n            originalEvent: t\n          }));\n        }\n\n        _onMapScroll(e) {\n          if (e.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;\n        }\n\n        loaded() {\n          return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();\n        }\n\n        _update(e) {\n          return this.style ? (this._styleDirty = this._styleDirty || e, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;\n        }\n\n        _requestRenderFrame(e) {\n          return this._update(), this._renderTaskQueue.add(e);\n        }\n\n        _cancelRenderFrame(e) {\n          this._renderTaskQueue.remove(e);\n        }\n\n        _requestDomTask(e) {\n          !this.loaded() || this.loaded() && !this.isMoving() ? e() : this._domRenderTaskQueue.add(e);\n        }\n\n        _render(t) {\n          let i;\n          const o = this.painter.context.extTimerQuery,\n                r = e.exported.now();\n          if (this.listens(\"gpu-timing-frame\") && (i = o.createQueryEXT(), o.beginQueryEXT(o.TIME_ELAPSED_EXT, i)), this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(t), this._domRenderTaskQueue.run(t), this._removed) return;\n          let n = !1;\n          const a = this._isInitialLoad ? 0 : this._fadeDuration;\n\n          if (this.style && this._styleDirty) {\n            this._styleDirty = !1;\n            const t = this.transform.zoom,\n                  i = this.transform.pitch,\n                  o = e.exported.now();\n            this.style.zoomHistory.update(t, o);\n            const r = new e.EvaluationParameters(t, {\n              now: o,\n              fadeDuration: a,\n              pitch: i,\n              zoomHistory: this.style.zoomHistory,\n              transition: this.style.getTransition()\n            }),\n                  s = r.crossFadingFactor();\n            1 === s && s === this._crossFadingFactor || (n = !0, this._crossFadingFactor = s), this.style.update(r);\n          }\n\n          this.style && this.style.fog && this.style.fog.hasTransition() && (this.style._markersNeedUpdate = !0, this._sourcesDirty = !0);\n          let s = !1;\n\n          if (this.style && this._sourcesDirty ? (this._sourcesDirty = !1, this.painter._updateFog(this.style), this._updateTerrain(), s = this._updateAverageElevation(r), this.style._updateSources(this.transform), this._forceMarkerUpdate()) : s = this._updateAverageElevation(r), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, a, this._crossSourceCollisions), this.style && this.painter.render(this.style, {\n            showTileBoundaries: this.showTileBoundaries,\n            showTerrainWireframe: this.showTerrainWireframe,\n            showOverdrawInspector: this._showOverdrawInspector,\n            showQueryGeometry: !!this._showQueryGeometry,\n            rotating: this.isRotating(),\n            zooming: this.isZooming(),\n            moving: this.isMoving(),\n            fadeDuration: a,\n            isInitialLoad: this._isInitialLoad,\n            showPadding: this.showPadding,\n            gpuTiming: !!this.listens(\"gpu-timing-layer\"),\n            speedIndexTiming: this.speedIndexTiming\n          }), this.fire(new e.Event(\"render\")), this.loaded() && !this._loaded && (this._loaded = !0, this.fire(new e.Event(\"load\"))), this.style && (this.style.hasTransitions() || n) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), this.listens(\"gpu-timing-frame\")) {\n            const t = e.exported.now() - r;\n            o.endQueryEXT(o.TIME_ELAPSED_EXT, i), setTimeout(() => {\n              const r = o.getQueryObjectEXT(i, o.QUERY_RESULT_EXT) / 1e6;\n              o.deleteQueryEXT(i), this.fire(new e.Event(\"gpu-timing-frame\", {\n                cpuTime: t,\n                gpuTime: r\n              }));\n            }, 50);\n          }\n\n          if (this.listens(\"gpu-timing-layer\")) {\n            const t = this.painter.collectGpuTimers();\n            setTimeout(() => {\n              const i = this.painter.queryGpuTimers(t);\n              this.fire(new e.Event(\"gpu-timing-layer\", {\n                layerTimes: i\n              }));\n            }, 50);\n          }\n\n          const l = this._sourcesDirty || this._styleDirty || this._placementDirty || s;\n          if (l || this._repaint) this.triggerRepaint();else {\n            const t = !this.isMoving() && this.loaded();\n            if (t && (s = this._updateAverageElevation(r, !0)), s) this.triggerRepaint();else if (this._triggerFrame(!1), t && (this.fire(new e.Event(\"idle\")), this._isInitialLoad = !1, this.speedIndexTiming)) {\n              const t = this._calculateSpeedIndex();\n\n              this.fire(new e.Event(\"speedindexcompleted\", {\n                speedIndex: t\n              })), this.speedIndexTiming = !1;\n            }\n          }\n          !this._loaded || this._fullyLoaded || l || (this._fullyLoaded = !0, this._authenticate());\n        }\n\n        _forceMarkerUpdate() {\n          for (const e of this._markers) e._update();\n        }\n\n        _updateAverageElevation(e, t = !1) {\n          const i = e => (this.transform.averageElevation = e, this._update(!1), !0);\n\n          if (!this.painter.averageElevationNeedsEasing()) return 0 !== this.transform.averageElevation && i(0);\n\n          if ((t || e - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(e)) {\n            const t = this.transform.averageElevation;\n            let o = this.transform.sampleAverageElevation(),\n                r = !1;\n            this.transform.elevation && (r = this.transform.elevation.exaggeration() !== this._averageElevationExaggeration, this._averageElevationExaggeration = this.transform.elevation.exaggeration()), isNaN(o) ? o = 0 : this._averageElevationLastSampledAt = e;\n            const n = Math.abs(t - o);\n\n            if (n > 1) {\n              if (this._isInitialLoad || r) return this._averageElevation.jumpTo(o), i(o);\n\n              this._averageElevation.easeTo(o, e, 300);\n            } else if (n > 1e-4) return this._averageElevation.jumpTo(o), i(o);\n          }\n\n          return !!this._averageElevation.isEasing(e) && i(this._averageElevation.getValue(e));\n        }\n\n        _authenticate() {\n          e.getMapSessionAPI(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, t => {\n            if (t && (t.message === e.AUTH_ERR_MSG || 401 === t.status)) {\n              const t = this.painter.context.gl;\n              e.storeAuthState(t, !1), this._logoControl instanceof Nr && this._logoControl._updateLogo(), t && t.clear(t.DEPTH_BUFFER_BIT | t.COLOR_BUFFER_BIT | t.STENCIL_BUFFER_BIT), this._silenceAuthErrors || this.fire(new e.ErrorEvent(new Error(\"A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/\")));\n            }\n          }), e.postMapLoadEvent(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, () => {});\n        }\n\n        _updateTerrain() {\n          this.painter.updateTerrain(this.style, this.isMoving() || this.isRotating() || this.isZooming());\n        }\n\n        _calculateSpeedIndex() {\n          const e = this.painter.canvasCopy(),\n                t = this.painter.getCanvasCopiesAndTimestamps();\n          t.timeStamps.push(performance.now());\n          const i = this.painter.context.gl,\n                o = i.createFramebuffer();\n\n          function r(e) {\n            i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, e, 0);\n            const t = new Uint8Array(i.drawingBufferWidth * i.drawingBufferHeight * 4);\n            return i.readPixels(0, 0, i.drawingBufferWidth, i.drawingBufferHeight, i.RGBA, i.UNSIGNED_BYTE, t), t;\n          }\n\n          return i.bindFramebuffer(i.FRAMEBUFFER, o), this._canvasPixelComparison(r(e), t.canvasCopies.map(r), t.timeStamps);\n        }\n\n        _canvasPixelComparison(e, t, i) {\n          let o = i[1] - i[0];\n          const r = e.length / 4;\n\n          for (let n = 0; n < t.length; n++) {\n            const a = t[n];\n            let s = 0;\n\n            for (let t = 0; t < a.length; t += 4) a[t] === e[t] && a[t + 1] === e[t + 1] && a[t + 2] === e[t + 2] && a[t + 3] === e[t + 3] && (s += 1);\n\n            o += (i[n + 2] - i[n + 1]) * (1 - s / r);\n          }\n\n          return o;\n        }\n\n        remove() {\n          this._hash && this._hash.remove();\n\n          for (const e of this._controls) e.onRemove(this);\n\n          this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this._domRenderTaskQueue.clear(), this.style && this.style.destroy(), this.painter.destroy(), this.handlers && this.handlers.destroy(), this.handlers = void 0, this.setStyle(null), void 0 !== e.window && (e.window.removeEventListener(\"resize\", this._onWindowResize, !1), e.window.removeEventListener(\"orientationchange\", this._onWindowResize, !1), e.window.removeEventListener(\"webkitfullscreenchange\", this._onWindowResize, !1), e.window.removeEventListener(\"online\", this._onWindowOnline, !1));\n          const t = this.painter.context.gl.getExtension(\"WEBGL_lose_context\");\n          t && t.loseContext(), $r(this._canvasContainer), $r(this._controlContainer), $r(this._missingCSSCanary), this._container.classList.remove(\"mapboxgl-map\"), e.removeAuthState(this.painter.context.gl), this._removed = !0, this.fire(new e.Event(\"remove\"));\n        }\n\n        triggerRepaint() {\n          this._triggerFrame(!0);\n        }\n\n        _triggerFrame(t) {\n          this._renderNextFrame = this._renderNextFrame || t, this.style && !this._frame && (this._frame = e.exported.frame(e => {\n            const t = !!this._renderNextFrame;\n            this._frame = null, this._renderNextFrame = null, t && this._render(e);\n          }));\n        }\n\n        _preloadTiles(t) {\n          const i = this.style ? Object.values(this.style._sourceCaches) : [];\n          return e.asyncAll(i, (e, i) => e._preloadTiles(t, i), () => {\n            this.triggerRepaint();\n          }), this;\n        }\n\n        _onWindowOnline() {\n          this._update();\n        }\n\n        _onWindowResize(e) {\n          this._trackResize && this.resize({\n            originalEvent: e\n          })._update();\n        }\n\n        get showTileBoundaries() {\n          return !!this._showTileBoundaries;\n        }\n\n        set showTileBoundaries(e) {\n          this._showTileBoundaries !== e && (this._showTileBoundaries = e, this._update());\n        }\n\n        get showTerrainWireframe() {\n          return !!this._showTerrainWireframe;\n        }\n\n        set showTerrainWireframe(e) {\n          this._showTerrainWireframe !== e && (this._showTerrainWireframe = e, this._update());\n        }\n\n        get speedIndexTiming() {\n          return !!this._speedIndexTiming;\n        }\n\n        set speedIndexTiming(e) {\n          this._speedIndexTiming !== e && (this._speedIndexTiming = e, this._update());\n        }\n\n        get showPadding() {\n          return !!this._showPadding;\n        }\n\n        set showPadding(e) {\n          this._showPadding !== e && (this._showPadding = e, this._update());\n        }\n\n        get showCollisionBoxes() {\n          return !!this._showCollisionBoxes;\n        }\n\n        set showCollisionBoxes(e) {\n          this._showCollisionBoxes !== e && (this._showCollisionBoxes = e, e ? this.style._generateCollisionBoxes() : this._update());\n        }\n\n        get showOverdrawInspector() {\n          return !!this._showOverdrawInspector;\n        }\n\n        set showOverdrawInspector(e) {\n          this._showOverdrawInspector !== e && (this._showOverdrawInspector = e, this._update());\n        }\n\n        get repaint() {\n          return !!this._repaint;\n        }\n\n        set repaint(e) {\n          this._repaint !== e && (this._repaint = e, this.triggerRepaint());\n        }\n\n        get vertices() {\n          return !!this._vertices;\n        }\n\n        set vertices(e) {\n          this._vertices = e, this._update();\n        }\n\n        _setCacheLimits(t, i) {\n          e.setCacheLimits(t, i);\n        }\n\n        get version() {\n          return e.version;\n        }\n\n      },\n      NavigationControl: class {\n        constructor(t) {\n          this.options = e.extend({}, Hr, t), this._container = n(\"div\", \"mapboxgl-ctrl mapboxgl-ctrl-group\"), this._container.addEventListener(\"contextmenu\", e => e.preventDefault()), this.options.showZoom && (e.bindAll([\"_setButtonTitle\", \"_updateZoomButtons\"], this), this._zoomInButton = this._createButton(\"mapboxgl-ctrl-zoom-in\", e => {\n            this._map && this._map.zoomIn({}, {\n              originalEvent: e\n            });\n          }), n(\"span\", \"mapboxgl-ctrl-icon\", this._zoomInButton).setAttribute(\"aria-hidden\", \"true\"), this._zoomOutButton = this._createButton(\"mapboxgl-ctrl-zoom-out\", e => {\n            this._map && this._map.zoomOut({}, {\n              originalEvent: e\n            });\n          }), n(\"span\", \"mapboxgl-ctrl-icon\", this._zoomOutButton).setAttribute(\"aria-hidden\", \"true\")), this.options.showCompass && (e.bindAll([\"_rotateCompassArrow\"], this), this._compass = this._createButton(\"mapboxgl-ctrl-compass\", e => {\n            const t = this._map;\n            t && (this.options.visualizePitch ? t.resetNorthPitch({}, {\n              originalEvent: e\n            }) : t.resetNorth({}, {\n              originalEvent: e\n            }));\n          }), this._compassIcon = n(\"span\", \"mapboxgl-ctrl-icon\", this._compass), this._compassIcon.setAttribute(\"aria-hidden\", \"true\"));\n        }\n\n        _updateZoomButtons() {\n          const e = this._map;\n          if (!e) return;\n          const t = e.getZoom(),\n                i = t === e.getMaxZoom(),\n                o = t === e.getMinZoom();\n          this._zoomInButton.disabled = i, this._zoomOutButton.disabled = o, this._zoomInButton.setAttribute(\"aria-disabled\", i.toString()), this._zoomOutButton.setAttribute(\"aria-disabled\", o.toString());\n        }\n\n        _rotateCompassArrow() {\n          const e = this._map;\n          if (!e) return;\n          const t = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(e.transform.pitch * (Math.PI / 180)), .5)}) rotateX(${e.transform.pitch}deg) rotateZ(${e.transform.angle * (180 / Math.PI)}deg)` : `rotate(${e.transform.angle * (180 / Math.PI)}deg)`;\n\n          e._requestDomTask(() => {\n            this._compassIcon && (this._compassIcon.style.transform = t);\n          });\n        }\n\n        onAdd(e) {\n          return this._map = e, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, \"ZoomIn\"), this._setButtonTitle(this._zoomOutButton, \"ZoomOut\"), e.on(\"zoom\", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, \"ResetBearing\"), this.options.visualizePitch && e.on(\"pitch\", this._rotateCompassArrow), e.on(\"rotate\", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Kr(e, this._compass, this.options.visualizePitch)), this._container;\n        }\n\n        onRemove() {\n          const e = this._map;\n          e && (this._container.remove(), this.options.showZoom && e.off(\"zoom\", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && e.off(\"pitch\", this._rotateCompassArrow), e.off(\"rotate\", this._rotateCompassArrow), this._handler && this._handler.off(), this._handler = void 0), this._map = void 0);\n        }\n\n        _createButton(e, t) {\n          const i = n(\"button\", e, this._container);\n          return i.type = \"button\", i.addEventListener(\"click\", t), i;\n        }\n\n        _setButtonTitle(e, t) {\n          if (!this._map) return;\n\n          const i = this._map._getUIString(`NavigationControl.${t}`);\n\n          e.setAttribute(\"aria-label\", i), e.firstElementChild && e.firstElementChild.setAttribute(\"title\", i);\n        }\n\n      },\n      GeolocateControl: class extends e.Evented {\n        constructor(t) {\n          super(), this.options = e.extend({}, Yr, t), e.bindAll([\"_onSuccess\", \"_onError\", \"_onZoom\", \"_finish\", \"_setupUI\", \"_updateCamera\", \"_updateMarker\", \"_updateMarkerRotation\", \"_onDeviceOrientation\"], this), this._updateMarkerRotationThrottled = Go(this._updateMarkerRotation, 20);\n        }\n\n        onAdd(t) {\n          var i;\n          return this._map = t, this._container = n(\"div\", \"mapboxgl-ctrl mapboxgl-ctrl-group\"), i = this._setupUI, void 0 !== Jr ? i(Jr) : void 0 !== e.window.navigator.permissions ? e.window.navigator.permissions.query({\n            name: \"geolocation\"\n          }).then(e => {\n            Jr = \"denied\" !== e.state, i(Jr);\n          }) : (Jr = !!e.window.navigator.geolocation, i(Jr)), this._container;\n        }\n\n        onRemove() {\n          void 0 !== this._geolocationWatchID && (e.window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), this._container.remove(), this._map.off(\"zoom\", this._onZoom), this._map = void 0, Qr = 0, en = !1;\n        }\n\n        _isOutOfMapMaxBounds(e) {\n          const t = this._map.getMaxBounds(),\n                i = e.coords;\n\n          return !!t && (i.longitude < t.getWest() || i.longitude > t.getEast() || i.latitude < t.getSouth() || i.latitude > t.getNorth());\n        }\n\n        _setErrorState() {\n          switch (this._watchState) {\n            case \"WAITING_ACTIVE\":\n              this._watchState = \"ACTIVE_ERROR\", this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-active\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-active-error\");\n              break;\n\n            case \"ACTIVE_LOCK\":\n              this._watchState = \"ACTIVE_ERROR\", this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-active\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-active-error\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-waiting\");\n              break;\n\n            case \"BACKGROUND\":\n              this._watchState = \"BACKGROUND_ERROR\", this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-background\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-background-error\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-waiting\");\n          }\n        }\n\n        _onSuccess(t) {\n          if (this._map) {\n            if (this._isOutOfMapMaxBounds(t)) return this._setErrorState(), this.fire(new e.Event(\"outofmaxbounds\", t)), this._updateMarker(), void this._finish();\n            if (this.options.trackUserLocation) switch (this._lastKnownPosition = t, this._watchState) {\n              case \"WAITING_ACTIVE\":\n              case \"ACTIVE_LOCK\":\n              case \"ACTIVE_ERROR\":\n                this._watchState = \"ACTIVE_LOCK\", this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-active-error\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-active\");\n                break;\n\n              case \"BACKGROUND\":\n              case \"BACKGROUND_ERROR\":\n                this._watchState = \"BACKGROUND\", this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-background-error\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-background\");\n            }\n            this.options.showUserLocation && \"OFF\" !== this._watchState && this._updateMarker(t), this.options.trackUserLocation && \"ACTIVE_LOCK\" !== this._watchState || this._updateCamera(t), this.options.showUserLocation && this._dotElement.classList.remove(\"mapboxgl-user-location-dot-stale\"), this.fire(new e.Event(\"geolocate\", t)), this._finish();\n          }\n        }\n\n        _updateCamera(t) {\n          const i = new e.LngLat(t.coords.longitude, t.coords.latitude),\n                o = t.coords.accuracy,\n                r = this._map.getBearing(),\n                n = e.extend({\n            bearing: r\n          }, this.options.fitBoundsOptions);\n\n          this._map.fitBounds(i.toBounds(o), n, {\n            geolocateSource: !0\n          });\n        }\n\n        _updateMarker(t) {\n          if (t) {\n            const i = new e.LngLat(t.coords.longitude, t.coords.latitude);\n            this._accuracyCircleMarker.setLngLat(i).addTo(this._map), this._userLocationDotMarker.setLngLat(i).addTo(this._map), this._accuracy = t.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();\n          } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();\n        }\n\n        _updateCircleRadius() {\n          const e = this._map._containerHeight / 2,\n                t = this._map.unproject([0, e]),\n                i = this._map.unproject([100, e]),\n                o = t.distanceTo(i) / 100,\n                r = Math.ceil(2 * this._accuracy / o);\n\n          this._circleElement.style.width = `${r}px`, this._circleElement.style.height = `${r}px`;\n        }\n\n        _onZoom() {\n          this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();\n        }\n\n        _updateMarkerRotation() {\n          this._userLocationDotMarker && \"number\" == typeof this._heading ? (this._userLocationDotMarker.setRotation(this._heading), this._dotElement.classList.add(\"mapboxgl-user-location-show-heading\")) : (this._dotElement.classList.remove(\"mapboxgl-user-location-show-heading\"), this._userLocationDotMarker.setRotation(0));\n        }\n\n        _onError(t) {\n          if (this._map) {\n            if (this.options.trackUserLocation) if (1 === t.code) {\n              this._watchState = \"OFF\", this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-active\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-active-error\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-background\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-background-error\"), this._geolocateButton.disabled = !0;\n\n              const e = this._map._getUIString(\"GeolocateControl.LocationNotAvailable\");\n\n              this._geolocateButton.setAttribute(\"aria-label\", e), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute(\"title\", e), void 0 !== this._geolocationWatchID && this._clearWatch();\n            } else {\n              if (3 === t.code && en) return;\n\n              this._setErrorState();\n            }\n            \"OFF\" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add(\"mapboxgl-user-location-dot-stale\"), this.fire(new e.Event(\"error\", t)), this._finish();\n          }\n        }\n\n        _finish() {\n          this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;\n        }\n\n        _setupUI(t) {\n          if (this._container.addEventListener(\"contextmenu\", e => e.preventDefault()), this._geolocateButton = n(\"button\", \"mapboxgl-ctrl-geolocate\", this._container), n(\"span\", \"mapboxgl-ctrl-icon\", this._geolocateButton).setAttribute(\"aria-hidden\", \"true\"), this._geolocateButton.type = \"button\", !1 === t) {\n            e.warnOnce(\"Geolocation support is not available so the GeolocateControl will be disabled.\");\n\n            const t = this._map._getUIString(\"GeolocateControl.LocationNotAvailable\");\n\n            this._geolocateButton.disabled = !0, this._geolocateButton.setAttribute(\"aria-label\", t), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute(\"title\", t);\n          } else {\n            const e = this._map._getUIString(\"GeolocateControl.FindMyLocation\");\n\n            this._geolocateButton.setAttribute(\"aria-label\", e), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute(\"title\", e);\n          }\n\n          this.options.trackUserLocation && (this._geolocateButton.setAttribute(\"aria-pressed\", \"false\"), this._watchState = \"OFF\"), this.options.showUserLocation && (this._dotElement = n(\"div\", \"mapboxgl-user-location\"), this._dotElement.appendChild(n(\"div\", \"mapboxgl-user-location-dot\")), this._dotElement.appendChild(n(\"div\", \"mapboxgl-user-location-heading\")), this._userLocationDotMarker = new Vr({\n            element: this._dotElement,\n            rotationAlignment: \"map\",\n            pitchAlignment: \"map\"\n          }), this._circleElement = n(\"div\", \"mapboxgl-user-location-accuracy-circle\"), this._accuracyCircleMarker = new Vr({\n            element: this._circleElement,\n            pitchAlignment: \"map\"\n          }), this.options.trackUserLocation && (this._watchState = \"OFF\"), this._map.on(\"zoom\", this._onZoom)), this._geolocateButton.addEventListener(\"click\", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on(\"movestart\", t => {\n            t.geolocateSource || \"ACTIVE_LOCK\" !== this._watchState || t.originalEvent && \"resize\" === t.originalEvent.type || (this._watchState = \"BACKGROUND\", this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-background\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-active\"), this.fire(new e.Event(\"trackuserlocationend\")));\n          });\n        }\n\n        _onDeviceOrientation(e) {\n          this._userLocationDotMarker && (e.webkitCompassHeading ? this._heading = e.webkitCompassHeading : !0 === e.absolute && (this._heading = -1 * e.alpha), this._updateMarkerRotationThrottled());\n        }\n\n        trigger() {\n          if (!this._setup) return e.warnOnce(\"Geolocate control triggered before added to a map\"), !1;\n\n          if (this.options.trackUserLocation) {\n            switch (this._watchState) {\n              case \"OFF\":\n                this._watchState = \"WAITING_ACTIVE\", this.fire(new e.Event(\"trackuserlocationstart\"));\n                break;\n\n              case \"WAITING_ACTIVE\":\n              case \"ACTIVE_LOCK\":\n              case \"ACTIVE_ERROR\":\n              case \"BACKGROUND_ERROR\":\n                Qr--, en = !1, this._watchState = \"OFF\", this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-active\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-active-error\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-background\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-background-error\"), this.fire(new e.Event(\"trackuserlocationend\"));\n                break;\n\n              case \"BACKGROUND\":\n                this._watchState = \"ACTIVE_LOCK\", this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-background\"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new e.Event(\"trackuserlocationstart\"));\n            }\n\n            switch (this._watchState) {\n              case \"WAITING_ACTIVE\":\n                this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-active\");\n                break;\n\n              case \"ACTIVE_LOCK\":\n                this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-active\");\n\n                break;\n\n              case \"ACTIVE_ERROR\":\n                this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-active-error\");\n                break;\n\n              case \"BACKGROUND\":\n                this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-background\");\n\n                break;\n\n              case \"BACKGROUND_ERROR\":\n                this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-background-error\");\n            }\n\n            if (\"OFF\" === this._watchState && void 0 !== this._geolocationWatchID) this._clearWatch();else if (void 0 === this._geolocationWatchID) {\n              let t;\n              this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.setAttribute(\"aria-pressed\", \"true\"), Qr++, Qr > 1 ? (t = {\n                maximumAge: 6e5,\n                timeout: 0\n              }, en = !0) : (t = this.options.positionOptions, en = !1), this._geolocationWatchID = e.window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, t), this.options.showUserHeading && this._addDeviceOrientationListener();\n            }\n          } else e.window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);\n\n          return !0;\n        }\n\n        _addDeviceOrientationListener() {\n          const t = () => {\n            e.window.addEventListener(\"ondeviceorientationabsolute\" in e.window ? \"deviceorientationabsolute\" : \"deviceorientation\", this._onDeviceOrientation);\n          };\n\n          void 0 !== e.window.DeviceMotionEvent && \"function\" == typeof e.window.DeviceMotionEvent.requestPermission ? DeviceOrientationEvent.requestPermission().then(e => {\n            \"granted\" === e && t();\n          }).catch(console.error) : t();\n        }\n\n        _clearWatch() {\n          e.window.navigator.geolocation.clearWatch(this._geolocationWatchID), e.window.removeEventListener(\"deviceorientation\", this._onDeviceOrientation), e.window.removeEventListener(\"deviceorientationabsolute\", this._onDeviceOrientation), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.setAttribute(\"aria-pressed\", \"false\"), this.options.showUserLocation && this._updateMarker(null);\n        }\n\n      },\n      AttributionControl: Ur,\n      ScaleControl: class {\n        constructor(t) {\n          this.options = e.extend({}, tn, t), e.bindAll([\"_onMove\", \"setUnit\"], this);\n        }\n\n        getDefaultPosition() {\n          return \"bottom-left\";\n        }\n\n        _onMove() {\n          on(this._map, this._container, this.options);\n        }\n\n        onAdd(e) {\n          return this._map = e, this._container = n(\"div\", \"mapboxgl-ctrl mapboxgl-ctrl-scale\", e.getContainer()), this._map.on(\"move\", this._onMove), this._onMove(), this._container;\n        }\n\n        onRemove() {\n          this._container.remove(), this._map.off(\"move\", this._onMove), this._map = void 0;\n        }\n\n        setUnit(e) {\n          this.options.unit = e, on(this._map, this._container, this.options);\n        }\n\n      },\n      FullscreenControl: class {\n        constructor(t) {\n          this._fullscreen = !1, t && t.container && (t.container instanceof e.window.HTMLElement ? this._container = t.container : e.warnOnce(\"Full screen control 'container' must be a DOM element.\")), e.bindAll([\"_onClickFullscreen\", \"_changeIcon\"], this), \"onfullscreenchange\" in e.window.document ? this._fullscreenchange = \"fullscreenchange\" : \"onwebkitfullscreenchange\" in e.window.document && (this._fullscreenchange = \"webkitfullscreenchange\");\n        }\n\n        onAdd(t) {\n          return this._map = t, this._container || (this._container = this._map.getContainer()), this._controlContainer = n(\"div\", \"mapboxgl-ctrl mapboxgl-ctrl-group\"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = \"none\", e.warnOnce(\"This device does not support fullscreen mode.\")), this._controlContainer;\n        }\n\n        onRemove() {\n          this._controlContainer.remove(), this._map = null, e.window.document.removeEventListener(this._fullscreenchange, this._changeIcon);\n        }\n\n        _checkFullscreenSupport() {\n          return !(!e.window.document.fullscreenEnabled && !e.window.document.webkitFullscreenEnabled);\n        }\n\n        _setupUI() {\n          const t = this._fullscreenButton = n(\"button\", \"mapboxgl-ctrl-fullscreen\", this._controlContainer);\n          n(\"span\", \"mapboxgl-ctrl-icon\", t).setAttribute(\"aria-hidden\", \"true\"), t.type = \"button\", this._updateTitle(), this._fullscreenButton.addEventListener(\"click\", this._onClickFullscreen), e.window.document.addEventListener(this._fullscreenchange, this._changeIcon);\n        }\n\n        _updateTitle() {\n          const e = this._getTitle();\n\n          this._fullscreenButton.setAttribute(\"aria-label\", e), this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute(\"title\", e);\n        }\n\n        _getTitle() {\n          return this._map._getUIString(this._isFullscreen() ? \"FullscreenControl.Exit\" : \"FullscreenControl.Enter\");\n        }\n\n        _isFullscreen() {\n          return this._fullscreen;\n        }\n\n        _changeIcon() {\n          (e.window.document.fullscreenElement || e.window.document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle(\"mapboxgl-ctrl-shrink\"), this._fullscreenButton.classList.toggle(\"mapboxgl-ctrl-fullscreen\"), this._updateTitle());\n        }\n\n        _onClickFullscreen() {\n          this._isFullscreen() ? e.window.document.exitFullscreen ? e.window.document.exitFullscreen() : e.window.document.webkitCancelFullScreen && e.window.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();\n        }\n\n      },\n      Popup: class extends e.Evented {\n        constructor(t) {\n          super(), this.options = e.extend(Object.create(nn), t), e.bindAll([\"_update\", \"_onClose\", \"remove\", \"_onMouseEvent\"], this), this._classList = new Set(t && t.className ? t.className.trim().split(/\\s+/) : []);\n        }\n\n        addTo(t) {\n          return this._map && this.remove(), this._map = t, this.options.closeOnClick && t.on(\"preclick\", this._onClose), this.options.closeOnMove && t.on(\"move\", this._onClose), t.on(\"remove\", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (t.on(\"mousemove\", this._onMouseEvent), t.on(\"mouseup\", this._onMouseEvent), t._canvasContainer.classList.add(\"mapboxgl-track-pointer\")) : t.on(\"move\", this._update), this.fire(new e.Event(\"open\")), this;\n        }\n\n        isOpen() {\n          return !!this._map;\n        }\n\n        remove() {\n          this._content && this._content.remove(), this._container && (this._container.remove(), this._container = void 0);\n          const t = this._map;\n          return t && (t.off(\"move\", this._update), t.off(\"move\", this._onClose), t.off(\"preclick\", this._onClose), t.off(\"click\", this._onClose), t.off(\"remove\", this.remove), t.off(\"mousemove\", this._onMouseEvent), t.off(\"mouseup\", this._onMouseEvent), t.off(\"drag\", this._onMouseEvent), this._map = void 0), this.fire(new e.Event(\"close\")), this;\n        }\n\n        getLngLat() {\n          return this._lngLat;\n        }\n\n        setLngLat(t) {\n          this._lngLat = e.LngLat.convert(t), this._pos = null, this._trackPointer = !1, this._update();\n          const i = this._map;\n          return i && (i.on(\"move\", this._update), i.off(\"mousemove\", this._onMouseEvent), i._canvasContainer.classList.remove(\"mapboxgl-track-pointer\")), this;\n        }\n\n        trackPointer() {\n          this._trackPointer = !0, this._pos = null, this._update();\n          const e = this._map;\n          return e && (e.off(\"move\", this._update), e.on(\"mousemove\", this._onMouseEvent), e.on(\"drag\", this._onMouseEvent), e._canvasContainer.classList.add(\"mapboxgl-track-pointer\")), this;\n        }\n\n        getElement() {\n          return this._container;\n        }\n\n        setText(t) {\n          return this.setDOMContent(e.window.document.createTextNode(t));\n        }\n\n        setHTML(t) {\n          const i = e.window.document.createDocumentFragment(),\n                o = e.window.document.createElement(\"body\");\n          let r;\n\n          for (o.innerHTML = t; r = o.firstChild, r;) i.appendChild(r);\n\n          return this.setDOMContent(i);\n        }\n\n        getMaxWidth() {\n          return this._container && this._container.style.maxWidth;\n        }\n\n        setMaxWidth(e) {\n          return this.options.maxWidth = e, this._update(), this;\n        }\n\n        setDOMContent(e) {\n          let t = this._content;\n          if (t) for (; t.hasChildNodes();) t.firstChild && t.removeChild(t.firstChild);else t = this._content = n(\"div\", \"mapboxgl-popup-content\", this._container || void 0);\n\n          if (t.appendChild(e), this.options.closeButton) {\n            const e = this._closeButton = n(\"button\", \"mapboxgl-popup-close-button\", t);\n            e.type = \"button\", e.setAttribute(\"aria-label\", \"Close popup\"), e.setAttribute(\"aria-hidden\", \"true\"), e.innerHTML = \"&#215;\", e.addEventListener(\"click\", this._onClose);\n          }\n\n          return this._update(), this._focusFirstElement(), this;\n        }\n\n        addClassName(e) {\n          return this._classList.add(e), this._updateClassList(), this;\n        }\n\n        removeClassName(e) {\n          return this._classList.delete(e), this._updateClassList(), this;\n        }\n\n        setOffset(e) {\n          return this.options.offset = e, this._update(), this;\n        }\n\n        toggleClassName(e) {\n          let t;\n          return this._classList.delete(e) ? t = !1 : (this._classList.add(e), t = !0), this._updateClassList(), t;\n        }\n\n        _onMouseEvent(e) {\n          this._update(e.point);\n        }\n\n        _getAnchor(e) {\n          if (this.options.anchor) return this.options.anchor;\n          const t = this._map,\n                i = this._container,\n                o = this._pos;\n          if (!t || !i || !o) return \"bottom\";\n          const r = i.offsetWidth,\n                n = i.offsetHeight,\n                a = o.x < r / 2,\n                s = o.x > t.transform.width - r / 2;\n          if (o.y + e < n) return a ? \"top-left\" : s ? \"top-right\" : \"top\";\n\n          if (o.y > t.transform.height - n) {\n            if (a) return \"bottom-left\";\n            if (s) return \"bottom-right\";\n          }\n\n          return a ? \"left\" : s ? \"right\" : \"bottom\";\n        }\n\n        _updateClassList() {\n          const e = this._container;\n          if (!e) return;\n          const t = [...this._classList];\n          t.push(\"mapboxgl-popup\"), this._anchor && t.push(`mapboxgl-popup-anchor-${this._anchor}`), this._trackPointer && t.push(\"mapboxgl-popup-track-pointer\"), e.className = t.join(\" \");\n        }\n\n        _update(e) {\n          const t = this._map,\n                i = this._content;\n          if (!t || !this._lngLat && !this._trackPointer || !i) return;\n          let o = this._container;\n\n          if (o || (o = this._container = n(\"div\", \"mapboxgl-popup\", t.getContainer()), this._tip = n(\"div\", \"mapboxgl-popup-tip\", o), o.appendChild(i)), this.options.maxWidth && o.style.maxWidth !== this.options.maxWidth && (o.style.maxWidth = this.options.maxWidth), t.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = jr(this._lngLat, this._pos, t.transform)), !this._trackPointer || e) {\n            const i = this._pos = this._trackPointer && e ? e : t.project(this._lngLat),\n                  o = sn(this.options.offset),\n                  r = this._anchor = this._getAnchor(o.y),\n                  n = sn(this.options.offset, r),\n                  a = i.add(n).round();\n\n            t._requestDomTask(() => {\n              this._container && r && (this._container.style.transform = `${Zr[r]} translate(${a.x}px,${a.y}px)`);\n            });\n          }\n\n          this._updateClassList();\n        }\n\n        _focusFirstElement() {\n          if (!this.options.focusAfterOpen || !this._container) return;\n\n          const e = this._container.querySelector(an);\n\n          e && e.focus();\n        }\n\n        _onClose() {\n          this.remove();\n        }\n\n        _setOpacity(e) {\n          this._content && (this._content.style.opacity = e), this._tip && (this._tip.style.opacity = e);\n        }\n\n      },\n      Marker: Vr,\n      Style: $t,\n      LngLat: e.LngLat,\n      LngLatBounds: e.LngLatBounds,\n      Point: e.pointGeometry,\n      MercatorCoordinate: e.MercatorCoordinate,\n      FreeCameraOptions: Ao,\n      Evented: e.Evented,\n      config: e.config,\n      prewarm: function () {\n        Ue().acquire(Oe);\n      },\n      clearPrewarmedResources: function () {\n        const e = Fe;\n        e && (e.isPreloaded() && 1 === e.numActive() ? (e.release(Oe), Fe = null) : console.warn(\"Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()\"));\n      },\n\n      get accessToken() {\n        return e.config.ACCESS_TOKEN;\n      },\n\n      set accessToken(t) {\n        e.config.ACCESS_TOKEN = t;\n      },\n\n      get baseApiUrl() {\n        return e.config.API_URL;\n      },\n\n      set baseApiUrl(t) {\n        e.config.API_URL = t;\n      },\n\n      get workerCount() {\n        return Be.workerCount;\n      },\n\n      set workerCount(e) {\n        Be.workerCount = e;\n      },\n\n      get maxParallelImageRequests() {\n        return e.config.MAX_PARALLEL_IMAGE_REQUESTS;\n      },\n\n      set maxParallelImageRequests(t) {\n        e.config.MAX_PARALLEL_IMAGE_REQUESTS = t;\n      },\n\n      clearStorage(t) {\n        e.clearTileCache(t);\n      },\n\n      workerUrl: \"\",\n      workerClass: null,\n      setNow: e.exported.setNow,\n      restoreNow: e.exported.restoreNow\n    };\n    return ln;\n  }); //\n\n  var mapboxgl$1 = mapboxgl;\n  return mapboxgl$1;\n}); //# sourceMappingURL=mapbox-gl.js.map","map":null,"metadata":{},"sourceType":"script"}